diff --git a/_ide_helper.php b/_ide_helper.php
index 7f7a796..4fde692 100644
--- a/_ide_helper.php
+++ b/_ide_helper.php
@@ -1,24 +1,26 @@
 <?php
 /**
  * A helper file for Laravel 5, to provide autocomplete information to your IDE
- * Generated for Laravel 5.4.28 on 2017-07-04.
+ * Generated for Laravel 5.6.11 on 2018-03-12 18:49:23.
+ *
+ * This file should not be included in your code, only analyzed by your IDE!
  *
  * @author Barry vd. Heuvel <barryvdh@gmail.com>
  * @see https://github.com/barryvdh/laravel-ide-helper
  */
 
-namespace {
-    exit("This file should not be included, only analyzed by your IDE");
+namespace Illuminate\Support\Facades { 
 
-    class App extends \Illuminate\Support\Facades\App{
+    class App {
         
         /**
          * Get the version number of the application.
          *
          * @return string 
          * @static 
-         */
-        public static function version(){
+         */ 
+        public static function version()
+        {
             return \Illuminate\Foundation\Application::version();
         }
         
@@ -28,8 +30,9 @@ namespace {
          * @param array $bootstrappers
          * @return void 
          * @static 
-         */
-        public static function bootstrapWith($bootstrappers){
+         */ 
+        public static function bootstrapWith($bootstrappers)
+        {
             \Illuminate\Foundation\Application::bootstrapWith($bootstrappers);
         }
         
@@ -39,8 +42,9 @@ namespace {
          * @param \Closure $callback
          * @return void 
          * @static 
-         */
-        public static function afterLoadingEnvironment($callback){
+         */ 
+        public static function afterLoadingEnvironment($callback)
+        {
             \Illuminate\Foundation\Application::afterLoadingEnvironment($callback);
         }
         
@@ -51,8 +55,9 @@ namespace {
          * @param \Closure $callback
          * @return void 
          * @static 
-         */
-        public static function beforeBootstrapping($bootstrapper, $callback){
+         */ 
+        public static function beforeBootstrapping($bootstrapper, $callback)
+        {
             \Illuminate\Foundation\Application::beforeBootstrapping($bootstrapper, $callback);
         }
         
@@ -63,8 +68,9 @@ namespace {
          * @param \Closure $callback
          * @return void 
          * @static 
-         */
-        public static function afterBootstrapping($bootstrapper, $callback){
+         */ 
+        public static function afterBootstrapping($bootstrapper, $callback)
+        {
             \Illuminate\Foundation\Application::afterBootstrapping($bootstrapper, $callback);
         }
         
@@ -73,8 +79,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function hasBeenBootstrapped(){
+         */ 
+        public static function hasBeenBootstrapped()
+        {
             return \Illuminate\Foundation\Application::hasBeenBootstrapped();
         }
         
@@ -84,8 +91,9 @@ namespace {
          * @param string $basePath
          * @return $this 
          * @static 
-         */
-        public static function setBasePath($basePath){
+         */ 
+        public static function setBasePath($basePath)
+        {
             return \Illuminate\Foundation\Application::setBasePath($basePath);
         }
         
@@ -95,8 +103,9 @@ namespace {
          * @param string $path Optionally, a path to append to the app path
          * @return string 
          * @static 
-         */
-        public static function path($path = ''){
+         */ 
+        public static function path($path = '')
+        {
             return \Illuminate\Foundation\Application::path($path);
         }
         
@@ -106,8 +115,9 @@ namespace {
          * @param string $path Optionally, a path to append to the base path
          * @return string 
          * @static 
-         */
-        public static function basePath($path = ''){
+         */ 
+        public static function basePath($path = '')
+        {
             return \Illuminate\Foundation\Application::basePath($path);
         }
         
@@ -117,8 +127,9 @@ namespace {
          * @param string $path Optionally, a path to append to the bootstrap path
          * @return string 
          * @static 
-         */
-        public static function bootstrapPath($path = ''){
+         */ 
+        public static function bootstrapPath($path = '')
+        {
             return \Illuminate\Foundation\Application::bootstrapPath($path);
         }
         
@@ -128,8 +139,9 @@ namespace {
          * @param string $path Optionally, a path to append to the config path
          * @return string 
          * @static 
-         */
-        public static function configPath($path = ''){
+         */ 
+        public static function configPath($path = '')
+        {
             return \Illuminate\Foundation\Application::configPath($path);
         }
         
@@ -139,8 +151,9 @@ namespace {
          * @param string $path Optionally, a path to append to the database path
          * @return string 
          * @static 
-         */
-        public static function databasePath($path = ''){
+         */ 
+        public static function databasePath($path = '')
+        {
             return \Illuminate\Foundation\Application::databasePath($path);
         }
         
@@ -150,8 +163,9 @@ namespace {
          * @param string $path
          * @return $this 
          * @static 
-         */
-        public static function useDatabasePath($path){
+         */ 
+        public static function useDatabasePath($path)
+        {
             return \Illuminate\Foundation\Application::useDatabasePath($path);
         }
         
@@ -160,8 +174,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function langPath(){
+         */ 
+        public static function langPath()
+        {
             return \Illuminate\Foundation\Application::langPath();
         }
         
@@ -170,8 +185,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function publicPath(){
+         */ 
+        public static function publicPath()
+        {
             return \Illuminate\Foundation\Application::publicPath();
         }
         
@@ -180,8 +196,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function storagePath(){
+         */ 
+        public static function storagePath()
+        {
             return \Illuminate\Foundation\Application::storagePath();
         }
         
@@ -191,8 +208,9 @@ namespace {
          * @param string $path
          * @return $this 
          * @static 
-         */
-        public static function useStoragePath($path){
+         */ 
+        public static function useStoragePath($path)
+        {
             return \Illuminate\Foundation\Application::useStoragePath($path);
         }
         
@@ -202,8 +220,9 @@ namespace {
          * @param string $path
          * @return string 
          * @static 
-         */
-        public static function resourcePath($path = ''){
+         */ 
+        public static function resourcePath($path = '')
+        {
             return \Illuminate\Foundation\Application::resourcePath($path);
         }
         
@@ -212,8 +231,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function environmentPath(){
+         */ 
+        public static function environmentPath()
+        {
             return \Illuminate\Foundation\Application::environmentPath();
         }
         
@@ -223,8 +243,9 @@ namespace {
          * @param string $path
          * @return $this 
          * @static 
-         */
-        public static function useEnvironmentPath($path){
+         */ 
+        public static function useEnvironmentPath($path)
+        {
             return \Illuminate\Foundation\Application::useEnvironmentPath($path);
         }
         
@@ -234,8 +255,9 @@ namespace {
          * @param string $file
          * @return $this 
          * @static 
-         */
-        public static function loadEnvironmentFrom($file){
+         */ 
+        public static function loadEnvironmentFrom($file)
+        {
             return \Illuminate\Foundation\Application::loadEnvironmentFrom($file);
         }
         
@@ -244,8 +266,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function environmentFile(){
+         */ 
+        public static function environmentFile()
+        {
             return \Illuminate\Foundation\Application::environmentFile();
         }
         
@@ -254,8 +277,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function environmentFilePath(){
+         */ 
+        public static function environmentFilePath()
+        {
             return \Illuminate\Foundation\Application::environmentFilePath();
         }
         
@@ -264,8 +288,9 @@ namespace {
          *
          * @return string|bool 
          * @static 
-         */
-        public static function environment(){
+         */ 
+        public static function environment()
+        {
             return \Illuminate\Foundation\Application::environment();
         }
         
@@ -274,8 +299,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function isLocal(){
+         */ 
+        public static function isLocal()
+        {
             return \Illuminate\Foundation\Application::isLocal();
         }
         
@@ -285,28 +311,31 @@ namespace {
          * @param \Closure $callback
          * @return string 
          * @static 
-         */
-        public static function detectEnvironment($callback){
+         */ 
+        public static function detectEnvironment($callback)
+        {
             return \Illuminate\Foundation\Application::detectEnvironment($callback);
         }
         
         /**
-         * Determine if we are running in the console.
+         * Determine if the application is running in the console.
          *
          * @return bool 
          * @static 
-         */
-        public static function runningInConsole(){
+         */ 
+        public static function runningInConsole()
+        {
             return \Illuminate\Foundation\Application::runningInConsole();
         }
         
         /**
-         * Determine if we are running unit tests.
+         * Determine if the application is running unit tests.
          *
          * @return bool 
          * @static 
-         */
-        public static function runningUnitTests(){
+         */ 
+        public static function runningUnitTests()
+        {
             return \Illuminate\Foundation\Application::runningUnitTests();
         }
         
@@ -315,8 +344,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function registerConfiguredProviders(){
+         */ 
+        public static function registerConfiguredProviders()
+        {
             \Illuminate\Foundation\Application::registerConfiguredProviders();
         }
         
@@ -328,8 +358,9 @@ namespace {
          * @param bool $force
          * @return \Illuminate\Support\ServiceProvider 
          * @static 
-         */
-        public static function register($provider, $options = array(), $force = false){
+         */ 
+        public static function register($provider, $options = array(), $force = false)
+        {
             return \Illuminate\Foundation\Application::register($provider, $options, $force);
         }
         
@@ -339,19 +370,33 @@ namespace {
          * @param \Illuminate\Support\ServiceProvider|string $provider
          * @return \Illuminate\Support\ServiceProvider|null 
          * @static 
-         */
-        public static function getProvider($provider){
+         */ 
+        public static function getProvider($provider)
+        {
             return \Illuminate\Foundation\Application::getProvider($provider);
         }
         
+        /**
+         * Get the registered service provider instances if any exist.
+         *
+         * @param \Illuminate\Support\ServiceProvider|string $provider
+         * @return array 
+         * @static 
+         */ 
+        public static function getProviders($provider)
+        {
+            return \Illuminate\Foundation\Application::getProviders($provider);
+        }
+        
         /**
          * Resolve a service provider instance from the class name.
          *
          * @param string $provider
          * @return \Illuminate\Support\ServiceProvider 
          * @static 
-         */
-        public static function resolveProvider($provider){
+         */ 
+        public static function resolveProvider($provider)
+        {
             return \Illuminate\Foundation\Application::resolveProvider($provider);
         }
         
@@ -360,8 +405,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function loadDeferredProviders(){
+         */ 
+        public static function loadDeferredProviders()
+        {
             \Illuminate\Foundation\Application::loadDeferredProviders();
         }
         
@@ -371,8 +417,9 @@ namespace {
          * @param string $service
          * @return void 
          * @static 
-         */
-        public static function loadDeferredProvider($service){
+         */ 
+        public static function loadDeferredProvider($service)
+        {
             \Illuminate\Foundation\Application::loadDeferredProvider($service);
         }
         
@@ -380,39 +427,28 @@ namespace {
          * Register a deferred provider and service.
          *
          * @param string $provider
-         * @param string $service
+         * @param string|null $service
          * @return void 
          * @static 
-         */
-        public static function registerDeferredProvider($provider, $service = null){
+         */ 
+        public static function registerDeferredProvider($provider, $service = null)
+        {
             \Illuminate\Foundation\Application::registerDeferredProvider($provider, $service);
         }
         
-        /**
-         * Resolve the given type from the container.
-         * 
-         * (Overriding Container::makeWith)
-         *
-         * @param string $abstract
-         * @param array $parameters
-         * @return mixed 
-         * @static 
-         */
-        public static function makeWith($abstract, $parameters){
-            return \Illuminate\Foundation\Application::makeWith($abstract, $parameters);
-        }
-        
         /**
          * Resolve the given type from the container.
          * 
          * (Overriding Container::make)
          *
          * @param string $abstract
+         * @param array $parameters
          * @return mixed 
          * @static 
-         */
-        public static function make($abstract){
-            return \Illuminate\Foundation\Application::make($abstract);
+         */ 
+        public static function make($abstract, $parameters = array())
+        {
+            return \Illuminate\Foundation\Application::make($abstract, $parameters);
         }
         
         /**
@@ -423,8 +459,9 @@ namespace {
          * @param string $abstract
          * @return bool 
          * @static 
-         */
-        public static function bound($abstract){
+         */ 
+        public static function bound($abstract)
+        {
             return \Illuminate\Foundation\Application::bound($abstract);
         }
         
@@ -433,8 +470,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function isBooted(){
+         */ 
+        public static function isBooted()
+        {
             return \Illuminate\Foundation\Application::isBooted();
         }
         
@@ -443,8 +481,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function boot(){
+         */ 
+        public static function boot()
+        {
             \Illuminate\Foundation\Application::boot();
         }
         
@@ -454,8 +493,9 @@ namespace {
          * @param mixed $callback
          * @return void 
          * @static 
-         */
-        public static function booting($callback){
+         */ 
+        public static function booting($callback)
+        {
             \Illuminate\Foundation\Application::booting($callback);
         }
         
@@ -465,8 +505,9 @@ namespace {
          * @param mixed $callback
          * @return void 
          * @static 
-         */
-        public static function booted($callback){
+         */ 
+        public static function booted($callback)
+        {
             \Illuminate\Foundation\Application::booted($callback);
         }
         
@@ -474,8 +515,9 @@ namespace {
          * {@inheritdoc}
          *
          * @static 
-         */
-        public static function handle($request, $type = 1, $catch = true){
+         */ 
+        public static function handle($request, $type = 1, $catch = true)
+        {
             return \Illuminate\Foundation\Application::handle($request, $type, $catch);
         }
         
@@ -484,8 +526,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function shouldSkipMiddleware(){
+         */ 
+        public static function shouldSkipMiddleware()
+        {
             return \Illuminate\Foundation\Application::shouldSkipMiddleware();
         }
         
@@ -494,18 +537,31 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getCachedServicesPath(){
+         */ 
+        public static function getCachedServicesPath()
+        {
             return \Illuminate\Foundation\Application::getCachedServicesPath();
         }
         
+        /**
+         * Get the path to the cached packages.php file.
+         *
+         * @return string 
+         * @static 
+         */ 
+        public static function getCachedPackagesPath()
+        {
+            return \Illuminate\Foundation\Application::getCachedPackagesPath();
+        }
+        
         /**
          * Determine if the application configuration is cached.
          *
          * @return bool 
          * @static 
-         */
-        public static function configurationIsCached(){
+         */ 
+        public static function configurationIsCached()
+        {
             return \Illuminate\Foundation\Application::configurationIsCached();
         }
         
@@ -514,8 +570,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getCachedConfigPath(){
+         */ 
+        public static function getCachedConfigPath()
+        {
             return \Illuminate\Foundation\Application::getCachedConfigPath();
         }
         
@@ -524,8 +581,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function routesAreCached(){
+         */ 
+        public static function routesAreCached()
+        {
             return \Illuminate\Foundation\Application::routesAreCached();
         }
         
@@ -534,8 +592,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getCachedRoutesPath(){
+         */ 
+        public static function getCachedRoutesPath()
+        {
             return \Illuminate\Foundation\Application::getCachedRoutesPath();
         }
         
@@ -544,8 +603,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function isDownForMaintenance(){
+         */ 
+        public static function isDownForMaintenance()
+        {
             return \Illuminate\Foundation\Application::isDownForMaintenance();
         }
         
@@ -558,8 +618,9 @@ namespace {
          * @return void 
          * @throws \Symfony\Component\HttpKernel\Exception\HttpException
          * @static 
-         */
-        public static function abort($code, $message = '', $headers = array()){
+         */ 
+        public static function abort($code, $message = '', $headers = array())
+        {
             \Illuminate\Foundation\Application::abort($code, $message, $headers);
         }
         
@@ -569,8 +630,9 @@ namespace {
          * @param \Closure $callback
          * @return $this 
          * @static 
-         */
-        public static function terminating($callback){
+         */ 
+        public static function terminating($callback)
+        {
             return \Illuminate\Foundation\Application::terminating($callback);
         }
         
@@ -579,8 +641,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function terminate(){
+         */ 
+        public static function terminate()
+        {
             \Illuminate\Foundation\Application::terminate();
         }
         
@@ -589,8 +652,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function getLoadedProviders(){
+         */ 
+        public static function getLoadedProviders()
+        {
             return \Illuminate\Foundation\Application::getLoadedProviders();
         }
         
@@ -599,8 +663,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function getDeferredServices(){
+         */ 
+        public static function getDeferredServices()
+        {
             return \Illuminate\Foundation\Application::getDeferredServices();
         }
         
@@ -610,8 +675,9 @@ namespace {
          * @param array $services
          * @return void 
          * @static 
-         */
-        public static function setDeferredServices($services){
+         */ 
+        public static function setDeferredServices($services)
+        {
             \Illuminate\Foundation\Application::setDeferredServices($services);
         }
         
@@ -621,8 +687,9 @@ namespace {
          * @param array $services
          * @return void 
          * @static 
-         */
-        public static function addDeferredServices($services){
+         */ 
+        public static function addDeferredServices($services)
+        {
             \Illuminate\Foundation\Application::addDeferredServices($services);
         }
         
@@ -632,8 +699,9 @@ namespace {
          * @param string $service
          * @return bool 
          * @static 
-         */
-        public static function isDeferredService($service){
+         */ 
+        public static function isDeferredService($service)
+        {
             return \Illuminate\Foundation\Application::isDeferredService($service);
         }
         
@@ -643,49 +711,20 @@ namespace {
          * @param string $namespace
          * @return void 
          * @static 
-         */
-        public static function provideFacades($namespace){
+         */ 
+        public static function provideFacades($namespace)
+        {
             \Illuminate\Foundation\Application::provideFacades($namespace);
         }
         
-        /**
-         * Define a callback to be used to configure Monolog.
-         *
-         * @param callable $callback
-         * @return $this 
-         * @static 
-         */
-        public static function configureMonologUsing($callback){
-            return \Illuminate\Foundation\Application::configureMonologUsing($callback);
-        }
-        
-        /**
-         * Determine if the application has a custom Monolog configurator.
-         *
-         * @return bool 
-         * @static 
-         */
-        public static function hasMonologConfigurator(){
-            return \Illuminate\Foundation\Application::hasMonologConfigurator();
-        }
-        
-        /**
-         * Get the custom Monolog configurator for the application.
-         *
-         * @return callable 
-         * @static 
-         */
-        public static function getMonologConfigurator(){
-            return \Illuminate\Foundation\Application::getMonologConfigurator();
-        }
-        
         /**
          * Get the current application locale.
          *
          * @return string 
          * @static 
-         */
-        public static function getLocale(){
+         */ 
+        public static function getLocale()
+        {
             return \Illuminate\Foundation\Application::getLocale();
         }
         
@@ -695,8 +734,9 @@ namespace {
          * @param string $locale
          * @return void 
          * @static 
-         */
-        public static function setLocale($locale){
+         */ 
+        public static function setLocale($locale)
+        {
             \Illuminate\Foundation\Application::setLocale($locale);
         }
         
@@ -706,8 +746,9 @@ namespace {
          * @param string $locale
          * @return bool 
          * @static 
-         */
-        public static function isLocale($locale){
+         */ 
+        public static function isLocale($locale)
+        {
             return \Illuminate\Foundation\Application::isLocale($locale);
         }
         
@@ -716,8 +757,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function registerCoreContainerAliases(){
+         */ 
+        public static function registerCoreContainerAliases()
+        {
             \Illuminate\Foundation\Application::registerCoreContainerAliases();
         }
         
@@ -726,8 +768,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function flush(){
+         */ 
+        public static function flush()
+        {
             \Illuminate\Foundation\Application::flush();
         }
         
@@ -737,8 +780,9 @@ namespace {
          * @return string 
          * @throws \RuntimeException
          * @static 
-         */
-        public static function getNamespace(){
+         */ 
+        public static function getNamespace()
+        {
             return \Illuminate\Foundation\Application::getNamespace();
         }
         
@@ -748,20 +792,40 @@ namespace {
          * @param string $concrete
          * @return \Illuminate\Contracts\Container\ContextualBindingBuilder 
          * @static 
-         */
-        public static function when($concrete){
+         */ 
+        public static function when($concrete)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::when($concrete);
         }
         
+        /**
+         * Returns true if the container can return an entry for the given identifier.
+         * 
+         * Returns false otherwise.
+         * 
+         * `has($id)` returning true does not mean that `get($id)` will not throw an exception.
+         * It does however mean that `get($id)` will not throw a `NotFoundExceptionInterface`.
+         *
+         * @param string $id Identifier of the entry to look for.
+         * @return bool 
+         * @static 
+         */ 
+        public static function has($id)
+        {
+            //Method inherited from \Illuminate\Container\Container            
+            return \Illuminate\Foundation\Application::has($id);
+        }
+        
         /**
          * Determine if the given abstract type has been resolved.
          *
          * @param string $abstract
          * @return bool 
          * @static 
-         */
-        public static function resolved($abstract){
+         */ 
+        public static function resolved($abstract)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::resolved($abstract);
         }
@@ -772,8 +836,9 @@ namespace {
          * @param string $abstract
          * @return bool 
          * @static 
-         */
-        public static function isShared($abstract){
+         */ 
+        public static function isShared($abstract)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::isShared($abstract);
         }
@@ -784,8 +849,9 @@ namespace {
          * @param string $name
          * @return bool 
          * @static 
-         */
-        public static function isAlias($name){
+         */ 
+        public static function isAlias($name)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::isAlias($name);
         }
@@ -793,13 +859,14 @@ namespace {
         /**
          * Register a binding with the container.
          *
-         * @param string|array $abstract
+         * @param string $abstract
          * @param \Closure|string|null $concrete
          * @param bool $shared
          * @return void 
          * @static 
-         */
-        public static function bind($abstract, $concrete = null, $shared = false){
+         */ 
+        public static function bind($abstract, $concrete = null, $shared = false)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::bind($abstract, $concrete, $shared);
         }
@@ -810,8 +877,9 @@ namespace {
          * @param string $method
          * @return bool 
          * @static 
-         */
-        public static function hasMethodBinding($method){
+         */ 
+        public static function hasMethodBinding($method)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::hasMethodBinding($method);
         }
@@ -819,12 +887,13 @@ namespace {
         /**
          * Bind a callback to resolve with Container::call.
          *
-         * @param string $method
+         * @param array|string $method
          * @param \Closure $callback
          * @return void 
          * @static 
-         */
-        public static function bindMethod($method, $callback){
+         */ 
+        public static function bindMethod($method, $callback)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::bindMethod($method, $callback);
         }
@@ -836,8 +905,9 @@ namespace {
          * @param mixed $instance
          * @return mixed 
          * @static 
-         */
-        public static function callMethodBinding($method, $instance){
+         */ 
+        public static function callMethodBinding($method, $instance)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::callMethodBinding($method, $instance);
         }
@@ -850,8 +920,9 @@ namespace {
          * @param \Closure|string $implementation
          * @return void 
          * @static 
-         */
-        public static function addContextualBinding($concrete, $abstract, $implementation){
+         */ 
+        public static function addContextualBinding($concrete, $abstract, $implementation)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::addContextualBinding($concrete, $abstract, $implementation);
         }
@@ -864,8 +935,9 @@ namespace {
          * @param bool $shared
          * @return void 
          * @static 
-         */
-        public static function bindIf($abstract, $concrete = null, $shared = false){
+         */ 
+        public static function bindIf($abstract, $concrete = null, $shared = false)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::bindIf($abstract, $concrete, $shared);
         }
@@ -873,12 +945,13 @@ namespace {
         /**
          * Register a shared binding in the container.
          *
-         * @param string|array $abstract
+         * @param string $abstract
          * @param \Closure|string|null $concrete
          * @return void 
          * @static 
-         */
-        public static function singleton($abstract, $concrete = null){
+         */ 
+        public static function singleton($abstract, $concrete = null)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::singleton($abstract, $concrete);
         }
@@ -891,8 +964,9 @@ namespace {
          * @return void 
          * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function extend($abstract, $closure){
+         */ 
+        public static function extend($abstract, $closure)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::extend($abstract, $closure);
         }
@@ -902,12 +976,13 @@ namespace {
          *
          * @param string $abstract
          * @param mixed $instance
-         * @return void 
+         * @return mixed 
          * @static 
-         */
-        public static function instance($abstract, $instance){
+         */ 
+        public static function instance($abstract, $instance)
+        {
             //Method inherited from \Illuminate\Container\Container            
-            \Illuminate\Foundation\Application::instance($abstract, $instance);
+            return \Illuminate\Foundation\Application::instance($abstract, $instance);
         }
         
         /**
@@ -917,8 +992,9 @@ namespace {
          * @param array|mixed $tags
          * @return void 
          * @static 
-         */
-        public static function tag($abstracts, $tags){
+         */ 
+        public static function tag($abstracts, $tags)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::tag($abstracts, $tags);
         }
@@ -929,8 +1005,9 @@ namespace {
          * @param string $tag
          * @return array 
          * @static 
-         */
-        public static function tagged($tag){
+         */ 
+        public static function tagged($tag)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::tagged($tag);
         }
@@ -942,8 +1019,9 @@ namespace {
          * @param string $alias
          * @return void 
          * @static 
-         */
-        public static function alias($abstract, $alias){
+         */ 
+        public static function alias($abstract, $alias)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::alias($abstract, $alias);
         }
@@ -955,8 +1033,9 @@ namespace {
          * @param \Closure $callback
          * @return mixed 
          * @static 
-         */
-        public static function rebinding($abstract, $callback){
+         */ 
+        public static function rebinding($abstract, $callback)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::rebinding($abstract, $callback);
         }
@@ -969,8 +1048,9 @@ namespace {
          * @param string $method
          * @return mixed 
          * @static 
-         */
-        public static function refresh($abstract, $target, $method){
+         */ 
+        public static function refresh($abstract, $target, $method)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::refresh($abstract, $target, $method);
         }
@@ -982,8 +1062,9 @@ namespace {
          * @param array $parameters
          * @return \Closure 
          * @static 
-         */
-        public static function wrap($callback, $parameters = array()){
+         */ 
+        public static function wrap($callback, $parameters = array())
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::wrap($callback, $parameters);
         }
@@ -996,8 +1077,9 @@ namespace {
          * @param string|null $defaultMethod
          * @return mixed 
          * @static 
-         */
-        public static function call($callback, $parameters = array(), $defaultMethod = null){
+         */ 
+        public static function call($callback, $parameters = array(), $defaultMethod = null)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::call($callback, $parameters, $defaultMethod);
         }
@@ -1008,12 +1090,42 @@ namespace {
          * @param string $abstract
          * @return \Closure 
          * @static 
-         */
-        public static function factory($abstract){
+         */ 
+        public static function factory($abstract)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::factory($abstract);
         }
         
+        /**
+         * An alias function name for make().
+         *
+         * @param string $abstract
+         * @param array $parameters
+         * @return mixed 
+         * @static 
+         */ 
+        public static function makeWith($abstract, $parameters = array())
+        {
+            //Method inherited from \Illuminate\Container\Container            
+            return \Illuminate\Foundation\Application::makeWith($abstract, $parameters);
+        }
+        
+        /**
+         * Finds an entry of the container by its identifier and returns it.
+         *
+         * @param string $id Identifier of the entry to look for.
+         * @throws NotFoundExceptionInterface  No entry was found for **this** identifier.
+         * @throws ContainerExceptionInterface Error while retrieving the entry.
+         * @return mixed Entry.
+         * @static 
+         */ 
+        public static function get($id)
+        {
+            //Method inherited from \Illuminate\Container\Container            
+            return \Illuminate\Foundation\Application::get($id);
+        }
+        
         /**
          * Instantiate a concrete instance of the given type.
          *
@@ -1021,8 +1133,9 @@ namespace {
          * @return mixed 
          * @throws \Illuminate\Contracts\Container\BindingResolutionException
          * @static 
-         */
-        public static function build($concrete){
+         */ 
+        public static function build($concrete)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::build($concrete);
         }
@@ -1030,12 +1143,13 @@ namespace {
         /**
          * Register a new resolving callback.
          *
-         * @param string $abstract
+         * @param \Closure|string $abstract
          * @param \Closure|null $callback
          * @return void 
          * @static 
-         */
-        public static function resolving($abstract, $callback = null){
+         */ 
+        public static function resolving($abstract, $callback = null)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::resolving($abstract, $callback);
         }
@@ -1043,12 +1157,13 @@ namespace {
         /**
          * Register a new after resolving callback for all types.
          *
-         * @param string $abstract
+         * @param \Closure|string $abstract
          * @param \Closure|null $callback
          * @return void 
          * @static 
-         */
-        public static function afterResolving($abstract, $callback = null){
+         */ 
+        public static function afterResolving($abstract, $callback = null)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::afterResolving($abstract, $callback);
         }
@@ -1058,8 +1173,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function getBindings(){
+         */ 
+        public static function getBindings()
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::getBindings();
         }
@@ -1071,8 +1187,9 @@ namespace {
          * @return string 
          * @throws \LogicException
          * @static 
-         */
-        public static function getAlias($abstract){
+         */ 
+        public static function getAlias($abstract)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::getAlias($abstract);
         }
@@ -1083,8 +1200,9 @@ namespace {
          * @param string $abstract
          * @return void 
          * @static 
-         */
-        public static function forgetExtenders($abstract){
+         */ 
+        public static function forgetExtenders($abstract)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::forgetExtenders($abstract);
         }
@@ -1095,8 +1213,9 @@ namespace {
          * @param string $abstract
          * @return void 
          * @static 
-         */
-        public static function forgetInstance($abstract){
+         */ 
+        public static function forgetInstance($abstract)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::forgetInstance($abstract);
         }
@@ -1106,8 +1225,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function forgetInstances(){
+         */ 
+        public static function forgetInstances()
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::forgetInstances();
         }
@@ -1117,8 +1237,9 @@ namespace {
          *
          * @return static 
          * @static 
-         */
-        public static function getInstance(){
+         */ 
+        public static function getInstance()
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::getInstance();
         }
@@ -1129,8 +1250,9 @@ namespace {
          * @param \Illuminate\Contracts\Container\Container|null $container
          * @return static 
          * @static 
-         */
-        public static function setInstance($container = null){
+         */ 
+        public static function setInstance($container = null)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::setInstance($container);
         }
@@ -1141,8 +1263,9 @@ namespace {
          * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function offsetExists($key){
+         */ 
+        public static function offsetExists($key)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::offsetExists($key);
         }
@@ -1153,8 +1276,9 @@ namespace {
          * @param string $key
          * @return mixed 
          * @static 
-         */
-        public static function offsetGet($key){
+         */ 
+        public static function offsetGet($key)
+        {
             //Method inherited from \Illuminate\Container\Container            
             return \Illuminate\Foundation\Application::offsetGet($key);
         }
@@ -1166,8 +1290,9 @@ namespace {
          * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function offsetSet($key, $value){
+         */ 
+        public static function offsetSet($key, $value)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::offsetSet($key, $value);
         }
@@ -1178,16 +1303,16 @@ namespace {
          * @param string $key
          * @return void 
          * @static 
-         */
-        public static function offsetUnset($key){
+         */ 
+        public static function offsetUnset($key)
+        {
             //Method inherited from \Illuminate\Container\Container            
             \Illuminate\Foundation\Application::offsetUnset($key);
         }
-        
+         
     }
 
-
-    class Artisan extends \Illuminate\Support\Facades\Artisan{
+    class Artisan {
         
         /**
          * Run the console application.
@@ -1196,8 +1321,9 @@ namespace {
          * @param \Symfony\Component\Console\Output\OutputInterface $output
          * @return int 
          * @static 
-         */
-        public static function handle($input, $output = null){
+         */ 
+        public static function handle($input, $output = null)
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             return \Vanguard\Console\Kernel::handle($input, $output);
         }
@@ -1209,8 +1335,9 @@ namespace {
          * @param int $status
          * @return void 
          * @static 
-         */
-        public static function terminate($input, $status){
+         */ 
+        public static function terminate($input, $status)
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             \Vanguard\Console\Kernel::terminate($input, $status);
         }
@@ -1222,8 +1349,9 @@ namespace {
          * @param \Closure $callback
          * @return \Illuminate\Foundation\Console\ClosureCommand 
          * @static 
-         */
-        public static function command($signature, $callback){
+         */ 
+        public static function command($signature, $callback)
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             return \Vanguard\Console\Kernel::command($signature, $callback);
         }
@@ -1234,8 +1362,9 @@ namespace {
          * @param \Symfony\Component\Console\Command\Command $command
          * @return void 
          * @static 
-         */
-        public static function registerCommand($command){
+         */ 
+        public static function registerCommand($command)
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             \Vanguard\Console\Kernel::registerCommand($command);
         }
@@ -1248,8 +1377,9 @@ namespace {
          * @param \Symfony\Component\Console\Output\OutputInterface $outputBuffer
          * @return int 
          * @static 
-         */
-        public static function call($command, $parameters = array(), $outputBuffer = null){
+         */ 
+        public static function call($command, $parameters = array(), $outputBuffer = null)
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             return \Vanguard\Console\Kernel::call($command, $parameters, $outputBuffer);
         }
@@ -1261,8 +1391,9 @@ namespace {
          * @param array $parameters
          * @return \Illuminate\Foundation\Bus\PendingDispatch 
          * @static 
-         */
-        public static function queue($command, $parameters = array()){
+         */ 
+        public static function queue($command, $parameters = array())
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             return \Vanguard\Console\Kernel::queue($command, $parameters);
         }
@@ -1272,8 +1403,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function all(){
+         */ 
+        public static function all()
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             return \Vanguard\Console\Kernel::all();
         }
@@ -1283,8 +1415,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function output(){
+         */ 
+        public static function output()
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             return \Vanguard\Console\Kernel::output();
         }
@@ -1294,8 +1427,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function bootstrap(){
+         */ 
+        public static function bootstrap()
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             \Vanguard\Console\Kernel::bootstrap();
         }
@@ -1306,16 +1440,16 @@ namespace {
          * @param \Illuminate\Console\Application $artisan
          * @return void 
          * @static 
-         */
-        public static function setArtisan($artisan){
+         */ 
+        public static function setArtisan($artisan)
+        {
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
             \Vanguard\Console\Kernel::setArtisan($artisan);
         }
-        
+         
     }
 
-
-    class Auth extends \Illuminate\Support\Facades\Auth{
+    class Auth {
         
         /**
          * Attempt to get the guard from the local cache.
@@ -1323,8 +1457,9 @@ namespace {
          * @param string $name
          * @return \Illuminate\Contracts\Auth\Guard|\Illuminate\Contracts\Auth\StatefulGuard 
          * @static 
-         */
-        public static function guard($name = null){
+         */ 
+        public static function guard($name = null)
+        {
             return \Illuminate\Auth\AuthManager::guard($name);
         }
         
@@ -1335,8 +1470,9 @@ namespace {
          * @param array $config
          * @return \Illuminate\Auth\SessionGuard 
          * @static 
-         */
-        public static function createSessionDriver($name, $config){
+         */ 
+        public static function createSessionDriver($name, $config)
+        {
             return \Illuminate\Auth\AuthManager::createSessionDriver($name, $config);
         }
         
@@ -1347,8 +1483,9 @@ namespace {
          * @param array $config
          * @return \Illuminate\Auth\TokenGuard 
          * @static 
-         */
-        public static function createTokenDriver($name, $config){
+         */ 
+        public static function createTokenDriver($name, $config)
+        {
             return \Illuminate\Auth\AuthManager::createTokenDriver($name, $config);
         }
         
@@ -1357,8 +1494,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getDefaultDriver(){
+         */ 
+        public static function getDefaultDriver()
+        {
             return \Illuminate\Auth\AuthManager::getDefaultDriver();
         }
         
@@ -1368,8 +1506,9 @@ namespace {
          * @param string $name
          * @return void 
          * @static 
-         */
-        public static function shouldUse($name){
+         */ 
+        public static function shouldUse($name)
+        {
             \Illuminate\Auth\AuthManager::shouldUse($name);
         }
         
@@ -1379,8 +1518,9 @@ namespace {
          * @param string $name
          * @return void 
          * @static 
-         */
-        public static function setDefaultDriver($name){
+         */ 
+        public static function setDefaultDriver($name)
+        {
             \Illuminate\Auth\AuthManager::setDefaultDriver($name);
         }
         
@@ -1391,8 +1531,9 @@ namespace {
          * @param callable $callback
          * @return $this 
          * @static 
-         */
-        public static function viaRequest($driver, $callback){
+         */ 
+        public static function viaRequest($driver, $callback)
+        {
             return \Illuminate\Auth\AuthManager::viaRequest($driver, $callback);
         }
         
@@ -1401,8 +1542,9 @@ namespace {
          *
          * @return \Closure 
          * @static 
-         */
-        public static function userResolver(){
+         */ 
+        public static function userResolver()
+        {
             return \Illuminate\Auth\AuthManager::userResolver();
         }
         
@@ -1412,8 +1554,9 @@ namespace {
          * @param \Closure $userResolver
          * @return $this 
          * @static 
-         */
-        public static function resolveUsersUsing($userResolver){
+         */ 
+        public static function resolveUsersUsing($userResolver)
+        {
             return \Illuminate\Auth\AuthManager::resolveUsersUsing($userResolver);
         }
         
@@ -1424,8 +1567,9 @@ namespace {
          * @param \Closure $callback
          * @return $this 
          * @static 
-         */
-        public static function extend($driver, $callback){
+         */ 
+        public static function extend($driver, $callback)
+        {
             return \Illuminate\Auth\AuthManager::extend($driver, $callback);
         }
         
@@ -1436,30 +1580,44 @@ namespace {
          * @param \Closure $callback
          * @return $this 
          * @static 
-         */
-        public static function provider($name, $callback){
+         */ 
+        public static function provider($name, $callback)
+        {
             return \Illuminate\Auth\AuthManager::provider($name, $callback);
         }
         
         /**
          * Create the user provider implementation for the driver.
          *
-         * @param string $provider
-         * @return \Illuminate\Contracts\Auth\UserProvider 
+         * @param string|null $provider
+         * @return \Illuminate\Contracts\Auth\UserProvider|null 
          * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function createUserProvider($provider){
+         */ 
+        public static function createUserProvider($provider = null)
+        {
             return \Illuminate\Auth\AuthManager::createUserProvider($provider);
         }
         
+        /**
+         * Get the default user provider name.
+         *
+         * @return string 
+         * @static 
+         */ 
+        public static function getDefaultUserProvider()
+        {
+            return \Illuminate\Auth\AuthManager::getDefaultUserProvider();
+        }
+        
         /**
          * Get the currently authenticated user.
          *
          * @return \Vanguard\User|null 
          * @static 
-         */
-        public static function user(){
+         */ 
+        public static function user()
+        {
             return \Illuminate\Auth\SessionGuard::user();
         }
         
@@ -1468,8 +1626,9 @@ namespace {
          *
          * @return int|null 
          * @static 
-         */
-        public static function id(){
+         */ 
+        public static function id()
+        {
             return \Illuminate\Auth\SessionGuard::id();
         }
         
@@ -1479,8 +1638,9 @@ namespace {
          * @param array $credentials
          * @return bool 
          * @static 
-         */
-        public static function once($credentials = array()){
+         */ 
+        public static function once($credentials = array())
+        {
             return \Illuminate\Auth\SessionGuard::once($credentials);
         }
         
@@ -1490,8 +1650,9 @@ namespace {
          * @param mixed $id
          * @return \Vanguard\User|false 
          * @static 
-         */
-        public static function onceUsingId($id){
+         */ 
+        public static function onceUsingId($id)
+        {
             return \Illuminate\Auth\SessionGuard::onceUsingId($id);
         }
         
@@ -1501,8 +1662,9 @@ namespace {
          * @param array $credentials
          * @return bool 
          * @static 
-         */
-        public static function validate($credentials = array()){
+         */ 
+        public static function validate($credentials = array())
+        {
             return \Illuminate\Auth\SessionGuard::validate($credentials);
         }
         
@@ -1513,8 +1675,9 @@ namespace {
          * @param array $extraConditions
          * @return \Symfony\Component\HttpFoundation\Response|null 
          * @static 
-         */
-        public static function basic($field = 'email', $extraConditions = array()){
+         */ 
+        public static function basic($field = 'email', $extraConditions = array())
+        {
             return \Illuminate\Auth\SessionGuard::basic($field, $extraConditions);
         }
         
@@ -1525,8 +1688,9 @@ namespace {
          * @param array $extraConditions
          * @return \Symfony\Component\HttpFoundation\Response|null 
          * @static 
-         */
-        public static function onceBasic($field = 'email', $extraConditions = array()){
+         */ 
+        public static function onceBasic($field = 'email', $extraConditions = array())
+        {
             return \Illuminate\Auth\SessionGuard::onceBasic($field, $extraConditions);
         }
         
@@ -1537,8 +1701,9 @@ namespace {
          * @param bool $remember
          * @return bool 
          * @static 
-         */
-        public static function attempt($credentials = array(), $remember = false){
+         */ 
+        public static function attempt($credentials = array(), $remember = false)
+        {
             return \Illuminate\Auth\SessionGuard::attempt($credentials, $remember);
         }
         
@@ -1549,8 +1714,9 @@ namespace {
          * @param bool $remember
          * @return \Vanguard\User|false 
          * @static 
-         */
-        public static function loginUsingId($id, $remember = false){
+         */ 
+        public static function loginUsingId($id, $remember = false)
+        {
             return \Illuminate\Auth\SessionGuard::loginUsingId($id, $remember);
         }
         
@@ -1561,8 +1727,9 @@ namespace {
          * @param bool $remember
          * @return void 
          * @static 
-         */
-        public static function login($user, $remember = false){
+         */ 
+        public static function login($user, $remember = false)
+        {
             \Illuminate\Auth\SessionGuard::login($user, $remember);
         }
         
@@ -1571,8 +1738,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function logout(){
+         */ 
+        public static function logout()
+        {
             \Illuminate\Auth\SessionGuard::logout();
         }
         
@@ -1582,8 +1750,9 @@ namespace {
          * @param mixed $callback
          * @return void 
          * @static 
-         */
-        public static function attempting($callback){
+         */ 
+        public static function attempting($callback)
+        {
             \Illuminate\Auth\SessionGuard::attempting($callback);
         }
         
@@ -1592,8 +1761,9 @@ namespace {
          *
          * @return \Vanguard\User 
          * @static 
-         */
-        public static function getLastAttempted(){
+         */ 
+        public static function getLastAttempted()
+        {
             return \Illuminate\Auth\SessionGuard::getLastAttempted();
         }
         
@@ -1602,8 +1772,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getName(){
+         */ 
+        public static function getName()
+        {
             return \Illuminate\Auth\SessionGuard::getName();
         }
         
@@ -1612,8 +1783,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getRecallerName(){
+         */ 
+        public static function getRecallerName()
+        {
             return \Illuminate\Auth\SessionGuard::getRecallerName();
         }
         
@@ -1622,8 +1794,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function viaRemember(){
+         */ 
+        public static function viaRemember()
+        {
             return \Illuminate\Auth\SessionGuard::viaRemember();
         }
         
@@ -1633,8 +1806,9 @@ namespace {
          * @return \Illuminate\Contracts\Cookie\QueueingFactory 
          * @throws \RuntimeException
          * @static 
-         */
-        public static function getCookieJar(){
+         */ 
+        public static function getCookieJar()
+        {
             return \Illuminate\Auth\SessionGuard::getCookieJar();
         }
         
@@ -1644,8 +1818,9 @@ namespace {
          * @param \Illuminate\Contracts\Cookie\QueueingFactory $cookie
          * @return void 
          * @static 
-         */
-        public static function setCookieJar($cookie){
+         */ 
+        public static function setCookieJar($cookie)
+        {
             \Illuminate\Auth\SessionGuard::setCookieJar($cookie);
         }
         
@@ -1654,8 +1829,9 @@ namespace {
          *
          * @return \Illuminate\Contracts\Events\Dispatcher 
          * @static 
-         */
-        public static function getDispatcher(){
+         */ 
+        public static function getDispatcher()
+        {
             return \Illuminate\Auth\SessionGuard::getDispatcher();
         }
         
@@ -1665,49 +1841,31 @@ namespace {
          * @param \Illuminate\Contracts\Events\Dispatcher $events
          * @return void 
          * @static 
-         */
-        public static function setDispatcher($events){
+         */ 
+        public static function setDispatcher($events)
+        {
             \Illuminate\Auth\SessionGuard::setDispatcher($events);
         }
         
         /**
          * Get the session store used by the guard.
          *
-         * @return \Illuminate\Session\Store 
+         * @return \Illuminate\Contracts\Session\Session 
          * @static 
-         */
-        public static function getSession(){
+         */ 
+        public static function getSession()
+        {
             return \Illuminate\Auth\SessionGuard::getSession();
         }
         
-        /**
-         * Get the user provider used by the guard.
-         *
-         * @return \Illuminate\Contracts\Auth\UserProvider 
-         * @static 
-         */
-        public static function getProvider(){
-            return \Illuminate\Auth\SessionGuard::getProvider();
-        }
-        
-        /**
-         * Set the user provider used by the guard.
-         *
-         * @param \Illuminate\Contracts\Auth\UserProvider $provider
-         * @return void 
-         * @static 
-         */
-        public static function setProvider($provider){
-            \Illuminate\Auth\SessionGuard::setProvider($provider);
-        }
-        
         /**
          * Return the currently cached user.
          *
          * @return \Vanguard\User|null 
          * @static 
-         */
-        public static function getUser(){
+         */ 
+        public static function getUser()
+        {
             return \Illuminate\Auth\SessionGuard::getUser();
         }
         
@@ -1717,8 +1875,9 @@ namespace {
          * @param \Illuminate\Contracts\Auth\Authenticatable $user
          * @return $this 
          * @static 
-         */
-        public static function setUser($user){
+         */ 
+        public static function setUser($user)
+        {
             return \Illuminate\Auth\SessionGuard::setUser($user);
         }
         
@@ -1727,8 +1886,9 @@ namespace {
          *
          * @return \Symfony\Component\HttpFoundation\Request 
          * @static 
-         */
-        public static function getRequest(){
+         */ 
+        public static function getRequest()
+        {
             return \Illuminate\Auth\SessionGuard::getRequest();
         }
         
@@ -1738,18 +1898,32 @@ namespace {
          * @param \Symfony\Component\HttpFoundation\Request $request
          * @return $this 
          * @static 
-         */
-        public static function setRequest($request){
+         */ 
+        public static function setRequest($request)
+        {
             return \Illuminate\Auth\SessionGuard::setRequest($request);
         }
         
+        /**
+         * Determine if the current user is authenticated.
+         *
+         * @return \Vanguard\User 
+         * @throws \Illuminate\Auth\AuthenticationException
+         * @static 
+         */ 
+        public static function authenticate()
+        {
+            return \Illuminate\Auth\SessionGuard::authenticate();
+        }
+        
         /**
          * Determine if the current user is authenticated.
          *
          * @return bool 
          * @static 
-         */
-        public static function check(){
+         */ 
+        public static function check()
+        {
             return \Illuminate\Auth\SessionGuard::check();
         }
         
@@ -1758,49 +1932,75 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function guest(){
+         */ 
+        public static function guest()
+        {
             return \Illuminate\Auth\SessionGuard::guest();
         }
         
         /**
-         * Determine if the current user is authenticated.
+         * Get the user provider used by the guard.
          *
-         * @return \Vanguard\User 
-         * @throws \Illuminate\Auth\AuthenticationException
+         * @return \Illuminate\Contracts\Auth\UserProvider 
          * @static 
-         */
-        public static function authenticate(){
-            return \Illuminate\Auth\SessionGuard::authenticate();
+         */ 
+        public static function getProvider()
+        {
+            return \Illuminate\Auth\SessionGuard::getProvider();
+        }
+        
+        /**
+         * Set the user provider used by the guard.
+         *
+         * @param \Illuminate\Contracts\Auth\UserProvider $provider
+         * @return void 
+         * @static 
+         */ 
+        public static function setProvider($provider)
+        {
+            \Illuminate\Auth\SessionGuard::setProvider($provider);
         }
         
         /**
          * Register a custom macro.
          *
          * @param string $name
-         * @param callable $macro
+         * @param object|callable $macro
          * @return void 
          * @static 
-         */
-        public static function macro($name, $macro){
+         */ 
+        public static function macro($name, $macro)
+        {
             \Illuminate\Auth\SessionGuard::macro($name, $macro);
         }
         
+        /**
+         * Mix another object into the class.
+         *
+         * @param object $mixin
+         * @return void 
+         * @static 
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Auth\SessionGuard::mixin($mixin);
+        }
+        
         /**
          * Checks if macro is registered.
          *
          * @param string $name
          * @return bool 
          * @static 
-         */
-        public static function hasMacro($name){
+         */ 
+        public static function hasMacro($name)
+        {
             return \Illuminate\Auth\SessionGuard::hasMacro($name);
         }
-        
+         
     }
 
-
-    class Blade extends \Illuminate\Support\Facades\Blade{
+    class Blade {
         
         /**
          * Compile the view at the given path.
@@ -1808,8 +2008,9 @@ namespace {
          * @param string $path
          * @return void 
          * @static 
-         */
-        public static function compile($path = null){
+         */ 
+        public static function compile($path = null)
+        {
             \Illuminate\View\Compilers\BladeCompiler::compile($path);
         }
         
@@ -1818,8 +2019,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getPath(){
+         */ 
+        public static function getPath()
+        {
             return \Illuminate\View\Compilers\BladeCompiler::getPath();
         }
         
@@ -1829,8 +2031,9 @@ namespace {
          * @param string $path
          * @return void 
          * @static 
-         */
-        public static function setPath($path){
+         */ 
+        public static function setPath($path)
+        {
             \Illuminate\View\Compilers\BladeCompiler::setPath($path);
         }
         
@@ -1840,8 +2043,9 @@ namespace {
          * @param string $value
          * @return string 
          * @static 
-         */
-        public static function compileString($value){
+         */ 
+        public static function compileString($value)
+        {
             return \Illuminate\View\Compilers\BladeCompiler::compileString($value);
         }
         
@@ -1851,8 +2055,9 @@ namespace {
          * @param string $expression
          * @return string 
          * @static 
-         */
-        public static function stripParentheses($expression){
+         */ 
+        public static function stripParentheses($expression)
+        {
             return \Illuminate\View\Compilers\BladeCompiler::stripParentheses($expression);
         }
         
@@ -1862,8 +2067,9 @@ namespace {
          * @param callable $compiler
          * @return void 
          * @static 
-         */
-        public static function extend($compiler){
+         */ 
+        public static function extend($compiler)
+        {
             \Illuminate\View\Compilers\BladeCompiler::extend($compiler);
         }
         
@@ -1872,11 +2078,64 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function getExtensions(){
+         */ 
+        public static function getExtensions()
+        {
             return \Illuminate\View\Compilers\BladeCompiler::getExtensions();
         }
         
+        /**
+         * Register an "if" statement directive.
+         *
+         * @param string $name
+         * @param callable $callback
+         * @return void 
+         * @static 
+         */ 
+        public static function if($name, $callback)
+        {
+            \Illuminate\View\Compilers\BladeCompiler::if($name, $callback);
+        }
+        
+        /**
+         * Check the result of a condition.
+         *
+         * @param string $name
+         * @param array $parameters
+         * @return bool 
+         * @static 
+         */ 
+        public static function check($name, $parameters = null)
+        {
+            return \Illuminate\View\Compilers\BladeCompiler::check($name, $parameters);
+        }
+        
+        /**
+         * Register a component alias directive.
+         *
+         * @param string $path
+         * @param string $alias
+         * @return void 
+         * @static 
+         */ 
+        public static function component($path, $alias = null)
+        {
+            \Illuminate\View\Compilers\BladeCompiler::component($path, $alias);
+        }
+        
+        /**
+         * Register an include alias directive.
+         *
+         * @param string $path
+         * @param string $alias
+         * @return void 
+         * @static 
+         */ 
+        public static function include($path, $alias = null)
+        {
+            \Illuminate\View\Compilers\BladeCompiler::include($path, $alias);
+        }
+        
         /**
          * Register a handler for custom directives.
          *
@@ -1884,8 +2143,9 @@ namespace {
          * @param callable $handler
          * @return void 
          * @static 
-         */
-        public static function directive($name, $handler){
+         */ 
+        public static function directive($name, $handler)
+        {
             \Illuminate\View\Compilers\BladeCompiler::directive($name, $handler);
         }
         
@@ -1894,8 +2154,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function getCustomDirectives(){
+         */ 
+        public static function getCustomDirectives()
+        {
             return \Illuminate\View\Compilers\BladeCompiler::getCustomDirectives();
         }
         
@@ -1905,19 +2166,43 @@ namespace {
          * @param string $format
          * @return void 
          * @static 
-         */
-        public static function setEchoFormat($format){
+         */ 
+        public static function setEchoFormat($format)
+        {
             \Illuminate\View\Compilers\BladeCompiler::setEchoFormat($format);
         }
         
+        /**
+         * Set the "echo" format to double encode entities.
+         *
+         * @return void 
+         * @static 
+         */ 
+        public static function withDoubleEncoding()
+        {
+            \Illuminate\View\Compilers\BladeCompiler::withDoubleEncoding();
+        }
+        
+        /**
+         * Set the "echo" format to not double encode entities.
+         *
+         * @return void 
+         * @static 
+         */ 
+        public static function withoutDoubleEncoding()
+        {
+            \Illuminate\View\Compilers\BladeCompiler::withoutDoubleEncoding();
+        }
+        
         /**
          * Get the path to the compiled version of a view.
          *
          * @param string $path
          * @return string 
          * @static 
-         */
-        public static function getCompiledPath($path){
+         */ 
+        public static function getCompiledPath($path)
+        {
             //Method inherited from \Illuminate\View\Compilers\Compiler            
             return \Illuminate\View\Compilers\BladeCompiler::getCompiledPath($path);
         }
@@ -1928,8 +2213,9 @@ namespace {
          * @param string $path
          * @return bool 
          * @static 
-         */
-        public static function isExpired($path){
+         */ 
+        public static function isExpired($path)
+        {
             //Method inherited from \Illuminate\View\Compilers\Compiler            
             return \Illuminate\View\Compilers\BladeCompiler::isExpired($path);
         }
@@ -1940,15 +2226,15 @@ namespace {
          * @param string $value
          * @return string 
          * @static 
-         */
-        public static function compileEchoDefaults($value){
+         */ 
+        public static function compileEchoDefaults($value)
+        {
             return \Illuminate\View\Compilers\BladeCompiler::compileEchoDefaults($value);
         }
-        
+         
     }
 
-
-    class Bus extends \Illuminate\Support\Facades\Bus{
+    class Bus {
         
         /**
          * Dispatch a command to its appropriate handler.
@@ -1956,8 +2242,9 @@ namespace {
          * @param mixed $command
          * @return mixed 
          * @static 
-         */
-        public static function dispatch($command){
+         */ 
+        public static function dispatch($command)
+        {
             return \Illuminate\Bus\Dispatcher::dispatch($command);
         }
         
@@ -1968,8 +2255,9 @@ namespace {
          * @param mixed $handler
          * @return mixed 
          * @static 
-         */
-        public static function dispatchNow($command, $handler = null){
+         */ 
+        public static function dispatchNow($command, $handler = null)
+        {
             return \Illuminate\Bus\Dispatcher::dispatchNow($command, $handler);
         }
         
@@ -1979,8 +2267,9 @@ namespace {
          * @param mixed $command
          * @return bool 
          * @static 
-         */
-        public static function hasCommandHandler($command){
+         */ 
+        public static function hasCommandHandler($command)
+        {
             return \Illuminate\Bus\Dispatcher::hasCommandHandler($command);
         }
         
@@ -1990,8 +2279,9 @@ namespace {
          * @param mixed $command
          * @return bool|mixed 
          * @static 
-         */
-        public static function getCommandHandler($command){
+         */ 
+        public static function getCommandHandler($command)
+        {
             return \Illuminate\Bus\Dispatcher::getCommandHandler($command);
         }
         
@@ -2002,8 +2292,9 @@ namespace {
          * @return mixed 
          * @throws \RuntimeException
          * @static 
-         */
-        public static function dispatchToQueue($command){
+         */ 
+        public static function dispatchToQueue($command)
+        {
             return \Illuminate\Bus\Dispatcher::dispatchToQueue($command);
         }
         
@@ -2013,8 +2304,9 @@ namespace {
          * @param array $pipes
          * @return $this 
          * @static 
-         */
-        public static function pipeThrough($pipes){
+         */ 
+        public static function pipeThrough($pipes)
+        {
             return \Illuminate\Bus\Dispatcher::pipeThrough($pipes);
         }
         
@@ -2024,24 +2316,25 @@ namespace {
          * @param array $map
          * @return $this 
          * @static 
-         */
-        public static function map($map){
+         */ 
+        public static function map($map)
+        {
             return \Illuminate\Bus\Dispatcher::map($map);
         }
-        
+         
     }
 
-
-    class Cache extends \Illuminate\Support\Facades\Cache{
+    class Cache {
         
         /**
          * Get a cache store instance by name.
          *
          * @param string|null $name
-         * @return mixed 
+         * @return \Illuminate\Contracts\Cache\Repository 
          * @static 
-         */
-        public static function store($name = null){
+         */ 
+        public static function store($name = null)
+        {
             return \Illuminate\Cache\CacheManager::store($name);
         }
         
@@ -2051,8 +2344,9 @@ namespace {
          * @param string $driver
          * @return mixed 
          * @static 
-         */
-        public static function driver($driver = null){
+         */ 
+        public static function driver($driver = null)
+        {
             return \Illuminate\Cache\CacheManager::driver($driver);
         }
         
@@ -2062,8 +2356,9 @@ namespace {
          * @param \Illuminate\Contracts\Cache\Store $store
          * @return \Illuminate\Cache\Repository 
          * @static 
-         */
-        public static function repository($store){
+         */ 
+        public static function repository($store)
+        {
             return \Illuminate\Cache\CacheManager::repository($store);
         }
         
@@ -2072,8 +2367,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getDefaultDriver(){
+         */ 
+        public static function getDefaultDriver()
+        {
             return \Illuminate\Cache\CacheManager::getDefaultDriver();
         }
         
@@ -2083,8 +2379,9 @@ namespace {
          * @param string $name
          * @return void 
          * @static 
-         */
-        public static function setDefaultDriver($name){
+         */ 
+        public static function setDefaultDriver($name)
+        {
             \Illuminate\Cache\CacheManager::setDefaultDriver($name);
         }
         
@@ -2095,8 +2392,9 @@ namespace {
          * @param \Closure $callback
          * @return $this 
          * @static 
-         */
-        public static function extend($driver, $callback){
+         */ 
+        public static function extend($driver, $callback)
+        {
             return \Illuminate\Cache\CacheManager::extend($driver, $callback);
         }
         
@@ -2106,8 +2404,9 @@ namespace {
          * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function has($key){
+         */ 
+        public static function has($key)
+        {
             return \Illuminate\Cache\Repository::has($key);
         }
         
@@ -2118,8 +2417,9 @@ namespace {
          * @param mixed $default
          * @return mixed 
          * @static 
-         */
-        public static function get($key, $default = null){
+         */ 
+        public static function get($key, $default = null)
+        {
             return \Illuminate\Cache\Repository::get($key, $default);
         }
         
@@ -2131,11 +2431,28 @@ namespace {
          * @param array $keys
          * @return array 
          * @static 
-         */
-        public static function many($keys){
+         */ 
+        public static function many($keys)
+        {
             return \Illuminate\Cache\Repository::many($keys);
         }
         
+        /**
+         * Obtains multiple cache items by their unique keys.
+         *
+         * @param \Psr\SimpleCache\iterable $keys A list of keys that can obtained in a single operation.
+         * @param mixed $default Default value to return for keys that do not exist.
+         * @return \Psr\SimpleCache\iterable A list of key => value pairs. Cache keys that do not exist or are stale will have $default as value.
+         * @throws \Psr\SimpleCache\InvalidArgumentException
+         *   MUST be thrown if $keys is neither an array nor a Traversable,
+         *   or if any of the $keys are not a legal value.
+         * @static 
+         */ 
+        public static function getMultiple($keys, $default = null)
+        {
+            return \Illuminate\Cache\Repository::getMultiple($keys, $default);
+        }
+        
         /**
          * Retrieve an item from the cache and delete it.
          *
@@ -2143,8 +2460,9 @@ namespace {
          * @param mixed $default
          * @return mixed 
          * @static 
-         */
-        public static function pull($key, $default = null){
+         */ 
+        public static function pull($key, $default = null)
+        {
             return \Illuminate\Cache\Repository::pull($key, $default);
         }
         
@@ -2153,36 +2471,75 @@ namespace {
          *
          * @param string $key
          * @param mixed $value
-         * @param \DateTime|float|int $minutes
+         * @param \DateTimeInterface|\DateInterval|float|int $minutes
          * @return void 
          * @static 
-         */
-        public static function put($key, $value, $minutes = null){
+         */ 
+        public static function put($key, $value, $minutes = null)
+        {
             \Illuminate\Cache\Repository::put($key, $value, $minutes);
         }
         
+        /**
+         * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time.
+         *
+         * @param string $key The key of the item to store.
+         * @param mixed $value The value of the item to store, must be serializable.
+         * @param null|int|\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and
+         *                                      the driver supports TTL then the library may set a default value
+         *                                      for it or let the driver take care of that.
+         * @return bool True on success and false on failure.
+         * @throws \Psr\SimpleCache\InvalidArgumentException
+         *   MUST be thrown if the $key string is not a legal value.
+         * @static 
+         */ 
+        public static function set($key, $value, $ttl = null)
+        {
+            return \Illuminate\Cache\Repository::set($key, $value, $ttl);
+        }
+        
         /**
          * Store multiple items in the cache for a given number of minutes.
          *
          * @param array $values
-         * @param float|int $minutes
+         * @param \DateTimeInterface|\DateInterval|float|int $minutes
          * @return void 
          * @static 
-         */
-        public static function putMany($values, $minutes){
+         */ 
+        public static function putMany($values, $minutes)
+        {
             \Illuminate\Cache\Repository::putMany($values, $minutes);
         }
         
+        /**
+         * Persists a set of key => value pairs in the cache, with an optional TTL.
+         *
+         * @param \Psr\SimpleCache\iterable $values A list of key => value pairs for a multiple-set operation.
+         * @param null|int|\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and
+         *                                       the driver supports TTL then the library may set a default value
+         *                                       for it or let the driver take care of that.
+         * @return bool True on success and false on failure.
+         * @throws \Psr\SimpleCache\InvalidArgumentException
+         *   MUST be thrown if $values is neither an array nor a Traversable,
+         *   or if any of the $values are not a legal value.
+         * @static 
+         */ 
+        public static function setMultiple($values, $ttl = null)
+        {
+            return \Illuminate\Cache\Repository::setMultiple($values, $ttl);
+        }
+        
         /**
          * Store an item in the cache if the key does not exist.
          *
          * @param string $key
          * @param mixed $value
-         * @param \DateTime|float|int $minutes
+         * @param \DateTimeInterface|\DateInterval|float|int $minutes
          * @return bool 
          * @static 
-         */
-        public static function add($key, $value, $minutes){
+         */ 
+        public static function add($key, $value, $minutes)
+        {
             return \Illuminate\Cache\Repository::add($key, $value, $minutes);
         }
         
@@ -2193,8 +2550,9 @@ namespace {
          * @param mixed $value
          * @return int|bool 
          * @static 
-         */
-        public static function increment($key, $value = 1){
+         */ 
+        public static function increment($key, $value = 1)
+        {
             return \Illuminate\Cache\Repository::increment($key, $value);
         }
         
@@ -2205,8 +2563,9 @@ namespace {
          * @param mixed $value
          * @return int|bool 
          * @static 
-         */
-        public static function decrement($key, $value = 1){
+         */ 
+        public static function decrement($key, $value = 1)
+        {
             return \Illuminate\Cache\Repository::decrement($key, $value);
         }
         
@@ -2217,8 +2576,9 @@ namespace {
          * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function forever($key, $value){
+         */ 
+        public static function forever($key, $value)
+        {
             \Illuminate\Cache\Repository::forever($key, $value);
         }
         
@@ -2226,12 +2586,13 @@ namespace {
          * Get an item from the cache, or store the default value.
          *
          * @param string $key
-         * @param \DateTime|float|int $minutes
+         * @param \DateTimeInterface|\DateInterval|float|int $minutes
          * @param \Closure $callback
          * @return mixed 
          * @static 
-         */
-        public static function remember($key, $minutes, $callback){
+         */ 
+        public static function remember($key, $minutes, $callback)
+        {
             return \Illuminate\Cache\Repository::remember($key, $minutes, $callback);
         }
         
@@ -2242,8 +2603,9 @@ namespace {
          * @param \Closure $callback
          * @return mixed 
          * @static 
-         */
-        public static function sear($key, $callback){
+         */ 
+        public static function sear($key, $callback)
+        {
             return \Illuminate\Cache\Repository::sear($key, $callback);
         }
         
@@ -2254,8 +2616,9 @@ namespace {
          * @param \Closure $callback
          * @return mixed 
          * @static 
-         */
-        public static function rememberForever($key, $callback){
+         */ 
+        public static function rememberForever($key, $callback)
+        {
             return \Illuminate\Cache\Repository::rememberForever($key, $callback);
         }
         
@@ -2265,11 +2628,52 @@ namespace {
          * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function forget($key){
+         */ 
+        public static function forget($key)
+        {
             return \Illuminate\Cache\Repository::forget($key);
         }
         
+        /**
+         * Delete an item from the cache by its unique key.
+         *
+         * @param string $key The unique cache key of the item to delete.
+         * @return bool True if the item was successfully removed. False if there was an error.
+         * @throws \Psr\SimpleCache\InvalidArgumentException
+         *   MUST be thrown if the $key string is not a legal value.
+         * @static 
+         */ 
+        public static function delete($key)
+        {
+            return \Illuminate\Cache\Repository::delete($key);
+        }
+        
+        /**
+         * Deletes multiple cache items in a single operation.
+         *
+         * @param \Psr\SimpleCache\iterable $keys A list of string-based keys to be deleted.
+         * @return bool True if the items were successfully removed. False if there was an error.
+         * @throws \Psr\SimpleCache\InvalidArgumentException
+         *   MUST be thrown if $keys is neither an array nor a Traversable,
+         *   or if any of the $keys are not a legal value.
+         * @static 
+         */ 
+        public static function deleteMultiple($keys)
+        {
+            return \Illuminate\Cache\Repository::deleteMultiple($keys);
+        }
+        
+        /**
+         * Wipes clean the entire cache's keys.
+         *
+         * @return bool True on success and false on failure.
+         * @static 
+         */ 
+        public static function clear()
+        {
+            return \Illuminate\Cache\Repository::clear();
+        }
+        
         /**
          * Begin executing a new tags operation if the store supports it.
          *
@@ -2277,8 +2681,9 @@ namespace {
          * @return \Illuminate\Cache\TaggedCache 
          * @throws \BadMethodCallException
          * @static 
-         */
-        public static function tags($names){
+         */ 
+        public static function tags($names)
+        {
             return \Illuminate\Cache\Repository::tags($names);
         }
         
@@ -2287,8 +2692,9 @@ namespace {
          *
          * @return float|int 
          * @static 
-         */
-        public static function getDefaultCacheTime(){
+         */ 
+        public static function getDefaultCacheTime()
+        {
             return \Illuminate\Cache\Repository::getDefaultCacheTime();
         }
         
@@ -2298,8 +2704,9 @@ namespace {
          * @param float|int $minutes
          * @return $this 
          * @static 
-         */
-        public static function setDefaultCacheTime($minutes){
+         */ 
+        public static function setDefaultCacheTime($minutes)
+        {
             return \Illuminate\Cache\Repository::setDefaultCacheTime($minutes);
         }
         
@@ -2308,8 +2715,9 @@ namespace {
          *
          * @return \Illuminate\Contracts\Cache\Store 
          * @static 
-         */
-        public static function getStore(){
+         */ 
+        public static function getStore()
+        {
             return \Illuminate\Cache\Repository::getStore();
         }
         
@@ -2319,8 +2727,9 @@ namespace {
          * @param \Illuminate\Contracts\Events\Dispatcher $events
          * @return void 
          * @static 
-         */
-        public static function setEventDispatcher($events){
+         */ 
+        public static function setEventDispatcher($events)
+        {
             \Illuminate\Cache\Repository::setEventDispatcher($events);
         }
         
@@ -2330,8 +2739,9 @@ namespace {
          * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function offsetExists($key){
+         */ 
+        public static function offsetExists($key)
+        {
             return \Illuminate\Cache\Repository::offsetExists($key);
         }
         
@@ -2341,8 +2751,9 @@ namespace {
          * @param string $key
          * @return mixed 
          * @static 
-         */
-        public static function offsetGet($key){
+         */ 
+        public static function offsetGet($key)
+        {
             return \Illuminate\Cache\Repository::offsetGet($key);
         }
         
@@ -2353,8 +2764,9 @@ namespace {
          * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function offsetSet($key, $value){
+         */ 
+        public static function offsetSet($key, $value)
+        {
             \Illuminate\Cache\Repository::offsetSet($key, $value);
         }
         
@@ -2364,8 +2776,9 @@ namespace {
          * @param string $key
          * @return void 
          * @static 
-         */
-        public static function offsetUnset($key){
+         */ 
+        public static function offsetUnset($key)
+        {
             \Illuminate\Cache\Repository::offsetUnset($key);
         }
         
@@ -2373,22 +2786,36 @@ namespace {
          * Register a custom macro.
          *
          * @param string $name
-         * @param callable $macro
+         * @param object|callable $macro
          * @return void 
          * @static 
-         */
-        public static function macro($name, $macro){
+         */ 
+        public static function macro($name, $macro)
+        {
             \Illuminate\Cache\Repository::macro($name, $macro);
         }
         
+        /**
+         * Mix another object into the class.
+         *
+         * @param object $mixin
+         * @return void 
+         * @static 
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Cache\Repository::mixin($mixin);
+        }
+        
         /**
          * Checks if macro is registered.
          *
          * @param string $name
          * @return bool 
          * @static 
-         */
-        public static function hasMacro($name){
+         */ 
+        public static function hasMacro($name)
+        {
             return \Illuminate\Cache\Repository::hasMacro($name);
         }
         
@@ -2400,8 +2827,9 @@ namespace {
          * @return mixed 
          * @throws \BadMethodCallException
          * @static 
-         */
-        public static function macroCall($method, $parameters){
+         */ 
+        public static function macroCall($method, $parameters)
+        {
             return \Illuminate\Cache\Repository::macroCall($method, $parameters);
         }
         
@@ -2410,8 +2838,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function flush(){
+         */ 
+        public static function flush()
+        {
             return \Illuminate\Cache\FileStore::flush();
         }
         
@@ -2420,8 +2849,9 @@ namespace {
          *
          * @return \Illuminate\Filesystem\Filesystem 
          * @static 
-         */
-        public static function getFilesystem(){
+         */ 
+        public static function getFilesystem()
+        {
             return \Illuminate\Cache\FileStore::getFilesystem();
         }
         
@@ -2430,8 +2860,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getDirectory(){
+         */ 
+        public static function getDirectory()
+        {
             return \Illuminate\Cache\FileStore::getDirectory();
         }
         
@@ -2440,15 +2871,15 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getPrefix(){
+         */ 
+        public static function getPrefix()
+        {
             return \Illuminate\Cache\FileStore::getPrefix();
         }
-        
+         
     }
 
-
-    class Config extends \Illuminate\Support\Facades\Config{
+    class Config {
         
         /**
          * Determine if the given configuration value exists.
@@ -2456,23 +2887,37 @@ namespace {
          * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function has($key){
+         */ 
+        public static function has($key)
+        {
             return \Illuminate\Config\Repository::has($key);
         }
         
         /**
          * Get the specified configuration value.
          *
-         * @param string $key
+         * @param array|string $key
          * @param mixed $default
          * @return mixed 
          * @static 
-         */
-        public static function get($key, $default = null){
+         */ 
+        public static function get($key, $default = null)
+        {
             return \Illuminate\Config\Repository::get($key, $default);
         }
         
+        /**
+         * Get many configuration values.
+         *
+         * @param array $keys
+         * @return array 
+         * @static 
+         */ 
+        public static function getMany($keys)
+        {
+            return \Illuminate\Config\Repository::getMany($keys);
+        }
+        
         /**
          * Set a given configuration value.
          *
@@ -2480,8 +2925,9 @@ namespace {
          * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function set($key, $value = null){
+         */ 
+        public static function set($key, $value = null)
+        {
             \Illuminate\Config\Repository::set($key, $value);
         }
         
@@ -2492,8 +2938,9 @@ namespace {
          * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function prepend($key, $value){
+         */ 
+        public static function prepend($key, $value)
+        {
             \Illuminate\Config\Repository::prepend($key, $value);
         }
         
@@ -2504,8 +2951,9 @@ namespace {
          * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function push($key, $value){
+         */ 
+        public static function push($key, $value)
+        {
             \Illuminate\Config\Repository::push($key, $value);
         }
         
@@ -2514,8 +2962,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function all(){
+         */ 
+        public static function all()
+        {
             return \Illuminate\Config\Repository::all();
         }
         
@@ -2525,8 +2974,9 @@ namespace {
          * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function offsetExists($key){
+         */ 
+        public static function offsetExists($key)
+        {
             return \Illuminate\Config\Repository::offsetExists($key);
         }
         
@@ -2536,8 +2986,9 @@ namespace {
          * @param string $key
          * @return mixed 
          * @static 
-         */
-        public static function offsetGet($key){
+         */ 
+        public static function offsetGet($key)
+        {
             return \Illuminate\Config\Repository::offsetGet($key);
         }
         
@@ -2548,8 +2999,9 @@ namespace {
          * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function offsetSet($key, $value){
+         */ 
+        public static function offsetSet($key, $value)
+        {
             \Illuminate\Config\Repository::offsetSet($key, $value);
         }
         
@@ -2559,15 +3011,15 @@ namespace {
          * @param string $key
          * @return void 
          * @static 
-         */
-        public static function offsetUnset($key){
+         */ 
+        public static function offsetUnset($key)
+        {
             \Illuminate\Config\Repository::offsetUnset($key);
         }
-        
+         
     }
 
-
-    class Cookie extends \Illuminate\Support\Facades\Cookie{
+    class Cookie {
         
         /**
          * Create a new cookie instance.
@@ -2577,13 +3029,16 @@ namespace {
          * @param int $minutes
          * @param string $path
          * @param string $domain
-         * @param bool $secure
+         * @param bool|null $secure
          * @param bool $httpOnly
+         * @param bool $raw
+         * @param string|null $sameSite
          * @return \Symfony\Component\HttpFoundation\Cookie 
          * @static 
-         */
-        public static function make($name, $value, $minutes = 0, $path = null, $domain = null, $secure = false, $httpOnly = true){
-            return \Illuminate\Cookie\CookieJar::make($name, $value, $minutes, $path, $domain, $secure, $httpOnly);
+         */ 
+        public static function make($name, $value, $minutes = 0, $path = null, $domain = null, $secure = null, $httpOnly = true, $raw = false, $sameSite = null)
+        {
+            return \Illuminate\Cookie\CookieJar::make($name, $value, $minutes, $path, $domain, $secure, $httpOnly, $raw, $sameSite);
         }
         
         /**
@@ -2593,13 +3048,16 @@ namespace {
          * @param string $value
          * @param string $path
          * @param string $domain
-         * @param bool $secure
+         * @param bool|null $secure
          * @param bool $httpOnly
+         * @param bool $raw
+         * @param string|null $sameSite
          * @return \Symfony\Component\HttpFoundation\Cookie 
          * @static 
-         */
-        public static function forever($name, $value, $path = null, $domain = null, $secure = false, $httpOnly = true){
-            return \Illuminate\Cookie\CookieJar::forever($name, $value, $path, $domain, $secure, $httpOnly);
+         */ 
+        public static function forever($name, $value, $path = null, $domain = null, $secure = null, $httpOnly = true, $raw = false, $sameSite = null)
+        {
+            return \Illuminate\Cookie\CookieJar::forever($name, $value, $path, $domain, $secure, $httpOnly, $raw, $sameSite);
         }
         
         /**
@@ -2610,8 +3068,9 @@ namespace {
          * @param string $domain
          * @return \Symfony\Component\HttpFoundation\Cookie 
          * @static 
-         */
-        public static function forget($name, $path = null, $domain = null){
+         */ 
+        public static function forget($name, $path = null, $domain = null)
+        {
             return \Illuminate\Cookie\CookieJar::forget($name, $path, $domain);
         }
         
@@ -2621,8 +3080,9 @@ namespace {
          * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function hasQueued($key){
+         */ 
+        public static function hasQueued($key)
+        {
             return \Illuminate\Cookie\CookieJar::hasQueued($key);
         }
         
@@ -2633,8 +3093,9 @@ namespace {
          * @param mixed $default
          * @return \Symfony\Component\HttpFoundation\Cookie 
          * @static 
-         */
-        public static function queued($key, $default = null){
+         */ 
+        public static function queued($key, $default = null)
+        {
             return \Illuminate\Cookie\CookieJar::queued($key, $default);
         }
         
@@ -2644,8 +3105,9 @@ namespace {
          * @param array $parameters
          * @return void 
          * @static 
-         */
-        public static function queue($parameters = null){
+         */ 
+        public static function queue($parameters = null)
+        {
             \Illuminate\Cookie\CookieJar::queue($parameters);
         }
         
@@ -2655,8 +3117,9 @@ namespace {
          * @param string $name
          * @return void 
          * @static 
-         */
-        public static function unqueue($name){
+         */ 
+        public static function unqueue($name)
+        {
             \Illuminate\Cookie\CookieJar::unqueue($name);
         }
         
@@ -2666,27 +3129,29 @@ namespace {
          * @param string $path
          * @param string $domain
          * @param bool $secure
+         * @param string $sameSite
          * @return $this 
          * @static 
-         */
-        public static function setDefaultPathAndDomain($path, $domain, $secure = false){
-            return \Illuminate\Cookie\CookieJar::setDefaultPathAndDomain($path, $domain, $secure);
+         */ 
+        public static function setDefaultPathAndDomain($path, $domain, $secure = false, $sameSite = null)
+        {
+            return \Illuminate\Cookie\CookieJar::setDefaultPathAndDomain($path, $domain, $secure, $sameSite);
         }
         
         /**
          * Get the cookies which have been queued for the next request.
          *
-         * @return array 
+         * @return \Symfony\Component\HttpFoundation\Cookie[] 
          * @static 
-         */
-        public static function getQueuedCookies(){
+         */ 
+        public static function getQueuedCookies()
+        {
             return \Illuminate\Cookie\CookieJar::getQueuedCookies();
         }
-        
+         
     }
 
-
-    class Crypt extends \Illuminate\Support\Facades\Crypt{
+    class Crypt {
         
         /**
          * Determine if the given key and cipher combination is valid.
@@ -2695,11 +3160,24 @@ namespace {
          * @param string $cipher
          * @return bool 
          * @static 
-         */
-        public static function supported($key, $cipher){
+         */ 
+        public static function supported($key, $cipher)
+        {
             return \Illuminate\Encryption\Encrypter::supported($key, $cipher);
         }
         
+        /**
+         * Create a new encryption key for the given cipher.
+         *
+         * @param string $cipher
+         * @return string 
+         * @static 
+         */ 
+        public static function generateKey($cipher)
+        {
+            return \Illuminate\Encryption\Encrypter::generateKey($cipher);
+        }
+        
         /**
          * Encrypt the given value.
          *
@@ -2708,8 +3186,9 @@ namespace {
          * @return string 
          * @throws \Illuminate\Contracts\Encryption\EncryptException
          * @static 
-         */
-        public static function encrypt($value, $serialize = true){
+         */ 
+        public static function encrypt($value, $serialize = true)
+        {
             return \Illuminate\Encryption\Encrypter::encrypt($value, $serialize);
         }
         
@@ -2719,8 +3198,9 @@ namespace {
          * @param string $value
          * @return string 
          * @static 
-         */
-        public static function encryptString($value){
+         */ 
+        public static function encryptString($value)
+        {
             return \Illuminate\Encryption\Encrypter::encryptString($value);
         }
         
@@ -2732,8 +3212,9 @@ namespace {
          * @return string 
          * @throws \Illuminate\Contracts\Encryption\DecryptException
          * @static 
-         */
-        public static function decrypt($payload, $unserialize = true){
+         */ 
+        public static function decrypt($payload, $unserialize = true)
+        {
             return \Illuminate\Encryption\Encrypter::decrypt($payload, $unserialize);
         }
         
@@ -2743,8 +3224,9 @@ namespace {
          * @param string $payload
          * @return string 
          * @static 
-         */
-        public static function decryptString($payload){
+         */ 
+        public static function decryptString($payload)
+        {
             return \Illuminate\Encryption\Encrypter::decryptString($payload);
         }
         
@@ -2753,15 +3235,15 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getKey(){
+         */ 
+        public static function getKey()
+        {
             return \Illuminate\Encryption\Encrypter::getKey();
         }
-        
+         
     }
 
-
-    class DB extends \Illuminate\Support\Facades\DB{
+    class DB {
         
         /**
          * Get a database connection instance.
@@ -2769,8 +3251,9 @@ namespace {
          * @param string $name
          * @return \Illuminate\Database\Connection 
          * @static 
-         */
-        public static function connection($name = null){
+         */ 
+        public static function connection($name = null)
+        {
             return \Illuminate\Database\DatabaseManager::connection($name);
         }
         
@@ -2780,8 +3263,9 @@ namespace {
          * @param string $name
          * @return void 
          * @static 
-         */
-        public static function purge($name = null){
+         */ 
+        public static function purge($name = null)
+        {
             \Illuminate\Database\DatabaseManager::purge($name);
         }
         
@@ -2791,8 +3275,9 @@ namespace {
          * @param string $name
          * @return void 
          * @static 
-         */
-        public static function disconnect($name = null){
+         */ 
+        public static function disconnect($name = null)
+        {
             \Illuminate\Database\DatabaseManager::disconnect($name);
         }
         
@@ -2802,8 +3287,9 @@ namespace {
          * @param string $name
          * @return \Illuminate\Database\Connection 
          * @static 
-         */
-        public static function reconnect($name = null){
+         */ 
+        public static function reconnect($name = null)
+        {
             return \Illuminate\Database\DatabaseManager::reconnect($name);
         }
         
@@ -2812,8 +3298,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getDefaultConnection(){
+         */ 
+        public static function getDefaultConnection()
+        {
             return \Illuminate\Database\DatabaseManager::getDefaultConnection();
         }
         
@@ -2823,8 +3310,9 @@ namespace {
          * @param string $name
          * @return void 
          * @static 
-         */
-        public static function setDefaultConnection($name){
+         */ 
+        public static function setDefaultConnection($name)
+        {
             \Illuminate\Database\DatabaseManager::setDefaultConnection($name);
         }
         
@@ -2833,8 +3321,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function supportedDrivers(){
+         */ 
+        public static function supportedDrivers()
+        {
             return \Illuminate\Database\DatabaseManager::supportedDrivers();
         }
         
@@ -2843,8 +3332,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function availableDrivers(){
+         */ 
+        public static function availableDrivers()
+        {
             return \Illuminate\Database\DatabaseManager::availableDrivers();
         }
         
@@ -2855,8 +3345,9 @@ namespace {
          * @param callable $resolver
          * @return void 
          * @static 
-         */
-        public static function extend($name, $resolver){
+         */ 
+        public static function extend($name, $resolver)
+        {
             \Illuminate\Database\DatabaseManager::extend($name, $resolver);
         }
         
@@ -2865,8 +3356,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function getConnections(){
+         */ 
+        public static function getConnections()
+        {
             return \Illuminate\Database\DatabaseManager::getConnections();
         }
         
@@ -2875,8 +3367,9 @@ namespace {
          *
          * @return \Illuminate\Database\Schema\MySqlBuilder 
          * @static 
-         */
-        public static function getSchemaBuilder(){
+         */ 
+        public static function getSchemaBuilder()
+        {
             return \Illuminate\Database\MySqlConnection::getSchemaBuilder();
         }
         
@@ -2887,8 +3380,9 @@ namespace {
          * @param array $bindings
          * @return void 
          * @static 
-         */
-        public static function bindValues($statement, $bindings){
+         */ 
+        public static function bindValues($statement, $bindings)
+        {
             \Illuminate\Database\MySqlConnection::bindValues($statement, $bindings);
         }
         
@@ -2897,8 +3391,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function useDefaultQueryGrammar(){
+         */ 
+        public static function useDefaultQueryGrammar()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::useDefaultQueryGrammar();
         }
@@ -2908,8 +3403,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function useDefaultSchemaGrammar(){
+         */ 
+        public static function useDefaultSchemaGrammar()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::useDefaultSchemaGrammar();
         }
@@ -2919,8 +3415,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function useDefaultPostProcessor(){
+         */ 
+        public static function useDefaultPostProcessor()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::useDefaultPostProcessor();
         }
@@ -2931,8 +3428,9 @@ namespace {
          * @param string $table
          * @return \Illuminate\Database\Query\Builder 
          * @static 
-         */
-        public static function table($table){
+         */ 
+        public static function table($table)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::table($table);
         }
@@ -2942,8 +3440,9 @@ namespace {
          *
          * @return \Illuminate\Database\Query\Builder 
          * @static 
-         */
-        public static function query(){
+         */ 
+        public static function query()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::query();
         }
@@ -2956,8 +3455,9 @@ namespace {
          * @param bool $useReadPdo
          * @return mixed 
          * @static 
-         */
-        public static function selectOne($query, $bindings = array(), $useReadPdo = true){
+         */ 
+        public static function selectOne($query, $bindings = array(), $useReadPdo = true)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::selectOne($query, $bindings, $useReadPdo);
         }
@@ -2969,8 +3469,9 @@ namespace {
          * @param array $bindings
          * @return array 
          * @static 
-         */
-        public static function selectFromWriteConnection($query, $bindings = array()){
+         */ 
+        public static function selectFromWriteConnection($query, $bindings = array())
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::selectFromWriteConnection($query, $bindings);
         }
@@ -2983,8 +3484,9 @@ namespace {
          * @param bool $useReadPdo
          * @return array 
          * @static 
-         */
-        public static function select($query, $bindings = array(), $useReadPdo = true){
+         */ 
+        public static function select($query, $bindings = array(), $useReadPdo = true)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::select($query, $bindings, $useReadPdo);
         }
@@ -2997,8 +3499,9 @@ namespace {
          * @param bool $useReadPdo
          * @return \Generator 
          * @static 
-         */
-        public static function cursor($query, $bindings = array(), $useReadPdo = true){
+         */ 
+        public static function cursor($query, $bindings = array(), $useReadPdo = true)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::cursor($query, $bindings, $useReadPdo);
         }
@@ -3010,8 +3513,9 @@ namespace {
          * @param array $bindings
          * @return bool 
          * @static 
-         */
-        public static function insert($query, $bindings = array()){
+         */ 
+        public static function insert($query, $bindings = array())
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::insert($query, $bindings);
         }
@@ -3023,8 +3527,9 @@ namespace {
          * @param array $bindings
          * @return int 
          * @static 
-         */
-        public static function update($query, $bindings = array()){
+         */ 
+        public static function update($query, $bindings = array())
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::update($query, $bindings);
         }
@@ -3036,8 +3541,9 @@ namespace {
          * @param array $bindings
          * @return int 
          * @static 
-         */
-        public static function delete($query, $bindings = array()){
+         */ 
+        public static function delete($query, $bindings = array())
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::delete($query, $bindings);
         }
@@ -3049,8 +3555,9 @@ namespace {
          * @param array $bindings
          * @return bool 
          * @static 
-         */
-        public static function statement($query, $bindings = array()){
+         */ 
+        public static function statement($query, $bindings = array())
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::statement($query, $bindings);
         }
@@ -3062,8 +3569,9 @@ namespace {
          * @param array $bindings
          * @return int 
          * @static 
-         */
-        public static function affectingStatement($query, $bindings = array()){
+         */ 
+        public static function affectingStatement($query, $bindings = array())
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::affectingStatement($query, $bindings);
         }
@@ -3074,8 +3582,9 @@ namespace {
          * @param string $query
          * @return bool 
          * @static 
-         */
-        public static function unprepared($query){
+         */ 
+        public static function unprepared($query)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::unprepared($query);
         }
@@ -3086,8 +3595,9 @@ namespace {
          * @param \Closure $callback
          * @return array 
          * @static 
-         */
-        public static function pretend($callback){
+         */ 
+        public static function pretend($callback)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::pretend($callback);
         }
@@ -3098,8 +3608,9 @@ namespace {
          * @param array $bindings
          * @return array 
          * @static 
-         */
-        public static function prepareBindings($bindings){
+         */ 
+        public static function prepareBindings($bindings)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::prepareBindings($bindings);
         }
@@ -3112,8 +3623,9 @@ namespace {
          * @param float|null $time
          * @return void 
          * @static 
-         */
-        public static function logQuery($query, $bindings, $time = null){
+         */ 
+        public static function logQuery($query, $bindings, $time = null)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::logQuery($query, $bindings, $time);
         }
@@ -3124,8 +3636,9 @@ namespace {
          * @param \Closure $callback
          * @return void 
          * @static 
-         */
-        public static function listen($callback){
+         */ 
+        public static function listen($callback)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::listen($callback);
         }
@@ -3136,19 +3649,34 @@ namespace {
          * @param mixed $value
          * @return \Illuminate\Database\Query\Expression 
          * @static 
-         */
-        public static function raw($value){
+         */ 
+        public static function raw($value)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::raw($value);
         }
         
         /**
-         * Is Doctrine available?
+         * Indicate if any records have been modified.
+         *
+         * @param bool $value
+         * @return void 
+         * @static 
+         */ 
+        public static function recordsHaveBeenModified($value = true)
+        {
+            //Method inherited from \Illuminate\Database\Connection            
+            \Illuminate\Database\MySqlConnection::recordsHaveBeenModified($value);
+        }
+        
+        /**
+         * Is Doctrine available?
          *
          * @return bool 
          * @static 
-         */
-        public static function isDoctrineAvailable(){
+         */ 
+        public static function isDoctrineAvailable()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::isDoctrineAvailable();
         }
@@ -3160,8 +3688,9 @@ namespace {
          * @param string $column
          * @return \Doctrine\DBAL\Schema\Column 
          * @static 
-         */
-        public static function getDoctrineColumn($table, $column){
+         */ 
+        public static function getDoctrineColumn($table, $column)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getDoctrineColumn($table, $column);
         }
@@ -3171,8 +3700,9 @@ namespace {
          *
          * @return \Doctrine\DBAL\Schema\AbstractSchemaManager 
          * @static 
-         */
-        public static function getDoctrineSchemaManager(){
+         */ 
+        public static function getDoctrineSchemaManager()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getDoctrineSchemaManager();
         }
@@ -3182,8 +3712,9 @@ namespace {
          *
          * @return \Doctrine\DBAL\Connection 
          * @static 
-         */
-        public static function getDoctrineConnection(){
+         */ 
+        public static function getDoctrineConnection()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getDoctrineConnection();
         }
@@ -3193,8 +3724,9 @@ namespace {
          *
          * @return \PDO 
          * @static 
-         */
-        public static function getPdo(){
+         */ 
+        public static function getPdo()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getPdo();
         }
@@ -3204,8 +3736,9 @@ namespace {
          *
          * @return \PDO 
          * @static 
-         */
-        public static function getReadPdo(){
+         */ 
+        public static function getReadPdo()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getReadPdo();
         }
@@ -3213,11 +3746,12 @@ namespace {
         /**
          * Set the PDO connection.
          *
-         * @param \PDO|null $pdo
+         * @param \PDO|\Closure|null $pdo
          * @return $this 
          * @static 
-         */
-        public static function setPdo($pdo){
+         */ 
+        public static function setPdo($pdo)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::setPdo($pdo);
         }
@@ -3225,11 +3759,12 @@ namespace {
         /**
          * Set the PDO connection used for reading.
          *
-         * @param \PDO|null $pdo
+         * @param \PDO|\Closure|null $pdo
          * @return $this 
          * @static 
-         */
-        public static function setReadPdo($pdo){
+         */ 
+        public static function setReadPdo($pdo)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::setReadPdo($pdo);
         }
@@ -3240,8 +3775,9 @@ namespace {
          * @param callable $reconnector
          * @return $this 
          * @static 
-         */
-        public static function setReconnector($reconnector){
+         */ 
+        public static function setReconnector($reconnector)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::setReconnector($reconnector);
         }
@@ -3251,8 +3787,9 @@ namespace {
          *
          * @return string|null 
          * @static 
-         */
-        public static function getName(){
+         */ 
+        public static function getName()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getName();
         }
@@ -3263,8 +3800,9 @@ namespace {
          * @param string|null $option
          * @return mixed 
          * @static 
-         */
-        public static function getConfig($option = null){
+         */ 
+        public static function getConfig($option = null)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getConfig($option);
         }
@@ -3274,8 +3812,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getDriverName(){
+         */ 
+        public static function getDriverName()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getDriverName();
         }
@@ -3285,8 +3824,9 @@ namespace {
          *
          * @return \Illuminate\Database\Query\Grammars\Grammar 
          * @static 
-         */
-        public static function getQueryGrammar(){
+         */ 
+        public static function getQueryGrammar()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getQueryGrammar();
         }
@@ -3297,8 +3837,9 @@ namespace {
          * @param \Illuminate\Database\Query\Grammars\Grammar $grammar
          * @return void 
          * @static 
-         */
-        public static function setQueryGrammar($grammar){
+         */ 
+        public static function setQueryGrammar($grammar)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::setQueryGrammar($grammar);
         }
@@ -3308,8 +3849,9 @@ namespace {
          *
          * @return \Illuminate\Database\Schema\Grammars\Grammar 
          * @static 
-         */
-        public static function getSchemaGrammar(){
+         */ 
+        public static function getSchemaGrammar()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getSchemaGrammar();
         }
@@ -3320,8 +3862,9 @@ namespace {
          * @param \Illuminate\Database\Schema\Grammars\Grammar $grammar
          * @return void 
          * @static 
-         */
-        public static function setSchemaGrammar($grammar){
+         */ 
+        public static function setSchemaGrammar($grammar)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::setSchemaGrammar($grammar);
         }
@@ -3331,8 +3874,9 @@ namespace {
          *
          * @return \Illuminate\Database\Query\Processors\Processor 
          * @static 
-         */
-        public static function getPostProcessor(){
+         */ 
+        public static function getPostProcessor()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getPostProcessor();
         }
@@ -3343,8 +3887,9 @@ namespace {
          * @param \Illuminate\Database\Query\Processors\Processor $processor
          * @return void 
          * @static 
-         */
-        public static function setPostProcessor($processor){
+         */ 
+        public static function setPostProcessor($processor)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::setPostProcessor($processor);
         }
@@ -3354,8 +3899,9 @@ namespace {
          *
          * @return \Illuminate\Contracts\Events\Dispatcher 
          * @static 
-         */
-        public static function getEventDispatcher(){
+         */ 
+        public static function getEventDispatcher()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getEventDispatcher();
         }
@@ -3366,8 +3912,9 @@ namespace {
          * @param \Illuminate\Contracts\Events\Dispatcher $events
          * @return void 
          * @static 
-         */
-        public static function setEventDispatcher($events){
+         */ 
+        public static function setEventDispatcher($events)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::setEventDispatcher($events);
         }
@@ -3377,8 +3924,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function pretending(){
+         */ 
+        public static function pretending()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::pretending();
         }
@@ -3388,8 +3936,9 @@ namespace {
          *
          * @return array 
          * @static 
-         */
-        public static function getQueryLog(){
+         */ 
+        public static function getQueryLog()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getQueryLog();
         }
@@ -3399,8 +3948,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function flushQueryLog(){
+         */ 
+        public static function flushQueryLog()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::flushQueryLog();
         }
@@ -3410,8 +3960,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function enableQueryLog(){
+         */ 
+        public static function enableQueryLog()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::enableQueryLog();
         }
@@ -3421,8 +3972,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function disableQueryLog(){
+         */ 
+        public static function disableQueryLog()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::disableQueryLog();
         }
@@ -3432,8 +3984,9 @@ namespace {
          *
          * @return bool 
          * @static 
-         */
-        public static function logging(){
+         */ 
+        public static function logging()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::logging();
         }
@@ -3443,8 +3996,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getDatabaseName(){
+         */ 
+        public static function getDatabaseName()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getDatabaseName();
         }
@@ -3455,8 +4009,9 @@ namespace {
          * @param string $database
          * @return string 
          * @static 
-         */
-        public static function setDatabaseName($database){
+         */ 
+        public static function setDatabaseName($database)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::setDatabaseName($database);
         }
@@ -3466,8 +4021,9 @@ namespace {
          *
          * @return string 
          * @static 
-         */
-        public static function getTablePrefix(){
+         */ 
+        public static function getTablePrefix()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getTablePrefix();
         }
@@ -3478,8 +4034,9 @@ namespace {
          * @param string $prefix
          * @return void 
          * @static 
-         */
-        public static function setTablePrefix($prefix){
+         */ 
+        public static function setTablePrefix($prefix)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::setTablePrefix($prefix);
         }
@@ -3490,8 +4047,9 @@ namespace {
          * @param \Illuminate\Database\Grammar $grammar
          * @return \Illuminate\Database\Grammar 
          * @static 
-         */
-        public static function withTablePrefix($grammar){
+         */ 
+        public static function withTablePrefix($grammar)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::withTablePrefix($grammar);
         }
@@ -3503,8 +4061,9 @@ namespace {
          * @param \Closure $callback
          * @return void 
          * @static 
-         */
-        public static function resolverFor($driver, $callback){
+         */ 
+        public static function resolverFor($driver, $callback)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::resolverFor($driver, $callback);
         }
@@ -3515,8 +4074,9 @@ namespace {
          * @param string $driver
          * @return mixed 
          * @static 
-         */
-        public static function getResolver($driver){
+         */ 
+        public static function getResolver($driver)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getResolver($driver);
         }
@@ -3529,8 +4089,9 @@ namespace {
          * @return mixed 
          * @throws \Exception|\Throwable
          * @static 
-         */
-        public static function transaction($callback, $attempts = 1){
+         */ 
+        public static function transaction($callback, $attempts = 1)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::transaction($callback, $attempts);
         }
@@ -3541,8 +4102,9 @@ namespace {
          * @return void 
          * @throws \Exception
          * @static 
-         */
-        public static function beginTransaction(){
+         */ 
+        public static function beginTransaction()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::beginTransaction();
         }
@@ -3552,8 +4114,9 @@ namespace {
          *
          * @return void 
          * @static 
-         */
-        public static function commit(){
+         */ 
+        public static function commit()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::commit();
         }
@@ -3564,8 +4127,9 @@ namespace {
          * @param int|null $toLevel
          * @return void 
          * @static 
-         */
-        public static function rollBack($toLevel = null){
+         */ 
+        public static function rollBack($toLevel = null)
+        {
             //Method inherited from \Illuminate\Database\Connection            
             \Illuminate\Database\MySqlConnection::rollBack($toLevel);
         }
@@ -3575,14536 +4139,17997 @@ namespace {
          *
          * @return int 
          * @static 
-         */
-        public static function transactionLevel(){
+         */ 
+        public static function transactionLevel()
+        {
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::transactionLevel();
         }
-        
+         
     }
 
-
-    class Eloquent extends \Illuminate\Database\Eloquent\Model{
+    class Event {
         
         /**
-         * Create and return an un-saved model instance.
+         * Register an event listener with the dispatcher.
          *
-         * @param array $attributes
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @param string|array $events
+         * @param mixed $listener
+         * @return void 
          * @static 
-         */
-        public static function make($attributes = array()){
-            return \Illuminate\Database\Eloquent\Builder::make($attributes);
+         */ 
+        public static function listen($events, $listener)
+        {
+            \Illuminate\Events\Dispatcher::listen($events, $listener);
         }
         
         /**
-         * Register a new global scope.
+         * Determine if a given event has listeners.
          *
-         * @param string $identifier
-         * @param \Illuminate\Database\Eloquent\Scope|\Closure $scope
-         * @return $this 
+         * @param string $eventName
+         * @return bool 
          * @static 
-         */
-        public static function withGlobalScope($identifier, $scope){
-            return \Illuminate\Database\Eloquent\Builder::withGlobalScope($identifier, $scope);
+         */ 
+        public static function hasListeners($eventName)
+        {
+            return \Illuminate\Events\Dispatcher::hasListeners($eventName);
         }
         
         /**
-         * Remove a registered global scope.
+         * Register an event and payload to be fired later.
          *
-         * @param \Illuminate\Database\Eloquent\Scope|string $scope
-         * @return $this 
+         * @param string $event
+         * @param array $payload
+         * @return void 
          * @static 
-         */
-        public static function withoutGlobalScope($scope){
-            return \Illuminate\Database\Eloquent\Builder::withoutGlobalScope($scope);
+         */ 
+        public static function push($event, $payload = array())
+        {
+            \Illuminate\Events\Dispatcher::push($event, $payload);
         }
         
         /**
-         * Remove all or passed registered global scopes.
+         * Flush a set of pushed events.
          *
-         * @param array|null $scopes
-         * @return $this 
+         * @param string $event
+         * @return void 
          * @static 
-         */
-        public static function withoutGlobalScopes($scopes = null){
-            return \Illuminate\Database\Eloquent\Builder::withoutGlobalScopes($scopes);
+         */ 
+        public static function flush($event)
+        {
+            \Illuminate\Events\Dispatcher::flush($event);
         }
         
         /**
-         * Get an array of global scopes that were removed from the query.
+         * Register an event subscriber with the dispatcher.
          *
-         * @return array 
+         * @param object|string $subscriber
+         * @return void 
          * @static 
-         */
-        public static function removedScopes(){
-            return \Illuminate\Database\Eloquent\Builder::removedScopes();
+         */ 
+        public static function subscribe($subscriber)
+        {
+            \Illuminate\Events\Dispatcher::subscribe($subscriber);
         }
         
         /**
-         * Add a where clause on the primary key to the query.
+         * Fire an event until the first non-null response is returned.
          *
-         * @param mixed $id
-         * @return $this 
+         * @param string|object $event
+         * @param mixed $payload
+         * @return array|null 
          * @static 
-         */
-        public static function whereKey($id){
-            return \Illuminate\Database\Eloquent\Builder::whereKey($id);
+         */ 
+        public static function until($event, $payload = array())
+        {
+            return \Illuminate\Events\Dispatcher::until($event, $payload);
         }
         
         /**
-         * Add a basic where clause to the query.
+         * Fire an event and call the listeners.
          *
-         * @param string|array|\Closure $column
-         * @param string $operator
-         * @param mixed $value
-         * @param string $boolean
-         * @return $this 
+         * @param string|object $event
+         * @param mixed $payload
+         * @param bool $halt
+         * @return array|null 
          * @static 
-         */
-        public static function where($column, $operator = null, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Eloquent\Builder::where($column, $operator, $value, $boolean);
+         */ 
+        public static function fire($event, $payload = array(), $halt = false)
+        {
+            return \Illuminate\Events\Dispatcher::fire($event, $payload, $halt);
         }
         
         /**
-         * Add an "or where" clause to the query.
+         * Fire an event and call the listeners.
          *
-         * @param string|\Closure $column
-         * @param string $operator
-         * @param mixed $value
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string|object $event
+         * @param mixed $payload
+         * @param bool $halt
+         * @return array|null 
          * @static 
-         */
-        public static function orWhere($column, $operator = null, $value = null){
-            return \Illuminate\Database\Eloquent\Builder::orWhere($column, $operator, $value);
+         */ 
+        public static function dispatch($event, $payload = array(), $halt = false)
+        {
+            return \Illuminate\Events\Dispatcher::dispatch($event, $payload, $halt);
         }
         
         /**
-         * Create a collection of models from plain arrays.
+         * Get all of the listeners for a given event name.
          *
-         * @param array $items
-         * @return \Illuminate\Database\Eloquent\Collection 
+         * @param string $eventName
+         * @return array 
          * @static 
-         */
-        public static function hydrate($items){
-            return \Illuminate\Database\Eloquent\Builder::hydrate($items);
+         */ 
+        public static function getListeners($eventName)
+        {
+            return \Illuminate\Events\Dispatcher::getListeners($eventName);
         }
         
         /**
-         * Create a collection of models from a raw query.
+         * Register an event listener with the dispatcher.
          *
-         * @param string $query
-         * @param array $bindings
-         * @return \Illuminate\Database\Eloquent\Collection 
+         * @param \Closure|string $listener
+         * @param bool $wildcard
+         * @return \Closure 
          * @static 
-         */
-        public static function fromQuery($query, $bindings = array()){
-            return \Illuminate\Database\Eloquent\Builder::fromQuery($query, $bindings);
+         */ 
+        public static function makeListener($listener, $wildcard = false)
+        {
+            return \Illuminate\Events\Dispatcher::makeListener($listener, $wildcard);
         }
         
         /**
-         * Find a model by its primary key.
+         * Create a class based listener using the IoC container.
          *
-         * @param mixed $id
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Model|\Illuminate\Database\Eloquent\Collection|static[]|static|null 
+         * @param string $listener
+         * @param bool $wildcard
+         * @return \Closure 
          * @static 
-         */
-        public static function find($id, $columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::find($id, $columns);
+         */ 
+        public static function createClassListener($listener, $wildcard = false)
+        {
+            return \Illuminate\Events\Dispatcher::createClassListener($listener, $wildcard);
         }
         
         /**
-         * Find multiple models by their primary keys.
+         * Remove a set of listeners from the dispatcher.
          *
-         * @param array $ids
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Collection 
+         * @param string $event
+         * @return void 
          * @static 
-         */
-        public static function findMany($ids, $columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::findMany($ids, $columns);
+         */ 
+        public static function forget($event)
+        {
+            \Illuminate\Events\Dispatcher::forget($event);
         }
         
         /**
-         * Find a model by its primary key or throw an exception.
+         * Forget all of the pushed listeners.
          *
-         * @param mixed $id
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Model|\Illuminate\Database\Eloquent\Collection 
-         * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
+         * @return void 
          * @static 
-         */
-        public static function findOrFail($id, $columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::findOrFail($id, $columns);
+         */ 
+        public static function forgetPushed()
+        {
+            \Illuminate\Events\Dispatcher::forgetPushed();
         }
         
         /**
-         * Find a model by its primary key or return fresh model instance.
+         * Set the queue resolver implementation.
          *
-         * @param mixed $id
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @param callable $resolver
+         * @return $this 
          * @static 
-         */
-        public static function findOrNew($id, $columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::findOrNew($id, $columns);
+         */ 
+        public static function setQueueResolver($resolver)
+        {
+            return \Illuminate\Events\Dispatcher::setQueueResolver($resolver);
         }
+         
+    }
+
+    class File {
         
         /**
-         * Get the first record matching the attributes or instantiate it.
+         * Determine if a file or directory exists.
          *
-         * @param array $attributes
-         * @param array $values
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @param string $path
+         * @return bool 
          * @static 
-         */
-        public static function firstOrNew($attributes, $values = array()){
-            return \Illuminate\Database\Eloquent\Builder::firstOrNew($attributes, $values);
+         */ 
+        public static function exists($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::exists($path);
         }
         
         /**
-         * Get the first record matching the attributes or create it.
+         * Get the contents of a file.
          *
-         * @param array $attributes
-         * @param array $values
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @param string $path
+         * @param bool $lock
+         * @return string 
+         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
          * @static 
-         */
-        public static function firstOrCreate($attributes, $values = array()){
-            return \Illuminate\Database\Eloquent\Builder::firstOrCreate($attributes, $values);
+         */ 
+        public static function get($path, $lock = false)
+        {
+            return \Illuminate\Filesystem\Filesystem::get($path, $lock);
         }
         
         /**
-         * Create or update a record matching the attributes, and fill it with values.
+         * Get contents of a file with shared access.
          *
-         * @param array $attributes
-         * @param array $values
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function updateOrCreate($attributes, $values = array()){
-            return \Illuminate\Database\Eloquent\Builder::updateOrCreate($attributes, $values);
+         */ 
+        public static function sharedGet($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::sharedGet($path);
         }
         
         /**
-         * Execute the query and get the first result or throw an exception.
+         * Get the returned value of a file.
          *
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Model|static 
-         * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
+         * @param string $path
+         * @return mixed 
+         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
          * @static 
-         */
-        public static function firstOrFail($columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::firstOrFail($columns);
+         */ 
+        public static function getRequire($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::getRequire($path);
         }
         
         /**
-         * Execute the query and get the first result or call a callback.
+         * Require the given file once.
          *
-         * @param \Closure|array $columns
-         * @param \Closure|null $callback
-         * @return \Illuminate\Database\Eloquent\Model|static|mixed 
+         * @param string $file
+         * @return mixed 
          * @static 
-         */
-        public static function firstOr($columns = array(), $callback = null){
-            return \Illuminate\Database\Eloquent\Builder::firstOr($columns, $callback);
+         */ 
+        public static function requireOnce($file)
+        {
+            return \Illuminate\Filesystem\Filesystem::requireOnce($file);
         }
         
         /**
-         * Get a single column's value from the first result of a query.
+         * Get the MD5 hash of the file at the given path.
          *
-         * @param string $column
-         * @return mixed 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function value($column){
-            return \Illuminate\Database\Eloquent\Builder::value($column);
+         */ 
+        public static function hash($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::hash($path);
         }
         
         /**
-         * Execute the query as a "select" statement.
+         * Write the contents of a file.
          *
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Collection|static[] 
+         * @param string $path
+         * @param string $contents
+         * @param bool $lock
+         * @return int 
          * @static 
-         */
-        public static function get($columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::get($columns);
+         */ 
+        public static function put($path, $contents, $lock = false)
+        {
+            return \Illuminate\Filesystem\Filesystem::put($path, $contents, $lock);
         }
         
         /**
-         * Get the hydrated models without eager loading.
+         * Prepend to a file.
          *
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Model[] 
+         * @param string $path
+         * @param string $data
+         * @return int 
          * @static 
-         */
-        public static function getModels($columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::getModels($columns);
+         */ 
+        public static function prepend($path, $data)
+        {
+            return \Illuminate\Filesystem\Filesystem::prepend($path, $data);
         }
         
         /**
-         * Eager load the relationships for the models.
+         * Append to a file.
          *
-         * @param array $models
-         * @return array 
+         * @param string $path
+         * @param string $data
+         * @return int 
          * @static 
-         */
-        public static function eagerLoadRelations($models){
-            return \Illuminate\Database\Eloquent\Builder::eagerLoadRelations($models);
+         */ 
+        public static function append($path, $data)
+        {
+            return \Illuminate\Filesystem\Filesystem::append($path, $data);
         }
         
         /**
-         * Get a generator for the given query.
+         * Get or set UNIX mode of a file or directory.
          *
-         * @return \Generator 
+         * @param string $path
+         * @param int $mode
+         * @return mixed 
          * @static 
-         */
-        public static function cursor(){
-            return \Illuminate\Database\Eloquent\Builder::cursor();
+         */ 
+        public static function chmod($path, $mode = null)
+        {
+            return \Illuminate\Filesystem\Filesystem::chmod($path, $mode);
         }
         
         /**
-         * Chunk the results of a query by comparing numeric IDs.
+         * Delete the file at a given path.
          *
-         * @param int $count
-         * @param callable $callback
-         * @param string $column
-         * @param string|null $alias
+         * @param string|array $paths
          * @return bool 
          * @static 
-         */
-        public static function chunkById($count, $callback, $column = null, $alias = null){
-            return \Illuminate\Database\Eloquent\Builder::chunkById($count, $callback, $column, $alias);
+         */ 
+        public static function delete($paths)
+        {
+            return \Illuminate\Filesystem\Filesystem::delete($paths);
         }
         
         /**
-         * Get an array with the values of a given column.
+         * Move a file to a new location.
          *
-         * @param string $column
-         * @param string|null $key
-         * @return \Illuminate\Support\Collection 
+         * @param string $path
+         * @param string $target
+         * @return bool 
          * @static 
-         */
-        public static function pluck($column, $key = null){
-            return \Illuminate\Database\Eloquent\Builder::pluck($column, $key);
+         */ 
+        public static function move($path, $target)
+        {
+            return \Illuminate\Filesystem\Filesystem::move($path, $target);
         }
         
         /**
-         * Paginate the given query.
+         * Copy a file to a new location.
          *
-         * @param int $perPage
-         * @param array $columns
-         * @param string $pageName
-         * @param int|null $page
-         * @return \Illuminate\Contracts\Pagination\LengthAwarePaginator 
-         * @throws \InvalidArgumentException
+         * @param string $path
+         * @param string $target
+         * @return bool 
          * @static 
-         */
-        public static function paginate($perPage = null, $columns = array(), $pageName = 'page', $page = null){
-            return \Illuminate\Database\Eloquent\Builder::paginate($perPage, $columns, $pageName, $page);
+         */ 
+        public static function copy($path, $target)
+        {
+            return \Illuminate\Filesystem\Filesystem::copy($path, $target);
         }
         
         /**
-         * Paginate the given query into a simple paginator.
+         * Create a hard link to the target file or directory.
          *
-         * @param int $perPage
-         * @param array $columns
-         * @param string $pageName
-         * @param int|null $page
-         * @return \Illuminate\Contracts\Pagination\Paginator 
+         * @param string $target
+         * @param string $link
+         * @return void 
          * @static 
-         */
-        public static function simplePaginate($perPage = null, $columns = array(), $pageName = 'page', $page = null){
-            return \Illuminate\Database\Eloquent\Builder::simplePaginate($perPage, $columns, $pageName, $page);
+         */ 
+        public static function link($target, $link)
+        {
+            \Illuminate\Filesystem\Filesystem::link($target, $link);
         }
         
         /**
-         * Save a new model and return the instance.
+         * Extract the file name from a file path.
          *
-         * @param array $attributes
-         * @return \Illuminate\Database\Eloquent\Model|$this 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function create($attributes = array()){
-            return \Illuminate\Database\Eloquent\Builder::create($attributes);
+         */ 
+        public static function name($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::name($path);
         }
         
         /**
-         * Save a new model and return the instance. Allow mass-assignment.
+         * Extract the trailing name component from a file path.
          *
-         * @param array $attributes
-         * @return \Illuminate\Database\Eloquent\Model|$this 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function forceCreate($attributes){
-            return \Illuminate\Database\Eloquent\Builder::forceCreate($attributes);
+         */ 
+        public static function basename($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::basename($path);
         }
         
         /**
-         * Register a replacement for the default delete function.
+         * Extract the parent directory from a file path.
          *
-         * @param \Closure $callback
-         * @return void 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function onDelete($callback){
-            \Illuminate\Database\Eloquent\Builder::onDelete($callback);
+         */ 
+        public static function dirname($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::dirname($path);
         }
         
         /**
-         * Call the given local model scopes.
+         * Extract the file extension from a file path.
          *
-         * @param array $scopes
-         * @return mixed 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function scopes($scopes){
-            return \Illuminate\Database\Eloquent\Builder::scopes($scopes);
+         */ 
+        public static function extension($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::extension($path);
         }
         
         /**
-         * Apply the scopes to the Eloquent builder instance and return it.
+         * Get the file type of a given file.
          *
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function applyScopes(){
-            return \Illuminate\Database\Eloquent\Builder::applyScopes();
+         */ 
+        public static function type($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::type($path);
         }
         
         /**
-         * Prevent the specified relations from being eager loaded.
+         * Get the mime-type of a given file.
          *
-         * @param mixed $relations
-         * @return $this 
+         * @param string $path
+         * @return string|false 
          * @static 
-         */
-        public static function without($relations){
-            return \Illuminate\Database\Eloquent\Builder::without($relations);
+         */ 
+        public static function mimeType($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::mimeType($path);
         }
         
         /**
-         * Create a new instance of the model being queried.
+         * Get the file size of a given file.
          *
-         * @param array $attributes
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @param string $path
+         * @return int 
          * @static 
-         */
-        public static function newModelInstance($attributes = array()){
-            return \Illuminate\Database\Eloquent\Builder::newModelInstance($attributes);
+         */ 
+        public static function size($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::size($path);
         }
         
         /**
-         * Get the underlying query builder instance.
+         * Get the file's last modification time.
          *
-         * @return \Illuminate\Database\Query\Builder 
+         * @param string $path
+         * @return int 
          * @static 
-         */
-        public static function getQuery(){
-            return \Illuminate\Database\Eloquent\Builder::getQuery();
+         */ 
+        public static function lastModified($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::lastModified($path);
         }
         
         /**
-         * Set the underlying query builder instance.
+         * Determine if the given path is a directory.
          *
-         * @param \Illuminate\Database\Query\Builder $query
-         * @return $this 
+         * @param string $directory
+         * @return bool 
          * @static 
-         */
-        public static function setQuery($query){
-            return \Illuminate\Database\Eloquent\Builder::setQuery($query);
+         */ 
+        public static function isDirectory($directory)
+        {
+            return \Illuminate\Filesystem\Filesystem::isDirectory($directory);
         }
         
         /**
-         * Get a base query builder instance.
+         * Determine if the given path is readable.
          *
-         * @return \Illuminate\Database\Query\Builder 
+         * @param string $path
+         * @return bool 
          * @static 
-         */
-        public static function toBase(){
-            return \Illuminate\Database\Eloquent\Builder::toBase();
+         */ 
+        public static function isReadable($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::isReadable($path);
         }
         
         /**
-         * Get the relationships being eagerly loaded.
+         * Determine if the given path is writable.
          *
-         * @return array 
+         * @param string $path
+         * @return bool 
          * @static 
-         */
-        public static function getEagerLoads(){
-            return \Illuminate\Database\Eloquent\Builder::getEagerLoads();
+         */ 
+        public static function isWritable($path)
+        {
+            return \Illuminate\Filesystem\Filesystem::isWritable($path);
         }
         
         /**
-         * Set the relationships being eagerly loaded.
+         * Determine if the given path is a file.
          *
-         * @param array $eagerLoad
-         * @return $this 
+         * @param string $file
+         * @return bool 
          * @static 
-         */
-        public static function setEagerLoads($eagerLoad){
-            return \Illuminate\Database\Eloquent\Builder::setEagerLoads($eagerLoad);
+         */ 
+        public static function isFile($file)
+        {
+            return \Illuminate\Filesystem\Filesystem::isFile($file);
         }
         
         /**
-         * Get the model instance being queried.
+         * Find path names matching a given pattern.
          *
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @param string $pattern
+         * @param int $flags
+         * @return array 
          * @static 
-         */
-        public static function getModel(){
-            return \Illuminate\Database\Eloquent\Builder::getModel();
+         */ 
+        public static function glob($pattern, $flags = 0)
+        {
+            return \Illuminate\Filesystem\Filesystem::glob($pattern, $flags);
         }
         
         /**
-         * Set a model instance for the model being queried.
+         * Get an array of all files in a directory.
          *
-         * @param \Illuminate\Database\Eloquent\Model $model
-         * @return $this 
+         * @param string $directory
+         * @param bool $hidden
+         * @return \Symfony\Component\Finder\SplFileInfo[] 
          * @static 
-         */
-        public static function setModel($model){
-            return \Illuminate\Database\Eloquent\Builder::setModel($model);
+         */ 
+        public static function files($directory, $hidden = false)
+        {
+            return \Illuminate\Filesystem\Filesystem::files($directory, $hidden);
         }
         
         /**
-         * Get the given macro by name.
+         * Get all of the files from the given directory (recursive).
          *
-         * @param string $name
-         * @return \Closure 
+         * @param string $directory
+         * @param bool $hidden
+         * @return \Symfony\Component\Finder\SplFileInfo[] 
          * @static 
-         */
-        public static function getMacro($name){
-            return \Illuminate\Database\Eloquent\Builder::getMacro($name);
+         */ 
+        public static function allFiles($directory, $hidden = false)
+        {
+            return \Illuminate\Filesystem\Filesystem::allFiles($directory, $hidden);
         }
         
         /**
-         * Chunk the results of the query.
+         * Get all of the directories within a given directory.
          *
-         * @param int $count
-         * @param callable $callback
-         * @return bool 
+         * @param string $directory
+         * @return array 
          * @static 
-         */
-        public static function chunk($count, $callback){
-            return \Illuminate\Database\Eloquent\Builder::chunk($count, $callback);
+         */ 
+        public static function directories($directory)
+        {
+            return \Illuminate\Filesystem\Filesystem::directories($directory);
         }
         
         /**
-         * Execute a callback over each item while chunking.
+         * Create a directory.
          *
-         * @param callable $callback
-         * @param int $count
+         * @param string $path
+         * @param int $mode
+         * @param bool $recursive
+         * @param bool $force
          * @return bool 
          * @static 
-         */
-        public static function each($callback, $count = 1000){
-            return \Illuminate\Database\Eloquent\Builder::each($callback, $count);
+         */ 
+        public static function makeDirectory($path, $mode = 493, $recursive = false, $force = false)
+        {
+            return \Illuminate\Filesystem\Filesystem::makeDirectory($path, $mode, $recursive, $force);
         }
         
         /**
-         * Execute the query and get the first result.
+         * Move a directory.
          *
-         * @param array $columns
-         * @return mixed 
+         * @param string $from
+         * @param string $to
+         * @param bool $overwrite
+         * @return bool 
          * @static 
-         */
-        public static function first($columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::first($columns);
+         */ 
+        public static function moveDirectory($from, $to, $overwrite = false)
+        {
+            return \Illuminate\Filesystem\Filesystem::moveDirectory($from, $to, $overwrite);
         }
         
         /**
-         * Apply the callback's query changes if the given "value" is true.
+         * Copy a directory from one location to another.
          *
-         * @param mixed $value
-         * @param callable $callback
-         * @param callable $default
-         * @return mixed 
+         * @param string $directory
+         * @param string $destination
+         * @param int $options
+         * @return bool 
          * @static 
-         */
-        public static function when($value, $callback, $default = null){
-            return \Illuminate\Database\Eloquent\Builder::when($value, $callback, $default);
+         */ 
+        public static function copyDirectory($directory, $destination, $options = null)
+        {
+            return \Illuminate\Filesystem\Filesystem::copyDirectory($directory, $destination, $options);
         }
         
         /**
-         * Apply the callback's query changes if the given "value" is false.
+         * Recursively delete a directory.
+         * 
+         * The directory itself may be optionally preserved.
          *
-         * @param mixed $value
-         * @param callable $callback
-         * @param callable $default
-         * @return mixed 
+         * @param string $directory
+         * @param bool $preserve
+         * @return bool 
          * @static 
-         */
-        public static function unless($value, $callback, $default = null){
-            return \Illuminate\Database\Eloquent\Builder::unless($value, $callback, $default);
+         */ 
+        public static function deleteDirectory($directory, $preserve = false)
+        {
+            return \Illuminate\Filesystem\Filesystem::deleteDirectory($directory, $preserve);
         }
         
         /**
-         * Add a relationship count / exists condition to the query.
+         * Empty the specified directory of all files and folders.
          *
-         * @param string $relation
-         * @param string $operator
-         * @param int $count
-         * @param string $boolean
-         * @param \Closure|null $callback
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string $directory
+         * @return bool 
          * @static 
-         */
-        public static function has($relation, $operator = '>=', $count = 1, $boolean = 'and', $callback = null){
-            return \Illuminate\Database\Eloquent\Builder::has($relation, $operator, $count, $boolean, $callback);
+         */ 
+        public static function cleanDirectory($directory)
+        {
+            return \Illuminate\Filesystem\Filesystem::cleanDirectory($directory);
         }
         
         /**
-         * Add a relationship count / exists condition to the query with an "or".
+         * Register a custom macro.
          *
-         * @param string $relation
-         * @param string $operator
-         * @param int $count
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function orHas($relation, $operator = '>=', $count = 1){
-            return \Illuminate\Database\Eloquent\Builder::orHas($relation, $operator, $count);
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Filesystem\Filesystem::macro($name, $macro);
         }
         
         /**
-         * Add a relationship count / exists condition to the query.
+         * Mix another object into the class.
          *
-         * @param string $relation
-         * @param string $boolean
-         * @param \Closure|null $callback
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function doesntHave($relation, $boolean = 'and', $callback = null){
-            return \Illuminate\Database\Eloquent\Builder::doesntHave($relation, $boolean, $callback);
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Filesystem\Filesystem::mixin($mixin);
         }
         
         /**
-         * Add a relationship count / exists condition to the query with where clauses.
+         * Checks if macro is registered.
          *
-         * @param string $relation
-         * @param \Closure|null $callback
-         * @param string $operator
-         * @param int $count
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function whereHas($relation, $callback = null, $operator = '>=', $count = 1){
-            return \Illuminate\Database\Eloquent\Builder::whereHas($relation, $callback, $operator, $count);
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Filesystem\Filesystem::hasMacro($name);
         }
+         
+    }
+
+    class Gate {
         
         /**
-         * Add a relationship count / exists condition to the query with where clauses and an "or".
+         * Determine if a given ability has been defined.
          *
-         * @param string $relation
-         * @param \Closure $callback
-         * @param string $operator
-         * @param int $count
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string|array $ability
+         * @return bool 
          * @static 
-         */
-        public static function orWhereHas($relation, $callback = null, $operator = '>=', $count = 1){
-            return \Illuminate\Database\Eloquent\Builder::orWhereHas($relation, $callback, $operator, $count);
+         */ 
+        public static function has($ability)
+        {
+            return \Illuminate\Auth\Access\Gate::has($ability);
         }
         
         /**
-         * Add a relationship count / exists condition to the query with where clauses.
+         * Define a new ability.
          *
-         * @param string $relation
-         * @param \Closure|null $callback
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string $ability
+         * @param callable|string $callback
+         * @return $this 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function whereDoesntHave($relation, $callback = null){
-            return \Illuminate\Database\Eloquent\Builder::whereDoesntHave($relation, $callback);
+         */ 
+        public static function define($ability, $callback)
+        {
+            return \Illuminate\Auth\Access\Gate::define($ability, $callback);
         }
         
         /**
-         * Add subselect queries to count the relations.
+         * Define abilities for a resource.
          *
-         * @param mixed $relations
+         * @param string $name
+         * @param string $class
+         * @param array $abilities
          * @return $this 
          * @static 
-         */
-        public static function withCount($relations){
-            return \Illuminate\Database\Eloquent\Builder::withCount($relations);
+         */ 
+        public static function resource($name, $class, $abilities = null)
+        {
+            return \Illuminate\Auth\Access\Gate::resource($name, $class, $abilities);
         }
         
         /**
-         * Merge the where constraints from another query to the current query.
+         * Define a policy class for a given class type.
          *
-         * @param \Illuminate\Database\Eloquent\Builder $from
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string $class
+         * @param string $policy
+         * @return $this 
          * @static 
-         */
-        public static function mergeConstraintsFrom($from){
-            return \Illuminate\Database\Eloquent\Builder::mergeConstraintsFrom($from);
+         */ 
+        public static function policy($class, $policy)
+        {
+            return \Illuminate\Auth\Access\Gate::policy($class, $policy);
         }
         
         /**
-         * Set the columns to be selected.
+         * Register a callback to run before all Gate checks.
          *
-         * @param array|mixed $columns
+         * @param callable $callback
          * @return $this 
          * @static 
-         */
-        public static function select($columns = array()){
-            return \Illuminate\Database\Query\Builder::select($columns);
+         */ 
+        public static function before($callback)
+        {
+            return \Illuminate\Auth\Access\Gate::before($callback);
         }
         
         /**
-         * Add a new "raw" select expression to the query.
+         * Register a callback to run after all Gate checks.
          *
-         * @param string $expression
-         * @param array $bindings
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param callable $callback
+         * @return $this 
          * @static 
-         */
-        public static function selectRaw($expression, $bindings = array()){
-            return \Illuminate\Database\Query\Builder::selectRaw($expression, $bindings);
+         */ 
+        public static function after($callback)
+        {
+            return \Illuminate\Auth\Access\Gate::after($callback);
         }
         
         /**
-         * Add a subselect expression to the query.
+         * Determine if the given ability should be granted for the current user.
          *
-         * @param \Closure|\Illuminate\Database\Query\Builder|string $query
-         * @param string $as
-         * @return \Illuminate\Database\Query\Builder|static 
-         * @throws \InvalidArgumentException
+         * @param string $ability
+         * @param array|mixed $arguments
+         * @return bool 
          * @static 
-         */
-        public static function selectSub($query, $as){
-            return \Illuminate\Database\Query\Builder::selectSub($query, $as);
+         */ 
+        public static function allows($ability, $arguments = array())
+        {
+            return \Illuminate\Auth\Access\Gate::allows($ability, $arguments);
         }
         
         /**
-         * Add a new select column to the query.
+         * Determine if the given ability should be denied for the current user.
          *
-         * @param array|mixed $column
-         * @return $this 
+         * @param string $ability
+         * @param array|mixed $arguments
+         * @return bool 
          * @static 
-         */
-        public static function addSelect($column){
-            return \Illuminate\Database\Query\Builder::addSelect($column);
+         */ 
+        public static function denies($ability, $arguments = array())
+        {
+            return \Illuminate\Auth\Access\Gate::denies($ability, $arguments);
         }
         
         /**
-         * Force the query to only return distinct results.
+         * Determine if all of the given abilities should be granted for the current user.
          *
-         * @return $this 
+         * @param \Illuminate\Auth\Access\iterable|string $abilities
+         * @param array|mixed $arguments
+         * @return bool 
          * @static 
-         */
-        public static function distinct(){
-            return \Illuminate\Database\Query\Builder::distinct();
+         */ 
+        public static function check($abilities, $arguments = array())
+        {
+            return \Illuminate\Auth\Access\Gate::check($abilities, $arguments);
         }
         
         /**
-         * Set the table which the query is targeting.
+         * Determine if any one of the given abilities should be granted for the current user.
          *
-         * @param string $table
-         * @return $this 
+         * @param \Illuminate\Auth\Access\iterable|string $abilities
+         * @param array|mixed $arguments
+         * @return bool 
          * @static 
-         */
-        public static function from($table){
-            return \Illuminate\Database\Query\Builder::from($table);
+         */ 
+        public static function any($abilities, $arguments = array())
+        {
+            return \Illuminate\Auth\Access\Gate::any($abilities, $arguments);
         }
         
         /**
-         * Add a join clause to the query.
+         * Determine if the given ability should be granted for the current user.
          *
-         * @param string $table
-         * @param string $first
-         * @param string $operator
-         * @param string $second
-         * @param string $type
-         * @param bool $where
-         * @return $this 
+         * @param string $ability
+         * @param array|mixed $arguments
+         * @return \Illuminate\Auth\Access\Response 
+         * @throws \Illuminate\Auth\Access\AuthorizationException
          * @static 
-         */
-        public static function join($table, $first, $operator = null, $second = null, $type = 'inner', $where = false){
-            return \Illuminate\Database\Query\Builder::join($table, $first, $operator, $second, $type, $where);
+         */ 
+        public static function authorize($ability, $arguments = array())
+        {
+            return \Illuminate\Auth\Access\Gate::authorize($ability, $arguments);
         }
         
         /**
-         * Add a "join where" clause to the query.
+         * Get a policy instance for a given class.
          *
-         * @param string $table
-         * @param string $first
-         * @param string $operator
-         * @param string $second
-         * @param string $type
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param object|string $class
+         * @return mixed 
          * @static 
-         */
-        public static function joinWhere($table, $first, $operator, $second, $type = 'inner'){
-            return \Illuminate\Database\Query\Builder::joinWhere($table, $first, $operator, $second, $type);
+         */ 
+        public static function getPolicyFor($class)
+        {
+            return \Illuminate\Auth\Access\Gate::getPolicyFor($class);
         }
         
         /**
-         * Add a left join to the query.
+         * Build a policy class instance of the given type.
          *
-         * @param string $table
-         * @param string $first
-         * @param string $operator
-         * @param string $second
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param object|string $class
+         * @return mixed 
          * @static 
-         */
-        public static function leftJoin($table, $first, $operator = null, $second = null){
-            return \Illuminate\Database\Query\Builder::leftJoin($table, $first, $operator, $second);
+         */ 
+        public static function resolvePolicy($class)
+        {
+            return \Illuminate\Auth\Access\Gate::resolvePolicy($class);
         }
         
         /**
-         * Add a "join where" clause to the query.
+         * Get a gate instance for the given user.
          *
-         * @param string $table
-         * @param string $first
-         * @param string $operator
-         * @param string $second
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param \Illuminate\Contracts\Auth\Authenticatable|mixed $user
+         * @return static 
          * @static 
-         */
-        public static function leftJoinWhere($table, $first, $operator, $second){
-            return \Illuminate\Database\Query\Builder::leftJoinWhere($table, $first, $operator, $second);
+         */ 
+        public static function forUser($user)
+        {
+            return \Illuminate\Auth\Access\Gate::forUser($user);
         }
         
         /**
-         * Add a right join to the query.
+         * Get all of the defined abilities.
          *
-         * @param string $table
-         * @param string $first
-         * @param string $operator
-         * @param string $second
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return array 
          * @static 
-         */
-        public static function rightJoin($table, $first, $operator = null, $second = null){
-            return \Illuminate\Database\Query\Builder::rightJoin($table, $first, $operator, $second);
+         */ 
+        public static function abilities()
+        {
+            return \Illuminate\Auth\Access\Gate::abilities();
         }
         
         /**
-         * Add a "right join where" clause to the query.
+         * Get all of the defined policies.
          *
-         * @param string $table
-         * @param string $first
-         * @param string $operator
-         * @param string $second
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return array 
          * @static 
-         */
-        public static function rightJoinWhere($table, $first, $operator, $second){
-            return \Illuminate\Database\Query\Builder::rightJoinWhere($table, $first, $operator, $second);
+         */ 
+        public static function policies()
+        {
+            return \Illuminate\Auth\Access\Gate::policies();
         }
+         
+    }
+
+    class Hash {
         
         /**
-         * Add a "cross join" clause to the query.
+         * Create an instance of the Bcrypt hash Driver.
          *
-         * @param string $table
-         * @param string $first
-         * @param string $operator
-         * @param string $second
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return \Illuminate\Hashing\BcryptHasher 
          * @static 
-         */
-        public static function crossJoin($table, $first = null, $operator = null, $second = null){
-            return \Illuminate\Database\Query\Builder::crossJoin($table, $first, $operator, $second);
+         */ 
+        public static function createBcryptDriver()
+        {
+            return \Illuminate\Hashing\HashManager::createBcryptDriver();
         }
         
         /**
-         * Pass the query to a given callback.
+         * Create an instance of the Argon2 hash Driver.
          *
-         * @param \Closure $callback
-         * @return \Illuminate\Database\Query\Builder 
+         * @return \Illuminate\Hashing\ArgonHasher 
          * @static 
-         */
-        public static function tap($callback){
-            return \Illuminate\Database\Query\Builder::tap($callback);
+         */ 
+        public static function createArgonDriver()
+        {
+            return \Illuminate\Hashing\HashManager::createArgonDriver();
         }
         
         /**
-         * Merge an array of where clauses and bindings.
+         * Get information about the given hashed value.
          *
-         * @param array $wheres
-         * @param array $bindings
-         * @return void 
+         * @param string $hashedValue
+         * @return array 
          * @static 
-         */
-        public static function mergeWheres($wheres, $bindings){
-            \Illuminate\Database\Query\Builder::mergeWheres($wheres, $bindings);
+         */ 
+        public static function info($hashedValue)
+        {
+            return \Illuminate\Hashing\HashManager::info($hashedValue);
         }
         
         /**
-         * Add a "where" clause comparing two columns to the query.
+         * Hash the given value.
          *
-         * @param string|array $first
-         * @param string|null $operator
-         * @param string|null $second
-         * @param string|null $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param string $value
+         * @param array $options
+         * @return string 
          * @static 
-         */
-        public static function whereColumn($first, $operator = null, $second = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereColumn($first, $operator, $second, $boolean);
+         */ 
+        public static function make($value, $options = array())
+        {
+            return \Illuminate\Hashing\HashManager::make($value, $options);
         }
         
         /**
-         * Add an "or where" clause comparing two columns to the query.
+         * Check the given plain value against a hash.
          *
-         * @param string|array $first
-         * @param string|null $operator
-         * @param string|null $second
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param string $value
+         * @param string $hashedValue
+         * @param array $options
+         * @return bool 
          * @static 
-         */
-        public static function orWhereColumn($first, $operator = null, $second = null){
-            return \Illuminate\Database\Query\Builder::orWhereColumn($first, $operator, $second);
+         */ 
+        public static function check($value, $hashedValue, $options = array())
+        {
+            return \Illuminate\Hashing\HashManager::check($value, $hashedValue, $options);
         }
         
         /**
-         * Add a raw where clause to the query.
+         * Check if the given hash has been hashed using the given options.
          *
-         * @param string $sql
-         * @param mixed $bindings
-         * @param string $boolean
-         * @return $this 
+         * @param string $hashedValue
+         * @param array $options
+         * @return bool 
          * @static 
-         */
-        public static function whereRaw($sql, $bindings = array(), $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereRaw($sql, $bindings, $boolean);
+         */ 
+        public static function needsRehash($hashedValue, $options = array())
+        {
+            return \Illuminate\Hashing\HashManager::needsRehash($hashedValue, $options);
         }
         
         /**
-         * Add a raw or where clause to the query.
+         * Get the default driver name.
          *
-         * @param string $sql
-         * @param array $bindings
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return string 
          * @static 
-         */
-        public static function orWhereRaw($sql, $bindings = array()){
-            return \Illuminate\Database\Query\Builder::orWhereRaw($sql, $bindings);
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \Illuminate\Hashing\HashManager::getDefaultDriver();
         }
         
         /**
-         * Add a "where in" clause to the query.
+         * Get a driver instance.
          *
-         * @param string $column
-         * @param mixed $values
-         * @param string $boolean
-         * @param bool $not
-         * @return $this 
+         * @param string $driver
+         * @return mixed 
          * @static 
-         */
-        public static function whereIn($column, $values, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::whereIn($column, $values, $boolean, $not);
+         */ 
+        public static function driver($driver = null)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Hashing\HashManager::driver($driver);
         }
         
         /**
-         * Add an "or where in" clause to the query.
+         * Register a custom driver creator Closure.
          *
-         * @param string $column
-         * @param mixed $values
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function orWhereIn($column, $values){
-            return \Illuminate\Database\Query\Builder::orWhereIn($column, $values);
+         */ 
+        public static function extend($driver, $callback)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Hashing\HashManager::extend($driver, $callback);
         }
         
         /**
-         * Add a "where not in" clause to the query.
+         * Get all of the created "drivers".
          *
-         * @param string $column
-         * @param mixed $values
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return array 
          * @static 
-         */
-        public static function whereNotIn($column, $values, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNotIn($column, $values, $boolean);
+         */ 
+        public static function getDrivers()
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Hashing\HashManager::getDrivers();
         }
+         
+    }
+
+    class Input {
         
         /**
-         * Add an "or where not in" clause to the query.
+         * Create a new Illuminate HTTP request from server variables.
          *
-         * @param string $column
-         * @param mixed $values
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return static 
          * @static 
-         */
-        public static function orWhereNotIn($column, $values){
-            return \Illuminate\Database\Query\Builder::orWhereNotIn($column, $values);
+         */ 
+        public static function capture()
+        {
+            return \Illuminate\Http\Request::capture();
         }
         
         /**
-         * Add a "where null" clause to the query.
+         * Return the Request instance.
          *
-         * @param string $column
-         * @param string $boolean
-         * @param bool $not
          * @return $this 
          * @static 
-         */
-        public static function whereNull($column, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::whereNull($column, $boolean, $not);
+         */ 
+        public static function instance()
+        {
+            return \Illuminate\Http\Request::instance();
         }
         
         /**
-         * Add an "or where null" clause to the query.
+         * Get the request method.
          *
-         * @param string $column
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return string 
          * @static 
-         */
-        public static function orWhereNull($column){
-            return \Illuminate\Database\Query\Builder::orWhereNull($column);
+         */ 
+        public static function method()
+        {
+            return \Illuminate\Http\Request::method();
         }
         
         /**
-         * Add a "where not null" clause to the query.
+         * Get the root URL for the application.
          *
-         * @param string $column
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return string 
          * @static 
-         */
-        public static function whereNotNull($column, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNotNull($column, $boolean);
+         */ 
+        public static function root()
+        {
+            return \Illuminate\Http\Request::root();
         }
         
         /**
-         * Add a where between statement to the query.
+         * Get the URL (no query string) for the request.
          *
-         * @param string $column
-         * @param array $values
-         * @param string $boolean
-         * @param bool $not
-         * @return $this 
+         * @return string 
          * @static 
-         */
-        public static function whereBetween($column, $values, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::whereBetween($column, $values, $boolean, $not);
+         */ 
+        public static function url()
+        {
+            return \Illuminate\Http\Request::url();
         }
         
         /**
-         * Add an or where between statement to the query.
+         * Get the full URL for the request.
          *
-         * @param string $column
-         * @param array $values
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return string 
          * @static 
-         */
-        public static function orWhereBetween($column, $values){
-            return \Illuminate\Database\Query\Builder::orWhereBetween($column, $values);
+         */ 
+        public static function fullUrl()
+        {
+            return \Illuminate\Http\Request::fullUrl();
         }
         
         /**
-         * Add a where not between statement to the query.
+         * Get the full URL for the request with the added query string parameters.
          *
-         * @param string $column
-         * @param array $values
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param array $query
+         * @return string 
          * @static 
-         */
-        public static function whereNotBetween($column, $values, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNotBetween($column, $values, $boolean);
+         */ 
+        public static function fullUrlWithQuery($query)
+        {
+            return \Illuminate\Http\Request::fullUrlWithQuery($query);
         }
         
         /**
-         * Add an or where not between statement to the query.
+         * Get the current path info for the request.
          *
-         * @param string $column
-         * @param array $values
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return string 
          * @static 
-         */
-        public static function orWhereNotBetween($column, $values){
-            return \Illuminate\Database\Query\Builder::orWhereNotBetween($column, $values);
+         */ 
+        public static function path()
+        {
+            return \Illuminate\Http\Request::path();
         }
         
         /**
-         * Add an "or where not null" clause to the query.
+         * Get the current decoded path info for the request.
          *
-         * @param string $column
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return string 
          * @static 
-         */
-        public static function orWhereNotNull($column){
-            return \Illuminate\Database\Query\Builder::orWhereNotNull($column);
+         */ 
+        public static function decodedPath()
+        {
+            return \Illuminate\Http\Request::decodedPath();
         }
         
         /**
-         * Add a "where date" statement to the query.
+         * Get a segment from the URI (1 based index).
          *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param int $index
+         * @param string|null $default
+         * @return string|null 
          * @static 
-         */
-        public static function whereDate($column, $operator, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereDate($column, $operator, $value, $boolean);
+         */ 
+        public static function segment($index, $default = null)
+        {
+            return \Illuminate\Http\Request::segment($index, $default);
         }
         
         /**
-         * Add an "or where date" statement to the query.
+         * Get all of the segments for the request path.
          *
-         * @param string $column
-         * @param string $operator
-         * @param string $value
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return array 
          * @static 
-         */
-        public static function orWhereDate($column, $operator, $value){
-            return \Illuminate\Database\Query\Builder::orWhereDate($column, $operator, $value);
+         */ 
+        public static function segments()
+        {
+            return \Illuminate\Http\Request::segments();
         }
         
         /**
-         * Add a "where time" statement to the query.
+         * Determine if the current request URI matches a pattern.
          *
-         * @param string $column
-         * @param string $operator
-         * @param int $value
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param mixed $patterns
+         * @return bool 
          * @static 
-         */
-        public static function whereTime($column, $operator, $value, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereTime($column, $operator, $value, $boolean);
+         */ 
+        public static function is($patterns = null)
+        {
+            return \Illuminate\Http\Request::is($patterns);
         }
         
         /**
-         * Add an "or where time" statement to the query.
+         * Determine if the route name matches a given pattern.
          *
-         * @param string $column
-         * @param string $operator
-         * @param int $value
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param mixed $patterns
+         * @return bool 
          * @static 
-         */
-        public static function orWhereTime($column, $operator, $value){
-            return \Illuminate\Database\Query\Builder::orWhereTime($column, $operator, $value);
+         */ 
+        public static function routeIs($patterns = null)
+        {
+            return \Illuminate\Http\Request::routeIs($patterns);
         }
         
         /**
-         * Add a "where day" statement to the query.
+         * Determine if the current request URL and query string matches a pattern.
          *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param mixed $patterns
+         * @return bool 
          * @static 
-         */
-        public static function whereDay($column, $operator, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereDay($column, $operator, $value, $boolean);
+         */ 
+        public static function fullUrlIs($patterns = null)
+        {
+            return \Illuminate\Http\Request::fullUrlIs($patterns);
         }
         
         /**
-         * Add a "where month" statement to the query.
+         * Determine if the request is the result of an AJAX call.
          *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return bool 
          * @static 
-         */
-        public static function whereMonth($column, $operator, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereMonth($column, $operator, $value, $boolean);
+         */ 
+        public static function ajax()
+        {
+            return \Illuminate\Http\Request::ajax();
         }
         
         /**
-         * Add a "where year" statement to the query.
+         * Determine if the request is the result of an PJAX call.
          *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return bool 
          * @static 
-         */
-        public static function whereYear($column, $operator, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereYear($column, $operator, $value, $boolean);
+         */ 
+        public static function pjax()
+        {
+            return \Illuminate\Http\Request::pjax();
         }
         
         /**
-         * Add a nested where statement to the query.
+         * Determine if the request is over HTTPS.
          *
-         * @param \Closure $callback
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return bool 
          * @static 
-         */
-        public static function whereNested($callback, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNested($callback, $boolean);
+         */ 
+        public static function secure()
+        {
+            return \Illuminate\Http\Request::secure();
         }
         
         /**
-         * Create a new query instance for nested where condition.
+         * Get the client IP address.
          *
-         * @return \Illuminate\Database\Query\Builder 
+         * @return string 
          * @static 
-         */
-        public static function forNestedWhere(){
-            return \Illuminate\Database\Query\Builder::forNestedWhere();
+         */ 
+        public static function ip()
+        {
+            return \Illuminate\Http\Request::ip();
         }
         
         /**
-         * Add another query builder as a nested where to the query builder.
+         * Get the client IP addresses.
          *
-         * @param \Illuminate\Database\Query\Builder|static $query
-         * @param string $boolean
-         * @return $this 
+         * @return array 
          * @static 
-         */
-        public static function addNestedWhereQuery($query, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::addNestedWhereQuery($query, $boolean);
+         */ 
+        public static function ips()
+        {
+            return \Illuminate\Http\Request::ips();
         }
         
         /**
-         * Add an exists clause to the query.
+         * Get the client user agent.
          *
-         * @param \Closure $callback
-         * @param string $boolean
-         * @param bool $not
-         * @return $this 
+         * @return string 
          * @static 
-         */
-        public static function whereExists($callback, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::whereExists($callback, $boolean, $not);
+         */ 
+        public static function userAgent()
+        {
+            return \Illuminate\Http\Request::userAgent();
         }
         
         /**
-         * Add an or exists clause to the query.
+         * Merge new input into the current request's input array.
          *
-         * @param \Closure $callback
-         * @param bool $not
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param array $input
+         * @return \Illuminate\Http\Request 
          * @static 
-         */
-        public static function orWhereExists($callback, $not = false){
-            return \Illuminate\Database\Query\Builder::orWhereExists($callback, $not);
+         */ 
+        public static function merge($input)
+        {
+            return \Illuminate\Http\Request::merge($input);
         }
         
         /**
-         * Add a where not exists clause to the query.
+         * Replace the input for the current request.
          *
-         * @param \Closure $callback
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param array $input
+         * @return \Illuminate\Http\Request 
          * @static 
-         */
-        public static function whereNotExists($callback, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNotExists($callback, $boolean);
+         */ 
+        public static function replace($input)
+        {
+            return \Illuminate\Http\Request::replace($input);
         }
         
         /**
-         * Add a where not exists clause to the query.
+         * Get the JSON payload for the request.
          *
-         * @param \Closure $callback
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param string $key
+         * @param mixed $default
+         * @return \Symfony\Component\HttpFoundation\ParameterBag|mixed 
          * @static 
-         */
-        public static function orWhereNotExists($callback){
-            return \Illuminate\Database\Query\Builder::orWhereNotExists($callback);
+         */ 
+        public static function json($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::json($key, $default);
         }
         
         /**
-         * Add an exists clause to the query.
+         * Create a new request instance from the given Laravel request.
          *
-         * @param \Illuminate\Database\Query\Builder $query
-         * @param string $boolean
-         * @param bool $not
-         * @return $this 
+         * @param \Illuminate\Http\Request $from
+         * @param \Illuminate\Http\Request|null $to
+         * @return static 
          * @static 
-         */
-        public static function addWhereExistsQuery($query, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::addWhereExistsQuery($query, $boolean, $not);
+         */ 
+        public static function createFrom($from, $to = null)
+        {
+            return \Illuminate\Http\Request::createFrom($from, $to);
         }
         
         /**
-         * Handles dynamic "where" clauses to the query.
+         * Create an Illuminate request from a Symfony instance.
          *
-         * @param string $method
-         * @param string $parameters
-         * @return $this 
+         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @return \Illuminate\Http\Request 
          * @static 
-         */
-        public static function dynamicWhere($method, $parameters){
-            return \Illuminate\Database\Query\Builder::dynamicWhere($method, $parameters);
+         */ 
+        public static function createFromBase($request)
+        {
+            return \Illuminate\Http\Request::createFromBase($request);
         }
         
         /**
-         * Add a "group by" clause to the query.
+         * Clones a request and overrides some of its parameters.
          *
-         * @param array $groups
-         * @return $this 
+         * @param array $query The GET parameters
+         * @param array $request The POST parameters
+         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
+         * @param array $cookies The COOKIE parameters
+         * @param array $files The FILES parameters
+         * @param array $server The SERVER parameters
+         * @return static 
          * @static 
-         */
-        public static function groupBy($groups = null){
-            return \Illuminate\Database\Query\Builder::groupBy($groups);
+         */ 
+        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null)
+        {
+            return \Illuminate\Http\Request::duplicate($query, $request, $attributes, $cookies, $files, $server);
         }
         
         /**
-         * Add a "having" clause to the query.
+         * Get the session associated with the request.
          *
-         * @param string $column
-         * @param string $operator
-         * @param string $value
-         * @param string $boolean
-         * @return $this 
+         * @return \Illuminate\Session\Store 
+         * @throws \RuntimeException
          * @static 
-         */
-        public static function having($column, $operator = null, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::having($column, $operator, $value, $boolean);
+         */ 
+        public static function session()
+        {
+            return \Illuminate\Http\Request::session();
         }
         
         /**
-         * Add a "or having" clause to the query.
+         * Get the session associated with the request.
          *
-         * @param string $column
-         * @param string $operator
-         * @param string $value
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return \Illuminate\Session\Store|null 
          * @static 
-         */
-        public static function orHaving($column, $operator = null, $value = null){
-            return \Illuminate\Database\Query\Builder::orHaving($column, $operator, $value);
+         */ 
+        public static function getSession()
+        {
+            return \Illuminate\Http\Request::getSession();
         }
         
         /**
-         * Add a raw having clause to the query.
+         * Set the session instance on the request.
          *
-         * @param string $sql
-         * @param array $bindings
-         * @param string $boolean
-         * @return $this 
+         * @param \Illuminate\Contracts\Session\Session $session
+         * @return void 
          * @static 
-         */
-        public static function havingRaw($sql, $bindings = array(), $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::havingRaw($sql, $bindings, $boolean);
+         */ 
+        public static function setLaravelSession($session)
+        {
+            \Illuminate\Http\Request::setLaravelSession($session);
         }
         
         /**
-         * Add a raw or having clause to the query.
+         * Get the user making the request.
          *
-         * @param string $sql
-         * @param array $bindings
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param string|null $guard
+         * @return mixed 
          * @static 
-         */
-        public static function orHavingRaw($sql, $bindings = array()){
-            return \Illuminate\Database\Query\Builder::orHavingRaw($sql, $bindings);
+         */ 
+        public static function user($guard = null)
+        {
+            return \Illuminate\Http\Request::user($guard);
         }
         
         /**
-         * Add an "order by" clause to the query.
+         * Get the route handling the request.
          *
-         * @param string $column
-         * @param string $direction
-         * @return $this 
+         * @param string|null $param
+         * @return \Illuminate\Routing\Route|object|string 
          * @static 
-         */
-        public static function orderBy($column, $direction = 'asc'){
-            return \Illuminate\Database\Query\Builder::orderBy($column, $direction);
+         */ 
+        public static function route($param = null)
+        {
+            return \Illuminate\Http\Request::route($param);
         }
         
         /**
-         * Add a descending "order by" clause to the query.
+         * Get a unique fingerprint for the request / route / IP address.
          *
-         * @param string $column
-         * @return $this 
+         * @return string 
+         * @throws \RuntimeException
          * @static 
-         */
-        public static function orderByDesc($column){
-            return \Illuminate\Database\Query\Builder::orderByDesc($column);
+         */ 
+        public static function fingerprint()
+        {
+            return \Illuminate\Http\Request::fingerprint();
         }
         
         /**
-         * Add an "order by" clause for a timestamp to the query.
+         * Set the JSON payload for the request.
          *
-         * @param string $column
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param \Symfony\Component\HttpFoundation\ParameterBag $json
+         * @return $this 
          * @static 
-         */
-        public static function latest($column = 'created_at'){
-            return \Illuminate\Database\Query\Builder::latest($column);
+         */ 
+        public static function setJson($json)
+        {
+            return \Illuminate\Http\Request::setJson($json);
         }
         
         /**
-         * Add an "order by" clause for a timestamp to the query.
+         * Get the user resolver callback.
          *
-         * @param string $column
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return \Closure 
          * @static 
-         */
-        public static function oldest($column = 'created_at'){
-            return \Illuminate\Database\Query\Builder::oldest($column);
+         */ 
+        public static function getUserResolver()
+        {
+            return \Illuminate\Http\Request::getUserResolver();
         }
         
         /**
-         * Put the query's results in random order.
+         * Set the user resolver callback.
          *
-         * @param string $seed
+         * @param \Closure $callback
          * @return $this 
          * @static 
-         */
-        public static function inRandomOrder($seed = ''){
-            return \Illuminate\Database\Query\Builder::inRandomOrder($seed);
+         */ 
+        public static function setUserResolver($callback)
+        {
+            return \Illuminate\Http\Request::setUserResolver($callback);
         }
         
         /**
-         * Add a raw "order by" clause to the query.
+         * Get the route resolver callback.
          *
-         * @param string $sql
-         * @param array $bindings
-         * @return $this 
+         * @return \Closure 
          * @static 
-         */
-        public static function orderByRaw($sql, $bindings = array()){
-            return \Illuminate\Database\Query\Builder::orderByRaw($sql, $bindings);
+         */ 
+        public static function getRouteResolver()
+        {
+            return \Illuminate\Http\Request::getRouteResolver();
         }
         
         /**
-         * Alias to set the "offset" value of the query.
+         * Set the route resolver callback.
          *
-         * @param int $value
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function skip($value){
-            return \Illuminate\Database\Query\Builder::skip($value);
+         */ 
+        public static function setRouteResolver($callback)
+        {
+            return \Illuminate\Http\Request::setRouteResolver($callback);
         }
         
         /**
-         * Set the "offset" value of the query.
+         * Get all of the input and files for the request.
          *
-         * @param int $value
-         * @return $this 
+         * @return array 
          * @static 
-         */
-        public static function offset($value){
-            return \Illuminate\Database\Query\Builder::offset($value);
+         */ 
+        public static function toArray()
+        {
+            return \Illuminate\Http\Request::toArray();
         }
         
         /**
-         * Alias to set the "limit" value of the query.
+         * Determine if the given offset exists.
          *
-         * @param int $value
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param string $offset
+         * @return bool 
          * @static 
-         */
-        public static function take($value){
-            return \Illuminate\Database\Query\Builder::take($value);
+         */ 
+        public static function offsetExists($offset)
+        {
+            return \Illuminate\Http\Request::offsetExists($offset);
         }
         
         /**
-         * Set the "limit" value of the query.
+         * Get the value at the given offset.
          *
-         * @param int $value
-         * @return $this 
+         * @param string $offset
+         * @return mixed 
          * @static 
-         */
-        public static function limit($value){
-            return \Illuminate\Database\Query\Builder::limit($value);
+         */ 
+        public static function offsetGet($offset)
+        {
+            return \Illuminate\Http\Request::offsetGet($offset);
         }
         
         /**
-         * Set the limit and offset for a given page.
+         * Set the value at the given offset.
          *
-         * @param int $page
-         * @param int $perPage
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param string $offset
+         * @param mixed $value
+         * @return void 
          * @static 
-         */
-        public static function forPage($page, $perPage = 15){
-            return \Illuminate\Database\Query\Builder::forPage($page, $perPage);
+         */ 
+        public static function offsetSet($offset, $value)
+        {
+            \Illuminate\Http\Request::offsetSet($offset, $value);
         }
         
         /**
-         * Constrain the query to the next "page" of results after a given ID.
+         * Remove the value at the given offset.
          *
-         * @param int $perPage
-         * @param int $lastId
-         * @param string $column
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param string $offset
+         * @return void 
          * @static 
-         */
-        public static function forPageAfterId($perPage = 15, $lastId = 0, $column = 'id'){
-            return \Illuminate\Database\Query\Builder::forPageAfterId($perPage, $lastId, $column);
+         */ 
+        public static function offsetUnset($offset)
+        {
+            \Illuminate\Http\Request::offsetUnset($offset);
         }
         
         /**
-         * Add a union statement to the query.
+         * Sets the parameters for this request.
+         * 
+         * This method also re-initializes all properties.
          *
-         * @param \Illuminate\Database\Query\Builder|\Closure $query
-         * @param bool $all
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param array $query The GET parameters
+         * @param array $request The POST parameters
+         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
+         * @param array $cookies The COOKIE parameters
+         * @param array $files The FILES parameters
+         * @param array $server The SERVER parameters
+         * @param string|resource|null $content The raw body data
          * @static 
-         */
-        public static function union($query, $all = false){
-            return \Illuminate\Database\Query\Builder::union($query, $all);
+         */ 
+        public static function initialize($query = array(), $request = array(), $attributes = array(), $cookies = array(), $files = array(), $server = array(), $content = null)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::initialize($query, $request, $attributes, $cookies, $files, $server, $content);
         }
         
         /**
-         * Add a union all statement to the query.
+         * Creates a new request with values from PHP's super globals.
          *
-         * @param \Illuminate\Database\Query\Builder|\Closure $query
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return static 
          * @static 
-         */
-        public static function unionAll($query){
-            return \Illuminate\Database\Query\Builder::unionAll($query);
+         */ 
+        public static function createFromGlobals()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::createFromGlobals();
         }
         
         /**
-         * Lock the selected rows in the table.
+         * Creates a Request based on a given URI and configuration.
+         * 
+         * The information contained in the URI always take precedence
+         * over the other information (server and parameters).
          *
-         * @param string|bool $value
-         * @return $this 
+         * @param string $uri The URI
+         * @param string $method The HTTP method
+         * @param array $parameters The query (GET) or request (POST) parameters
+         * @param array $cookies The request cookies ($_COOKIE)
+         * @param array $files The request files ($_FILES)
+         * @param array $server The server parameters ($_SERVER)
+         * @param string|resource|null $content The raw body data
+         * @return static 
          * @static 
-         */
-        public static function lock($value = true){
-            return \Illuminate\Database\Query\Builder::lock($value);
+         */ 
+        public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);
         }
         
         /**
-         * Lock the selected rows in the table for updating.
+         * Sets a callable able to create a Request instance.
+         * 
+         * This is mainly useful when you need to override the Request class
+         * to keep BC with an existing system. It should not be used for any
+         * other purpose.
          *
-         * @return \Illuminate\Database\Query\Builder 
+         * @param callable|null $callable A PHP callable
          * @static 
-         */
-        public static function lockForUpdate(){
-            return \Illuminate\Database\Query\Builder::lockForUpdate();
+         */ 
+        public static function setFactory($callable)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setFactory($callable);
         }
         
         /**
-         * Share lock the selected rows in the table.
+         * Overrides the PHP global variables according to this request instance.
+         * 
+         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.
+         * $_FILES is never overridden, see rfc1867
          *
-         * @return \Illuminate\Database\Query\Builder 
          * @static 
-         */
-        public static function sharedLock(){
-            return \Illuminate\Database\Query\Builder::sharedLock();
+         */ 
+        public static function overrideGlobals()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::overrideGlobals();
         }
         
         /**
-         * Get the SQL representation of the query.
+         * Sets a list of trusted proxies.
+         * 
+         * You should only list the reverse proxies that you manage directly.
          *
-         * @return string 
+         * @param array $proxies A list of trusted proxies
+         * @param int $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies
+         * @throws \InvalidArgumentException When $trustedHeaderSet is invalid
          * @static 
-         */
-        public static function toSql(){
-            return \Illuminate\Database\Query\Builder::toSql();
+         */ 
+        public static function setTrustedProxies($proxies, $trustedHeaderSet)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedProxies($proxies, $trustedHeaderSet);
         }
         
         /**
-         * Get the count of the total records for the paginator.
+         * Gets the list of trusted proxies.
          *
-         * @param array $columns
-         * @return int 
+         * @return array An array of trusted proxies
          * @static 
-         */
-        public static function getCountForPagination($columns = array()){
-            return \Illuminate\Database\Query\Builder::getCountForPagination($columns);
+         */ 
+        public static function getTrustedProxies()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedProxies();
         }
         
         /**
-         * Concatenate values of a given column as a string.
+         * Gets the set of trusted headers from trusted proxies.
          *
-         * @param string $column
-         * @param string $glue
-         * @return string 
+         * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies
          * @static 
-         */
-        public static function implode($column, $glue = ''){
-            return \Illuminate\Database\Query\Builder::implode($column, $glue);
+         */ 
+        public static function getTrustedHeaderSet()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHeaderSet();
         }
         
         /**
-         * Determine if any rows exist for the current query.
+         * Sets a list of trusted host patterns.
+         * 
+         * You should only list the hosts you manage using regexs.
          *
-         * @return bool 
+         * @param array $hostPatterns A list of trusted host patterns
          * @static 
-         */
-        public static function exists(){
-            return \Illuminate\Database\Query\Builder::exists();
+         */ 
+        public static function setTrustedHosts($hostPatterns)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedHosts($hostPatterns);
         }
         
         /**
-         * Retrieve the "count" result of the query.
+         * Gets the list of trusted host patterns.
          *
-         * @param string $columns
-         * @return int 
+         * @return array An array of trusted host patterns
          * @static 
-         */
-        public static function count($columns = '*'){
-            return \Illuminate\Database\Query\Builder::count($columns);
+         */ 
+        public static function getTrustedHosts()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHosts();
         }
         
         /**
-         * Retrieve the minimum value of a given column.
+         * Normalizes a query string.
+         * 
+         * It builds a normalized query string, where keys/value pairs are alphabetized,
+         * have consistent escaping and unneeded delimiters are removed.
          *
-         * @param string $column
-         * @return mixed 
+         * @param string $qs Query string
+         * @return string A normalized query string for the Request
          * @static 
-         */
-        public static function min($column){
-            return \Illuminate\Database\Query\Builder::min($column);
+         */ 
+        public static function normalizeQueryString($qs)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::normalizeQueryString($qs);
         }
         
         /**
-         * Retrieve the maximum value of a given column.
+         * Enables support for the _method request parameter to determine the intended HTTP method.
+         * 
+         * Be warned that enabling this feature might lead to CSRF issues in your code.
+         * Check that you are using CSRF tokens when required.
+         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered
+         * and used to send a "PUT" or "DELETE" request via the _method request parameter.
+         * If these methods are not protected against CSRF, this presents a possible vulnerability.
+         * 
+         * The HTTP method can only be overridden when the real HTTP method is POST.
          *
-         * @param string $column
-         * @return mixed 
          * @static 
-         */
-        public static function max($column){
-            return \Illuminate\Database\Query\Builder::max($column);
+         */ 
+        public static function enableHttpMethodParameterOverride()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::enableHttpMethodParameterOverride();
         }
         
         /**
-         * Retrieve the sum of the values of a given column.
+         * Checks whether support for the _method request parameter is enabled.
          *
-         * @param string $column
-         * @return mixed 
+         * @return bool True when the _method request parameter is enabled, false otherwise
          * @static 
-         */
-        public static function sum($column){
-            return \Illuminate\Database\Query\Builder::sum($column);
+         */ 
+        public static function getHttpMethodParameterOverride()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getHttpMethodParameterOverride();
         }
         
         /**
-         * Retrieve the average of the values of a given column.
+         * Gets a "parameter" value from any bag.
+         * 
+         * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the
+         * flexibility in controllers, it is better to explicitly get request parameters from the appropriate
+         * public property instead (attributes, query, request).
+         * 
+         * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY
          *
-         * @param string $column
+         * @param string $key The key
+         * @param mixed $default The default value if the parameter key does not exist
          * @return mixed 
          * @static 
-         */
-        public static function avg($column){
-            return \Illuminate\Database\Query\Builder::avg($column);
+         */ 
+        public static function get($key, $default = null)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::get($key, $default);
         }
         
         /**
-         * Alias for the "avg" method.
+         * Whether the request contains a Session which was started in one of the
+         * previous requests.
          *
-         * @param string $column
-         * @return mixed 
+         * @return bool 
          * @static 
-         */
-        public static function average($column){
-            return \Illuminate\Database\Query\Builder::average($column);
+         */ 
+        public static function hasPreviousSession()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::hasPreviousSession();
         }
         
         /**
-         * Execute an aggregate function on the database.
+         * Whether the request contains a Session object.
+         * 
+         * This method does not give any information about the state of the session object,
+         * like whether the session is started or not. It is just a way to check if this Request
+         * is associated with a Session instance.
          *
-         * @param string $function
-         * @param array $columns
-         * @return mixed 
+         * @return bool true when the Request contains a Session object, false otherwise
          * @static 
-         */
-        public static function aggregate($function, $columns = array()){
-            return \Illuminate\Database\Query\Builder::aggregate($function, $columns);
+         */ 
+        public static function hasSession()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::hasSession();
         }
         
         /**
-         * Execute a numeric aggregate function on the database.
+         * Sets the Session.
          *
-         * @param string $function
-         * @param array $columns
-         * @return float|int 
+         * @param \Symfony\Component\HttpFoundation\SessionInterface $session The Session
          * @static 
-         */
-        public static function numericAggregate($function, $columns = array()){
-            return \Illuminate\Database\Query\Builder::numericAggregate($function, $columns);
+         */ 
+        public static function setSession($session)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setSession($session);
         }
         
         /**
-         * Insert a new record into the database.
+         * Returns the client IP addresses.
+         * 
+         * In the returned array the most trusted IP address is first, and the
+         * least trusted one last. The "real" client IP address is the last one,
+         * but this is also the least trusted one. Trusted proxies are stripped.
+         * 
+         * Use this method carefully; you should use getClientIp() instead.
          *
-         * @param array $values
-         * @return bool 
+         * @return array The client IP addresses
+         * @see getClientIp()
          * @static 
-         */
-        public static function insert($values){
-            return \Illuminate\Database\Query\Builder::insert($values);
+         */ 
+        public static function getClientIps()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getClientIps();
         }
         
         /**
-         * Insert a new record and get the value of the primary key.
+         * Returns the client IP address.
+         * 
+         * This method can read the client IP address from the "X-Forwarded-For" header
+         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"
+         * header value is a comma+space separated list of IP addresses, the left-most
+         * being the original client, and each successive proxy that passed the request
+         * adding the IP address where it received the request from.
          *
-         * @param array $values
-         * @param string $sequence
-         * @return int 
+         * @return string|null The client IP address
+         * @see getClientIps()
+         * @see http://en.wikipedia.org/wiki/X-Forwarded-For
          * @static 
-         */
-        public static function insertGetId($values, $sequence = null){
-            return \Illuminate\Database\Query\Builder::insertGetId($values, $sequence);
+         */ 
+        public static function getClientIp()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getClientIp();
         }
         
         /**
-         * Insert or update a record matching the attributes, and fill it with values.
+         * Returns current script name.
          *
-         * @param array $attributes
-         * @param array $values
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function updateOrInsert($attributes, $values = array()){
-            return \Illuminate\Database\Query\Builder::updateOrInsert($attributes, $values);
+         */ 
+        public static function getScriptName()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getScriptName();
         }
         
         /**
-         * Run a truncate statement on the table.
+         * Returns the path being requested relative to the executed script.
+         * 
+         * The path info always starts with a /.
+         * 
+         * Suppose this request is instantiated from /mysite on localhost:
+         * 
+         *  * http://localhost/mysite              returns an empty string
+         *  * http://localhost/mysite/about        returns '/about'
+         *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'
+         *  * http://localhost/mysite/about?var=1  returns '/about'
          *
-         * @return void 
+         * @return string The raw path (i.e. not urldecoded)
          * @static 
-         */
-        public static function truncate(){
-            \Illuminate\Database\Query\Builder::truncate();
+         */ 
+        public static function getPathInfo()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPathInfo();
         }
         
         /**
-         * Create a raw database expression.
+         * Returns the root path from which this request is executed.
+         * 
+         * Suppose that an index.php file instantiates this request object:
+         * 
+         *  * http://localhost/index.php         returns an empty string
+         *  * http://localhost/index.php/page    returns an empty string
+         *  * http://localhost/web/index.php     returns '/web'
+         *  * http://localhost/we%20b/index.php  returns '/we%20b'
          *
-         * @param mixed $value
-         * @return \Illuminate\Database\Query\Expression 
+         * @return string The raw path (i.e. not urldecoded)
          * @static 
-         */
-        public static function raw($value){
-            return \Illuminate\Database\Query\Builder::raw($value);
+         */ 
+        public static function getBasePath()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getBasePath();
         }
         
         /**
-         * Get the current query value bindings in a flattened array.
+         * Returns the root URL from which this request is executed.
+         * 
+         * The base URL never ends with a /.
+         * 
+         * This is similar to getBasePath(), except that it also includes the
+         * script filename (e.g. index.php) if one exists.
          *
-         * @return array 
+         * @return string The raw URL (i.e. not urldecoded)
          * @static 
-         */
-        public static function getBindings(){
-            return \Illuminate\Database\Query\Builder::getBindings();
+         */ 
+        public static function getBaseUrl()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getBaseUrl();
         }
         
         /**
-         * Get the raw array of bindings.
+         * Gets the request's scheme.
          *
-         * @return array 
+         * @return string 
          * @static 
-         */
-        public static function getRawBindings(){
-            return \Illuminate\Database\Query\Builder::getRawBindings();
+         */ 
+        public static function getScheme()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getScheme();
         }
         
         /**
-         * Set the bindings on the query builder.
+         * Returns the port on which the request is made.
+         * 
+         * This method can read the client port from the "X-Forwarded-Port" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Port" header must contain the client port.
          *
-         * @param array $bindings
-         * @param string $type
-         * @return $this 
-         * @throws \InvalidArgumentException
+         * @return int|string can be a string if fetched from the server bag
          * @static 
-         */
-        public static function setBindings($bindings, $type = 'where'){
-            return \Illuminate\Database\Query\Builder::setBindings($bindings, $type);
+         */ 
+        public static function getPort()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPort();
         }
         
         /**
-         * Add a binding to the query.
+         * Returns the user.
          *
-         * @param mixed $value
-         * @param string $type
-         * @return $this 
-         * @throws \InvalidArgumentException
+         * @return string|null 
          * @static 
-         */
-        public static function addBinding($value, $type = 'where'){
-            return \Illuminate\Database\Query\Builder::addBinding($value, $type);
+         */ 
+        public static function getUser()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUser();
         }
         
         /**
-         * Merge an array of bindings into our bindings.
+         * Returns the password.
          *
-         * @param \Illuminate\Database\Query\Builder $query
-         * @return $this 
+         * @return string|null 
          * @static 
-         */
-        public static function mergeBindings($query){
-            return \Illuminate\Database\Query\Builder::mergeBindings($query);
+         */ 
+        public static function getPassword()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPassword();
         }
         
         /**
-         * Get the database query processor instance.
+         * Gets the user info.
          *
-         * @return \Illuminate\Database\Query\Processors\Processor 
+         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server
          * @static 
-         */
-        public static function getProcessor(){
-            return \Illuminate\Database\Query\Builder::getProcessor();
+         */ 
+        public static function getUserInfo()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUserInfo();
         }
         
         /**
-         * Get the query grammar instance.
+         * Returns the HTTP host being requested.
+         * 
+         * The port name will be appended to the host if it's non-standard.
          *
-         * @return \Illuminate\Database\Query\Grammars\Grammar 
+         * @return string 
          * @static 
-         */
-        public static function getGrammar(){
-            return \Illuminate\Database\Query\Builder::getGrammar();
+         */ 
+        public static function getHttpHost()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getHttpHost();
         }
         
         /**
-         * Use the write pdo for query.
+         * Returns the requested URI (path and query string).
          *
-         * @return $this 
+         * @return string The raw URI (i.e. not URI decoded)
          * @static 
-         */
-        public static function useWritePdo(){
-            return \Illuminate\Database\Query\Builder::useWritePdo();
+         */ 
+        public static function getRequestUri()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRequestUri();
         }
         
         /**
-         * Clone the query without the given properties.
+         * Gets the scheme and HTTP host.
+         * 
+         * If the URL was called with basic authentication, the user
+         * and the password are not added to the generated string.
          *
-         * @param array $except
-         * @return static 
+         * @return string The scheme and HTTP host
          * @static 
-         */
-        public static function cloneWithout($except){
-            return \Illuminate\Database\Query\Builder::cloneWithout($except);
+         */ 
+        public static function getSchemeAndHttpHost()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getSchemeAndHttpHost();
         }
         
         /**
-         * Clone the query without the given bindings.
+         * Generates a normalized URI (URL) for the Request.
          *
-         * @param array $except
-         * @return static 
+         * @return string A normalized URI (URL) for the Request
+         * @see getQueryString()
          * @static 
-         */
-        public static function cloneWithoutBindings($except){
-            return \Illuminate\Database\Query\Builder::cloneWithoutBindings($except);
+         */ 
+        public static function getUri()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUri();
         }
         
         /**
-         * Register a custom macro.
+         * Generates a normalized URI for the given path.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @param string $path A path to use instead of the current one
+         * @return string The normalized URI for the path
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Database\Query\Builder::macro($name, $macro);
+         */ 
+        public static function getUriForPath($path)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUriForPath($path);
         }
         
         /**
-         * Checks if macro is registered.
+         * Returns the path as relative reference from the current Request path.
+         * 
+         * Only the URIs path component (no schema, host etc.) is relevant and must be given.
+         * Both paths must be absolute and not contain relative parts.
+         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.
+         * Furthermore, they can be used to reduce the link size in documents.
+         * 
+         * Example target paths, given a base path of "/a/b/c/d":
+         * - "/a/b/c/d"     -> ""
+         * - "/a/b/c/"      -> "./"
+         * - "/a/b/"        -> "../"
+         * - "/a/b/c/other" -> "other"
+         * - "/a/x/y"       -> "../../x/y"
          *
-         * @param string $name
-         * @return bool 
+         * @param string $path The target path
+         * @return string The relative target path
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Database\Query\Builder::hasMacro($name);
+         */ 
+        public static function getRelativeUriForPath($path)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRelativeUriForPath($path);
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Generates the normalized query string for the Request.
+         * 
+         * It builds a normalized query string, where keys/value pairs are alphabetized
+         * and have consistent escaping.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return mixed 
-         * @throws \BadMethodCallException
+         * @return string|null A normalized query string for the Request
          * @static 
-         */
-        public static function macroCall($method, $parameters){
-            return \Illuminate\Database\Query\Builder::macroCall($method, $parameters);
+         */ 
+        public static function getQueryString()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getQueryString();
         }
         
-    }
-
-
-    class Event extends \Illuminate\Support\Facades\Event{
-        
         /**
-         * Register an event listener with the dispatcher.
+         * Checks whether the request is secure or not.
+         * 
+         * This method can read the client protocol from the "X-Forwarded-Proto" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".
          *
-         * @param string|array $events
-         * @param mixed $listener
-         * @return void 
+         * @return bool 
          * @static 
-         */
-        public static function listen($events, $listener){
-            \Illuminate\Events\Dispatcher::listen($events, $listener);
+         */ 
+        public static function isSecure()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isSecure();
         }
         
         /**
-         * Determine if a given event has listeners.
+         * Returns the host name.
+         * 
+         * This method can read the client host name from the "X-Forwarded-Host" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Host" header must contain the client host name.
          *
-         * @param string $eventName
-         * @return bool 
+         * @return string 
+         * @throws SuspiciousOperationException when the host name is invalid or not trusted
          * @static 
-         */
-        public static function hasListeners($eventName){
-            return \Illuminate\Events\Dispatcher::hasListeners($eventName);
+         */ 
+        public static function getHost()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getHost();
         }
         
         /**
-         * Register an event and payload to be fired later.
+         * Sets the request method.
          *
-         * @param string $event
-         * @param array $payload
-         * @return void 
+         * @param string $method
          * @static 
-         */
-        public static function push($event, $payload = array()){
-            \Illuminate\Events\Dispatcher::push($event, $payload);
+         */ 
+        public static function setMethod($method)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setMethod($method);
         }
         
         /**
-         * Flush a set of pushed events.
-         *
-         * @param string $event
-         * @return void 
+         * Gets the request "intended" method.
+         * 
+         * If the X-HTTP-Method-Override header is set, and if the method is a POST,
+         * then it is used to determine the "real" intended HTTP method.
+         * 
+         * The _method request parameter can also be used to determine the HTTP method,
+         * but only if enableHttpMethodParameterOverride() has been called.
+         * 
+         * The method is always an uppercased string.
+         *
+         * @return string The request method
+         * @see getRealMethod()
          * @static 
-         */
-        public static function flush($event){
-            \Illuminate\Events\Dispatcher::flush($event);
+         */ 
+        public static function getMethod()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getMethod();
         }
         
         /**
-         * Register an event subscriber with the dispatcher.
+         * Gets the "real" request method.
          *
-         * @param object|string $subscriber
-         * @return void 
+         * @return string The request method
+         * @see getMethod()
          * @static 
-         */
-        public static function subscribe($subscriber){
-            \Illuminate\Events\Dispatcher::subscribe($subscriber);
+         */ 
+        public static function getRealMethod()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRealMethod();
         }
         
         /**
-         * Fire an event until the first non-null response is returned.
+         * Gets the mime type associated with the format.
          *
-         * @param string|object $event
-         * @param mixed $payload
-         * @return array|null 
+         * @param string $format The format
+         * @return string The associated mime type (null if not found)
          * @static 
-         */
-        public static function until($event, $payload = array()){
-            return \Illuminate\Events\Dispatcher::until($event, $payload);
+         */ 
+        public static function getMimeType($format)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getMimeType($format);
         }
         
         /**
-         * Fire an event and call the listeners.
+         * Gets the mime types associated with the format.
          *
-         * @param string|object $event
-         * @param mixed $payload
-         * @param bool $halt
-         * @return array|null 
+         * @param string $format The format
+         * @return array The associated mime types
          * @static 
-         */
-        public static function fire($event, $payload = array(), $halt = false){
-            return \Illuminate\Events\Dispatcher::fire($event, $payload, $halt);
+         */ 
+        public static function getMimeTypes($format)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getMimeTypes($format);
         }
         
         /**
-         * Fire an event and call the listeners.
+         * Gets the format associated with the mime type.
          *
-         * @param string|object $event
-         * @param mixed $payload
-         * @param bool $halt
-         * @return array|null 
+         * @param string $mimeType The associated mime type
+         * @return string|null The format (null if not found)
          * @static 
-         */
-        public static function dispatch($event, $payload = array(), $halt = false){
-            return \Illuminate\Events\Dispatcher::dispatch($event, $payload, $halt);
+         */ 
+        public static function getFormat($mimeType)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getFormat($mimeType);
         }
         
         /**
-         * Get all of the listeners for a given event name.
+         * Associates a format with mime types.
          *
-         * @param string $eventName
-         * @return array 
+         * @param string $format The format
+         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)
          * @static 
-         */
-        public static function getListeners($eventName){
-            return \Illuminate\Events\Dispatcher::getListeners($eventName);
+         */ 
+        public static function setFormat($format, $mimeTypes)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setFormat($format, $mimeTypes);
         }
         
         /**
-         * Register an event listener with the dispatcher.
+         * Gets the request format.
+         * 
+         * Here is the process to determine the format:
+         * 
+         *  * format defined by the user (with setRequestFormat())
+         *  * _format request attribute
+         *  * $default
          *
-         * @param string|\Closure $listener
-         * @param bool $wildcard
-         * @return \Closure 
+         * @param string $default The default format
+         * @return string The request format
          * @static 
-         */
-        public static function makeListener($listener, $wildcard = false){
-            return \Illuminate\Events\Dispatcher::makeListener($listener, $wildcard);
+         */ 
+        public static function getRequestFormat($default = 'html')
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRequestFormat($default);
         }
         
         /**
-         * Create a class based listener using the IoC container.
+         * Sets the request format.
          *
-         * @param string $listener
-         * @param bool $wildcard
-         * @return \Closure 
+         * @param string $format The request format
          * @static 
-         */
-        public static function createClassListener($listener, $wildcard = false){
-            return \Illuminate\Events\Dispatcher::createClassListener($listener, $wildcard);
+         */ 
+        public static function setRequestFormat($format)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setRequestFormat($format);
         }
         
         /**
-         * Remove a set of listeners from the dispatcher.
+         * Gets the format associated with the request.
          *
-         * @param string $event
-         * @return void 
+         * @return string|null The format (null if no content type is present)
          * @static 
-         */
-        public static function forget($event){
-            \Illuminate\Events\Dispatcher::forget($event);
+         */ 
+        public static function getContentType()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getContentType();
         }
         
         /**
-         * Forget all of the pushed listeners.
+         * Sets the default locale.
          *
-         * @return void 
+         * @param string $locale
          * @static 
-         */
-        public static function forgetPushed(){
-            \Illuminate\Events\Dispatcher::forgetPushed();
+         */ 
+        public static function setDefaultLocale($locale)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setDefaultLocale($locale);
         }
         
         /**
-         * Set the queue resolver implementation.
+         * Get the default locale.
          *
-         * @param callable $resolver
-         * @return $this 
+         * @return string 
          * @static 
-         */
-        public static function setQueueResolver($resolver){
-            return \Illuminate\Events\Dispatcher::setQueueResolver($resolver);
+         */ 
+        public static function getDefaultLocale()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getDefaultLocale();
         }
         
-    }
-
-
-    class File extends \Illuminate\Support\Facades\File{
-        
         /**
-         * Determine if a file or directory exists.
+         * Sets the locale.
          *
-         * @param string $path
-         * @return bool 
+         * @param string $locale
          * @static 
-         */
-        public static function exists($path){
-            return \Illuminate\Filesystem\Filesystem::exists($path);
+         */ 
+        public static function setLocale($locale)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setLocale($locale);
         }
         
         /**
-         * Get the contents of a file.
+         * Get the locale.
          *
-         * @param string $path
-         * @param bool $lock
          * @return string 
-         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
          * @static 
-         */
-        public static function get($path, $lock = false){
-            return \Illuminate\Filesystem\Filesystem::get($path, $lock);
+         */ 
+        public static function getLocale()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getLocale();
         }
         
         /**
-         * Get contents of a file with shared access.
+         * Checks if the request method is of specified type.
          *
-         * @param string $path
-         * @return string 
+         * @param string $method Uppercase request method (GET, POST etc)
+         * @return bool 
          * @static 
-         */
-        public static function sharedGet($path){
-            return \Illuminate\Filesystem\Filesystem::sharedGet($path);
+         */ 
+        public static function isMethod($method)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethod($method);
         }
         
         /**
-         * Get the returned value of a file.
+         * Checks whether or not the method is safe.
          *
-         * @param string $path
-         * @return mixed 
-         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
+         * @see https://tools.ietf.org/html/rfc7231#section-4.2.1
+         * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.
+         * @return bool 
          * @static 
-         */
-        public static function getRequire($path){
-            return \Illuminate\Filesystem\Filesystem::getRequire($path);
+         */ 
+        public static function isMethodSafe()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodSafe();
         }
         
         /**
-         * Require the given file once.
+         * Checks whether or not the method is idempotent.
          *
-         * @param string $file
-         * @return mixed 
+         * @return bool 
          * @static 
-         */
-        public static function requireOnce($file){
-            return \Illuminate\Filesystem\Filesystem::requireOnce($file);
+         */ 
+        public static function isMethodIdempotent()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodIdempotent();
         }
         
         /**
-         * Get the MD5 hash of the file at the given path.
+         * Checks whether the method is cacheable or not.
          *
-         * @param string $path
-         * @return string 
+         * @see https://tools.ietf.org/html/rfc7231#section-4.2.3
+         * @return bool 
          * @static 
-         */
-        public static function hash($path){
-            return \Illuminate\Filesystem\Filesystem::hash($path);
+         */ 
+        public static function isMethodCacheable()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodCacheable();
         }
         
         /**
-         * Write the contents of a file.
+         * Returns the protocol version.
+         * 
+         * If the application is behind a proxy, the protocol version used in the
+         * requests between the client and the proxy and between the proxy and the
+         * server might be different. This returns the former (from the "Via" header)
+         * if the proxy is trusted (see "setTrustedProxies()"), otherwise it returns
+         * the latter (from the "SERVER_PROTOCOL" server parameter).
          *
-         * @param string $path
-         * @param string $contents
-         * @param bool $lock
-         * @return int 
+         * @return string 
          * @static 
-         */
-        public static function put($path, $contents, $lock = false){
-            return \Illuminate\Filesystem\Filesystem::put($path, $contents, $lock);
+         */ 
+        public static function getProtocolVersion()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getProtocolVersion();
         }
         
         /**
-         * Prepend to a file.
+         * Returns the request body content.
          *
-         * @param string $path
-         * @param string $data
-         * @return int 
+         * @param bool $asResource If true, a resource will be returned
+         * @return string|resource The request body content or a resource to read the body stream
+         * @throws \LogicException
          * @static 
-         */
-        public static function prepend($path, $data){
-            return \Illuminate\Filesystem\Filesystem::prepend($path, $data);
+         */ 
+        public static function getContent($asResource = false)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getContent($asResource);
         }
         
         /**
-         * Append to a file.
+         * Gets the Etags.
          *
-         * @param string $path
-         * @param string $data
-         * @return int 
+         * @return array The entity tags
          * @static 
-         */
-        public static function append($path, $data){
-            return \Illuminate\Filesystem\Filesystem::append($path, $data);
+         */ 
+        public static function getETags()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getETags();
         }
         
         /**
-         * Get or set UNIX mode of a file or directory.
+         * 
          *
-         * @param string $path
-         * @param int $mode
-         * @return mixed 
+         * @return bool 
          * @static 
-         */
-        public static function chmod($path, $mode = null){
-            return \Illuminate\Filesystem\Filesystem::chmod($path, $mode);
+         */ 
+        public static function isNoCache()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isNoCache();
         }
         
         /**
-         * Delete the file at a given path.
+         * Returns the preferred language.
          *
-         * @param string|array $paths
-         * @return bool 
+         * @param array $locales An array of ordered available locales
+         * @return string|null The preferred locale
          * @static 
-         */
-        public static function delete($paths){
-            return \Illuminate\Filesystem\Filesystem::delete($paths);
+         */ 
+        public static function getPreferredLanguage($locales = null)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPreferredLanguage($locales);
         }
         
         /**
-         * Move a file to a new location.
+         * Gets a list of languages acceptable by the client browser.
          *
-         * @param string $path
-         * @param string $target
-         * @return bool 
+         * @return array Languages ordered in the user browser preferences
          * @static 
-         */
-        public static function move($path, $target){
-            return \Illuminate\Filesystem\Filesystem::move($path, $target);
+         */ 
+        public static function getLanguages()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getLanguages();
         }
         
         /**
-         * Copy a file to a new location.
+         * Gets a list of charsets acceptable by the client browser.
          *
-         * @param string $path
-         * @param string $target
-         * @return bool 
+         * @return array List of charsets in preferable order
          * @static 
-         */
-        public static function copy($path, $target){
-            return \Illuminate\Filesystem\Filesystem::copy($path, $target);
+         */ 
+        public static function getCharsets()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getCharsets();
         }
         
         /**
-         * Create a hard link to the target file or directory.
+         * Gets a list of encodings acceptable by the client browser.
          *
-         * @param string $target
-         * @param string $link
-         * @return void 
+         * @return array List of encodings in preferable order
          * @static 
-         */
-        public static function link($target, $link){
-            \Illuminate\Filesystem\Filesystem::link($target, $link);
+         */ 
+        public static function getEncodings()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getEncodings();
         }
         
         /**
-         * Extract the file name from a file path.
+         * Gets a list of content types acceptable by the client browser.
          *
-         * @param string $path
-         * @return string 
+         * @return array List of content types in preferable order
          * @static 
-         */
-        public static function name($path){
-            return \Illuminate\Filesystem\Filesystem::name($path);
+         */ 
+        public static function getAcceptableContentTypes()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getAcceptableContentTypes();
         }
         
         /**
-         * Extract the trailing name component from a file path.
-         *
-         * @param string $path
-         * @return string 
+         * Returns true if the request is a XMLHttpRequest.
+         * 
+         * It works if your JavaScript library sets an X-Requested-With HTTP header.
+         * It is known to work with common JavaScript frameworks:
+         *
+         * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript
+         * @return bool true if the request is an XMLHttpRequest, false otherwise
          * @static 
-         */
-        public static function basename($path){
-            return \Illuminate\Filesystem\Filesystem::basename($path);
+         */ 
+        public static function isXmlHttpRequest()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isXmlHttpRequest();
         }
         
         /**
-         * Extract the parent directory from a file path.
+         * Indicates whether this request originated from a trusted proxy.
+         * 
+         * This can be useful to determine whether or not to trust the
+         * contents of a proxy-specific header.
          *
-         * @param string $path
-         * @return string 
+         * @return bool true if the request came from a trusted proxy, false otherwise
          * @static 
-         */
-        public static function dirname($path){
-            return \Illuminate\Filesystem\Filesystem::dirname($path);
+         */ 
+        public static function isFromTrustedProxy()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isFromTrustedProxy();
         }
         
         /**
-         * Extract the file extension from a file path.
+         * Determine if the given content types match.
          *
-         * @param string $path
-         * @return string 
+         * @param string $actual
+         * @param string $type
+         * @return bool 
          * @static 
-         */
-        public static function extension($path){
-            return \Illuminate\Filesystem\Filesystem::extension($path);
+         */ 
+        public static function matchesType($actual, $type)
+        {
+            return \Illuminate\Http\Request::matchesType($actual, $type);
         }
         
         /**
-         * Get the file type of a given file.
+         * Determine if the request is sending JSON.
          *
-         * @param string $path
-         * @return string 
+         * @return bool 
          * @static 
-         */
-        public static function type($path){
-            return \Illuminate\Filesystem\Filesystem::type($path);
+         */ 
+        public static function isJson()
+        {
+            return \Illuminate\Http\Request::isJson();
         }
         
         /**
-         * Get the mime-type of a given file.
+         * Determine if the current request probably expects a JSON response.
          *
-         * @param string $path
-         * @return string|false 
+         * @return bool 
          * @static 
-         */
-        public static function mimeType($path){
-            return \Illuminate\Filesystem\Filesystem::mimeType($path);
+         */ 
+        public static function expectsJson()
+        {
+            return \Illuminate\Http\Request::expectsJson();
         }
         
         /**
-         * Get the file size of a given file.
+         * Determine if the current request is asking for JSON.
          *
-         * @param string $path
-         * @return int 
+         * @return bool 
          * @static 
-         */
-        public static function size($path){
-            return \Illuminate\Filesystem\Filesystem::size($path);
+         */ 
+        public static function wantsJson()
+        {
+            return \Illuminate\Http\Request::wantsJson();
         }
         
         /**
-         * Get the file's last modification time.
+         * Determines whether the current requests accepts a given content type.
          *
-         * @param string $path
-         * @return int 
+         * @param string|array $contentTypes
+         * @return bool 
          * @static 
-         */
-        public static function lastModified($path){
-            return \Illuminate\Filesystem\Filesystem::lastModified($path);
+         */ 
+        public static function accepts($contentTypes)
+        {
+            return \Illuminate\Http\Request::accepts($contentTypes);
         }
         
         /**
-         * Determine if the given path is a directory.
+         * Return the most suitable content type from the given array based on content negotiation.
          *
-         * @param string $directory
-         * @return bool 
+         * @param string|array $contentTypes
+         * @return string|null 
          * @static 
-         */
-        public static function isDirectory($directory){
-            return \Illuminate\Filesystem\Filesystem::isDirectory($directory);
+         */ 
+        public static function prefers($contentTypes)
+        {
+            return \Illuminate\Http\Request::prefers($contentTypes);
         }
         
         /**
-         * Determine if the given path is readable.
+         * Determine if the current request accepts any content type.
          *
-         * @param string $path
          * @return bool 
          * @static 
-         */
-        public static function isReadable($path){
-            return \Illuminate\Filesystem\Filesystem::isReadable($path);
+         */ 
+        public static function acceptsAnyContentType()
+        {
+            return \Illuminate\Http\Request::acceptsAnyContentType();
         }
         
         /**
-         * Determine if the given path is writable.
+         * Determines whether a request accepts JSON.
          *
-         * @param string $path
          * @return bool 
          * @static 
-         */
-        public static function isWritable($path){
-            return \Illuminate\Filesystem\Filesystem::isWritable($path);
+         */ 
+        public static function acceptsJson()
+        {
+            return \Illuminate\Http\Request::acceptsJson();
         }
         
         /**
-         * Determine if the given path is a file.
+         * Determines whether a request accepts HTML.
          *
-         * @param string $file
          * @return bool 
          * @static 
-         */
-        public static function isFile($file){
-            return \Illuminate\Filesystem\Filesystem::isFile($file);
+         */ 
+        public static function acceptsHtml()
+        {
+            return \Illuminate\Http\Request::acceptsHtml();
         }
         
         /**
-         * Find path names matching a given pattern.
+         * Get the data format expected in the response.
          *
-         * @param string $pattern
-         * @param int $flags
-         * @return array 
+         * @param string $default
+         * @return string 
          * @static 
-         */
-        public static function glob($pattern, $flags = 0){
-            return \Illuminate\Filesystem\Filesystem::glob($pattern, $flags);
+         */ 
+        public static function format($default = 'html')
+        {
+            return \Illuminate\Http\Request::format($default);
         }
         
         /**
-         * Get an array of all files in a directory.
+         * Retrieve an old input item.
          *
-         * @param string $directory
-         * @return array 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function files($directory){
-            return \Illuminate\Filesystem\Filesystem::files($directory);
+         */ 
+        public static function old($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::old($key, $default);
         }
         
         /**
-         * Get all of the files from the given directory (recursive).
+         * Flash the input for the current request to the session.
          *
-         * @param string $directory
-         * @param bool $hidden
-         * @return array 
+         * @return void 
          * @static 
-         */
-        public static function allFiles($directory, $hidden = false){
-            return \Illuminate\Filesystem\Filesystem::allFiles($directory, $hidden);
+         */ 
+        public static function flash()
+        {
+            \Illuminate\Http\Request::flash();
         }
         
         /**
-         * Get all of the directories within a given directory.
+         * Flash only some of the input to the session.
          *
-         * @param string $directory
-         * @return array 
+         * @param array|mixed $keys
+         * @return void 
          * @static 
-         */
-        public static function directories($directory){
-            return \Illuminate\Filesystem\Filesystem::directories($directory);
+         */ 
+        public static function flashOnly($keys)
+        {
+            \Illuminate\Http\Request::flashOnly($keys);
         }
         
         /**
-         * Create a directory.
+         * Flash only some of the input to the session.
          *
-         * @param string $path
-         * @param int $mode
-         * @param bool $recursive
-         * @param bool $force
-         * @return bool 
+         * @param array|mixed $keys
+         * @return void 
          * @static 
-         */
-        public static function makeDirectory($path, $mode = 493, $recursive = false, $force = false){
-            return \Illuminate\Filesystem\Filesystem::makeDirectory($path, $mode, $recursive, $force);
+         */ 
+        public static function flashExcept($keys)
+        {
+            \Illuminate\Http\Request::flashExcept($keys);
         }
         
         /**
-         * Move a directory.
+         * Flush all of the old input from the session.
          *
-         * @param string $from
-         * @param string $to
-         * @param bool $overwrite
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function moveDirectory($from, $to, $overwrite = false){
-            return \Illuminate\Filesystem\Filesystem::moveDirectory($from, $to, $overwrite);
+         */ 
+        public static function flush()
+        {
+            \Illuminate\Http\Request::flush();
         }
         
         /**
-         * Copy a directory from one location to another.
+         * Retrieve a server variable from the request.
          *
-         * @param string $directory
-         * @param string $destination
-         * @param int $options
-         * @return bool 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function copyDirectory($directory, $destination, $options = null){
-            return \Illuminate\Filesystem\Filesystem::copyDirectory($directory, $destination, $options);
+         */ 
+        public static function server($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::server($key, $default);
         }
         
         /**
-         * Recursively delete a directory.
-         * 
-         * The directory itself may be optionally preserved.
+         * Determine if a header is set on the request.
          *
-         * @param string $directory
-         * @param bool $preserve
+         * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function deleteDirectory($directory, $preserve = false){
-            return \Illuminate\Filesystem\Filesystem::deleteDirectory($directory, $preserve);
+         */ 
+        public static function hasHeader($key)
+        {
+            return \Illuminate\Http\Request::hasHeader($key);
         }
         
         /**
-         * Empty the specified directory of all files and folders.
+         * Retrieve a header from the request.
          *
-         * @param string $directory
-         * @return bool 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function cleanDirectory($directory){
-            return \Illuminate\Filesystem\Filesystem::cleanDirectory($directory);
+         */ 
+        public static function header($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::header($key, $default);
         }
         
         /**
-         * Register a custom macro.
+         * Get the bearer token from the request headers.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @return string|null 
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Filesystem\Filesystem::macro($name, $macro);
+         */ 
+        public static function bearerToken()
+        {
+            return \Illuminate\Http\Request::bearerToken();
         }
         
         /**
-         * Checks if macro is registered.
+         * Determine if the request contains a given input item key.
          *
-         * @param string $name
+         * @param string|array $key
          * @return bool 
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Filesystem\Filesystem::hasMacro($name);
+         */ 
+        public static function exists($key)
+        {
+            return \Illuminate\Http\Request::exists($key);
         }
         
-    }
-
-
-    class Gate extends \Illuminate\Support\Facades\Gate{
-        
         /**
-         * Determine if a given ability has been defined.
+         * Determine if the request contains a given input item key.
          *
-         * @param string $ability
+         * @param string|array $key
          * @return bool 
          * @static 
-         */
-        public static function has($ability){
-            return \Illuminate\Auth\Access\Gate::has($ability);
+         */ 
+        public static function has($key)
+        {
+            return \Illuminate\Http\Request::has($key);
         }
         
         /**
-         * Define a new ability.
+         * Determine if the request contains any of the given inputs.
          *
-         * @param string $ability
-         * @param callable|string $callback
-         * @return $this 
-         * @throws \InvalidArgumentException
+         * @param string|array $key
+         * @return bool 
          * @static 
-         */
-        public static function define($ability, $callback){
-            return \Illuminate\Auth\Access\Gate::define($ability, $callback);
+         */ 
+        public static function hasAny($keys)
+        {
+            return \Illuminate\Http\Request::hasAny($keys);
         }
         
         /**
-         * Define abilities for a resource.
+         * Determine if the request contains a non-empty value for an input item.
          *
-         * @param string $name
-         * @param string $class
-         * @param array $abilities
-         * @return $this 
+         * @param string|array $key
+         * @return bool 
          * @static 
-         */
-        public static function resource($name, $class, $abilities = null){
-            return \Illuminate\Auth\Access\Gate::resource($name, $class, $abilities);
+         */ 
+        public static function filled($key)
+        {
+            return \Illuminate\Http\Request::filled($key);
         }
         
         /**
-         * Define a policy class for a given class type.
+         * Get the keys for all of the input and files.
          *
-         * @param string $class
-         * @param string $policy
-         * @return $this 
+         * @return array 
          * @static 
-         */
-        public static function policy($class, $policy){
-            return \Illuminate\Auth\Access\Gate::policy($class, $policy);
+         */ 
+        public static function keys()
+        {
+            return \Illuminate\Http\Request::keys();
         }
         
         /**
-         * Register a callback to run before all Gate checks.
+         * Get all of the input and files for the request.
          *
-         * @param callable $callback
-         * @return $this 
+         * @param array|mixed $keys
+         * @return array 
          * @static 
-         */
-        public static function before($callback){
-            return \Illuminate\Auth\Access\Gate::before($callback);
+         */ 
+        public static function all($keys = null)
+        {
+            return \Illuminate\Http\Request::all($keys);
         }
         
         /**
-         * Register a callback to run after all Gate checks.
+         * Retrieve an input item from the request.
          *
-         * @param callable $callback
-         * @return $this 
+         * @param string|null $key
+         * @param string|array|null $default
+         * @return string|array|null 
          * @static 
-         */
-        public static function after($callback){
-            return \Illuminate\Auth\Access\Gate::after($callback);
+         */ 
+        public static function input($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::input($key, $default);
         }
         
         /**
-         * Determine if the given ability should be granted for the current user.
+         * Get a subset containing the provided keys with values from the input data.
          *
-         * @param string $ability
-         * @param array|mixed $arguments
-         * @return bool 
+         * @param array|mixed $keys
+         * @return array 
          * @static 
-         */
-        public static function allows($ability, $arguments = array()){
-            return \Illuminate\Auth\Access\Gate::allows($ability, $arguments);
+         */ 
+        public static function only($keys)
+        {
+            return \Illuminate\Http\Request::only($keys);
         }
         
         /**
-         * Determine if the given ability should be denied for the current user.
+         * Get all of the input except for a specified array of items.
          *
-         * @param string $ability
-         * @param array|mixed $arguments
-         * @return bool 
+         * @param array|mixed $keys
+         * @return array 
          * @static 
-         */
-        public static function denies($ability, $arguments = array()){
-            return \Illuminate\Auth\Access\Gate::denies($ability, $arguments);
+         */ 
+        public static function except($keys)
+        {
+            return \Illuminate\Http\Request::except($keys);
         }
         
         /**
-         * Determine if the given ability should be granted for the current user.
+         * Retrieve a query string item from the request.
          *
-         * @param string $ability
-         * @param array|mixed $arguments
-         * @return bool 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function check($ability, $arguments = array()){
-            return \Illuminate\Auth\Access\Gate::check($ability, $arguments);
+         */ 
+        public static function query($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::query($key, $default);
         }
         
         /**
-         * Determine if the given ability should be granted for the current user.
+         * Retrieve a request payload item from the request.
          *
-         * @param string $ability
-         * @param array|mixed $arguments
-         * @return \Illuminate\Auth\Access\Response 
-         * @throws \Illuminate\Auth\Access\AuthorizationException
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function authorize($ability, $arguments = array()){
-            return \Illuminate\Auth\Access\Gate::authorize($ability, $arguments);
+         */ 
+        public static function post($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::post($key, $default);
         }
         
         /**
-         * Get a policy instance for a given class.
+         * Determine if a cookie is set on the request.
          *
-         * @param object|string $class
-         * @return mixed 
+         * @param string $key
+         * @return bool 
          * @static 
-         */
-        public static function getPolicyFor($class){
-            return \Illuminate\Auth\Access\Gate::getPolicyFor($class);
+         */ 
+        public static function hasCookie($key)
+        {
+            return \Illuminate\Http\Request::hasCookie($key);
         }
         
         /**
-         * Build a policy class instance of the given type.
+         * Retrieve a cookie from the request.
          *
-         * @param object|string $class
-         * @return mixed 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function resolvePolicy($class){
-            return \Illuminate\Auth\Access\Gate::resolvePolicy($class);
+         */ 
+        public static function cookie($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::cookie($key, $default);
         }
         
         /**
-         * Get a gate instance for the given user.
+         * Get an array of all of the files on the request.
          *
-         * @param \Illuminate\Contracts\Auth\Authenticatable|mixed $user
-         * @return static 
+         * @return array 
          * @static 
-         */
-        public static function forUser($user){
-            return \Illuminate\Auth\Access\Gate::forUser($user);
+         */ 
+        public static function allFiles()
+        {
+            return \Illuminate\Http\Request::allFiles();
         }
         
         /**
-         * Get all of the defined abilities.
+         * Determine if the uploaded data contains a file.
          *
-         * @return array 
+         * @param string $key
+         * @return bool 
          * @static 
-         */
-        public static function abilities(){
-            return \Illuminate\Auth\Access\Gate::abilities();
+         */ 
+        public static function hasFile($key)
+        {
+            return \Illuminate\Http\Request::hasFile($key);
         }
         
-    }
-
-
-    class Hash extends \Illuminate\Support\Facades\Hash{
+        /**
+         * Retrieve a file from the request.
+         *
+         * @param string $key
+         * @param mixed $default
+         * @return \Illuminate\Http\UploadedFile|array|null 
+         * @static 
+         */ 
+        public static function file($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::file($key, $default);
+        }
         
         /**
-         * Hash the given value.
+         * Register a custom macro.
          *
-         * @param string $value
-         * @param array $options
-         * @return string 
-         * @throws \RuntimeException
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function make($value, $options = array()){
-            return \Illuminate\Hashing\BcryptHasher::make($value, $options);
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Http\Request::macro($name, $macro);
         }
         
         /**
-         * Check the given plain value against a hash.
+         * Mix another object into the class.
          *
-         * @param string $value
-         * @param string $hashedValue
-         * @param array $options
-         * @return bool 
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function check($value, $hashedValue, $options = array()){
-            return \Illuminate\Hashing\BcryptHasher::check($value, $hashedValue, $options);
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Http\Request::mixin($mixin);
         }
         
         /**
-         * Check if the given hash has been hashed using the given options.
+         * Checks if macro is registered.
          *
-         * @param string $hashedValue
-         * @param array $options
+         * @param string $name
          * @return bool 
          * @static 
-         */
-        public static function needsRehash($hashedValue, $options = array()){
-            return \Illuminate\Hashing\BcryptHasher::needsRehash($hashedValue, $options);
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Http\Request::hasMacro($name);
         }
         
         /**
-         * Set the default password work factor.
+         * 
          *
-         * @param int $rounds
-         * @return $this 
          * @static 
-         */
-        public static function setRounds($rounds){
-            return \Illuminate\Hashing\BcryptHasher::setRounds($rounds);
+         */ 
+        public static function validate($rules, $params = null)
+        {
+            return \Illuminate\Http\Request::validate($rules, $params);
         }
-        
+         
     }
 
-
-    class Input extends \Illuminate\Support\Facades\Input{
+    class Lang {
         
         /**
-         * Create a new Illuminate HTTP request from server variables.
+         * Determine if a translation exists for a given locale.
          *
-         * @return static 
+         * @param string $key
+         * @param string|null $locale
+         * @return bool 
          * @static 
-         */
-        public static function capture(){
-            return \Illuminate\Http\Request::capture();
+         */ 
+        public static function hasForLocale($key, $locale = null)
+        {
+            return \Illuminate\Translation\Translator::hasForLocale($key, $locale);
         }
         
         /**
-         * Return the Request instance.
+         * Determine if a translation exists.
          *
-         * @return $this 
+         * @param string $key
+         * @param string|null $locale
+         * @param bool $fallback
+         * @return bool 
          * @static 
-         */
-        public static function instance(){
-            return \Illuminate\Http\Request::instance();
+         */ 
+        public static function has($key, $locale = null, $fallback = true)
+        {
+            return \Illuminate\Translation\Translator::has($key, $locale, $fallback);
         }
         
         /**
-         * Get the request method.
+         * Get the translation for a given key.
          *
-         * @return string 
+         * @param string $key
+         * @param array $replace
+         * @param string $locale
+         * @return string|array|null 
          * @static 
-         */
-        public static function method(){
-            return \Illuminate\Http\Request::method();
+         */ 
+        public static function trans($key, $replace = array(), $locale = null)
+        {
+            return \Illuminate\Translation\Translator::trans($key, $replace, $locale);
         }
         
         /**
-         * Get the root URL for the application.
+         * Get the translation for the given key.
          *
-         * @return string 
+         * @param string $key
+         * @param array $replace
+         * @param string|null $locale
+         * @param bool $fallback
+         * @return string|array|null 
          * @static 
-         */
-        public static function root(){
-            return \Illuminate\Http\Request::root();
+         */ 
+        public static function get($key, $replace = array(), $locale = null, $fallback = true)
+        {
+            return \Illuminate\Translation\Translator::get($key, $replace, $locale, $fallback);
         }
         
         /**
-         * Get the URL (no query string) for the request.
+         * Get the translation for a given key from the JSON translation files.
          *
-         * @return string 
+         * @param string $key
+         * @param array $replace
+         * @param string $locale
+         * @return string|array|null 
          * @static 
-         */
-        public static function url(){
-            return \Illuminate\Http\Request::url();
+         */ 
+        public static function getFromJson($key, $replace = array(), $locale = null)
+        {
+            return \Illuminate\Translation\Translator::getFromJson($key, $replace, $locale);
         }
         
         /**
-         * Get the full URL for the request.
+         * Get a translation according to an integer value.
          *
+         * @param string $key
+         * @param int|array|\Countable $number
+         * @param array $replace
+         * @param string $locale
          * @return string 
          * @static 
-         */
-        public static function fullUrl(){
-            return \Illuminate\Http\Request::fullUrl();
+         */ 
+        public static function transChoice($key, $number, $replace = array(), $locale = null)
+        {
+            return \Illuminate\Translation\Translator::transChoice($key, $number, $replace, $locale);
         }
         
         /**
-         * Get the full URL for the request with the added query string parameters.
+         * Get a translation according to an integer value.
          *
-         * @param array $query
+         * @param string $key
+         * @param int|array|\Countable $number
+         * @param array $replace
+         * @param string $locale
          * @return string 
          * @static 
-         */
-        public static function fullUrlWithQuery($query){
-            return \Illuminate\Http\Request::fullUrlWithQuery($query);
+         */ 
+        public static function choice($key, $number, $replace = array(), $locale = null)
+        {
+            return \Illuminate\Translation\Translator::choice($key, $number, $replace, $locale);
         }
         
         /**
-         * Get the current path info for the request.
+         * Add translation lines to the given locale.
          *
-         * @return string 
+         * @param array $lines
+         * @param string $locale
+         * @param string $namespace
+         * @return void 
          * @static 
-         */
-        public static function path(){
-            return \Illuminate\Http\Request::path();
+         */ 
+        public static function addLines($lines, $locale, $namespace = '*')
+        {
+            \Illuminate\Translation\Translator::addLines($lines, $locale, $namespace);
         }
         
         /**
-         * Get the current encoded path info for the request.
+         * Load the specified language group.
          *
-         * @return string 
+         * @param string $namespace
+         * @param string $group
+         * @param string $locale
+         * @return void 
          * @static 
-         */
-        public static function decodedPath(){
-            return \Illuminate\Http\Request::decodedPath();
+         */ 
+        public static function load($namespace, $group, $locale)
+        {
+            \Illuminate\Translation\Translator::load($namespace, $group, $locale);
         }
         
         /**
-         * Get a segment from the URI (1 based index).
+         * Add a new namespace to the loader.
          *
-         * @param int $index
-         * @param string|null $default
-         * @return string|null 
+         * @param string $namespace
+         * @param string $hint
+         * @return void 
          * @static 
-         */
-        public static function segment($index, $default = null){
-            return \Illuminate\Http\Request::segment($index, $default);
+         */ 
+        public static function addNamespace($namespace, $hint)
+        {
+            \Illuminate\Translation\Translator::addNamespace($namespace, $hint);
         }
         
         /**
-         * Get all of the segments for the request path.
+         * Add a new JSON path to the loader.
          *
-         * @return array 
+         * @param string $path
+         * @return void 
          * @static 
-         */
-        public static function segments(){
-            return \Illuminate\Http\Request::segments();
+         */ 
+        public static function addJsonPath($path)
+        {
+            \Illuminate\Translation\Translator::addJsonPath($path);
         }
         
         /**
-         * Determine if the current request URI matches a pattern.
+         * Parse a key into namespace, group, and item.
          *
-         * @return bool 
+         * @param string $key
+         * @return array 
          * @static 
-         */
-        public static function is(){
-            return \Illuminate\Http\Request::is();
+         */ 
+        public static function parseKey($key)
+        {
+            return \Illuminate\Translation\Translator::parseKey($key);
         }
         
         /**
-         * Check if the route name matches the given string.
+         * Get the message selector instance.
          *
-         * @param string $name
-         * @return bool 
+         * @return \Illuminate\Translation\MessageSelector 
          * @static 
-         */
-        public static function routeIs($name){
-            return \Illuminate\Http\Request::routeIs($name);
+         */ 
+        public static function getSelector()
+        {
+            return \Illuminate\Translation\Translator::getSelector();
         }
         
         /**
-         * Determine if the current request URL and query string matches a pattern.
+         * Set the message selector instance.
          *
-         * @return bool 
+         * @param \Illuminate\Translation\MessageSelector $selector
+         * @return void 
          * @static 
-         */
-        public static function fullUrlIs(){
-            return \Illuminate\Http\Request::fullUrlIs();
+         */ 
+        public static function setSelector($selector)
+        {
+            \Illuminate\Translation\Translator::setSelector($selector);
         }
         
         /**
-         * Determine if the request is the result of an AJAX call.
+         * Get the language line loader implementation.
          *
-         * @return bool 
+         * @return \Illuminate\Contracts\Translation\Loader 
          * @static 
-         */
-        public static function ajax(){
-            return \Illuminate\Http\Request::ajax();
+         */ 
+        public static function getLoader()
+        {
+            return \Illuminate\Translation\Translator::getLoader();
         }
         
         /**
-         * Determine if the request is the result of an PJAX call.
+         * Get the default locale being used.
          *
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function pjax(){
-            return \Illuminate\Http\Request::pjax();
+         */ 
+        public static function locale()
+        {
+            return \Illuminate\Translation\Translator::locale();
         }
         
         /**
-         * Determine if the request is over HTTPS.
+         * Get the default locale being used.
          *
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function secure(){
-            return \Illuminate\Http\Request::secure();
+         */ 
+        public static function getLocale()
+        {
+            return \Illuminate\Translation\Translator::getLocale();
         }
         
         /**
-         * Returns the client IP address.
+         * Set the default locale.
          *
-         * @return string 
+         * @param string $locale
+         * @return void 
          * @static 
-         */
-        public static function ip(){
-            return \Illuminate\Http\Request::ip();
+         */ 
+        public static function setLocale($locale)
+        {
+            \Illuminate\Translation\Translator::setLocale($locale);
         }
         
         /**
-         * Returns the client IP addresses.
+         * Get the fallback locale being used.
          *
-         * @return array 
+         * @return string 
          * @static 
-         */
-        public static function ips(){
-            return \Illuminate\Http\Request::ips();
+         */ 
+        public static function getFallback()
+        {
+            return \Illuminate\Translation\Translator::getFallback();
         }
         
         /**
-         * Merge new input into the current request's input array.
+         * Set the fallback locale being used.
          *
-         * @param array $input
+         * @param string $fallback
          * @return void 
          * @static 
-         */
-        public static function merge($input){
-            \Illuminate\Http\Request::merge($input);
+         */ 
+        public static function setFallback($fallback)
+        {
+            \Illuminate\Translation\Translator::setFallback($fallback);
         }
         
         /**
-         * Replace the input for the current request.
+         * Set the loaded translation groups.
          *
-         * @param array $input
+         * @param array $loaded
          * @return void 
          * @static 
-         */
-        public static function replace($input){
-            \Illuminate\Http\Request::replace($input);
+         */ 
+        public static function setLoaded($loaded)
+        {
+            \Illuminate\Translation\Translator::setLoaded($loaded);
         }
         
         /**
-         * Get the JSON payload for the request.
+         * Set the parsed value of a key.
          *
          * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param array $parsed
+         * @return void 
          * @static 
-         */
-        public static function json($key = null, $default = null){
-            return \Illuminate\Http\Request::json($key, $default);
+         */ 
+        public static function setParsedKey($key, $parsed)
+        {
+            //Method inherited from \Illuminate\Support\NamespacedItemResolver            
+            \Illuminate\Translation\Translator::setParsedKey($key, $parsed);
         }
         
         /**
-         * Create an Illuminate request from a Symfony instance.
+         * Register a custom macro.
          *
-         * @param \Symfony\Component\HttpFoundation\Request $request
-         * @return \Illuminate\Http\Request 
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function createFromBase($request){
-            return \Illuminate\Http\Request::createFromBase($request);
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Translation\Translator::macro($name, $macro);
         }
         
         /**
-         * Clones a request and overrides some of its parameters.
+         * Mix another object into the class.
          *
-         * @param array $query The GET parameters
-         * @param array $request The POST parameters
-         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
-         * @param array $cookies The COOKIE parameters
-         * @param array $files The FILES parameters
-         * @param array $server The SERVER parameters
-         * @return static 
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null){
-            return \Illuminate\Http\Request::duplicate($query, $request, $attributes, $cookies, $files, $server);
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Translation\Translator::mixin($mixin);
         }
         
         /**
-         * Get the session associated with the request.
+         * Checks if macro is registered.
          *
-         * @return \Illuminate\Session\Store 
-         * @throws \RuntimeException
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function session(){
-            return \Illuminate\Http\Request::session();
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Translation\Translator::hasMacro($name);
         }
-        
+         
+    }
+
+    class Log {
+        
         /**
-         * Set the session instance on the request.
+         * Adds a log record at the DEBUG level.
          *
-         * @param \Illuminate\Contracts\Session\Session $session
-         * @return void 
+         * @param string $message The log message
+         * @param array $context The log context
+         * @return Boolean Whether the record has been processed
          * @static 
-         */
-        public static function setLaravelSession($session){
-            \Illuminate\Http\Request::setLaravelSession($session);
+         */ 
+        public static function debug($message, $context = array())
+        {
+            return \Monolog\Logger::debug($message, $context);
         }
         
         /**
-         * Get the user making the request.
+         * Adds a log record at the INFO level.
          *
-         * @param string|null $guard
-         * @return mixed 
+         * @param string $message The log message
+         * @param array $context The log context
+         * @return Boolean Whether the record has been processed
          * @static 
-         */
-        public static function user($guard = null){
-            return \Illuminate\Http\Request::user($guard);
+         */ 
+        public static function info($message, $context = array())
+        {
+            return \Monolog\Logger::info($message, $context);
         }
         
         /**
-         * Get the route handling the request.
+         * Adds a log record at the NOTICE level.
          *
-         * @param string|null $param
-         * @return \Illuminate\Routing\Route|object|string 
+         * @param string $message The log message
+         * @param array $context The log context
+         * @return Boolean Whether the record has been processed
          * @static 
-         */
-        public static function route($param = null){
-            return \Illuminate\Http\Request::route($param);
+         */ 
+        public static function notice($message, $context = array())
+        {
+            return \Monolog\Logger::notice($message, $context);
         }
         
         /**
-         * Get a unique fingerprint for the request / route / IP address.
+         * Adds a log record at the WARNING level.
          *
-         * @return string 
-         * @throws \RuntimeException
+         * @param string $message The log message
+         * @param array $context The log context
+         * @return Boolean Whether the record has been processed
          * @static 
-         */
-        public static function fingerprint(){
-            return \Illuminate\Http\Request::fingerprint();
+         */ 
+        public static function warning($message, $context = array())
+        {
+            return \Monolog\Logger::warning($message, $context);
         }
         
         /**
-         * Set the JSON payload for the request.
+         * Adds a log record at the ERROR level.
          *
-         * @param array $json
-         * @return $this 
+         * @param string $message The log message
+         * @param array $context The log context
+         * @return Boolean Whether the record has been processed
          * @static 
-         */
-        public static function setJson($json){
-            return \Illuminate\Http\Request::setJson($json);
+         */ 
+        public static function error($message, $context = array())
+        {
+            return \Monolog\Logger::error($message, $context);
         }
         
         /**
-         * Get the user resolver callback.
+         * Adds a log record at the CRITICAL level.
          *
-         * @return \Closure 
+         * @param string $message The log message
+         * @param array $context The log context
+         * @return Boolean Whether the record has been processed
          * @static 
-         */
-        public static function getUserResolver(){
-            return \Illuminate\Http\Request::getUserResolver();
+         */ 
+        public static function critical($message, $context = array())
+        {
+            return \Monolog\Logger::critical($message, $context);
         }
         
         /**
-         * Set the user resolver callback.
+         * Adds a log record at the ALERT level.
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $message The log message
+         * @param array $context The log context
+         * @return Boolean Whether the record has been processed
          * @static 
-         */
-        public static function setUserResolver($callback){
-            return \Illuminate\Http\Request::setUserResolver($callback);
+         */ 
+        public static function alert($message, $context = array())
+        {
+            return \Monolog\Logger::alert($message, $context);
         }
         
         /**
-         * Get the route resolver callback.
+         * Adds a log record at the EMERGENCY level.
          *
-         * @return \Closure 
+         * @param string $message The log message
+         * @param array $context The log context
+         * @return Boolean Whether the record has been processed
          * @static 
-         */
-        public static function getRouteResolver(){
-            return \Illuminate\Http\Request::getRouteResolver();
+         */ 
+        public static function emergency($message, $context = array())
+        {
+            return \Monolog\Logger::emergency($message, $context);
         }
         
         /**
-         * Set the route resolver callback.
+         * Create a new, on-demand aggregate logger instance.
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @param array $channels
+         * @param string|null $channel
+         * @return \Psr\Log\LoggerInterface 
          * @static 
-         */
-        public static function setRouteResolver($callback){
-            return \Illuminate\Http\Request::setRouteResolver($callback);
+         */ 
+        public static function stack($channels, $channel = null)
+        {
+            return \Illuminate\Log\LogManager::stack($channels, $channel);
         }
         
         /**
-         * Get all of the input and files for the request.
+         * Get a log channel instance.
          *
-         * @return array 
+         * @param string|null $channel
+         * @return mixed 
          * @static 
-         */
-        public static function toArray(){
-            return \Illuminate\Http\Request::toArray();
+         */ 
+        public static function channel($channel = null)
+        {
+            return \Illuminate\Log\LogManager::channel($channel);
         }
         
         /**
-         * Determine if the given offset exists.
+         * Get a log driver instance.
          *
-         * @param string $offset
-         * @return bool 
+         * @param string|null $driver
+         * @return mixed 
          * @static 
-         */
-        public static function offsetExists($offset){
-            return \Illuminate\Http\Request::offsetExists($offset);
+         */ 
+        public static function driver($driver = null)
+        {
+            return \Illuminate\Log\LogManager::driver($driver);
         }
         
         /**
-         * Get the value at the given offset.
+         * Get the default log driver name.
          *
-         * @param string $offset
-         * @return mixed 
+         * @return string 
          * @static 
-         */
-        public static function offsetGet($offset){
-            return \Illuminate\Http\Request::offsetGet($offset);
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \Illuminate\Log\LogManager::getDefaultDriver();
         }
         
         /**
-         * Set the value at the given offset.
+         * Set the default log driver name.
          *
-         * @param string $offset
-         * @param mixed $value
+         * @param string $name
          * @return void 
          * @static 
-         */
-        public static function offsetSet($offset, $value){
-            \Illuminate\Http\Request::offsetSet($offset, $value);
+         */ 
+        public static function setDefaultDriver($name)
+        {
+            \Illuminate\Log\LogManager::setDefaultDriver($name);
         }
         
         /**
-         * Remove the value at the given offset.
+         * Register a custom driver creator Closure.
          *
-         * @param string $offset
-         * @return void 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function offsetUnset($offset){
-            \Illuminate\Http\Request::offsetUnset($offset);
+         */ 
+        public static function extend($driver, $callback)
+        {
+            return \Illuminate\Log\LogManager::extend($driver, $callback);
         }
         
         /**
-         * Sets the parameters for this request.
-         * 
-         * This method also re-initializes all properties.
+         * Logs with an arbitrary level.
          *
-         * @param array $query The GET parameters
-         * @param array $request The POST parameters
-         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
-         * @param array $cookies The COOKIE parameters
-         * @param array $files The FILES parameters
-         * @param array $server The SERVER parameters
-         * @param string|resource $content The raw body data
+         * @param mixed $level
+         * @param string $message
+         * @param array $context
+         * @return void 
          * @static 
-         */
-        public static function initialize($query = array(), $request = array(), $attributes = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::initialize($query, $request, $attributes, $cookies, $files, $server, $content);
+         */ 
+        public static function log($level, $message, $context = array())
+        {
+            \Illuminate\Log\LogManager::log($level, $message, $context);
         }
+         
+    }
+
+    class Mail {
         
         /**
-         * Creates a new request with values from PHP's super globals.
+         * Set the global from address and name.
          *
-         * @return static 
+         * @param string $address
+         * @param string|null $name
+         * @return void 
          * @static 
-         */
-        public static function createFromGlobals(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::createFromGlobals();
+         */ 
+        public static function alwaysFrom($address, $name = null)
+        {
+            \Illuminate\Mail\Mailer::alwaysFrom($address, $name);
         }
         
         /**
-         * Creates a Request based on a given URI and configuration.
-         * 
-         * The information contained in the URI always take precedence
-         * over the other information (server and parameters).
+         * Set the global reply-to address and name.
          *
-         * @param string $uri The URI
-         * @param string $method The HTTP method
-         * @param array $parameters The query (GET) or request (POST) parameters
-         * @param array $cookies The request cookies ($_COOKIE)
-         * @param array $files The request files ($_FILES)
-         * @param array $server The server parameters ($_SERVER)
-         * @param string $content The raw body data
-         * @return static 
+         * @param string $address
+         * @param string|null $name
+         * @return void 
          * @static 
-         */
-        public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);
+         */ 
+        public static function alwaysReplyTo($address, $name = null)
+        {
+            \Illuminate\Mail\Mailer::alwaysReplyTo($address, $name);
         }
         
         /**
-         * Sets a callable able to create a Request instance.
-         * 
-         * This is mainly useful when you need to override the Request class
-         * to keep BC with an existing system. It should not be used for any
-         * other purpose.
+         * Set the global to address and name.
          *
-         * @param callable|null $callable A PHP callable
+         * @param string $address
+         * @param string|null $name
+         * @return void 
          * @static 
-         */
-        public static function setFactory($callable){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setFactory($callable);
+         */ 
+        public static function alwaysTo($address, $name = null)
+        {
+            \Illuminate\Mail\Mailer::alwaysTo($address, $name);
         }
         
         /**
-         * Overrides the PHP global variables according to this request instance.
-         * 
-         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.
-         * $_FILES is never overridden, see rfc1867
+         * Begin the process of mailing a mailable class instance.
          *
+         * @param mixed $users
+         * @return \Illuminate\Mail\PendingMail 
          * @static 
-         */
-        public static function overrideGlobals(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::overrideGlobals();
+         */ 
+        public static function to($users)
+        {
+            return \Illuminate\Mail\Mailer::to($users);
         }
         
         /**
-         * Sets a list of trusted proxies.
-         * 
-         * You should only list the reverse proxies that you manage directly.
+         * Begin the process of mailing a mailable class instance.
          *
-         * @param array $proxies A list of trusted proxies
-         * @param int $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies
-         * @throws \InvalidArgumentException When $trustedHeaderSet is invalid
+         * @param mixed $users
+         * @return \Illuminate\Mail\PendingMail 
          * @static 
-         */
-        public static function setTrustedProxies($proxies){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedProxies($proxies);
+         */ 
+        public static function bcc($users)
+        {
+            return \Illuminate\Mail\Mailer::bcc($users);
         }
         
         /**
-         * Gets the list of trusted proxies.
+         * Send a new message with only an HTML part.
          *
-         * @return array An array of trusted proxies
+         * @param string $html
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function getTrustedProxies(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedProxies();
+         */ 
+        public static function html($html, $callback)
+        {
+            \Illuminate\Mail\Mailer::html($html, $callback);
         }
         
         /**
-         * Gets the set of trusted headers from trusted proxies.
+         * Send a new message when only a raw text part.
          *
-         * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies
+         * @param string $text
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function getTrustedHeaderSet(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHeaderSet();
+         */ 
+        public static function raw($text, $callback)
+        {
+            \Illuminate\Mail\Mailer::raw($text, $callback);
         }
         
         /**
-         * Sets a list of trusted host patterns.
-         * 
-         * You should only list the hosts you manage using regexs.
+         * Send a new message when only a plain part.
          *
-         * @param array $hostPatterns A list of trusted host patterns
+         * @param string $view
+         * @param array $data
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function setTrustedHosts($hostPatterns){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedHosts($hostPatterns);
+         */ 
+        public static function plain($view, $data, $callback)
+        {
+            \Illuminate\Mail\Mailer::plain($view, $data, $callback);
         }
         
         /**
-         * Gets the list of trusted host patterns.
+         * Render the given message as a view.
          *
-         * @return array An array of trusted host patterns
+         * @param string|array $view
+         * @param array $data
+         * @return string 
          * @static 
-         */
-        public static function getTrustedHosts(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHosts();
+         */ 
+        public static function render($view, $data = array())
+        {
+            return \Illuminate\Mail\Mailer::render($view, $data);
         }
         
         /**
-         * Sets the name for trusted headers.
-         * 
-         * The following header keys are supported:
-         * 
-         *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())
-         *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())
-         *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())
-         *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())
-         *  * Request::HEADER_FORWARDED:    defaults to Forwarded         (see RFC 7239)
-         * 
-         * Setting an empty value allows to disable the trusted header for the given key.
+         * Send a new message using a view.
          *
-         * @param string $key The header key
-         * @param string $value The header name
-         * @throws \InvalidArgumentException
-         * @deprecated since version 3.3, to be removed in 4.0. Use the $trustedHeaderSet argument of the Request::setTrustedProxies() method instead.
+         * @param string|array|\Illuminate\Mail\MailableContract $view
+         * @param array $data
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function setTrustedHeaderName($key, $value){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedHeaderName($key, $value);
+         */ 
+        public static function send($view, $data = array(), $callback = null)
+        {
+            \Illuminate\Mail\Mailer::send($view, $data, $callback);
         }
         
         /**
-         * Gets the trusted proxy header name.
+         * Queue a new e-mail message for sending.
          *
-         * @param string $key The header key
-         * @return string The header name
-         * @throws \InvalidArgumentException
-         * @deprecated since version 3.3, to be removed in 4.0. Use the Request::getTrustedHeaderSet() method instead.
+         * @param string|array|\Illuminate\Mail\MailableContract $view
+         * @param string|null $queue
+         * @return mixed 
          * @static 
-         */
-        public static function getTrustedHeaderName($key){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHeaderName($key);
+         */ 
+        public static function queue($view, $queue = null)
+        {
+            return \Illuminate\Mail\Mailer::queue($view, $queue);
         }
         
         /**
-         * Normalizes a query string.
-         * 
-         * It builds a normalized query string, where keys/value pairs are alphabetized,
-         * have consistent escaping and unneeded delimiters are removed.
+         * Queue a new e-mail message for sending on the given queue.
          *
-         * @param string $qs Query string
-         * @return string A normalized query string for the Request
+         * @param string $queue
+         * @param string|array $view
+         * @return mixed 
          * @static 
-         */
-        public static function normalizeQueryString($qs){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::normalizeQueryString($qs);
+         */ 
+        public static function onQueue($queue, $view)
+        {
+            return \Illuminate\Mail\Mailer::onQueue($queue, $view);
         }
         
         /**
-         * Enables support for the _method request parameter to determine the intended HTTP method.
-         * 
-         * Be warned that enabling this feature might lead to CSRF issues in your code.
-         * Check that you are using CSRF tokens when required.
-         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered
-         * and used to send a "PUT" or "DELETE" request via the _method request parameter.
-         * If these methods are not protected against CSRF, this presents a possible vulnerability.
+         * Queue a new e-mail message for sending on the given queue.
          * 
-         * The HTTP method can only be overridden when the real HTTP method is POST.
+         * This method didn't match rest of framework's "onQueue" phrasing. Added "onQueue".
          *
+         * @param string $queue
+         * @param string|array $view
+         * @return mixed 
          * @static 
-         */
-        public static function enableHttpMethodParameterOverride(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::enableHttpMethodParameterOverride();
+         */ 
+        public static function queueOn($queue, $view)
+        {
+            return \Illuminate\Mail\Mailer::queueOn($queue, $view);
         }
         
         /**
-         * Checks whether support for the _method request parameter is enabled.
+         * Queue a new e-mail message for sending after (n) seconds.
          *
-         * @return bool True when the _method request parameter is enabled, false otherwise
+         * @param \DateTimeInterface|\DateInterval|int $delay
+         * @param string|array|\Illuminate\Mail\MailableContract $view
+         * @param string|null $queue
+         * @return mixed 
          * @static 
-         */
-        public static function getHttpMethodParameterOverride(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHttpMethodParameterOverride();
+         */ 
+        public static function later($delay, $view, $queue = null)
+        {
+            return \Illuminate\Mail\Mailer::later($delay, $view, $queue);
         }
         
         /**
-         * Gets a "parameter" value from any bag.
-         * 
-         * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the
-         * flexibility in controllers, it is better to explicitly get request parameters from the appropriate
-         * public property instead (attributes, query, request).
-         * 
-         * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY
+         * Queue a new e-mail message for sending after (n) seconds on the given queue.
          *
-         * @param string $key the key
-         * @param mixed $default the default value if the parameter key does not exist
+         * @param string $queue
+         * @param \DateTimeInterface|\DateInterval|int $delay
+         * @param string|array $view
          * @return mixed 
          * @static 
-         */
-        public static function get($key, $default = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::get($key, $default);
+         */ 
+        public static function laterOn($queue, $delay, $view)
+        {
+            return \Illuminate\Mail\Mailer::laterOn($queue, $delay, $view);
         }
         
         /**
-         * Gets the Session.
+         * Get the view factory instance.
          *
-         * @return \Symfony\Component\HttpFoundation\SessionInterface|null The session
+         * @return \Illuminate\Contracts\View\Factory 
          * @static 
-         */
-        public static function getSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getSession();
+         */ 
+        public static function getViewFactory()
+        {
+            return \Illuminate\Mail\Mailer::getViewFactory();
         }
         
         /**
-         * Whether the request contains a Session which was started in one of the
-         * previous requests.
+         * Get the Swift Mailer instance.
          *
-         * @return bool 
+         * @return \Swift_Mailer 
          * @static 
-         */
-        public static function hasPreviousSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::hasPreviousSession();
+         */ 
+        public static function getSwiftMailer()
+        {
+            return \Illuminate\Mail\Mailer::getSwiftMailer();
         }
         
         /**
-         * Whether the request contains a Session object.
-         * 
-         * This method does not give any information about the state of the session object,
-         * like whether the session is started or not. It is just a way to check if this Request
-         * is associated with a Session instance.
+         * Get the array of failed recipients.
          *
-         * @return bool true when the Request contains a Session object, false otherwise
+         * @return array 
          * @static 
-         */
-        public static function hasSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::hasSession();
+         */ 
+        public static function failures()
+        {
+            return \Illuminate\Mail\Mailer::failures();
         }
         
         /**
-         * Sets the Session.
+         * Set the Swift Mailer instance.
          *
-         * @param \Symfony\Component\HttpFoundation\SessionInterface $session The Session
+         * @param \Swift_Mailer $swift
+         * @return void 
          * @static 
-         */
-        public static function setSession($session){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setSession($session);
+         */ 
+        public static function setSwiftMailer($swift)
+        {
+            \Illuminate\Mail\Mailer::setSwiftMailer($swift);
         }
         
         /**
-         * Returns the client IP addresses.
-         * 
-         * In the returned array the most trusted IP address is first, and the
-         * least trusted one last. The "real" client IP address is the last one,
-         * but this is also the least trusted one. Trusted proxies are stripped.
-         * 
-         * Use this method carefully; you should use getClientIp() instead.
+         * Set the queue manager instance.
          *
-         * @return array The client IP addresses
-         * @see getClientIp()
+         * @param \Illuminate\Contracts\Queue\Factory $queue
+         * @return $this 
          * @static 
-         */
-        public static function getClientIps(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getClientIps();
+         */ 
+        public static function setQueue($queue)
+        {
+            return \Illuminate\Mail\Mailer::setQueue($queue);
         }
         
         /**
-         * Returns the client IP address.
-         * 
-         * This method can read the client IP address from the "X-Forwarded-For" header
-         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"
-         * header value is a comma+space separated list of IP addresses, the left-most
-         * being the original client, and each successive proxy that passed the request
-         * adding the IP address where it received the request from.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-For",
-         * ("Client-Ip" for instance), configure it via the $trustedHeaderSet
-         * argument of the Request::setTrustedProxies() method instead.
+         * Register a custom macro.
          *
-         * @return string|null The client IP address
-         * @see getClientIps()
-         * @see http://en.wikipedia.org/wiki/X-Forwarded-For
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function getClientIp(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getClientIp();
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Mail\Mailer::macro($name, $macro);
         }
         
         /**
-         * Returns current script name.
+         * Mix another object into the class.
          *
-         * @return string 
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function getScriptName(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getScriptName();
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Mail\Mailer::mixin($mixin);
         }
         
         /**
-         * Returns the path being requested relative to the executed script.
-         * 
-         * The path info always starts with a /.
-         * 
-         * Suppose this request is instantiated from /mysite on localhost:
-         * 
-         *  * http://localhost/mysite              returns an empty string
-         *  * http://localhost/mysite/about        returns '/about'
-         *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'
-         *  * http://localhost/mysite/about?var=1  returns '/about'
+         * Checks if macro is registered.
          *
-         * @return string The raw path (i.e. not urldecoded)
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function getPathInfo(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPathInfo();
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Mail\Mailer::hasMacro($name);
         }
+         
+    }
+
+    class Password {
         
         /**
-         * Returns the root path from which this request is executed.
-         * 
-         * Suppose that an index.php file instantiates this request object:
-         * 
-         *  * http://localhost/index.php         returns an empty string
-         *  * http://localhost/index.php/page    returns an empty string
-         *  * http://localhost/web/index.php     returns '/web'
-         *  * http://localhost/we%20b/index.php  returns '/we%20b'
+         * Attempt to get the broker from the local cache.
          *
-         * @return string The raw path (i.e. not urldecoded)
+         * @param string $name
+         * @return \Illuminate\Contracts\Auth\PasswordBroker 
          * @static 
-         */
-        public static function getBasePath(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getBasePath();
+         */ 
+        public static function broker($name = null)
+        {
+            return \Illuminate\Auth\Passwords\PasswordBrokerManager::broker($name);
         }
         
         /**
-         * Returns the root URL from which this request is executed.
-         * 
-         * The base URL never ends with a /.
-         * 
-         * This is similar to getBasePath(), except that it also includes the
-         * script filename (e.g. index.php) if one exists.
+         * Get the default password broker name.
          *
-         * @return string The raw URL (i.e. not urldecoded)
+         * @return string 
          * @static 
-         */
-        public static function getBaseUrl(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getBaseUrl();
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \Illuminate\Auth\Passwords\PasswordBrokerManager::getDefaultDriver();
         }
         
         /**
-         * Gets the request's scheme.
+         * Set the default password broker name.
          *
-         * @return string 
+         * @param string $name
+         * @return void 
          * @static 
-         */
-        public static function getScheme(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getScheme();
+         */ 
+        public static function setDefaultDriver($name)
+        {
+            \Illuminate\Auth\Passwords\PasswordBrokerManager::setDefaultDriver($name);
         }
+         
+    }
+
+    class Queue {
         
         /**
-         * Returns the port on which the request is made.
-         * 
-         * This method can read the client port from the "X-Forwarded-Port" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Port" header must contain the client port.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Port",
-         * configure it via via the $trustedHeaderSet argument of the
-         * Request::setTrustedProxies() method instead.
+         * Register an event listener for the before job event.
          *
-         * @return int|string can be a string if fetched from the server bag
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function getPort(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPort();
+         */ 
+        public static function before($callback)
+        {
+            \Illuminate\Queue\QueueManager::before($callback);
         }
         
         /**
-         * Returns the user.
+         * Register an event listener for the after job event.
          *
-         * @return string|null 
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function getUser(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUser();
+         */ 
+        public static function after($callback)
+        {
+            \Illuminate\Queue\QueueManager::after($callback);
         }
         
         /**
-         * Returns the password.
+         * Register an event listener for the exception occurred job event.
          *
-         * @return string|null 
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function getPassword(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPassword();
+         */ 
+        public static function exceptionOccurred($callback)
+        {
+            \Illuminate\Queue\QueueManager::exceptionOccurred($callback);
         }
         
         /**
-         * Gets the user info.
+         * Register an event listener for the daemon queue loop.
          *
-         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function getUserInfo(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUserInfo();
+         */ 
+        public static function looping($callback)
+        {
+            \Illuminate\Queue\QueueManager::looping($callback);
         }
         
         /**
-         * Returns the HTTP host being requested.
-         * 
-         * The port name will be appended to the host if it's non-standard.
+         * Register an event listener for the failed job event.
          *
-         * @return string 
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function getHttpHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHttpHost();
+         */ 
+        public static function failing($callback)
+        {
+            \Illuminate\Queue\QueueManager::failing($callback);
         }
         
         /**
-         * Returns the requested URI (path and query string).
+         * Register an event listener for the daemon queue stopping.
          *
-         * @return string The raw URI (i.e. not URI decoded)
+         * @param mixed $callback
+         * @return void 
          * @static 
-         */
-        public static function getRequestUri(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRequestUri();
+         */ 
+        public static function stopping($callback)
+        {
+            \Illuminate\Queue\QueueManager::stopping($callback);
         }
         
         /**
-         * Gets the scheme and HTTP host.
-         * 
-         * If the URL was called with basic authentication, the user
-         * and the password are not added to the generated string.
+         * Determine if the driver is connected.
          *
-         * @return string The scheme and HTTP host
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function getSchemeAndHttpHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getSchemeAndHttpHost();
+         */ 
+        public static function connected($name = null)
+        {
+            return \Illuminate\Queue\QueueManager::connected($name);
         }
         
         /**
-         * Generates a normalized URI (URL) for the Request.
+         * Resolve a queue connection instance.
          *
-         * @return string A normalized URI (URL) for the Request
-         * @see getQueryString()
+         * @param string $name
+         * @return \Illuminate\Contracts\Queue\Queue 
          * @static 
-         */
-        public static function getUri(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUri();
+         */ 
+        public static function connection($name = null)
+        {
+            return \Illuminate\Queue\QueueManager::connection($name);
         }
         
         /**
-         * Generates a normalized URI for the given path.
+         * Add a queue connection resolver.
          *
-         * @param string $path A path to use instead of the current one
-         * @return string The normalized URI for the path
+         * @param string $driver
+         * @param \Closure $resolver
+         * @return void 
          * @static 
-         */
-        public static function getUriForPath($path){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUriForPath($path);
+         */ 
+        public static function extend($driver, $resolver)
+        {
+            \Illuminate\Queue\QueueManager::extend($driver, $resolver);
         }
         
         /**
-         * Returns the path as relative reference from the current Request path.
-         * 
-         * Only the URIs path component (no schema, host etc.) is relevant and must be given.
-         * Both paths must be absolute and not contain relative parts.
-         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.
-         * Furthermore, they can be used to reduce the link size in documents.
-         * 
-         * Example target paths, given a base path of "/a/b/c/d":
-         * - "/a/b/c/d"     -> ""
-         * - "/a/b/c/"      -> "./"
-         * - "/a/b/"        -> "../"
-         * - "/a/b/c/other" -> "other"
-         * - "/a/x/y"       -> "../../x/y"
+         * Add a queue connection resolver.
          *
-         * @param string $path The target path
-         * @return string The relative target path
+         * @param string $driver
+         * @param \Closure $resolver
+         * @return void 
          * @static 
-         */
-        public static function getRelativeUriForPath($path){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRelativeUriForPath($path);
+         */ 
+        public static function addConnector($driver, $resolver)
+        {
+            \Illuminate\Queue\QueueManager::addConnector($driver, $resolver);
         }
         
         /**
-         * Generates the normalized query string for the Request.
-         * 
-         * It builds a normalized query string, where keys/value pairs are alphabetized
-         * and have consistent escaping.
+         * Get the name of the default queue connection.
          *
-         * @return string|null A normalized query string for the Request
+         * @return string 
          * @static 
-         */
-        public static function getQueryString(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getQueryString();
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \Illuminate\Queue\QueueManager::getDefaultDriver();
         }
         
         /**
-         * Checks whether the request is secure or not.
-         * 
-         * This method can read the client protocol from the "X-Forwarded-Proto" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Proto"
-         * ("SSL_HTTPS" for instance), configure it via the $trustedHeaderSet
-         * argument of the Request::setTrustedProxies() method instead.
+         * Set the name of the default queue connection.
          *
-         * @return bool 
+         * @param string $name
+         * @return void 
          * @static 
-         */
-        public static function isSecure(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isSecure();
+         */ 
+        public static function setDefaultDriver($name)
+        {
+            \Illuminate\Queue\QueueManager::setDefaultDriver($name);
         }
         
         /**
-         * Returns the host name.
-         * 
-         * This method can read the client host name from the "X-Forwarded-Host" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Host" header must contain the client host name.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Host",
-         * configure it via the $trustedHeaderSet argument of the
-         * Request::setTrustedProxies() method instead.
+         * Get the full name for the given connection.
          *
+         * @param string $connection
          * @return string 
-         * @throws SuspiciousOperationException when the host name is invalid or not trusted
          * @static 
-         */
-        public static function getHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHost();
+         */ 
+        public static function getName($connection = null)
+        {
+            return \Illuminate\Queue\QueueManager::getName($connection);
         }
         
         /**
-         * Sets the request method.
+         * Determine if the application is in maintenance mode.
          *
-         * @param string $method
+         * @return bool 
          * @static 
-         */
-        public static function setMethod($method){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setMethod($method);
+         */ 
+        public static function isDownForMaintenance()
+        {
+            return \Illuminate\Queue\QueueManager::isDownForMaintenance();
         }
         
         /**
-         * Gets the request "intended" method.
-         * 
-         * If the X-HTTP-Method-Override header is set, and if the method is a POST,
-         * then it is used to determine the "real" intended HTTP method.
-         * 
-         * The _method request parameter can also be used to determine the HTTP method,
-         * but only if enableHttpMethodParameterOverride() has been called.
-         * 
-         * The method is always an uppercased string.
+         * Get the size of the queue.
          *
-         * @return string The request method
-         * @see getRealMethod()
+         * @param string $queue
+         * @return int 
          * @static 
-         */
-        public static function getMethod(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMethod();
+         */ 
+        public static function size($queue = null)
+        {
+            return \Illuminate\Queue\SyncQueue::size($queue);
         }
         
         /**
-         * Gets the "real" request method.
+         * Push a new job onto the queue.
          *
-         * @return string The request method
-         * @see getMethod()
+         * @param string $job
+         * @param mixed $data
+         * @param string $queue
+         * @return mixed 
+         * @throws \Exception|\Throwable
          * @static 
-         */
-        public static function getRealMethod(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRealMethod();
+         */ 
+        public static function push($job, $data = '', $queue = null)
+        {
+            return \Illuminate\Queue\SyncQueue::push($job, $data, $queue);
         }
         
         /**
-         * Gets the mime type associated with the format.
+         * Push a raw payload onto the queue.
          *
-         * @param string $format The format
-         * @return string The associated mime type (null if not found)
+         * @param string $payload
+         * @param string $queue
+         * @param array $options
+         * @return mixed 
          * @static 
-         */
-        public static function getMimeType($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMimeType($format);
+         */ 
+        public static function pushRaw($payload, $queue = null, $options = array())
+        {
+            return \Illuminate\Queue\SyncQueue::pushRaw($payload, $queue, $options);
         }
         
         /**
-         * Gets the mime types associated with the format.
+         * Push a new job onto the queue after a delay.
          *
-         * @param string $format The format
-         * @return array The associated mime types
+         * @param \DateTimeInterface|\DateInterval|int $delay
+         * @param string $job
+         * @param mixed $data
+         * @param string $queue
+         * @return mixed 
          * @static 
-         */
-        public static function getMimeTypes($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMimeTypes($format);
+         */ 
+        public static function later($delay, $job, $data = '', $queue = null)
+        {
+            return \Illuminate\Queue\SyncQueue::later($delay, $job, $data, $queue);
         }
         
         /**
-         * Gets the format associated with the mime type.
+         * Pop the next job off of the queue.
          *
-         * @param string $mimeType The associated mime type
-         * @return string|null The format (null if not found)
+         * @param string $queue
+         * @return \Illuminate\Contracts\Queue\Job|null 
          * @static 
-         */
-        public static function getFormat($mimeType){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getFormat($mimeType);
+         */ 
+        public static function pop($queue = null)
+        {
+            return \Illuminate\Queue\SyncQueue::pop($queue);
         }
         
         /**
-         * Associates a format with mime types.
+         * Push a new job onto the queue.
          *
-         * @param string $format The format
-         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)
+         * @param string $queue
+         * @param string $job
+         * @param mixed $data
+         * @return mixed 
          * @static 
-         */
-        public static function setFormat($format, $mimeTypes){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setFormat($format, $mimeTypes);
+         */ 
+        public static function pushOn($queue, $job, $data = '')
+        {
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::pushOn($queue, $job, $data);
         }
         
         /**
-         * Gets the request format.
-         * 
-         * Here is the process to determine the format:
-         * 
-         *  * format defined by the user (with setRequestFormat())
-         *  * _format request attribute
-         *  * $default
+         * Push a new job onto the queue after a delay.
          *
-         * @param string $default The default format
-         * @return string The request format
+         * @param string $queue
+         * @param \DateTimeInterface|\DateInterval|int $delay
+         * @param string $job
+         * @param mixed $data
+         * @return mixed 
          * @static 
-         */
-        public static function getRequestFormat($default = 'html'){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRequestFormat($default);
+         */ 
+        public static function laterOn($queue, $delay, $job, $data = '')
+        {
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::laterOn($queue, $delay, $job, $data);
         }
         
         /**
-         * Sets the request format.
+         * Push an array of jobs onto the queue.
          *
-         * @param string $format The request format
+         * @param array $jobs
+         * @param mixed $data
+         * @param string $queue
+         * @return mixed 
          * @static 
-         */
-        public static function setRequestFormat($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setRequestFormat($format);
+         */ 
+        public static function bulk($jobs, $data = '', $queue = null)
+        {
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::bulk($jobs, $data, $queue);
         }
         
         /**
-         * Gets the format associated with the request.
+         * Get the expiration timestamp for an object-based queue handler.
          *
-         * @return string|null The format (null if no content type is present)
+         * @param mixed $job
+         * @return mixed 
          * @static 
-         */
-        public static function getContentType(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getContentType();
+         */ 
+        public static function getJobExpiration($job)
+        {
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::getJobExpiration($job);
         }
         
         /**
-         * Sets the default locale.
+         * Get the connection name for the queue.
          *
-         * @param string $locale
+         * @return string 
          * @static 
-         */
-        public static function setDefaultLocale($locale){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setDefaultLocale($locale);
+         */ 
+        public static function getConnectionName()
+        {
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::getConnectionName();
         }
         
         /**
-         * Get the default locale.
+         * Set the connection name for the queue.
          *
-         * @return string 
+         * @param string $name
+         * @return $this 
          * @static 
-         */
-        public static function getDefaultLocale(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getDefaultLocale();
+         */ 
+        public static function setConnectionName($name)
+        {
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::setConnectionName($name);
         }
         
         /**
-         * Sets the locale.
+         * Set the IoC container instance.
          *
-         * @param string $locale
+         * @param \Illuminate\Container\Container $container
+         * @return void 
          * @static 
-         */
-        public static function setLocale($locale){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setLocale($locale);
+         */ 
+        public static function setContainer($container)
+        {
+            //Method inherited from \Illuminate\Queue\Queue            
+            \Illuminate\Queue\SyncQueue::setContainer($container);
         }
+         
+    }
+
+    class Redirect {
         
         /**
-         * Get the locale.
+         * Create a new redirect response to the "home" route.
          *
-         * @return string 
+         * @param int $status
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function getLocale(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getLocale();
+         */ 
+        public static function home($status = 302)
+        {
+            return \Illuminate\Routing\Redirector::home($status);
         }
         
         /**
-         * Checks if the request method is of specified type.
+         * Create a new redirect response to the previous location.
          *
-         * @param string $method Uppercase request method (GET, POST etc)
-         * @return bool 
+         * @param int $status
+         * @param array $headers
+         * @param mixed $fallback
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function isMethod($method){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethod($method);
+         */ 
+        public static function back($status = 302, $headers = array(), $fallback = false)
+        {
+            return \Illuminate\Routing\Redirector::back($status, $headers, $fallback);
         }
         
         /**
-         * Checks whether or not the method is safe.
+         * Create a new redirect response to the current URI.
          *
-         * @see https://tools.ietf.org/html/rfc7231#section-4.2.1
-         * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.
-         * @return bool 
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function isMethodSafe(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethodSafe();
+         */ 
+        public static function refresh($status = 302, $headers = array())
+        {
+            return \Illuminate\Routing\Redirector::refresh($status, $headers);
         }
         
         /**
-         * Checks whether or not the method is idempotent.
+         * Create a new redirect response, while putting the current URL in the session.
          *
-         * @return bool 
+         * @param string $path
+         * @param int $status
+         * @param array $headers
+         * @param bool $secure
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function isMethodIdempotent(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethodIdempotent();
+         */ 
+        public static function guest($path, $status = 302, $headers = array(), $secure = null)
+        {
+            return \Illuminate\Routing\Redirector::guest($path, $status, $headers, $secure);
         }
         
         /**
-         * Checks whether the method is cacheable or not.
+         * Create a new redirect response to the previously intended location.
          *
-         * @see https://tools.ietf.org/html/rfc7231#section-4.2.3
-         * @return bool 
+         * @param string $default
+         * @param int $status
+         * @param array $headers
+         * @param bool $secure
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function isMethodCacheable(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethodCacheable();
+         */ 
+        public static function intended($default = '/', $status = 302, $headers = array(), $secure = null)
+        {
+            return \Illuminate\Routing\Redirector::intended($default, $status, $headers, $secure);
         }
         
         /**
-         * Returns the request body content.
+         * Create a new redirect response to the given path.
          *
-         * @param bool $asResource If true, a resource will be returned
-         * @return string|resource The request body content or a resource to read the body stream
-         * @throws \LogicException
+         * @param string $path
+         * @param int $status
+         * @param array $headers
+         * @param bool $secure
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function getContent($asResource = false){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getContent($asResource);
+         */ 
+        public static function to($path, $status = 302, $headers = array(), $secure = null)
+        {
+            return \Illuminate\Routing\Redirector::to($path, $status, $headers, $secure);
         }
         
         /**
-         * Gets the Etags.
+         * Create a new redirect response to an external URL (no validation).
          *
-         * @return array The entity tags
+         * @param string $path
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function getETags(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getETags();
+         */ 
+        public static function away($path, $status = 302, $headers = array())
+        {
+            return \Illuminate\Routing\Redirector::away($path, $status, $headers);
         }
         
         /**
-         * 
+         * Create a new redirect response to the given HTTPS path.
          *
-         * @return bool 
-         * @static 
-         */
-        public static function isNoCache(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isNoCache();
+         * @param string $path
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
+         * @static 
+         */ 
+        public static function secure($path, $status = 302, $headers = array())
+        {
+            return \Illuminate\Routing\Redirector::secure($path, $status, $headers);
         }
         
         /**
-         * Returns the preferred language.
+         * Create a new redirect response to a named route.
          *
-         * @param array $locales An array of ordered available locales
-         * @return string|null The preferred locale
+         * @param string $route
+         * @param array $parameters
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function getPreferredLanguage($locales = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPreferredLanguage($locales);
+         */ 
+        public static function route($route, $parameters = array(), $status = 302, $headers = array())
+        {
+            return \Illuminate\Routing\Redirector::route($route, $parameters, $status, $headers);
         }
         
         /**
-         * Gets a list of languages acceptable by the client browser.
+         * Create a new redirect response to a controller action.
          *
-         * @return array Languages ordered in the user browser preferences
+         * @param string $action
+         * @param array $parameters
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function getLanguages(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getLanguages();
+         */ 
+        public static function action($action, $parameters = array(), $status = 302, $headers = array())
+        {
+            return \Illuminate\Routing\Redirector::action($action, $parameters, $status, $headers);
         }
         
         /**
-         * Gets a list of charsets acceptable by the client browser.
+         * Get the URL generator instance.
          *
-         * @return array List of charsets in preferable order
+         * @return \Illuminate\Routing\UrlGenerator 
          * @static 
-         */
-        public static function getCharsets(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getCharsets();
+         */ 
+        public static function getUrlGenerator()
+        {
+            return \Illuminate\Routing\Redirector::getUrlGenerator();
         }
         
         /**
-         * Gets a list of encodings acceptable by the client browser.
+         * Set the active session store.
          *
-         * @return array List of encodings in preferable order
+         * @param \Illuminate\Session\Store $session
+         * @return void 
          * @static 
-         */
-        public static function getEncodings(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getEncodings();
+         */ 
+        public static function setSession($session)
+        {
+            \Illuminate\Routing\Redirector::setSession($session);
         }
         
         /**
-         * Gets a list of content types acceptable by the client browser.
+         * Register a custom macro.
          *
-         * @return array List of content types in preferable order
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function getAcceptableContentTypes(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getAcceptableContentTypes();
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Routing\Redirector::macro($name, $macro);
         }
         
         /**
-         * Returns true if the request is a XMLHttpRequest.
-         * 
-         * It works if your JavaScript library sets an X-Requested-With HTTP header.
-         * It is known to work with common JavaScript frameworks:
+         * Mix another object into the class.
          *
-         * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript
-         * @return bool true if the request is an XMLHttpRequest, false otherwise
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function isXmlHttpRequest(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isXmlHttpRequest();
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Routing\Redirector::mixin($mixin);
         }
         
         /**
-         * Indicates whether this request originated from a trusted proxy.
-         * 
-         * This can be useful to determine whether or not to trust the
-         * contents of a proxy-specific header.
+         * Checks if macro is registered.
          *
-         * @return bool true if the request came from a trusted proxy, false otherwise
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function isFromTrustedProxy(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isFromTrustedProxy();
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Routing\Redirector::hasMacro($name);
         }
+         
+    }
+
+    class Request {
         
         /**
-         * Determine if the given content types match.
+         * Create a new Illuminate HTTP request from server variables.
          *
-         * @param string $actual
-         * @param string $type
-         * @return bool 
+         * @return static 
          * @static 
-         */
-        public static function matchesType($actual, $type){
-            return \Illuminate\Http\Request::matchesType($actual, $type);
+         */ 
+        public static function capture()
+        {
+            return \Illuminate\Http\Request::capture();
         }
         
         /**
-         * Determine if the request is sending JSON.
+         * Return the Request instance.
          *
-         * @return bool 
+         * @return $this 
          * @static 
-         */
-        public static function isJson(){
-            return \Illuminate\Http\Request::isJson();
+         */ 
+        public static function instance()
+        {
+            return \Illuminate\Http\Request::instance();
         }
         
         /**
-         * Determine if the current request probably expects a JSON response.
+         * Get the request method.
          *
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function expectsJson(){
-            return \Illuminate\Http\Request::expectsJson();
+         */ 
+        public static function method()
+        {
+            return \Illuminate\Http\Request::method();
         }
         
         /**
-         * Determine if the current request is asking for JSON in return.
+         * Get the root URL for the application.
          *
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function wantsJson(){
-            return \Illuminate\Http\Request::wantsJson();
+         */ 
+        public static function root()
+        {
+            return \Illuminate\Http\Request::root();
         }
         
         /**
-         * Determines whether the current requests accepts a given content type.
+         * Get the URL (no query string) for the request.
          *
-         * @param string|array $contentTypes
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function accepts($contentTypes){
-            return \Illuminate\Http\Request::accepts($contentTypes);
+         */ 
+        public static function url()
+        {
+            return \Illuminate\Http\Request::url();
         }
         
         /**
-         * Return the most suitable content type from the given array based on content negotiation.
+         * Get the full URL for the request.
          *
-         * @param string|array $contentTypes
-         * @return string|null 
+         * @return string 
          * @static 
-         */
-        public static function prefers($contentTypes){
-            return \Illuminate\Http\Request::prefers($contentTypes);
+         */ 
+        public static function fullUrl()
+        {
+            return \Illuminate\Http\Request::fullUrl();
         }
         
         /**
-         * Determines whether a request accepts JSON.
+         * Get the full URL for the request with the added query string parameters.
          *
-         * @return bool 
+         * @param array $query
+         * @return string 
          * @static 
-         */
-        public static function acceptsJson(){
-            return \Illuminate\Http\Request::acceptsJson();
+         */ 
+        public static function fullUrlWithQuery($query)
+        {
+            return \Illuminate\Http\Request::fullUrlWithQuery($query);
         }
         
         /**
-         * Determines whether a request accepts HTML.
+         * Get the current path info for the request.
          *
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function acceptsHtml(){
-            return \Illuminate\Http\Request::acceptsHtml();
+         */ 
+        public static function path()
+        {
+            return \Illuminate\Http\Request::path();
         }
         
         /**
-         * Get the data format expected in the response.
+         * Get the current decoded path info for the request.
          *
-         * @param string $default
          * @return string 
          * @static 
-         */
-        public static function format($default = 'html'){
-            return \Illuminate\Http\Request::format($default);
+         */ 
+        public static function decodedPath()
+        {
+            return \Illuminate\Http\Request::decodedPath();
         }
         
         /**
-         * Retrieve an old input item.
+         * Get a segment from the URI (1 based index).
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param int $index
+         * @param string|null $default
+         * @return string|null 
          * @static 
-         */
-        public static function old($key = null, $default = null){
-            return \Illuminate\Http\Request::old($key, $default);
+         */ 
+        public static function segment($index, $default = null)
+        {
+            return \Illuminate\Http\Request::segment($index, $default);
         }
         
         /**
-         * Flash the input for the current request to the session.
+         * Get all of the segments for the request path.
          *
-         * @return void 
+         * @return array 
          * @static 
-         */
-        public static function flash(){
-            \Illuminate\Http\Request::flash();
+         */ 
+        public static function segments()
+        {
+            return \Illuminate\Http\Request::segments();
         }
         
         /**
-         * Flash only some of the input to the session.
+         * Determine if the current request URI matches a pattern.
          *
-         * @param array|mixed $keys
-         * @return void 
+         * @param mixed $patterns
+         * @return bool 
          * @static 
-         */
-        public static function flashOnly($keys){
-            \Illuminate\Http\Request::flashOnly($keys);
+         */ 
+        public static function is($patterns = null)
+        {
+            return \Illuminate\Http\Request::is($patterns);
         }
         
         /**
-         * Flash only some of the input to the session.
+         * Determine if the route name matches a given pattern.
          *
-         * @param array|mixed $keys
-         * @return void 
+         * @param mixed $patterns
+         * @return bool 
          * @static 
-         */
-        public static function flashExcept($keys){
-            \Illuminate\Http\Request::flashExcept($keys);
+         */ 
+        public static function routeIs($patterns = null)
+        {
+            return \Illuminate\Http\Request::routeIs($patterns);
         }
         
         /**
-         * Flush all of the old input from the session.
+         * Determine if the current request URL and query string matches a pattern.
          *
-         * @return void 
+         * @param mixed $patterns
+         * @return bool 
          * @static 
-         */
-        public static function flush(){
-            \Illuminate\Http\Request::flush();
+         */ 
+        public static function fullUrlIs($patterns = null)
+        {
+            return \Illuminate\Http\Request::fullUrlIs($patterns);
         }
         
         /**
-         * Retrieve a server variable from the request.
+         * Determine if the request is the result of an AJAX call.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return bool 
          * @static 
-         */
-        public static function server($key = null, $default = null){
-            return \Illuminate\Http\Request::server($key, $default);
+         */ 
+        public static function ajax()
+        {
+            return \Illuminate\Http\Request::ajax();
         }
         
         /**
-         * Determine if a header is set on the request.
+         * Determine if the request is the result of an PJAX call.
          *
-         * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function hasHeader($key){
-            return \Illuminate\Http\Request::hasHeader($key);
+         */ 
+        public static function pjax()
+        {
+            return \Illuminate\Http\Request::pjax();
         }
         
         /**
-         * Retrieve a header from the request.
+         * Determine if the request is over HTTPS.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return bool 
          * @static 
-         */
-        public static function header($key = null, $default = null){
-            return \Illuminate\Http\Request::header($key, $default);
+         */ 
+        public static function secure()
+        {
+            return \Illuminate\Http\Request::secure();
         }
         
         /**
-         * Get the bearer token from the request headers.
+         * Get the client IP address.
          *
-         * @return string|null 
+         * @return string 
          * @static 
-         */
-        public static function bearerToken(){
-            return \Illuminate\Http\Request::bearerToken();
+         */ 
+        public static function ip()
+        {
+            return \Illuminate\Http\Request::ip();
         }
         
         /**
-         * Determine if the request contains a given input item key.
+         * Get the client IP addresses.
          *
-         * @param string|array $key
-         * @return bool 
+         * @return array 
          * @static 
-         */
-        public static function exists($key){
-            return \Illuminate\Http\Request::exists($key);
+         */ 
+        public static function ips()
+        {
+            return \Illuminate\Http\Request::ips();
         }
         
         /**
-         * Determine if the request contains a non-empty value for an input item.
+         * Get the client user agent.
          *
-         * @param string|array $key
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function has($key){
-            return \Illuminate\Http\Request::has($key);
+         */ 
+        public static function userAgent()
+        {
+            return \Illuminate\Http\Request::userAgent();
         }
         
         /**
-         * Get all of the input and files for the request.
+         * Merge new input into the current request's input array.
          *
-         * @return array 
+         * @param array $input
+         * @return \Illuminate\Http\Request 
          * @static 
-         */
-        public static function all(){
-            return \Illuminate\Http\Request::all();
+         */ 
+        public static function merge($input)
+        {
+            return \Illuminate\Http\Request::merge($input);
         }
         
         /**
-         * Retrieve an input item from the request.
+         * Replace the input for the current request.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param array $input
+         * @return \Illuminate\Http\Request 
          * @static 
-         */
-        public static function input($key = null, $default = null){
-            return \Illuminate\Http\Request::input($key, $default);
+         */ 
+        public static function replace($input)
+        {
+            return \Illuminate\Http\Request::replace($input);
         }
         
         /**
-         * Get a subset containing the provided keys with values from the input data.
+         * Get the JSON payload for the request.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param string $key
+         * @param mixed $default
+         * @return \Symfony\Component\HttpFoundation\ParameterBag|mixed 
          * @static 
-         */
-        public static function only($keys){
-            return \Illuminate\Http\Request::only($keys);
+         */ 
+        public static function json($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::json($key, $default);
         }
         
         /**
-         * Get all of the input except for a specified array of items.
+         * Create a new request instance from the given Laravel request.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param \Illuminate\Http\Request $from
+         * @param \Illuminate\Http\Request|null $to
+         * @return static 
          * @static 
-         */
-        public static function except($keys){
-            return \Illuminate\Http\Request::except($keys);
+         */ 
+        public static function createFrom($from, $to = null)
+        {
+            return \Illuminate\Http\Request::createFrom($from, $to);
         }
         
         /**
-         * Intersect an array of items with the input data.
+         * Create an Illuminate request from a Symfony instance.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @return \Illuminate\Http\Request 
          * @static 
-         */
-        public static function intersect($keys){
-            return \Illuminate\Http\Request::intersect($keys);
+         */ 
+        public static function createFromBase($request)
+        {
+            return \Illuminate\Http\Request::createFromBase($request);
         }
         
         /**
-         * Retrieve a query string item from the request.
+         * Clones a request and overrides some of its parameters.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param array $query The GET parameters
+         * @param array $request The POST parameters
+         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
+         * @param array $cookies The COOKIE parameters
+         * @param array $files The FILES parameters
+         * @param array $server The SERVER parameters
+         * @return static 
          * @static 
-         */
-        public static function query($key = null, $default = null){
-            return \Illuminate\Http\Request::query($key, $default);
+         */ 
+        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null)
+        {
+            return \Illuminate\Http\Request::duplicate($query, $request, $attributes, $cookies, $files, $server);
         }
         
         /**
-         * Determine if a cookie is set on the request.
+         * Get the session associated with the request.
          *
-         * @param string $key
-         * @return bool 
+         * @return \Illuminate\Session\Store 
+         * @throws \RuntimeException
          * @static 
-         */
-        public static function hasCookie($key){
-            return \Illuminate\Http\Request::hasCookie($key);
+         */ 
+        public static function session()
+        {
+            return \Illuminate\Http\Request::session();
         }
         
         /**
-         * Retrieve a cookie from the request.
+         * Get the session associated with the request.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return \Illuminate\Session\Store|null 
          * @static 
-         */
-        public static function cookie($key = null, $default = null){
-            return \Illuminate\Http\Request::cookie($key, $default);
+         */ 
+        public static function getSession()
+        {
+            return \Illuminate\Http\Request::getSession();
         }
         
         /**
-         * Get an array of all of the files on the request.
+         * Set the session instance on the request.
          *
-         * @return array 
+         * @param \Illuminate\Contracts\Session\Session $session
+         * @return void 
          * @static 
-         */
-        public static function allFiles(){
-            return \Illuminate\Http\Request::allFiles();
+         */ 
+        public static function setLaravelSession($session)
+        {
+            \Illuminate\Http\Request::setLaravelSession($session);
         }
         
         /**
-         * Determine if the uploaded data contains a file.
+         * Get the user making the request.
          *
-         * @param string $key
-         * @return bool 
+         * @param string|null $guard
+         * @return mixed 
          * @static 
-         */
-        public static function hasFile($key){
-            return \Illuminate\Http\Request::hasFile($key);
+         */ 
+        public static function user($guard = null)
+        {
+            return \Illuminate\Http\Request::user($guard);
         }
         
         /**
-         * Retrieve a file from the request.
+         * Get the route handling the request.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return \Illuminate\Http\UploadedFile|array|null 
+         * @param string|null $param
+         * @return \Illuminate\Routing\Route|object|string 
          * @static 
-         */
-        public static function file($key = null, $default = null){
-            return \Illuminate\Http\Request::file($key, $default);
+         */ 
+        public static function route($param = null)
+        {
+            return \Illuminate\Http\Request::route($param);
         }
         
         /**
-         * Register a custom macro.
+         * Get a unique fingerprint for the request / route / IP address.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @return string 
+         * @throws \RuntimeException
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Http\Request::macro($name, $macro);
+         */ 
+        public static function fingerprint()
+        {
+            return \Illuminate\Http\Request::fingerprint();
         }
         
         /**
-         * Checks if macro is registered.
+         * Set the JSON payload for the request.
          *
-         * @param string $name
-         * @return bool 
+         * @param \Symfony\Component\HttpFoundation\ParameterBag $json
+         * @return $this 
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Http\Request::hasMacro($name);
+         */ 
+        public static function setJson($json)
+        {
+            return \Illuminate\Http\Request::setJson($json);
         }
         
-    }
-
-
-    class Inspiring extends \Illuminate\Foundation\Inspiring{
-        
-    }
-
-
-    class Lang extends \Illuminate\Support\Facades\Lang{
-        
         /**
-         * Determine if a translation exists for a given locale.
+         * Get the user resolver callback.
          *
-         * @param string $key
-         * @param string|null $locale
-         * @return bool 
+         * @return \Closure 
          * @static 
-         */
-        public static function hasForLocale($key, $locale = null){
-            return \Illuminate\Translation\Translator::hasForLocale($key, $locale);
+         */ 
+        public static function getUserResolver()
+        {
+            return \Illuminate\Http\Request::getUserResolver();
         }
         
         /**
-         * Determine if a translation exists.
+         * Set the user resolver callback.
          *
-         * @param string $key
-         * @param string|null $locale
-         * @param bool $fallback
-         * @return bool 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function has($key, $locale = null, $fallback = true){
-            return \Illuminate\Translation\Translator::has($key, $locale, $fallback);
+         */ 
+        public static function setUserResolver($callback)
+        {
+            return \Illuminate\Http\Request::setUserResolver($callback);
         }
         
         /**
-         * Get the translation for a given key.
+         * Get the route resolver callback.
          *
-         * @param string $key
-         * @param array $replace
-         * @param string $locale
-         * @return string|array|null 
+         * @return \Closure 
          * @static 
-         */
-        public static function trans($key, $replace = array(), $locale = null){
-            return \Illuminate\Translation\Translator::trans($key, $replace, $locale);
+         */ 
+        public static function getRouteResolver()
+        {
+            return \Illuminate\Http\Request::getRouteResolver();
         }
         
         /**
-         * Get the translation for the given key.
+         * Set the route resolver callback.
          *
-         * @param string $key
-         * @param array $replace
-         * @param string|null $locale
-         * @param bool $fallback
-         * @return string|array|null 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function get($key, $replace = array(), $locale = null, $fallback = true){
-            return \Illuminate\Translation\Translator::get($key, $replace, $locale, $fallback);
+         */ 
+        public static function setRouteResolver($callback)
+        {
+            return \Illuminate\Http\Request::setRouteResolver($callback);
         }
         
         /**
-         * Get the translation for a given key from the JSON translation files.
+         * Get all of the input and files for the request.
          *
-         * @param string $key
-         * @param array $replace
-         * @param string $locale
-         * @return string 
+         * @return array 
          * @static 
-         */
-        public static function getFromJson($key, $replace = array(), $locale = null){
-            return \Illuminate\Translation\Translator::getFromJson($key, $replace, $locale);
+         */ 
+        public static function toArray()
+        {
+            return \Illuminate\Http\Request::toArray();
         }
         
         /**
-         * Get a translation according to an integer value.
+         * Determine if the given offset exists.
          *
-         * @param string $key
-         * @param int|array|\Countable $number
-         * @param array $replace
-         * @param string $locale
-         * @return string 
+         * @param string $offset
+         * @return bool 
          * @static 
-         */
-        public static function transChoice($key, $number, $replace = array(), $locale = null){
-            return \Illuminate\Translation\Translator::transChoice($key, $number, $replace, $locale);
+         */ 
+        public static function offsetExists($offset)
+        {
+            return \Illuminate\Http\Request::offsetExists($offset);
         }
         
         /**
-         * Get a translation according to an integer value.
+         * Get the value at the given offset.
          *
-         * @param string $key
-         * @param int|array|\Countable $number
-         * @param array $replace
-         * @param string $locale
-         * @return string 
+         * @param string $offset
+         * @return mixed 
          * @static 
-         */
-        public static function choice($key, $number, $replace = array(), $locale = null){
-            return \Illuminate\Translation\Translator::choice($key, $number, $replace, $locale);
+         */ 
+        public static function offsetGet($offset)
+        {
+            return \Illuminate\Http\Request::offsetGet($offset);
         }
         
         /**
-         * Add translation lines to the given locale.
+         * Set the value at the given offset.
          *
-         * @param array $lines
-         * @param string $locale
-         * @param string $namespace
+         * @param string $offset
+         * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function addLines($lines, $locale, $namespace = '*'){
-            \Illuminate\Translation\Translator::addLines($lines, $locale, $namespace);
+         */ 
+        public static function offsetSet($offset, $value)
+        {
+            \Illuminate\Http\Request::offsetSet($offset, $value);
         }
         
         /**
-         * Load the specified language group.
+         * Remove the value at the given offset.
          *
-         * @param string $namespace
-         * @param string $group
-         * @param string $locale
+         * @param string $offset
          * @return void 
          * @static 
-         */
-        public static function load($namespace, $group, $locale){
-            \Illuminate\Translation\Translator::load($namespace, $group, $locale);
+         */ 
+        public static function offsetUnset($offset)
+        {
+            \Illuminate\Http\Request::offsetUnset($offset);
         }
         
         /**
-         * Add a new namespace to the loader.
+         * Sets the parameters for this request.
+         * 
+         * This method also re-initializes all properties.
          *
-         * @param string $namespace
-         * @param string $hint
-         * @return void 
+         * @param array $query The GET parameters
+         * @param array $request The POST parameters
+         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
+         * @param array $cookies The COOKIE parameters
+         * @param array $files The FILES parameters
+         * @param array $server The SERVER parameters
+         * @param string|resource|null $content The raw body data
          * @static 
-         */
-        public static function addNamespace($namespace, $hint){
-            \Illuminate\Translation\Translator::addNamespace($namespace, $hint);
+         */ 
+        public static function initialize($query = array(), $request = array(), $attributes = array(), $cookies = array(), $files = array(), $server = array(), $content = null)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::initialize($query, $request, $attributes, $cookies, $files, $server, $content);
         }
         
         /**
-         * Parse a key into namespace, group, and item.
+         * Creates a new request with values from PHP's super globals.
          *
-         * @param string $key
-         * @return array 
+         * @return static 
          * @static 
-         */
-        public static function parseKey($key){
-            return \Illuminate\Translation\Translator::parseKey($key);
+         */ 
+        public static function createFromGlobals()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::createFromGlobals();
         }
         
         /**
-         * Get the message selector instance.
+         * Creates a Request based on a given URI and configuration.
+         * 
+         * The information contained in the URI always take precedence
+         * over the other information (server and parameters).
          *
-         * @return \Illuminate\Translation\MessageSelector 
+         * @param string $uri The URI
+         * @param string $method The HTTP method
+         * @param array $parameters The query (GET) or request (POST) parameters
+         * @param array $cookies The request cookies ($_COOKIE)
+         * @param array $files The request files ($_FILES)
+         * @param array $server The server parameters ($_SERVER)
+         * @param string|resource|null $content The raw body data
+         * @return static 
          * @static 
-         */
-        public static function getSelector(){
-            return \Illuminate\Translation\Translator::getSelector();
+         */ 
+        public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);
         }
         
         /**
-         * Set the message selector instance.
+         * Sets a callable able to create a Request instance.
+         * 
+         * This is mainly useful when you need to override the Request class
+         * to keep BC with an existing system. It should not be used for any
+         * other purpose.
          *
-         * @param \Illuminate\Translation\MessageSelector $selector
-         * @return void 
+         * @param callable|null $callable A PHP callable
          * @static 
-         */
-        public static function setSelector($selector){
-            \Illuminate\Translation\Translator::setSelector($selector);
+         */ 
+        public static function setFactory($callable)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setFactory($callable);
         }
         
         /**
-         * Get the language line loader implementation.
+         * Overrides the PHP global variables according to this request instance.
+         * 
+         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.
+         * $_FILES is never overridden, see rfc1867
          *
-         * @return \Illuminate\Translation\LoaderInterface 
          * @static 
-         */
-        public static function getLoader(){
-            return \Illuminate\Translation\Translator::getLoader();
+         */ 
+        public static function overrideGlobals()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::overrideGlobals();
         }
         
         /**
-         * Get the default locale being used.
+         * Sets a list of trusted proxies.
+         * 
+         * You should only list the reverse proxies that you manage directly.
          *
-         * @return string 
+         * @param array $proxies A list of trusted proxies
+         * @param int $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies
+         * @throws \InvalidArgumentException When $trustedHeaderSet is invalid
          * @static 
-         */
-        public static function locale(){
-            return \Illuminate\Translation\Translator::locale();
+         */ 
+        public static function setTrustedProxies($proxies, $trustedHeaderSet)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedProxies($proxies, $trustedHeaderSet);
         }
         
         /**
-         * Get the default locale being used.
+         * Gets the list of trusted proxies.
          *
-         * @return string 
+         * @return array An array of trusted proxies
          * @static 
-         */
-        public static function getLocale(){
-            return \Illuminate\Translation\Translator::getLocale();
+         */ 
+        public static function getTrustedProxies()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedProxies();
         }
         
         /**
-         * Set the default locale.
+         * Gets the set of trusted headers from trusted proxies.
          *
-         * @param string $locale
-         * @return void 
+         * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies
          * @static 
-         */
-        public static function setLocale($locale){
-            \Illuminate\Translation\Translator::setLocale($locale);
+         */ 
+        public static function getTrustedHeaderSet()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHeaderSet();
         }
         
         /**
-         * Get the fallback locale being used.
+         * Sets a list of trusted host patterns.
+         * 
+         * You should only list the hosts you manage using regexs.
          *
-         * @return string 
+         * @param array $hostPatterns A list of trusted host patterns
          * @static 
-         */
-        public static function getFallback(){
-            return \Illuminate\Translation\Translator::getFallback();
+         */ 
+        public static function setTrustedHosts($hostPatterns)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedHosts($hostPatterns);
         }
         
         /**
-         * Set the fallback locale being used.
+         * Gets the list of trusted host patterns.
          *
-         * @param string $fallback
-         * @return void 
+         * @return array An array of trusted host patterns
          * @static 
-         */
-        public static function setFallback($fallback){
-            \Illuminate\Translation\Translator::setFallback($fallback);
+         */ 
+        public static function getTrustedHosts()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHosts();
         }
         
         /**
-         * Set the parsed value of a key.
+         * Normalizes a query string.
+         * 
+         * It builds a normalized query string, where keys/value pairs are alphabetized,
+         * have consistent escaping and unneeded delimiters are removed.
          *
-         * @param string $key
-         * @param array $parsed
-         * @return void 
+         * @param string $qs Query string
+         * @return string A normalized query string for the Request
          * @static 
-         */
-        public static function setParsedKey($key, $parsed){
-            //Method inherited from \Illuminate\Support\NamespacedItemResolver            
-            \Illuminate\Translation\Translator::setParsedKey($key, $parsed);
+         */ 
+        public static function normalizeQueryString($qs)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::normalizeQueryString($qs);
         }
         
         /**
-         * Register a custom macro.
-         *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
-         * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Translation\Translator::macro($name, $macro);
-        }
-        
-        /**
-         * Checks if macro is registered.
+         * Enables support for the _method request parameter to determine the intended HTTP method.
+         * 
+         * Be warned that enabling this feature might lead to CSRF issues in your code.
+         * Check that you are using CSRF tokens when required.
+         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered
+         * and used to send a "PUT" or "DELETE" request via the _method request parameter.
+         * If these methods are not protected against CSRF, this presents a possible vulnerability.
+         * 
+         * The HTTP method can only be overridden when the real HTTP method is POST.
          *
-         * @param string $name
-         * @return bool 
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Translation\Translator::hasMacro($name);
+         */ 
+        public static function enableHttpMethodParameterOverride()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::enableHttpMethodParameterOverride();
         }
         
-    }
-
-
-    class Log extends \Illuminate\Support\Facades\Log{
-        
         /**
-         * Adds a log record at the DEBUG level.
+         * Checks whether support for the _method request parameter is enabled.
          *
-         * @param string $message The log message
-         * @param array $context The log context
-         * @return Boolean Whether the record has been processed
+         * @return bool True when the _method request parameter is enabled, false otherwise
          * @static 
-         */
-        public static function debug($message, $context = array()){
-            return \Monolog\Logger::debug($message, $context);
+         */ 
+        public static function getHttpMethodParameterOverride()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getHttpMethodParameterOverride();
         }
         
         /**
-         * Adds a log record at the INFO level.
+         * Gets a "parameter" value from any bag.
+         * 
+         * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the
+         * flexibility in controllers, it is better to explicitly get request parameters from the appropriate
+         * public property instead (attributes, query, request).
+         * 
+         * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY
          *
-         * @param string $message The log message
-         * @param array $context The log context
-         * @return Boolean Whether the record has been processed
+         * @param string $key The key
+         * @param mixed $default The default value if the parameter key does not exist
+         * @return mixed 
          * @static 
-         */
-        public static function info($message, $context = array()){
-            return \Monolog\Logger::info($message, $context);
+         */ 
+        public static function get($key, $default = null)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::get($key, $default);
         }
         
         /**
-         * Adds a log record at the NOTICE level.
+         * Whether the request contains a Session which was started in one of the
+         * previous requests.
          *
-         * @param string $message The log message
-         * @param array $context The log context
-         * @return Boolean Whether the record has been processed
+         * @return bool 
          * @static 
-         */
-        public static function notice($message, $context = array()){
-            return \Monolog\Logger::notice($message, $context);
+         */ 
+        public static function hasPreviousSession()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::hasPreviousSession();
         }
         
         /**
-         * Adds a log record at the WARNING level.
+         * Whether the request contains a Session object.
+         * 
+         * This method does not give any information about the state of the session object,
+         * like whether the session is started or not. It is just a way to check if this Request
+         * is associated with a Session instance.
          *
-         * @param string $message The log message
-         * @param array $context The log context
-         * @return Boolean Whether the record has been processed
+         * @return bool true when the Request contains a Session object, false otherwise
          * @static 
-         */
-        public static function warning($message, $context = array()){
-            return \Monolog\Logger::warning($message, $context);
+         */ 
+        public static function hasSession()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::hasSession();
         }
         
         /**
-         * Adds a log record at the ERROR level.
+         * Sets the Session.
          *
-         * @param string $message The log message
-         * @param array $context The log context
-         * @return Boolean Whether the record has been processed
+         * @param \Symfony\Component\HttpFoundation\SessionInterface $session The Session
          * @static 
-         */
-        public static function error($message, $context = array()){
-            return \Monolog\Logger::error($message, $context);
+         */ 
+        public static function setSession($session)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setSession($session);
         }
         
         /**
-         * Adds a log record at the CRITICAL level.
+         * Returns the client IP addresses.
+         * 
+         * In the returned array the most trusted IP address is first, and the
+         * least trusted one last. The "real" client IP address is the last one,
+         * but this is also the least trusted one. Trusted proxies are stripped.
+         * 
+         * Use this method carefully; you should use getClientIp() instead.
          *
-         * @param string $message The log message
-         * @param array $context The log context
-         * @return Boolean Whether the record has been processed
+         * @return array The client IP addresses
+         * @see getClientIp()
          * @static 
-         */
-        public static function critical($message, $context = array()){
-            return \Monolog\Logger::critical($message, $context);
+         */ 
+        public static function getClientIps()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getClientIps();
         }
         
         /**
-         * Adds a log record at the ALERT level.
+         * Returns the client IP address.
+         * 
+         * This method can read the client IP address from the "X-Forwarded-For" header
+         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"
+         * header value is a comma+space separated list of IP addresses, the left-most
+         * being the original client, and each successive proxy that passed the request
+         * adding the IP address where it received the request from.
          *
-         * @param string $message The log message
-         * @param array $context The log context
-         * @return Boolean Whether the record has been processed
+         * @return string|null The client IP address
+         * @see getClientIps()
+         * @see http://en.wikipedia.org/wiki/X-Forwarded-For
          * @static 
-         */
-        public static function alert($message, $context = array()){
-            return \Monolog\Logger::alert($message, $context);
+         */ 
+        public static function getClientIp()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getClientIp();
         }
         
         /**
-         * Adds a log record at the EMERGENCY level.
+         * Returns current script name.
          *
-         * @param string $message The log message
-         * @param array $context The log context
-         * @return Boolean Whether the record has been processed
+         * @return string 
          * @static 
-         */
-        public static function emergency($message, $context = array()){
-            return \Monolog\Logger::emergency($message, $context);
+         */ 
+        public static function getScriptName()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getScriptName();
         }
         
         /**
-         * Log a message to the logs.
+         * Returns the path being requested relative to the executed script.
+         * 
+         * The path info always starts with a /.
+         * 
+         * Suppose this request is instantiated from /mysite on localhost:
+         * 
+         *  * http://localhost/mysite              returns an empty string
+         *  * http://localhost/mysite/about        returns '/about'
+         *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'
+         *  * http://localhost/mysite/about?var=1  returns '/about'
          *
-         * @param string $level
-         * @param string $message
-         * @param array $context
-         * @return void 
+         * @return string The raw path (i.e. not urldecoded)
          * @static 
-         */
-        public static function log($level, $message, $context = array()){
-            \Illuminate\Log\Writer::log($level, $message, $context);
+         */ 
+        public static function getPathInfo()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPathInfo();
         }
         
         /**
-         * Dynamically pass log calls into the writer.
+         * Returns the root path from which this request is executed.
+         * 
+         * Suppose that an index.php file instantiates this request object:
+         * 
+         *  * http://localhost/index.php         returns an empty string
+         *  * http://localhost/index.php/page    returns an empty string
+         *  * http://localhost/web/index.php     returns '/web'
+         *  * http://localhost/we%20b/index.php  returns '/we%20b'
          *
-         * @param string $level
-         * @param string $message
-         * @param array $context
-         * @return void 
+         * @return string The raw path (i.e. not urldecoded)
          * @static 
-         */
-        public static function write($level, $message, $context = array()){
-            \Illuminate\Log\Writer::write($level, $message, $context);
+         */ 
+        public static function getBasePath()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getBasePath();
         }
         
         /**
-         * Register a file log handler.
+         * Returns the root URL from which this request is executed.
+         * 
+         * The base URL never ends with a /.
+         * 
+         * This is similar to getBasePath(), except that it also includes the
+         * script filename (e.g. index.php) if one exists.
          *
-         * @param string $path
-         * @param string $level
-         * @return void 
+         * @return string The raw URL (i.e. not urldecoded)
          * @static 
-         */
-        public static function useFiles($path, $level = 'debug'){
-            \Illuminate\Log\Writer::useFiles($path, $level);
+         */ 
+        public static function getBaseUrl()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getBaseUrl();
         }
         
         /**
-         * Register a daily file log handler.
+         * Gets the request's scheme.
          *
-         * @param string $path
-         * @param int $days
-         * @param string $level
-         * @return void 
+         * @return string 
          * @static 
-         */
-        public static function useDailyFiles($path, $days = 0, $level = 'debug'){
-            \Illuminate\Log\Writer::useDailyFiles($path, $days, $level);
+         */ 
+        public static function getScheme()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getScheme();
         }
         
         /**
-         * Register a Syslog handler.
+         * Returns the port on which the request is made.
+         * 
+         * This method can read the client port from the "X-Forwarded-Port" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Port" header must contain the client port.
          *
-         * @param string $name
-         * @param string $level
-         * @param mixed $facility
-         * @return \Psr\Log\LoggerInterface 
+         * @return int|string can be a string if fetched from the server bag
          * @static 
-         */
-        public static function useSyslog($name = 'laravel', $level = 'debug', $facility = 8){
-            return \Illuminate\Log\Writer::useSyslog($name, $level, $facility);
+         */ 
+        public static function getPort()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPort();
         }
         
         /**
-         * Register an error_log handler.
+         * Returns the user.
          *
-         * @param string $level
-         * @param int $messageType
-         * @return void 
+         * @return string|null 
          * @static 
-         */
-        public static function useErrorLog($level = 'debug', $messageType = 0){
-            \Illuminate\Log\Writer::useErrorLog($level, $messageType);
+         */ 
+        public static function getUser()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUser();
         }
         
         /**
-         * Register a new callback handler for when a log event is triggered.
+         * Returns the password.
          *
-         * @param \Closure $callback
-         * @return void 
-         * @throws \RuntimeException
+         * @return string|null 
          * @static 
-         */
-        public static function listen($callback){
-            \Illuminate\Log\Writer::listen($callback);
+         */ 
+        public static function getPassword()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPassword();
         }
         
         /**
-         * Get the underlying Monolog instance.
+         * Gets the user info.
          *
-         * @return \Monolog\Logger 
+         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server
          * @static 
-         */
-        public static function getMonolog(){
-            return \Illuminate\Log\Writer::getMonolog();
+         */ 
+        public static function getUserInfo()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUserInfo();
         }
         
         /**
-         * Get the event dispatcher instance.
+         * Returns the HTTP host being requested.
+         * 
+         * The port name will be appended to the host if it's non-standard.
          *
-         * @return \Illuminate\Contracts\Events\Dispatcher 
+         * @return string 
          * @static 
-         */
-        public static function getEventDispatcher(){
-            return \Illuminate\Log\Writer::getEventDispatcher();
+         */ 
+        public static function getHttpHost()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getHttpHost();
         }
         
         /**
-         * Set the event dispatcher instance.
+         * Returns the requested URI (path and query string).
          *
-         * @param \Illuminate\Contracts\Events\Dispatcher $dispatcher
-         * @return void 
+         * @return string The raw URI (i.e. not URI decoded)
          * @static 
-         */
-        public static function setEventDispatcher($dispatcher){
-            \Illuminate\Log\Writer::setEventDispatcher($dispatcher);
+         */ 
+        public static function getRequestUri()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRequestUri();
         }
         
-    }
-
-
-    class Mail extends \Illuminate\Support\Facades\Mail{
-        
         /**
-         * Set the global from address and name.
+         * Gets the scheme and HTTP host.
+         * 
+         * If the URL was called with basic authentication, the user
+         * and the password are not added to the generated string.
          *
-         * @param string $address
-         * @param string|null $name
-         * @return void 
+         * @return string The scheme and HTTP host
          * @static 
-         */
-        public static function alwaysFrom($address, $name = null){
-            \Illuminate\Mail\Mailer::alwaysFrom($address, $name);
+         */ 
+        public static function getSchemeAndHttpHost()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getSchemeAndHttpHost();
         }
         
         /**
-         * Set the global reply-to address and name.
+         * Generates a normalized URI (URL) for the Request.
          *
-         * @param string $address
-         * @param string|null $name
-         * @return void 
+         * @return string A normalized URI (URL) for the Request
+         * @see getQueryString()
          * @static 
-         */
-        public static function alwaysReplyTo($address, $name = null){
-            \Illuminate\Mail\Mailer::alwaysReplyTo($address, $name);
+         */ 
+        public static function getUri()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUri();
         }
         
         /**
-         * Set the global to address and name.
+         * Generates a normalized URI for the given path.
          *
-         * @param string $address
-         * @param string|null $name
-         * @return void 
+         * @param string $path A path to use instead of the current one
+         * @return string The normalized URI for the path
          * @static 
-         */
-        public static function alwaysTo($address, $name = null){
-            \Illuminate\Mail\Mailer::alwaysTo($address, $name);
+         */ 
+        public static function getUriForPath($path)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUriForPath($path);
         }
         
         /**
-         * Begin the process of mailing a mailable class instance.
+         * Returns the path as relative reference from the current Request path.
+         * 
+         * Only the URIs path component (no schema, host etc.) is relevant and must be given.
+         * Both paths must be absolute and not contain relative parts.
+         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.
+         * Furthermore, they can be used to reduce the link size in documents.
+         * 
+         * Example target paths, given a base path of "/a/b/c/d":
+         * - "/a/b/c/d"     -> ""
+         * - "/a/b/c/"      -> "./"
+         * - "/a/b/"        -> "../"
+         * - "/a/b/c/other" -> "other"
+         * - "/a/x/y"       -> "../../x/y"
          *
-         * @param mixed $users
-         * @return \Illuminate\Mail\PendingMail 
+         * @param string $path The target path
+         * @return string The relative target path
          * @static 
-         */
-        public static function to($users){
-            return \Illuminate\Mail\Mailer::to($users);
+         */ 
+        public static function getRelativeUriForPath($path)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRelativeUriForPath($path);
         }
         
         /**
-         * Begin the process of mailing a mailable class instance.
+         * Generates the normalized query string for the Request.
+         * 
+         * It builds a normalized query string, where keys/value pairs are alphabetized
+         * and have consistent escaping.
          *
-         * @param mixed $users
-         * @return \Illuminate\Mail\PendingMail 
+         * @return string|null A normalized query string for the Request
          * @static 
-         */
-        public static function bcc($users){
-            return \Illuminate\Mail\Mailer::bcc($users);
+         */ 
+        public static function getQueryString()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getQueryString();
         }
         
         /**
-         * Send a new message when only a raw text part.
+         * Checks whether the request is secure or not.
+         * 
+         * This method can read the client protocol from the "X-Forwarded-Proto" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".
          *
-         * @param string $text
-         * @param mixed $callback
-         * @return void 
+         * @return bool 
          * @static 
-         */
-        public static function raw($text, $callback){
-            \Illuminate\Mail\Mailer::raw($text, $callback);
+         */ 
+        public static function isSecure()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isSecure();
         }
         
         /**
-         * Send a new message when only a plain part.
+         * Returns the host name.
+         * 
+         * This method can read the client host name from the "X-Forwarded-Host" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Host" header must contain the client host name.
          *
-         * @param string $view
-         * @param array $data
-         * @param mixed $callback
-         * @return void 
+         * @return string 
+         * @throws SuspiciousOperationException when the host name is invalid or not trusted
          * @static 
-         */
-        public static function plain($view, $data, $callback){
-            \Illuminate\Mail\Mailer::plain($view, $data, $callback);
+         */ 
+        public static function getHost()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getHost();
         }
         
         /**
-         * Send a new message using a view.
+         * Sets the request method.
          *
-         * @param string|array $view
-         * @param array $data
-         * @param \Closure|string $callback
-         * @return void 
+         * @param string $method
          * @static 
-         */
-        public static function send($view, $data = array(), $callback = null){
-            \Illuminate\Mail\Mailer::send($view, $data, $callback);
+         */ 
+        public static function setMethod($method)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setMethod($method);
         }
         
         /**
-         * Queue a new e-mail message for sending.
+         * Gets the request "intended" method.
+         * 
+         * If the X-HTTP-Method-Override header is set, and if the method is a POST,
+         * then it is used to determine the "real" intended HTTP method.
+         * 
+         * The _method request parameter can also be used to determine the HTTP method,
+         * but only if enableHttpMethodParameterOverride() has been called.
+         * 
+         * The method is always an uppercased string.
          *
-         * @param string|array $view
-         * @param array $data
-         * @param \Closure|string $callback
-         * @param string|null $queue
-         * @return mixed 
+         * @return string The request method
+         * @see getRealMethod()
          * @static 
-         */
-        public static function queue($view, $data = array(), $callback = null, $queue = null){
-            return \Illuminate\Mail\Mailer::queue($view, $data, $callback, $queue);
+         */ 
+        public static function getMethod()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getMethod();
         }
         
         /**
-         * Queue a new e-mail message for sending on the given queue.
+         * Gets the "real" request method.
          *
-         * @param string $queue
-         * @param string|array $view
-         * @param array $data
-         * @param \Closure|string $callback
-         * @return mixed 
+         * @return string The request method
+         * @see getMethod()
          * @static 
-         */
-        public static function onQueue($queue, $view, $data, $callback){
-            return \Illuminate\Mail\Mailer::onQueue($queue, $view, $data, $callback);
+         */ 
+        public static function getRealMethod()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRealMethod();
         }
         
         /**
-         * Queue a new e-mail message for sending on the given queue.
-         * 
-         * This method didn't match rest of framework's "onQueue" phrasing. Added "onQueue".
+         * Gets the mime type associated with the format.
          *
-         * @param string $queue
-         * @param string|array $view
-         * @param array $data
-         * @param \Closure|string $callback
-         * @return mixed 
+         * @param string $format The format
+         * @return string The associated mime type (null if not found)
          * @static 
-         */
-        public static function queueOn($queue, $view, $data, $callback){
-            return \Illuminate\Mail\Mailer::queueOn($queue, $view, $data, $callback);
+         */ 
+        public static function getMimeType($format)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getMimeType($format);
         }
         
         /**
-         * Queue a new e-mail message for sending after (n) seconds.
+         * Gets the mime types associated with the format.
          *
-         * @param int $delay
-         * @param string|array $view
-         * @param array $data
-         * @param \Closure|string $callback
-         * @param string|null $queue
-         * @return mixed 
+         * @param string $format The format
+         * @return array The associated mime types
          * @static 
-         */
-        public static function later($delay, $view, $data = array(), $callback = null, $queue = null){
-            return \Illuminate\Mail\Mailer::later($delay, $view, $data, $callback, $queue);
+         */ 
+        public static function getMimeTypes($format)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getMimeTypes($format);
         }
         
         /**
-         * Queue a new e-mail message for sending after (n) seconds on the given queue.
+         * Gets the format associated with the mime type.
          *
-         * @param string $queue
-         * @param int $delay
-         * @param string|array $view
-         * @param array $data
-         * @param \Closure|string $callback
-         * @return mixed 
+         * @param string $mimeType The associated mime type
+         * @return string|null The format (null if not found)
          * @static 
-         */
-        public static function laterOn($queue, $delay, $view, $data, $callback){
-            return \Illuminate\Mail\Mailer::laterOn($queue, $delay, $view, $data, $callback);
+         */ 
+        public static function getFormat($mimeType)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getFormat($mimeType);
         }
         
         /**
-         * Get the view factory instance.
+         * Associates a format with mime types.
          *
-         * @return \Illuminate\Contracts\View\Factory 
+         * @param string $format The format
+         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)
          * @static 
-         */
-        public static function getViewFactory(){
-            return \Illuminate\Mail\Mailer::getViewFactory();
+         */ 
+        public static function setFormat($format, $mimeTypes)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setFormat($format, $mimeTypes);
         }
         
         /**
-         * Get the Swift Mailer instance.
+         * Gets the request format.
+         * 
+         * Here is the process to determine the format:
+         * 
+         *  * format defined by the user (with setRequestFormat())
+         *  * _format request attribute
+         *  * $default
          *
-         * @return \Swift_Mailer 
+         * @param string $default The default format
+         * @return string The request format
          * @static 
-         */
-        public static function getSwiftMailer(){
-            return \Illuminate\Mail\Mailer::getSwiftMailer();
+         */ 
+        public static function getRequestFormat($default = 'html')
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRequestFormat($default);
         }
         
         /**
-         * Get the array of failed recipients.
+         * Sets the request format.
          *
-         * @return array 
+         * @param string $format The request format
          * @static 
-         */
-        public static function failures(){
-            return \Illuminate\Mail\Mailer::failures();
+         */ 
+        public static function setRequestFormat($format)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setRequestFormat($format);
         }
         
         /**
-         * Set the Swift Mailer instance.
+         * Gets the format associated with the request.
          *
-         * @param \Swift_Mailer $swift
-         * @return void 
+         * @return string|null The format (null if no content type is present)
          * @static 
-         */
-        public static function setSwiftMailer($swift){
-            \Illuminate\Mail\Mailer::setSwiftMailer($swift);
+         */ 
+        public static function getContentType()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getContentType();
         }
         
         /**
-         * Set the queue manager instance.
+         * Sets the default locale.
          *
-         * @param \Illuminate\Contracts\Queue\Factory $queue
-         * @return $this 
+         * @param string $locale
          * @static 
-         */
-        public static function setQueue($queue){
-            return \Illuminate\Mail\Mailer::setQueue($queue);
+         */ 
+        public static function setDefaultLocale($locale)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setDefaultLocale($locale);
         }
         
         /**
-         * Register a custom macro.
+         * Get the default locale.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @return string 
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Mail\Mailer::macro($name, $macro);
+         */ 
+        public static function getDefaultLocale()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getDefaultLocale();
         }
         
         /**
-         * Checks if macro is registered.
+         * Sets the locale.
          *
-         * @param string $name
-         * @return bool 
+         * @param string $locale
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Mail\Mailer::hasMacro($name);
+         */ 
+        public static function setLocale($locale)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setLocale($locale);
         }
         
-    }
-
-
-    class Password extends \Illuminate\Support\Facades\Password{
-        
         /**
-         * Attempt to get the broker from the local cache.
+         * Get the locale.
          *
-         * @param string $name
-         * @return \Illuminate\Contracts\Auth\PasswordBroker 
+         * @return string 
          * @static 
-         */
-        public static function broker($name = null){
-            return \Illuminate\Auth\Passwords\PasswordBrokerManager::broker($name);
+         */ 
+        public static function getLocale()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getLocale();
         }
         
         /**
-         * Get the default password broker name.
+         * Checks if the request method is of specified type.
          *
-         * @return string 
+         * @param string $method Uppercase request method (GET, POST etc)
+         * @return bool 
          * @static 
-         */
-        public static function getDefaultDriver(){
-            return \Illuminate\Auth\Passwords\PasswordBrokerManager::getDefaultDriver();
+         */ 
+        public static function isMethod($method)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethod($method);
         }
         
         /**
-         * Set the default password broker name.
+         * Checks whether or not the method is safe.
          *
-         * @param string $name
-         * @return void 
+         * @see https://tools.ietf.org/html/rfc7231#section-4.2.1
+         * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.
+         * @return bool 
          * @static 
-         */
-        public static function setDefaultDriver($name){
-            \Illuminate\Auth\Passwords\PasswordBrokerManager::setDefaultDriver($name);
+         */ 
+        public static function isMethodSafe()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodSafe();
         }
         
-    }
-
-
-    class Queue extends \Illuminate\Support\Facades\Queue{
-        
         /**
-         * Register an event listener for the before job event.
+         * Checks whether or not the method is idempotent.
          *
-         * @param mixed $callback
-         * @return void 
+         * @return bool 
          * @static 
-         */
-        public static function before($callback){
-            \Illuminate\Queue\QueueManager::before($callback);
+         */ 
+        public static function isMethodIdempotent()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodIdempotent();
         }
         
         /**
-         * Register an event listener for the after job event.
+         * Checks whether the method is cacheable or not.
          *
-         * @param mixed $callback
-         * @return void 
+         * @see https://tools.ietf.org/html/rfc7231#section-4.2.3
+         * @return bool 
          * @static 
-         */
-        public static function after($callback){
-            \Illuminate\Queue\QueueManager::after($callback);
+         */ 
+        public static function isMethodCacheable()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodCacheable();
         }
         
         /**
-         * Register an event listener for the exception occurred job event.
+         * Returns the protocol version.
+         * 
+         * If the application is behind a proxy, the protocol version used in the
+         * requests between the client and the proxy and between the proxy and the
+         * server might be different. This returns the former (from the "Via" header)
+         * if the proxy is trusted (see "setTrustedProxies()"), otherwise it returns
+         * the latter (from the "SERVER_PROTOCOL" server parameter).
          *
-         * @param mixed $callback
-         * @return void 
+         * @return string 
          * @static 
-         */
-        public static function exceptionOccurred($callback){
-            \Illuminate\Queue\QueueManager::exceptionOccurred($callback);
+         */ 
+        public static function getProtocolVersion()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getProtocolVersion();
         }
         
         /**
-         * Register an event listener for the daemon queue loop.
+         * Returns the request body content.
          *
-         * @param mixed $callback
-         * @return void 
+         * @param bool $asResource If true, a resource will be returned
+         * @return string|resource The request body content or a resource to read the body stream
+         * @throws \LogicException
          * @static 
-         */
-        public static function looping($callback){
-            \Illuminate\Queue\QueueManager::looping($callback);
+         */ 
+        public static function getContent($asResource = false)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getContent($asResource);
         }
         
         /**
-         * Register an event listener for the failed job event.
+         * Gets the Etags.
          *
-         * @param mixed $callback
-         * @return void 
+         * @return array The entity tags
          * @static 
-         */
-        public static function failing($callback){
-            \Illuminate\Queue\QueueManager::failing($callback);
+         */ 
+        public static function getETags()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getETags();
         }
         
         /**
-         * Register an event listener for the daemon queue stopping.
+         * 
          *
-         * @param mixed $callback
-         * @return void 
+         * @return bool 
          * @static 
-         */
-        public static function stopping($callback){
-            \Illuminate\Queue\QueueManager::stopping($callback);
+         */ 
+        public static function isNoCache()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isNoCache();
         }
         
         /**
-         * Determine if the driver is connected.
+         * Returns the preferred language.
          *
-         * @param string $name
-         * @return bool 
+         * @param array $locales An array of ordered available locales
+         * @return string|null The preferred locale
          * @static 
-         */
-        public static function connected($name = null){
-            return \Illuminate\Queue\QueueManager::connected($name);
+         */ 
+        public static function getPreferredLanguage($locales = null)
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPreferredLanguage($locales);
         }
         
         /**
-         * Resolve a queue connection instance.
+         * Gets a list of languages acceptable by the client browser.
          *
-         * @param string $name
-         * @return \Illuminate\Contracts\Queue\Queue 
+         * @return array Languages ordered in the user browser preferences
          * @static 
-         */
-        public static function connection($name = null){
-            return \Illuminate\Queue\QueueManager::connection($name);
+         */ 
+        public static function getLanguages()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getLanguages();
         }
         
         /**
-         * Add a queue connection resolver.
+         * Gets a list of charsets acceptable by the client browser.
          *
-         * @param string $driver
-         * @param \Closure $resolver
-         * @return void 
+         * @return array List of charsets in preferable order
          * @static 
-         */
-        public static function extend($driver, $resolver){
-            \Illuminate\Queue\QueueManager::extend($driver, $resolver);
+         */ 
+        public static function getCharsets()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getCharsets();
         }
         
         /**
-         * Add a queue connection resolver.
+         * Gets a list of encodings acceptable by the client browser.
          *
-         * @param string $driver
-         * @param \Closure $resolver
-         * @return void 
+         * @return array List of encodings in preferable order
          * @static 
-         */
-        public static function addConnector($driver, $resolver){
-            \Illuminate\Queue\QueueManager::addConnector($driver, $resolver);
+         */ 
+        public static function getEncodings()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getEncodings();
         }
         
         /**
-         * Get the name of the default queue connection.
+         * Gets a list of content types acceptable by the client browser.
          *
-         * @return string 
+         * @return array List of content types in preferable order
          * @static 
-         */
-        public static function getDefaultDriver(){
-            return \Illuminate\Queue\QueueManager::getDefaultDriver();
+         */ 
+        public static function getAcceptableContentTypes()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getAcceptableContentTypes();
         }
         
         /**
-         * Set the name of the default queue connection.
+         * Returns true if the request is a XMLHttpRequest.
+         * 
+         * It works if your JavaScript library sets an X-Requested-With HTTP header.
+         * It is known to work with common JavaScript frameworks:
          *
-         * @param string $name
-         * @return void 
+         * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript
+         * @return bool true if the request is an XMLHttpRequest, false otherwise
          * @static 
-         */
-        public static function setDefaultDriver($name){
-            \Illuminate\Queue\QueueManager::setDefaultDriver($name);
+         */ 
+        public static function isXmlHttpRequest()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isXmlHttpRequest();
         }
         
         /**
-         * Get the full name for the given connection.
+         * Indicates whether this request originated from a trusted proxy.
+         * 
+         * This can be useful to determine whether or not to trust the
+         * contents of a proxy-specific header.
          *
-         * @param string $connection
-         * @return string 
+         * @return bool true if the request came from a trusted proxy, false otherwise
          * @static 
-         */
-        public static function getName($connection = null){
-            return \Illuminate\Queue\QueueManager::getName($connection);
+         */ 
+        public static function isFromTrustedProxy()
+        {
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isFromTrustedProxy();
         }
         
         /**
-         * Determine if the application is in maintenance mode.
+         * Determine if the given content types match.
          *
+         * @param string $actual
+         * @param string $type
          * @return bool 
          * @static 
-         */
-        public static function isDownForMaintenance(){
-            return \Illuminate\Queue\QueueManager::isDownForMaintenance();
+         */ 
+        public static function matchesType($actual, $type)
+        {
+            return \Illuminate\Http\Request::matchesType($actual, $type);
         }
         
         /**
-         * Get the size of the queue.
+         * Determine if the request is sending JSON.
          *
-         * @param string $queue
-         * @return int 
+         * @return bool 
          * @static 
-         */
-        public static function size($queue = null){
-            return \Illuminate\Queue\SyncQueue::size($queue);
+         */ 
+        public static function isJson()
+        {
+            return \Illuminate\Http\Request::isJson();
         }
         
         /**
-         * Push a new job onto the queue.
+         * Determine if the current request probably expects a JSON response.
          *
-         * @param string $job
-         * @param mixed $data
-         * @param string $queue
-         * @return mixed 
-         * @throws \Exception|\Throwable
+         * @return bool 
          * @static 
-         */
-        public static function push($job, $data = '', $queue = null){
-            return \Illuminate\Queue\SyncQueue::push($job, $data, $queue);
+         */ 
+        public static function expectsJson()
+        {
+            return \Illuminate\Http\Request::expectsJson();
         }
         
         /**
-         * Push a raw payload onto the queue.
+         * Determine if the current request is asking for JSON.
          *
-         * @param string $payload
-         * @param string $queue
-         * @param array $options
-         * @return mixed 
+         * @return bool 
          * @static 
-         */
-        public static function pushRaw($payload, $queue = null, $options = array()){
-            return \Illuminate\Queue\SyncQueue::pushRaw($payload, $queue, $options);
+         */ 
+        public static function wantsJson()
+        {
+            return \Illuminate\Http\Request::wantsJson();
         }
         
         /**
-         * Push a new job onto the queue after a delay.
+         * Determines whether the current requests accepts a given content type.
          *
-         * @param \DateTime|int $delay
-         * @param string $job
-         * @param mixed $data
-         * @param string $queue
-         * @return mixed 
+         * @param string|array $contentTypes
+         * @return bool 
          * @static 
-         */
-        public static function later($delay, $job, $data = '', $queue = null){
-            return \Illuminate\Queue\SyncQueue::later($delay, $job, $data, $queue);
+         */ 
+        public static function accepts($contentTypes)
+        {
+            return \Illuminate\Http\Request::accepts($contentTypes);
         }
         
         /**
-         * Pop the next job off of the queue.
+         * Return the most suitable content type from the given array based on content negotiation.
          *
-         * @param string $queue
-         * @return \Illuminate\Contracts\Queue\Job|null 
+         * @param string|array $contentTypes
+         * @return string|null 
          * @static 
-         */
-        public static function pop($queue = null){
-            return \Illuminate\Queue\SyncQueue::pop($queue);
+         */ 
+        public static function prefers($contentTypes)
+        {
+            return \Illuminate\Http\Request::prefers($contentTypes);
         }
         
         /**
-         * Push a new job onto the queue.
+         * Determine if the current request accepts any content type.
          *
-         * @param string $queue
-         * @param string $job
-         * @param mixed $data
-         * @return mixed 
+         * @return bool 
          * @static 
-         */
-        public static function pushOn($queue, $job, $data = ''){
-            //Method inherited from \Illuminate\Queue\Queue            
-            return \Illuminate\Queue\SyncQueue::pushOn($queue, $job, $data);
+         */ 
+        public static function acceptsAnyContentType()
+        {
+            return \Illuminate\Http\Request::acceptsAnyContentType();
         }
         
         /**
-         * Push a new job onto the queue after a delay.
+         * Determines whether a request accepts JSON.
          *
-         * @param string $queue
-         * @param \DateTime|int $delay
-         * @param string $job
-         * @param mixed $data
-         * @return mixed 
+         * @return bool 
          * @static 
-         */
-        public static function laterOn($queue, $delay, $job, $data = ''){
-            //Method inherited from \Illuminate\Queue\Queue            
-            return \Illuminate\Queue\SyncQueue::laterOn($queue, $delay, $job, $data);
+         */ 
+        public static function acceptsJson()
+        {
+            return \Illuminate\Http\Request::acceptsJson();
         }
         
         /**
-         * Push an array of jobs onto the queue.
+         * Determines whether a request accepts HTML.
          *
-         * @param array $jobs
-         * @param mixed $data
-         * @param string $queue
-         * @return mixed 
+         * @return bool 
          * @static 
-         */
-        public static function bulk($jobs, $data = '', $queue = null){
-            //Method inherited from \Illuminate\Queue\Queue            
-            return \Illuminate\Queue\SyncQueue::bulk($jobs, $data, $queue);
+         */ 
+        public static function acceptsHtml()
+        {
+            return \Illuminate\Http\Request::acceptsHtml();
         }
         
         /**
-         * Get the connection name for the queue.
+         * Get the data format expected in the response.
          *
+         * @param string $default
          * @return string 
          * @static 
-         */
-        public static function getConnectionName(){
-            //Method inherited from \Illuminate\Queue\Queue            
-            return \Illuminate\Queue\SyncQueue::getConnectionName();
+         */ 
+        public static function format($default = 'html')
+        {
+            return \Illuminate\Http\Request::format($default);
         }
         
         /**
-         * Set the connection name for the queue.
+         * Retrieve an old input item.
          *
-         * @param string $name
-         * @return $this 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function setConnectionName($name){
-            //Method inherited from \Illuminate\Queue\Queue            
-            return \Illuminate\Queue\SyncQueue::setConnectionName($name);
+         */ 
+        public static function old($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::old($key, $default);
+        }
+        
+        /**
+         * Flash the input for the current request to the session.
+         *
+         * @return void 
+         * @static 
+         */ 
+        public static function flash()
+        {
+            \Illuminate\Http\Request::flash();
         }
         
         /**
-         * Set the IoC container instance.
+         * Flash only some of the input to the session.
          *
-         * @param \Illuminate\Container\Container $container
+         * @param array|mixed $keys
          * @return void 
          * @static 
-         */
-        public static function setContainer($container){
-            //Method inherited from \Illuminate\Queue\Queue            
-            \Illuminate\Queue\SyncQueue::setContainer($container);
+         */ 
+        public static function flashOnly($keys)
+        {
+            \Illuminate\Http\Request::flashOnly($keys);
         }
         
-    }
-
-
-    class Redirect extends \Illuminate\Support\Facades\Redirect{
-        
         /**
-         * Create a new redirect response to the "home" route.
+         * Flash only some of the input to the session.
          *
-         * @param int $status
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param array|mixed $keys
+         * @return void 
          * @static 
-         */
-        public static function home($status = 302){
-            return \Illuminate\Routing\Redirector::home($status);
+         */ 
+        public static function flashExcept($keys)
+        {
+            \Illuminate\Http\Request::flashExcept($keys);
         }
         
         /**
-         * Create a new redirect response to the previous location.
+         * Flush all of the old input from the session.
          *
-         * @param int $status
-         * @param array $headers
-         * @param mixed $fallback
-         * @return \Illuminate\Http\RedirectResponse 
+         * @return void 
          * @static 
-         */
-        public static function back($status = 302, $headers = array(), $fallback = false){
-            return \Illuminate\Routing\Redirector::back($status, $headers, $fallback);
+         */ 
+        public static function flush()
+        {
+            \Illuminate\Http\Request::flush();
         }
         
         /**
-         * Create a new redirect response to the current URI.
+         * Retrieve a server variable from the request.
          *
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function refresh($status = 302, $headers = array()){
-            return \Illuminate\Routing\Redirector::refresh($status, $headers);
+         */ 
+        public static function server($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::server($key, $default);
         }
         
         /**
-         * Create a new redirect response, while putting the current URL in the session.
+         * Determine if a header is set on the request.
          *
-         * @param string $path
-         * @param int $status
-         * @param array $headers
-         * @param bool $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string $key
+         * @return bool 
          * @static 
-         */
-        public static function guest($path, $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\Redirector::guest($path, $status, $headers, $secure);
+         */ 
+        public static function hasHeader($key)
+        {
+            return \Illuminate\Http\Request::hasHeader($key);
         }
         
         /**
-         * Create a new redirect response to the previously intended location.
+         * Retrieve a header from the request.
          *
-         * @param string $default
-         * @param int $status
-         * @param array $headers
-         * @param bool $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function intended($default = '/', $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\Redirector::intended($default, $status, $headers, $secure);
+         */ 
+        public static function header($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::header($key, $default);
         }
         
         /**
-         * Create a new redirect response to the given path.
+         * Get the bearer token from the request headers.
          *
-         * @param string $path
-         * @param int $status
-         * @param array $headers
-         * @param bool $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @return string|null 
          * @static 
-         */
-        public static function to($path, $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\Redirector::to($path, $status, $headers, $secure);
+         */ 
+        public static function bearerToken()
+        {
+            return \Illuminate\Http\Request::bearerToken();
         }
         
         /**
-         * Create a new redirect response to an external URL (no validation).
+         * Determine if the request contains a given input item key.
          *
-         * @param string $path
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string|array $key
+         * @return bool 
          * @static 
-         */
-        public static function away($path, $status = 302, $headers = array()){
-            return \Illuminate\Routing\Redirector::away($path, $status, $headers);
+         */ 
+        public static function exists($key)
+        {
+            return \Illuminate\Http\Request::exists($key);
         }
         
         /**
-         * Create a new redirect response to the given HTTPS path.
+         * Determine if the request contains a given input item key.
          *
-         * @param string $path
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string|array $key
+         * @return bool 
          * @static 
-         */
-        public static function secure($path, $status = 302, $headers = array()){
-            return \Illuminate\Routing\Redirector::secure($path, $status, $headers);
+         */ 
+        public static function has($key)
+        {
+            return \Illuminate\Http\Request::has($key);
         }
         
         /**
-         * Create a new redirect response to a named route.
+         * Determine if the request contains any of the given inputs.
          *
-         * @param string $route
-         * @param array $parameters
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string|array $key
+         * @return bool 
          * @static 
-         */
-        public static function route($route, $parameters = array(), $status = 302, $headers = array()){
-            return \Illuminate\Routing\Redirector::route($route, $parameters, $status, $headers);
+         */ 
+        public static function hasAny($keys)
+        {
+            return \Illuminate\Http\Request::hasAny($keys);
         }
         
         /**
-         * Create a new redirect response to a controller action.
+         * Determine if the request contains a non-empty value for an input item.
          *
-         * @param string $action
-         * @param array $parameters
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string|array $key
+         * @return bool 
          * @static 
-         */
-        public static function action($action, $parameters = array(), $status = 302, $headers = array()){
-            return \Illuminate\Routing\Redirector::action($action, $parameters, $status, $headers);
+         */ 
+        public static function filled($key)
+        {
+            return \Illuminate\Http\Request::filled($key);
         }
         
         /**
-         * Get the URL generator instance.
+         * Get the keys for all of the input and files.
          *
-         * @return \Illuminate\Routing\UrlGenerator 
+         * @return array 
          * @static 
-         */
-        public static function getUrlGenerator(){
-            return \Illuminate\Routing\Redirector::getUrlGenerator();
+         */ 
+        public static function keys()
+        {
+            return \Illuminate\Http\Request::keys();
         }
         
         /**
-         * Set the active session store.
+         * Get all of the input and files for the request.
          *
-         * @param \Illuminate\Session\Store $session
-         * @return void 
+         * @param array|mixed $keys
+         * @return array 
          * @static 
-         */
-        public static function setSession($session){
-            \Illuminate\Routing\Redirector::setSession($session);
+         */ 
+        public static function all($keys = null)
+        {
+            return \Illuminate\Http\Request::all($keys);
         }
         
-    }
-
-
-    class Request extends \Illuminate\Support\Facades\Request{
-        
         /**
-         * Create a new Illuminate HTTP request from server variables.
+         * Retrieve an input item from the request.
          *
-         * @return static 
+         * @param string|null $key
+         * @param string|array|null $default
+         * @return string|array|null 
          * @static 
-         */
-        public static function capture(){
-            return \Illuminate\Http\Request::capture();
+         */ 
+        public static function input($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::input($key, $default);
         }
         
         /**
-         * Return the Request instance.
+         * Get a subset containing the provided keys with values from the input data.
          *
-         * @return $this 
+         * @param array|mixed $keys
+         * @return array 
          * @static 
-         */
-        public static function instance(){
-            return \Illuminate\Http\Request::instance();
+         */ 
+        public static function only($keys)
+        {
+            return \Illuminate\Http\Request::only($keys);
         }
         
         /**
-         * Get the request method.
+         * Get all of the input except for a specified array of items.
          *
-         * @return string 
+         * @param array|mixed $keys
+         * @return array 
          * @static 
-         */
-        public static function method(){
-            return \Illuminate\Http\Request::method();
+         */ 
+        public static function except($keys)
+        {
+            return \Illuminate\Http\Request::except($keys);
         }
         
         /**
-         * Get the root URL for the application.
+         * Retrieve a query string item from the request.
          *
-         * @return string 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function root(){
-            return \Illuminate\Http\Request::root();
+         */ 
+        public static function query($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::query($key, $default);
         }
         
         /**
-         * Get the URL (no query string) for the request.
+         * Retrieve a request payload item from the request.
          *
-         * @return string 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function url(){
-            return \Illuminate\Http\Request::url();
+         */ 
+        public static function post($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::post($key, $default);
         }
         
         /**
-         * Get the full URL for the request.
+         * Determine if a cookie is set on the request.
          *
-         * @return string 
+         * @param string $key
+         * @return bool 
          * @static 
-         */
-        public static function fullUrl(){
-            return \Illuminate\Http\Request::fullUrl();
+         */ 
+        public static function hasCookie($key)
+        {
+            return \Illuminate\Http\Request::hasCookie($key);
         }
         
         /**
-         * Get the full URL for the request with the added query string parameters.
+         * Retrieve a cookie from the request.
          *
-         * @param array $query
-         * @return string 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
-         */
-        public static function fullUrlWithQuery($query){
-            return \Illuminate\Http\Request::fullUrlWithQuery($query);
+         */ 
+        public static function cookie($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::cookie($key, $default);
         }
         
         /**
-         * Get the current path info for the request.
+         * Get an array of all of the files on the request.
          *
-         * @return string 
+         * @return array 
          * @static 
-         */
-        public static function path(){
-            return \Illuminate\Http\Request::path();
+         */ 
+        public static function allFiles()
+        {
+            return \Illuminate\Http\Request::allFiles();
         }
         
         /**
-         * Get the current encoded path info for the request.
+         * Determine if the uploaded data contains a file.
          *
-         * @return string 
+         * @param string $key
+         * @return bool 
          * @static 
-         */
-        public static function decodedPath(){
-            return \Illuminate\Http\Request::decodedPath();
+         */ 
+        public static function hasFile($key)
+        {
+            return \Illuminate\Http\Request::hasFile($key);
         }
         
         /**
-         * Get a segment from the URI (1 based index).
+         * Retrieve a file from the request.
          *
-         * @param int $index
-         * @param string|null $default
-         * @return string|null 
+         * @param string $key
+         * @param mixed $default
+         * @return \Illuminate\Http\UploadedFile|array|null 
          * @static 
-         */
-        public static function segment($index, $default = null){
-            return \Illuminate\Http\Request::segment($index, $default);
+         */ 
+        public static function file($key = null, $default = null)
+        {
+            return \Illuminate\Http\Request::file($key, $default);
         }
         
         /**
-         * Get all of the segments for the request path.
+         * Register a custom macro.
          *
-         * @return array 
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function segments(){
-            return \Illuminate\Http\Request::segments();
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Http\Request::macro($name, $macro);
         }
         
         /**
-         * Determine if the current request URI matches a pattern.
+         * Mix another object into the class.
          *
-         * @return bool 
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function is(){
-            return \Illuminate\Http\Request::is();
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Http\Request::mixin($mixin);
         }
         
         /**
-         * Check if the route name matches the given string.
+         * Checks if macro is registered.
          *
          * @param string $name
          * @return bool 
          * @static 
-         */
-        public static function routeIs($name){
-            return \Illuminate\Http\Request::routeIs($name);
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Http\Request::hasMacro($name);
         }
         
         /**
-         * Determine if the current request URL and query string matches a pattern.
+         * 
          *
-         * @return bool 
          * @static 
-         */
-        public static function fullUrlIs(){
-            return \Illuminate\Http\Request::fullUrlIs();
+         */ 
+        public static function validate($rules, $params = null)
+        {
+            return \Illuminate\Http\Request::validate($rules, $params);
         }
+         
+    }
+
+    class Response {
         
         /**
-         * Determine if the request is the result of an AJAX call.
+         * Return a new response from the application.
          *
-         * @return bool 
+         * @param string $content
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\Response 
          * @static 
-         */
-        public static function ajax(){
-            return \Illuminate\Http\Request::ajax();
+         */ 
+        public static function make($content = '', $status = 200, $headers = array())
+        {
+            return \Illuminate\Routing\ResponseFactory::make($content, $status, $headers);
         }
         
         /**
-         * Determine if the request is the result of an PJAX call.
+         * Return a new view response from the application.
          *
-         * @return bool 
+         * @param string $view
+         * @param array $data
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\Response 
          * @static 
-         */
-        public static function pjax(){
-            return \Illuminate\Http\Request::pjax();
+         */ 
+        public static function view($view, $data = array(), $status = 200, $headers = array())
+        {
+            return \Illuminate\Routing\ResponseFactory::view($view, $data, $status, $headers);
         }
         
         /**
-         * Determine if the request is over HTTPS.
+         * Return a new JSON response from the application.
          *
-         * @return bool 
+         * @param mixed $data
+         * @param int $status
+         * @param array $headers
+         * @param int $options
+         * @return \Illuminate\Http\JsonResponse 
          * @static 
-         */
-        public static function secure(){
-            return \Illuminate\Http\Request::secure();
+         */ 
+        public static function json($data = array(), $status = 200, $headers = array(), $options = 0)
+        {
+            return \Illuminate\Routing\ResponseFactory::json($data, $status, $headers, $options);
         }
         
         /**
-         * Returns the client IP address.
+         * Return a new JSONP response from the application.
          *
-         * @return string 
+         * @param string $callback
+         * @param mixed $data
+         * @param int $status
+         * @param array $headers
+         * @param int $options
+         * @return \Illuminate\Http\JsonResponse 
          * @static 
-         */
-        public static function ip(){
-            return \Illuminate\Http\Request::ip();
+         */ 
+        public static function jsonp($callback, $data = array(), $status = 200, $headers = array(), $options = 0)
+        {
+            return \Illuminate\Routing\ResponseFactory::jsonp($callback, $data, $status, $headers, $options);
         }
         
         /**
-         * Returns the client IP addresses.
+         * Return a new streamed response from the application.
          *
-         * @return array 
+         * @param \Closure $callback
+         * @param int $status
+         * @param array $headers
+         * @return \Symfony\Component\HttpFoundation\StreamedResponse 
          * @static 
-         */
-        public static function ips(){
-            return \Illuminate\Http\Request::ips();
+         */ 
+        public static function stream($callback, $status = 200, $headers = array())
+        {
+            return \Illuminate\Routing\ResponseFactory::stream($callback, $status, $headers);
         }
         
         /**
-         * Merge new input into the current request's input array.
+         * Return a new streamed response as a file download from the application.
          *
-         * @param array $input
-         * @return void 
+         * @param \Closure $callback
+         * @param string|null $name
+         * @param array $headers
+         * @param string|null $disposition
+         * @return \Symfony\Component\HttpFoundation\StreamedResponse 
          * @static 
-         */
-        public static function merge($input){
-            \Illuminate\Http\Request::merge($input);
+         */ 
+        public static function streamDownload($callback, $name = null, $headers = array(), $disposition = 'attachment')
+        {
+            return \Illuminate\Routing\ResponseFactory::streamDownload($callback, $name, $headers, $disposition);
         }
         
         /**
-         * Replace the input for the current request.
+         * Create a new file download response.
          *
-         * @param array $input
-         * @return void 
+         * @param \SplFileInfo|string $file
+         * @param string|null $name
+         * @param array $headers
+         * @param string|null $disposition
+         * @return \Symfony\Component\HttpFoundation\BinaryFileResponse 
          * @static 
-         */
-        public static function replace($input){
-            \Illuminate\Http\Request::replace($input);
+         */ 
+        public static function download($file, $name = null, $headers = array(), $disposition = 'attachment')
+        {
+            return \Illuminate\Routing\ResponseFactory::download($file, $name, $headers, $disposition);
         }
         
         /**
-         * Get the JSON payload for the request.
+         * Return the raw contents of a binary file.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param \SplFileInfo|string $file
+         * @param array $headers
+         * @return \Symfony\Component\HttpFoundation\BinaryFileResponse 
          * @static 
-         */
-        public static function json($key = null, $default = null){
-            return \Illuminate\Http\Request::json($key, $default);
+         */ 
+        public static function file($file, $headers = array())
+        {
+            return \Illuminate\Routing\ResponseFactory::file($file, $headers);
         }
         
         /**
-         * Create an Illuminate request from a Symfony instance.
+         * Create a new redirect response to the given path.
          *
-         * @param \Symfony\Component\HttpFoundation\Request $request
-         * @return \Illuminate\Http\Request 
+         * @param string $path
+         * @param int $status
+         * @param array $headers
+         * @param bool|null $secure
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function createFromBase($request){
-            return \Illuminate\Http\Request::createFromBase($request);
+         */ 
+        public static function redirectTo($path, $status = 302, $headers = array(), $secure = null)
+        {
+            return \Illuminate\Routing\ResponseFactory::redirectTo($path, $status, $headers, $secure);
         }
         
         /**
-         * Clones a request and overrides some of its parameters.
+         * Create a new redirect response to a named route.
          *
-         * @param array $query The GET parameters
-         * @param array $request The POST parameters
-         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
-         * @param array $cookies The COOKIE parameters
-         * @param array $files The FILES parameters
-         * @param array $server The SERVER parameters
-         * @return static 
+         * @param string $route
+         * @param array $parameters
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null){
-            return \Illuminate\Http\Request::duplicate($query, $request, $attributes, $cookies, $files, $server);
+         */ 
+        public static function redirectToRoute($route, $parameters = array(), $status = 302, $headers = array())
+        {
+            return \Illuminate\Routing\ResponseFactory::redirectToRoute($route, $parameters, $status, $headers);
         }
         
         /**
-         * Get the session associated with the request.
+         * Create a new redirect response to a controller action.
          *
-         * @return \Illuminate\Session\Store 
-         * @throws \RuntimeException
+         * @param string $action
+         * @param array $parameters
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function session(){
-            return \Illuminate\Http\Request::session();
+         */ 
+        public static function redirectToAction($action, $parameters = array(), $status = 302, $headers = array())
+        {
+            return \Illuminate\Routing\ResponseFactory::redirectToAction($action, $parameters, $status, $headers);
         }
         
         /**
-         * Set the session instance on the request.
+         * Create a new redirect response, while putting the current URL in the session.
          *
-         * @param \Illuminate\Contracts\Session\Session $session
-         * @return void 
+         * @param string $path
+         * @param int $status
+         * @param array $headers
+         * @param bool|null $secure
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function setLaravelSession($session){
-            \Illuminate\Http\Request::setLaravelSession($session);
+         */ 
+        public static function redirectGuest($path, $status = 302, $headers = array(), $secure = null)
+        {
+            return \Illuminate\Routing\ResponseFactory::redirectGuest($path, $status, $headers, $secure);
         }
         
         /**
-         * Get the user making the request.
+         * Create a new redirect response to the previously intended location.
          *
-         * @param string|null $guard
-         * @return mixed 
+         * @param string $default
+         * @param int $status
+         * @param array $headers
+         * @param bool|null $secure
+         * @return \Illuminate\Http\RedirectResponse 
          * @static 
-         */
-        public static function user($guard = null){
-            return \Illuminate\Http\Request::user($guard);
+         */ 
+        public static function redirectToIntended($default = '/', $status = 302, $headers = array(), $secure = null)
+        {
+            return \Illuminate\Routing\ResponseFactory::redirectToIntended($default, $status, $headers, $secure);
         }
         
         /**
-         * Get the route handling the request.
+         * Register a custom macro.
          *
-         * @param string|null $param
-         * @return \Illuminate\Routing\Route|object|string 
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function route($param = null){
-            return \Illuminate\Http\Request::route($param);
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Routing\ResponseFactory::macro($name, $macro);
         }
         
         /**
-         * Get a unique fingerprint for the request / route / IP address.
+         * Mix another object into the class.
          *
-         * @return string 
-         * @throws \RuntimeException
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function fingerprint(){
-            return \Illuminate\Http\Request::fingerprint();
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Routing\ResponseFactory::mixin($mixin);
         }
         
         /**
-         * Set the JSON payload for the request.
+         * Checks if macro is registered.
          *
-         * @param array $json
-         * @return $this 
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function setJson($json){
-            return \Illuminate\Http\Request::setJson($json);
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Routing\ResponseFactory::hasMacro($name);
         }
+         
+    }
+
+    class Route {
         
         /**
-         * Get the user resolver callback.
+         * Register a new GET route with the router.
          *
-         * @return \Closure 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function getUserResolver(){
-            return \Illuminate\Http\Request::getUserResolver();
+         */ 
+        public static function get($uri, $action = null)
+        {
+            return \Illuminate\Routing\Router::get($uri, $action);
         }
         
         /**
-         * Set the user resolver callback.
+         * Register a new POST route with the router.
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function setUserResolver($callback){
-            return \Illuminate\Http\Request::setUserResolver($callback);
+         */ 
+        public static function post($uri, $action = null)
+        {
+            return \Illuminate\Routing\Router::post($uri, $action);
         }
         
         /**
-         * Get the route resolver callback.
+         * Register a new PUT route with the router.
          *
-         * @return \Closure 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function getRouteResolver(){
-            return \Illuminate\Http\Request::getRouteResolver();
+         */ 
+        public static function put($uri, $action = null)
+        {
+            return \Illuminate\Routing\Router::put($uri, $action);
         }
         
         /**
-         * Set the route resolver callback.
+         * Register a new PATCH route with the router.
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function setRouteResolver($callback){
-            return \Illuminate\Http\Request::setRouteResolver($callback);
+         */ 
+        public static function patch($uri, $action = null)
+        {
+            return \Illuminate\Routing\Router::patch($uri, $action);
         }
         
         /**
-         * Get all of the input and files for the request.
+         * Register a new DELETE route with the router.
          *
-         * @return array 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function toArray(){
-            return \Illuminate\Http\Request::toArray();
+         */ 
+        public static function delete($uri, $action = null)
+        {
+            return \Illuminate\Routing\Router::delete($uri, $action);
         }
         
         /**
-         * Determine if the given offset exists.
+         * Register a new OPTIONS route with the router.
          *
-         * @param string $offset
-         * @return bool 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function offsetExists($offset){
-            return \Illuminate\Http\Request::offsetExists($offset);
+         */ 
+        public static function options($uri, $action = null)
+        {
+            return \Illuminate\Routing\Router::options($uri, $action);
         }
         
         /**
-         * Get the value at the given offset.
+         * Register a new route responding to all verbs.
          *
-         * @param string $offset
-         * @return mixed 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function offsetGet($offset){
-            return \Illuminate\Http\Request::offsetGet($offset);
+         */ 
+        public static function any($uri, $action = null)
+        {
+            return \Illuminate\Routing\Router::any($uri, $action);
         }
         
         /**
-         * Set the value at the given offset.
+         * Register a new Fallback route with the router.
          *
-         * @param string $offset
-         * @param mixed $value
-         * @return void 
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function offsetSet($offset, $value){
-            \Illuminate\Http\Request::offsetSet($offset, $value);
+         */ 
+        public static function fallback($action)
+        {
+            return \Illuminate\Routing\Router::fallback($action);
         }
         
         /**
-         * Remove the value at the given offset.
+         * Create a redirect from one URI to another.
          *
-         * @param string $offset
-         * @return void 
+         * @param string $uri
+         * @param string $destination
+         * @param int $status
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function offsetUnset($offset){
-            \Illuminate\Http\Request::offsetUnset($offset);
+         */ 
+        public static function redirect($uri, $destination, $status = 301)
+        {
+            return \Illuminate\Routing\Router::redirect($uri, $destination, $status);
         }
         
         /**
-         * Sets the parameters for this request.
-         * 
-         * This method also re-initializes all properties.
+         * Register a new route that returns a view.
          *
-         * @param array $query The GET parameters
-         * @param array $request The POST parameters
-         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
-         * @param array $cookies The COOKIE parameters
-         * @param array $files The FILES parameters
-         * @param array $server The SERVER parameters
-         * @param string|resource $content The raw body data
+         * @param string $uri
+         * @param string $view
+         * @param array $data
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function initialize($query = array(), $request = array(), $attributes = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::initialize($query, $request, $attributes, $cookies, $files, $server, $content);
+         */ 
+        public static function view($uri, $view, $data = array())
+        {
+            return \Illuminate\Routing\Router::view($uri, $view, $data);
         }
         
         /**
-         * Creates a new request with values from PHP's super globals.
+         * Register a new route with the given verbs.
          *
-         * @return static 
+         * @param array|string $methods
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function createFromGlobals(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::createFromGlobals();
+         */ 
+        public static function match($methods, $uri, $action = null)
+        {
+            return \Illuminate\Routing\Router::match($methods, $uri, $action);
         }
         
         /**
-         * Creates a Request based on a given URI and configuration.
-         * 
-         * The information contained in the URI always take precedence
-         * over the other information (server and parameters).
+         * Register an array of resource controllers.
          *
-         * @param string $uri The URI
-         * @param string $method The HTTP method
-         * @param array $parameters The query (GET) or request (POST) parameters
-         * @param array $cookies The request cookies ($_COOKIE)
-         * @param array $files The request files ($_FILES)
-         * @param array $server The server parameters ($_SERVER)
-         * @param string $content The raw body data
-         * @return static 
+         * @param array $resources
+         * @return void 
          * @static 
-         */
-        public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);
+         */ 
+        public static function resources($resources)
+        {
+            \Illuminate\Routing\Router::resources($resources);
         }
         
         /**
-         * Sets a callable able to create a Request instance.
-         * 
-         * This is mainly useful when you need to override the Request class
-         * to keep BC with an existing system. It should not be used for any
-         * other purpose.
+         * Route a resource to a controller.
          *
-         * @param callable|null $callable A PHP callable
+         * @param string $name
+         * @param string $controller
+         * @param array $options
+         * @return \Illuminate\Routing\PendingResourceRegistration 
          * @static 
-         */
-        public static function setFactory($callable){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setFactory($callable);
+         */ 
+        public static function resource($name, $controller, $options = array())
+        {
+            return \Illuminate\Routing\Router::resource($name, $controller, $options);
         }
         
         /**
-         * Overrides the PHP global variables according to this request instance.
-         * 
-         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.
-         * $_FILES is never overridden, see rfc1867
+         * Register an array of API resource controllers.
          *
+         * @param array $resources
+         * @return void 
          * @static 
-         */
-        public static function overrideGlobals(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::overrideGlobals();
+         */ 
+        public static function apiResources($resources)
+        {
+            \Illuminate\Routing\Router::apiResources($resources);
         }
         
         /**
-         * Sets a list of trusted proxies.
-         * 
-         * You should only list the reverse proxies that you manage directly.
+         * Route an API resource to a controller.
          *
-         * @param array $proxies A list of trusted proxies
-         * @param int $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies
-         * @throws \InvalidArgumentException When $trustedHeaderSet is invalid
+         * @param string $name
+         * @param string $controller
+         * @param array $options
+         * @return \Illuminate\Routing\PendingResourceRegistration 
          * @static 
-         */
-        public static function setTrustedProxies($proxies){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedProxies($proxies);
+         */ 
+        public static function apiResource($name, $controller, $options = array())
+        {
+            return \Illuminate\Routing\Router::apiResource($name, $controller, $options);
         }
         
         /**
-         * Gets the list of trusted proxies.
+         * Create a route group with shared attributes.
          *
-         * @return array An array of trusted proxies
+         * @param array $attributes
+         * @param \Closure|string $routes
+         * @return void 
          * @static 
-         */
-        public static function getTrustedProxies(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedProxies();
+         */ 
+        public static function group($attributes, $routes)
+        {
+            \Illuminate\Routing\Router::group($attributes, $routes);
         }
         
         /**
-         * Gets the set of trusted headers from trusted proxies.
+         * Merge the given array with the last group stack.
          *
-         * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies
+         * @param array $new
+         * @return array 
          * @static 
-         */
-        public static function getTrustedHeaderSet(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHeaderSet();
+         */ 
+        public static function mergeWithLastGroup($new)
+        {
+            return \Illuminate\Routing\Router::mergeWithLastGroup($new);
         }
         
         /**
-         * Sets a list of trusted host patterns.
-         * 
-         * You should only list the hosts you manage using regexs.
+         * Get the prefix from the last group on the stack.
          *
-         * @param array $hostPatterns A list of trusted host patterns
+         * @return string 
          * @static 
-         */
-        public static function setTrustedHosts($hostPatterns){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedHosts($hostPatterns);
+         */ 
+        public static function getLastGroupPrefix()
+        {
+            return \Illuminate\Routing\Router::getLastGroupPrefix();
         }
         
         /**
-         * Gets the list of trusted host patterns.
+         * Return the response returned by the given route.
          *
-         * @return array An array of trusted host patterns
+         * @param string $name
+         * @return mixed 
          * @static 
-         */
-        public static function getTrustedHosts(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHosts();
+         */ 
+        public static function respondWithRoute($name)
+        {
+            return \Illuminate\Routing\Router::respondWithRoute($name);
         }
         
         /**
-         * Sets the name for trusted headers.
-         * 
-         * The following header keys are supported:
-         * 
-         *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())
-         *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())
-         *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())
-         *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())
-         *  * Request::HEADER_FORWARDED:    defaults to Forwarded         (see RFC 7239)
-         * 
-         * Setting an empty value allows to disable the trusted header for the given key.
+         * Dispatch the request to the application.
          *
-         * @param string $key The header key
-         * @param string $value The header name
-         * @throws \InvalidArgumentException
-         * @deprecated since version 3.3, to be removed in 4.0. Use the $trustedHeaderSet argument of the Request::setTrustedProxies() method instead.
+         * @param \Illuminate\Http\Request $request
+         * @return \Illuminate\Http\Response|\Illuminate\Http\JsonResponse 
          * @static 
-         */
-        public static function setTrustedHeaderName($key, $value){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedHeaderName($key, $value);
+         */ 
+        public static function dispatch($request)
+        {
+            return \Illuminate\Routing\Router::dispatch($request);
         }
         
         /**
-         * Gets the trusted proxy header name.
+         * Dispatch the request to a route and return the response.
          *
-         * @param string $key The header key
-         * @return string The header name
-         * @throws \InvalidArgumentException
-         * @deprecated since version 3.3, to be removed in 4.0. Use the Request::getTrustedHeaderSet() method instead.
+         * @param \Illuminate\Http\Request $request
+         * @return mixed 
          * @static 
-         */
-        public static function getTrustedHeaderName($key){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHeaderName($key);
+         */ 
+        public static function dispatchToRoute($request)
+        {
+            return \Illuminate\Routing\Router::dispatchToRoute($request);
         }
         
         /**
-         * Normalizes a query string.
-         * 
-         * It builds a normalized query string, where keys/value pairs are alphabetized,
-         * have consistent escaping and unneeded delimiters are removed.
+         * Gather the middleware for the given route with resolved class names.
          *
-         * @param string $qs Query string
-         * @return string A normalized query string for the Request
+         * @param \Illuminate\Routing\Route $route
+         * @return array 
          * @static 
-         */
-        public static function normalizeQueryString($qs){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::normalizeQueryString($qs);
+         */ 
+        public static function gatherRouteMiddleware($route)
+        {
+            return \Illuminate\Routing\Router::gatherRouteMiddleware($route);
         }
         
         /**
-         * Enables support for the _method request parameter to determine the intended HTTP method.
-         * 
-         * Be warned that enabling this feature might lead to CSRF issues in your code.
-         * Check that you are using CSRF tokens when required.
-         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered
-         * and used to send a "PUT" or "DELETE" request via the _method request parameter.
-         * If these methods are not protected against CSRF, this presents a possible vulnerability.
-         * 
-         * The HTTP method can only be overridden when the real HTTP method is POST.
+         * Create a response instance from the given value.
          *
+         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @param mixed $response
+         * @return \Illuminate\Http\Response|\Illuminate\Http\JsonResponse 
          * @static 
-         */
-        public static function enableHttpMethodParameterOverride(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::enableHttpMethodParameterOverride();
+         */ 
+        public static function prepareResponse($request, $response)
+        {
+            return \Illuminate\Routing\Router::prepareResponse($request, $response);
         }
         
         /**
-         * Checks whether support for the _method request parameter is enabled.
+         * Static version of prepareResponse.
          *
-         * @return bool True when the _method request parameter is enabled, false otherwise
+         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @param mixed $response
+         * @return \Illuminate\Http\Response|\Illuminate\Http\JsonResponse 
          * @static 
-         */
-        public static function getHttpMethodParameterOverride(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHttpMethodParameterOverride();
+         */ 
+        public static function toResponse($request, $response)
+        {
+            return \Illuminate\Routing\Router::toResponse($request, $response);
         }
         
         /**
-         * Gets a "parameter" value from any bag.
-         * 
-         * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the
-         * flexibility in controllers, it is better to explicitly get request parameters from the appropriate
-         * public property instead (attributes, query, request).
-         * 
-         * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY
+         * Substitute the route bindings onto the route.
          *
-         * @param string $key the key
-         * @param mixed $default the default value if the parameter key does not exist
-         * @return mixed 
+         * @param \Illuminate\Routing\Route $route
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function get($key, $default = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::get($key, $default);
+         */ 
+        public static function substituteBindings($route)
+        {
+            return \Illuminate\Routing\Router::substituteBindings($route);
         }
         
         /**
-         * Gets the Session.
+         * Substitute the implicit Eloquent model bindings for the route.
          *
-         * @return \Symfony\Component\HttpFoundation\SessionInterface|null The session
+         * @param \Illuminate\Routing\Route $route
+         * @return void 
          * @static 
-         */
-        public static function getSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getSession();
+         */ 
+        public static function substituteImplicitBindings($route)
+        {
+            \Illuminate\Routing\Router::substituteImplicitBindings($route);
         }
         
         /**
-         * Whether the request contains a Session which was started in one of the
-         * previous requests.
+         * Register a route matched event listener.
          *
-         * @return bool 
+         * @param string|callable $callback
+         * @return void 
          * @static 
-         */
-        public static function hasPreviousSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::hasPreviousSession();
+         */ 
+        public static function matched($callback)
+        {
+            \Illuminate\Routing\Router::matched($callback);
         }
         
         /**
-         * Whether the request contains a Session object.
-         * 
-         * This method does not give any information about the state of the session object,
-         * like whether the session is started or not. It is just a way to check if this Request
-         * is associated with a Session instance.
+         * Get all of the defined middleware short-hand names.
          *
-         * @return bool true when the Request contains a Session object, false otherwise
+         * @return array 
          * @static 
-         */
-        public static function hasSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::hasSession();
+         */ 
+        public static function getMiddleware()
+        {
+            return \Illuminate\Routing\Router::getMiddleware();
         }
         
         /**
-         * Sets the Session.
+         * Register a short-hand name for a middleware.
          *
-         * @param \Symfony\Component\HttpFoundation\SessionInterface $session The Session
+         * @param string $name
+         * @param string $class
+         * @return $this 
          * @static 
-         */
-        public static function setSession($session){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setSession($session);
+         */ 
+        public static function aliasMiddleware($name, $class)
+        {
+            return \Illuminate\Routing\Router::aliasMiddleware($name, $class);
         }
         
         /**
-         * Returns the client IP addresses.
-         * 
-         * In the returned array the most trusted IP address is first, and the
-         * least trusted one last. The "real" client IP address is the last one,
-         * but this is also the least trusted one. Trusted proxies are stripped.
-         * 
-         * Use this method carefully; you should use getClientIp() instead.
+         * Check if a middlewareGroup with the given name exists.
          *
-         * @return array The client IP addresses
-         * @see getClientIp()
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function getClientIps(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getClientIps();
+         */ 
+        public static function hasMiddlewareGroup($name)
+        {
+            return \Illuminate\Routing\Router::hasMiddlewareGroup($name);
         }
         
         /**
-         * Returns the client IP address.
-         * 
-         * This method can read the client IP address from the "X-Forwarded-For" header
-         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"
-         * header value is a comma+space separated list of IP addresses, the left-most
-         * being the original client, and each successive proxy that passed the request
-         * adding the IP address where it received the request from.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-For",
-         * ("Client-Ip" for instance), configure it via the $trustedHeaderSet
-         * argument of the Request::setTrustedProxies() method instead.
+         * Get all of the defined middleware groups.
          *
-         * @return string|null The client IP address
-         * @see getClientIps()
-         * @see http://en.wikipedia.org/wiki/X-Forwarded-For
+         * @return array 
          * @static 
-         */
-        public static function getClientIp(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getClientIp();
+         */ 
+        public static function getMiddlewareGroups()
+        {
+            return \Illuminate\Routing\Router::getMiddlewareGroups();
         }
         
         /**
-         * Returns current script name.
+         * Register a group of middleware.
          *
-         * @return string 
+         * @param string $name
+         * @param array $middleware
+         * @return $this 
          * @static 
-         */
-        public static function getScriptName(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getScriptName();
+         */ 
+        public static function middlewareGroup($name, $middleware)
+        {
+            return \Illuminate\Routing\Router::middlewareGroup($name, $middleware);
         }
         
         /**
-         * Returns the path being requested relative to the executed script.
-         * 
-         * The path info always starts with a /.
-         * 
-         * Suppose this request is instantiated from /mysite on localhost:
+         * Add a middleware to the beginning of a middleware group.
          * 
-         *  * http://localhost/mysite              returns an empty string
-         *  * http://localhost/mysite/about        returns '/about'
-         *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'
-         *  * http://localhost/mysite/about?var=1  returns '/about'
+         * If the middleware is already in the group, it will not be added again.
          *
-         * @return string The raw path (i.e. not urldecoded)
+         * @param string $group
+         * @param string $middleware
+         * @return $this 
          * @static 
-         */
-        public static function getPathInfo(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPathInfo();
+         */ 
+        public static function prependMiddlewareToGroup($group, $middleware)
+        {
+            return \Illuminate\Routing\Router::prependMiddlewareToGroup($group, $middleware);
         }
         
         /**
-         * Returns the root path from which this request is executed.
-         * 
-         * Suppose that an index.php file instantiates this request object:
+         * Add a middleware to the end of a middleware group.
          * 
-         *  * http://localhost/index.php         returns an empty string
-         *  * http://localhost/index.php/page    returns an empty string
-         *  * http://localhost/web/index.php     returns '/web'
-         *  * http://localhost/we%20b/index.php  returns '/we%20b'
+         * If the middleware is already in the group, it will not be added again.
          *
-         * @return string The raw path (i.e. not urldecoded)
+         * @param string $group
+         * @param string $middleware
+         * @return $this 
          * @static 
-         */
-        public static function getBasePath(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getBasePath();
+         */ 
+        public static function pushMiddlewareToGroup($group, $middleware)
+        {
+            return \Illuminate\Routing\Router::pushMiddlewareToGroup($group, $middleware);
         }
         
         /**
-         * Returns the root URL from which this request is executed.
-         * 
-         * The base URL never ends with a /.
-         * 
-         * This is similar to getBasePath(), except that it also includes the
-         * script filename (e.g. index.php) if one exists.
+         * Add a new route parameter binder.
          *
-         * @return string The raw URL (i.e. not urldecoded)
+         * @param string $key
+         * @param string|callable $binder
+         * @return void 
          * @static 
-         */
-        public static function getBaseUrl(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getBaseUrl();
+         */ 
+        public static function bind($key, $binder)
+        {
+            \Illuminate\Routing\Router::bind($key, $binder);
         }
         
         /**
-         * Gets the request's scheme.
+         * Register a model binder for a wildcard.
          *
-         * @return string 
+         * @param string $key
+         * @param string $class
+         * @param \Closure|null $callback
+         * @return void 
+         * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
          * @static 
-         */
-        public static function getScheme(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getScheme();
+         */ 
+        public static function model($key, $class, $callback = null)
+        {
+            \Illuminate\Routing\Router::model($key, $class, $callback);
         }
         
         /**
-         * Returns the port on which the request is made.
-         * 
-         * This method can read the client port from the "X-Forwarded-Port" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Port" header must contain the client port.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Port",
-         * configure it via via the $trustedHeaderSet argument of the
-         * Request::setTrustedProxies() method instead.
+         * Get the binding callback for a given binding.
+         *
+         * @param string $key
+         * @return \Closure|null 
+         * @static 
+         */ 
+        public static function getBindingCallback($key)
+        {
+            return \Illuminate\Routing\Router::getBindingCallback($key);
+        }
+        
+        /**
+         * Get the global "where" patterns.
          *
-         * @return int|string can be a string if fetched from the server bag
+         * @return array 
          * @static 
-         */
-        public static function getPort(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPort();
+         */ 
+        public static function getPatterns()
+        {
+            return \Illuminate\Routing\Router::getPatterns();
         }
         
         /**
-         * Returns the user.
+         * Set a global where pattern on all routes.
          *
-         * @return string|null 
+         * @param string $key
+         * @param string $pattern
+         * @return void 
          * @static 
-         */
-        public static function getUser(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUser();
+         */ 
+        public static function pattern($key, $pattern)
+        {
+            \Illuminate\Routing\Router::pattern($key, $pattern);
         }
         
         /**
-         * Returns the password.
+         * Set a group of global where patterns on all routes.
          *
-         * @return string|null 
+         * @param array $patterns
+         * @return void 
          * @static 
-         */
-        public static function getPassword(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPassword();
+         */ 
+        public static function patterns($patterns)
+        {
+            \Illuminate\Routing\Router::patterns($patterns);
         }
         
         /**
-         * Gets the user info.
+         * Determine if the router currently has a group stack.
          *
-         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server
+         * @return bool 
          * @static 
-         */
-        public static function getUserInfo(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUserInfo();
+         */ 
+        public static function hasGroupStack()
+        {
+            return \Illuminate\Routing\Router::hasGroupStack();
         }
         
         /**
-         * Returns the HTTP host being requested.
-         * 
-         * The port name will be appended to the host if it's non-standard.
+         * Get the current group stack for the router.
          *
-         * @return string 
+         * @return array 
          * @static 
-         */
-        public static function getHttpHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHttpHost();
+         */ 
+        public static function getGroupStack()
+        {
+            return \Illuminate\Routing\Router::getGroupStack();
         }
         
         /**
-         * Returns the requested URI (path and query string).
+         * Get a route parameter for the current route.
          *
-         * @return string The raw URI (i.e. not URI decoded)
+         * @param string $key
+         * @param string $default
+         * @return mixed 
          * @static 
-         */
-        public static function getRequestUri(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRequestUri();
+         */ 
+        public static function input($key, $default = null)
+        {
+            return \Illuminate\Routing\Router::input($key, $default);
         }
         
         /**
-         * Gets the scheme and HTTP host.
-         * 
-         * If the URL was called with basic authentication, the user
-         * and the password are not added to the generated string.
+         * Get the request currently being dispatched.
          *
-         * @return string The scheme and HTTP host
+         * @return \Illuminate\Http\Request 
          * @static 
-         */
-        public static function getSchemeAndHttpHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getSchemeAndHttpHost();
+         */ 
+        public static function getCurrentRequest()
+        {
+            return \Illuminate\Routing\Router::getCurrentRequest();
         }
         
         /**
-         * Generates a normalized URI (URL) for the Request.
+         * Get the currently dispatched route instance.
          *
-         * @return string A normalized URI (URL) for the Request
-         * @see getQueryString()
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function getUri(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUri();
+         */ 
+        public static function getCurrentRoute()
+        {
+            return \Illuminate\Routing\Router::getCurrentRoute();
         }
         
         /**
-         * Generates a normalized URI for the given path.
+         * Get the currently dispatched route instance.
          *
-         * @param string $path A path to use instead of the current one
-         * @return string The normalized URI for the path
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function getUriForPath($path){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUriForPath($path);
+         */ 
+        public static function current()
+        {
+            return \Illuminate\Routing\Router::current();
         }
         
         /**
-         * Returns the path as relative reference from the current Request path.
-         * 
-         * Only the URIs path component (no schema, host etc.) is relevant and must be given.
-         * Both paths must be absolute and not contain relative parts.
-         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.
-         * Furthermore, they can be used to reduce the link size in documents.
-         * 
-         * Example target paths, given a base path of "/a/b/c/d":
-         * - "/a/b/c/d"     -> ""
-         * - "/a/b/c/"      -> "./"
-         * - "/a/b/"        -> "../"
-         * - "/a/b/c/other" -> "other"
-         * - "/a/x/y"       -> "../../x/y"
+         * Check if a route with the given name exists.
          *
-         * @param string $path The target path
-         * @return string The relative target path
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function getRelativeUriForPath($path){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRelativeUriForPath($path);
+         */ 
+        public static function has($name)
+        {
+            return \Illuminate\Routing\Router::has($name);
         }
         
         /**
-         * Generates the normalized query string for the Request.
-         * 
-         * It builds a normalized query string, where keys/value pairs are alphabetized
-         * and have consistent escaping.
+         * Get the current route name.
          *
-         * @return string|null A normalized query string for the Request
+         * @return string|null 
          * @static 
-         */
-        public static function getQueryString(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getQueryString();
+         */ 
+        public static function currentRouteName()
+        {
+            return \Illuminate\Routing\Router::currentRouteName();
         }
         
         /**
-         * Checks whether the request is secure or not.
-         * 
-         * This method can read the client protocol from the "X-Forwarded-Proto" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Proto"
-         * ("SSL_HTTPS" for instance), configure it via the $trustedHeaderSet
-         * argument of the Request::setTrustedProxies() method instead.
+         * Alias for the "currentRouteNamed" method.
          *
+         * @param mixed $patterns
          * @return bool 
          * @static 
-         */
-        public static function isSecure(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isSecure();
+         */ 
+        public static function is($patterns = null)
+        {
+            return \Illuminate\Routing\Router::is($patterns);
         }
         
         /**
-         * Returns the host name.
-         * 
-         * This method can read the client host name from the "X-Forwarded-Host" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Host" header must contain the client host name.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Host",
-         * configure it via the $trustedHeaderSet argument of the
-         * Request::setTrustedProxies() method instead.
+         * Determine if the current route matches a pattern.
          *
-         * @return string 
-         * @throws SuspiciousOperationException when the host name is invalid or not trusted
+         * @param mixed $patterns
+         * @return bool 
          * @static 
-         */
-        public static function getHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHost();
+         */ 
+        public static function currentRouteNamed($patterns = null)
+        {
+            return \Illuminate\Routing\Router::currentRouteNamed($patterns);
         }
         
         /**
-         * Sets the request method.
+         * Get the current route action.
          *
-         * @param string $method
+         * @return string|null 
          * @static 
-         */
-        public static function setMethod($method){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setMethod($method);
+         */ 
+        public static function currentRouteAction()
+        {
+            return \Illuminate\Routing\Router::currentRouteAction();
         }
         
         /**
-         * Gets the request "intended" method.
-         * 
-         * If the X-HTTP-Method-Override header is set, and if the method is a POST,
-         * then it is used to determine the "real" intended HTTP method.
-         * 
-         * The _method request parameter can also be used to determine the HTTP method,
-         * but only if enableHttpMethodParameterOverride() has been called.
-         * 
-         * The method is always an uppercased string.
+         * Alias for the "currentRouteUses" method.
          *
-         * @return string The request method
-         * @see getRealMethod()
+         * @param array $patterns
+         * @return bool 
          * @static 
-         */
-        public static function getMethod(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMethod();
+         */ 
+        public static function uses($patterns = null)
+        {
+            return \Illuminate\Routing\Router::uses($patterns);
         }
         
         /**
-         * Gets the "real" request method.
+         * Determine if the current route action matches a given action.
          *
-         * @return string The request method
-         * @see getMethod()
+         * @param string $action
+         * @return bool 
          * @static 
-         */
-        public static function getRealMethod(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRealMethod();
+         */ 
+        public static function currentRouteUses($action)
+        {
+            return \Illuminate\Routing\Router::currentRouteUses($action);
         }
         
         /**
-         * Gets the mime type associated with the format.
+         * Register the typical authentication routes for an application.
          *
-         * @param string $format The format
-         * @return string The associated mime type (null if not found)
+         * @return void 
          * @static 
-         */
-        public static function getMimeType($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMimeType($format);
+         */ 
+        public static function auth()
+        {
+            \Illuminate\Routing\Router::auth();
         }
         
         /**
-         * Gets the mime types associated with the format.
+         * Set the unmapped global resource parameters to singular.
          *
-         * @param string $format The format
-         * @return array The associated mime types
+         * @param bool $singular
+         * @return void 
          * @static 
-         */
-        public static function getMimeTypes($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMimeTypes($format);
+         */ 
+        public static function singularResourceParameters($singular = true)
+        {
+            \Illuminate\Routing\Router::singularResourceParameters($singular);
         }
         
         /**
-         * Gets the format associated with the mime type.
+         * Set the global resource parameter mapping.
          *
-         * @param string $mimeType The associated mime type
-         * @return string|null The format (null if not found)
+         * @param array $parameters
+         * @return void 
          * @static 
-         */
-        public static function getFormat($mimeType){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getFormat($mimeType);
+         */ 
+        public static function resourceParameters($parameters = array())
+        {
+            \Illuminate\Routing\Router::resourceParameters($parameters);
         }
         
         /**
-         * Associates a format with mime types.
+         * Get or set the verbs used in the resource URIs.
          *
-         * @param string $format The format
-         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)
+         * @param array $verbs
+         * @return array|null 
          * @static 
-         */
-        public static function setFormat($format, $mimeTypes){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setFormat($format, $mimeTypes);
+         */ 
+        public static function resourceVerbs($verbs = array())
+        {
+            return \Illuminate\Routing\Router::resourceVerbs($verbs);
         }
         
         /**
-         * Gets the request format.
-         * 
-         * Here is the process to determine the format:
-         * 
-         *  * format defined by the user (with setRequestFormat())
-         *  * _format request attribute
-         *  * $default
+         * Get the underlying route collection.
          *
-         * @param string $default The default format
-         * @return string The request format
+         * @return \Illuminate\Routing\RouteCollection 
          * @static 
-         */
-        public static function getRequestFormat($default = 'html'){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRequestFormat($default);
+         */ 
+        public static function getRoutes()
+        {
+            return \Illuminate\Routing\Router::getRoutes();
         }
         
         /**
-         * Sets the request format.
+         * Set the route collection instance.
          *
-         * @param string $format The request format
+         * @param \Illuminate\Routing\RouteCollection $routes
+         * @return void 
          * @static 
-         */
-        public static function setRequestFormat($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setRequestFormat($format);
+         */ 
+        public static function setRoutes($routes)
+        {
+            \Illuminate\Routing\Router::setRoutes($routes);
         }
         
         /**
-         * Gets the format associated with the request.
+         * Register a custom macro.
          *
-         * @return string|null The format (null if no content type is present)
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function getContentType(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getContentType();
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Routing\Router::macro($name, $macro);
         }
         
         /**
-         * Sets the default locale.
+         * Mix another object into the class.
          *
-         * @param string $locale
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function setDefaultLocale($locale){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setDefaultLocale($locale);
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Routing\Router::mixin($mixin);
         }
         
         /**
-         * Get the default locale.
+         * Checks if macro is registered.
          *
-         * @return string 
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function getDefaultLocale(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getDefaultLocale();
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Routing\Router::hasMacro($name);
         }
         
         /**
-         * Sets the locale.
+         * Dynamically handle calls to the class.
          *
-         * @param string $locale
+         * @param string $method
+         * @param array $parameters
+         * @return mixed 
+         * @throws \BadMethodCallException
          * @static 
-         */
-        public static function setLocale($locale){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setLocale($locale);
+         */ 
+        public static function macroCall($method, $parameters)
+        {
+            return \Illuminate\Routing\Router::macroCall($method, $parameters);
         }
+         
+    }
+
+    class Schema {
         
         /**
-         * Get the locale.
+         * Determine if the given table exists.
          *
-         * @return string 
+         * @param string $table
+         * @return bool 
          * @static 
-         */
-        public static function getLocale(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getLocale();
+         */ 
+        public static function hasTable($table)
+        {
+            return \Illuminate\Database\Schema\MySqlBuilder::hasTable($table);
         }
         
         /**
-         * Checks if the request method is of specified type.
+         * Get the column listing for a given table.
          *
-         * @param string $method Uppercase request method (GET, POST etc)
-         * @return bool 
+         * @param string $table
+         * @return array 
          * @static 
-         */
-        public static function isMethod($method){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethod($method);
+         */ 
+        public static function getColumnListing($table)
+        {
+            return \Illuminate\Database\Schema\MySqlBuilder::getColumnListing($table);
         }
         
         /**
-         * Checks whether or not the method is safe.
+         * Drop all tables from the database.
          *
-         * @see https://tools.ietf.org/html/rfc7231#section-4.2.1
-         * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function isMethodSafe(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethodSafe();
+         */ 
+        public static function dropAllTables()
+        {
+            \Illuminate\Database\Schema\MySqlBuilder::dropAllTables();
         }
         
         /**
-         * Checks whether or not the method is idempotent.
+         * Set the default string length for migrations.
          *
-         * @return bool 
+         * @param int $length
+         * @return void 
          * @static 
-         */
-        public static function isMethodIdempotent(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethodIdempotent();
+         */ 
+        public static function defaultStringLength($length)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::defaultStringLength($length);
         }
         
         /**
-         * Checks whether the method is cacheable or not.
+         * Determine if the given table has a given column.
          *
-         * @see https://tools.ietf.org/html/rfc7231#section-4.2.3
+         * @param string $table
+         * @param string $column
          * @return bool 
          * @static 
-         */
-        public static function isMethodCacheable(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethodCacheable();
+         */ 
+        public static function hasColumn($table, $column)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::hasColumn($table, $column);
         }
         
         /**
-         * Returns the request body content.
+         * Determine if the given table has given columns.
          *
-         * @param bool $asResource If true, a resource will be returned
-         * @return string|resource The request body content or a resource to read the body stream
-         * @throws \LogicException
+         * @param string $table
+         * @param array $columns
+         * @return bool 
          * @static 
-         */
-        public static function getContent($asResource = false){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getContent($asResource);
+         */ 
+        public static function hasColumns($table, $columns)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::hasColumns($table, $columns);
         }
         
         /**
-         * Gets the Etags.
+         * Get the data type for the given column name.
          *
-         * @return array The entity tags
+         * @param string $table
+         * @param string $column
+         * @return string 
          * @static 
-         */
-        public static function getETags(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getETags();
+         */ 
+        public static function getColumnType($table, $column)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::getColumnType($table, $column);
         }
         
         /**
-         * 
+         * Modify a table on the schema.
          *
-         * @return bool 
+         * @param string $table
+         * @param \Closure $callback
+         * @return void 
          * @static 
-         */
-        public static function isNoCache(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isNoCache();
+         */ 
+        public static function table($table, $callback)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::table($table, $callback);
         }
         
         /**
-         * Returns the preferred language.
+         * Create a new table on the schema.
          *
-         * @param array $locales An array of ordered available locales
-         * @return string|null The preferred locale
+         * @param string $table
+         * @param \Closure $callback
+         * @return void 
          * @static 
-         */
-        public static function getPreferredLanguage($locales = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPreferredLanguage($locales);
+         */ 
+        public static function create($table, $callback)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::create($table, $callback);
         }
         
         /**
-         * Gets a list of languages acceptable by the client browser.
+         * Drop a table from the schema.
          *
-         * @return array Languages ordered in the user browser preferences
+         * @param string $table
+         * @return void 
          * @static 
-         */
-        public static function getLanguages(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getLanguages();
+         */ 
+        public static function drop($table)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::drop($table);
         }
         
         /**
-         * Gets a list of charsets acceptable by the client browser.
+         * Drop a table from the schema if it exists.
          *
-         * @return array List of charsets in preferable order
+         * @param string $table
+         * @return void 
          * @static 
-         */
-        public static function getCharsets(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getCharsets();
+         */ 
+        public static function dropIfExists($table)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::dropIfExists($table);
         }
         
         /**
-         * Gets a list of encodings acceptable by the client browser.
+         * Rename a table on the schema.
          *
-         * @return array List of encodings in preferable order
+         * @param string $from
+         * @param string $to
+         * @return void 
          * @static 
-         */
-        public static function getEncodings(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getEncodings();
+         */ 
+        public static function rename($from, $to)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::rename($from, $to);
         }
         
         /**
-         * Gets a list of content types acceptable by the client browser.
+         * Enable foreign key constraints.
          *
-         * @return array List of content types in preferable order
+         * @return bool 
          * @static 
-         */
-        public static function getAcceptableContentTypes(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getAcceptableContentTypes();
+         */ 
+        public static function enableForeignKeyConstraints()
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::enableForeignKeyConstraints();
         }
         
         /**
-         * Returns true if the request is a XMLHttpRequest.
-         * 
-         * It works if your JavaScript library sets an X-Requested-With HTTP header.
-         * It is known to work with common JavaScript frameworks:
+         * Disable foreign key constraints.
          *
-         * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript
-         * @return bool true if the request is an XMLHttpRequest, false otherwise
+         * @return bool 
          * @static 
-         */
-        public static function isXmlHttpRequest(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isXmlHttpRequest();
+         */ 
+        public static function disableForeignKeyConstraints()
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::disableForeignKeyConstraints();
         }
         
         /**
-         * Indicates whether this request originated from a trusted proxy.
-         * 
-         * This can be useful to determine whether or not to trust the
-         * contents of a proxy-specific header.
+         * Get the database connection instance.
          *
-         * @return bool true if the request came from a trusted proxy, false otherwise
+         * @return \Illuminate\Database\Connection 
          * @static 
-         */
-        public static function isFromTrustedProxy(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isFromTrustedProxy();
+         */ 
+        public static function getConnection()
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::getConnection();
         }
         
         /**
-         * Determine if the given content types match.
+         * Set the database connection instance.
          *
-         * @param string $actual
-         * @param string $type
-         * @return bool 
+         * @param \Illuminate\Database\Connection $connection
+         * @return $this 
          * @static 
-         */
-        public static function matchesType($actual, $type){
-            return \Illuminate\Http\Request::matchesType($actual, $type);
+         */ 
+        public static function setConnection($connection)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::setConnection($connection);
         }
         
         /**
-         * Determine if the request is sending JSON.
+         * Set the Schema Blueprint resolver callback.
          *
-         * @return bool 
+         * @param \Closure $resolver
+         * @return void 
          * @static 
-         */
-        public static function isJson(){
-            return \Illuminate\Http\Request::isJson();
+         */ 
+        public static function blueprintResolver($resolver)
+        {
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::blueprintResolver($resolver);
         }
+         
+    }
+
+    class Session {
         
         /**
-         * Determine if the current request probably expects a JSON response.
+         * Get the session configuration.
          *
-         * @return bool 
+         * @return array 
          * @static 
-         */
-        public static function expectsJson(){
-            return \Illuminate\Http\Request::expectsJson();
+         */ 
+        public static function getSessionConfig()
+        {
+            return \Illuminate\Session\SessionManager::getSessionConfig();
         }
         
         /**
-         * Determine if the current request is asking for JSON in return.
+         * Get the default session driver name.
          *
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function wantsJson(){
-            return \Illuminate\Http\Request::wantsJson();
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \Illuminate\Session\SessionManager::getDefaultDriver();
         }
         
         /**
-         * Determines whether the current requests accepts a given content type.
+         * Set the default session driver name.
          *
-         * @param string|array $contentTypes
-         * @return bool 
+         * @param string $name
+         * @return void 
          * @static 
-         */
-        public static function accepts($contentTypes){
-            return \Illuminate\Http\Request::accepts($contentTypes);
+         */ 
+        public static function setDefaultDriver($name)
+        {
+            \Illuminate\Session\SessionManager::setDefaultDriver($name);
         }
         
         /**
-         * Return the most suitable content type from the given array based on content negotiation.
+         * Get a driver instance.
          *
-         * @param string|array $contentTypes
-         * @return string|null 
+         * @param string $driver
+         * @return mixed 
          * @static 
-         */
-        public static function prefers($contentTypes){
-            return \Illuminate\Http\Request::prefers($contentTypes);
+         */ 
+        public static function driver($driver = null)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Session\SessionManager::driver($driver);
         }
         
         /**
-         * Determines whether a request accepts JSON.
+         * Register a custom driver creator Closure.
          *
-         * @return bool 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function acceptsJson(){
-            return \Illuminate\Http\Request::acceptsJson();
+         */ 
+        public static function extend($driver, $callback)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Session\SessionManager::extend($driver, $callback);
         }
         
         /**
-         * Determines whether a request accepts HTML.
+         * Get all of the created "drivers".
          *
-         * @return bool 
+         * @return array 
          * @static 
-         */
-        public static function acceptsHtml(){
-            return \Illuminate\Http\Request::acceptsHtml();
+         */ 
+        public static function getDrivers()
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Session\SessionManager::getDrivers();
         }
         
         /**
-         * Get the data format expected in the response.
+         * Start the session, reading the data from a handler.
          *
-         * @param string $default
-         * @return string 
+         * @return bool 
          * @static 
-         */
-        public static function format($default = 'html'){
-            return \Illuminate\Http\Request::format($default);
+         */ 
+        public static function start()
+        {
+            return \Illuminate\Session\Store::start();
         }
         
         /**
-         * Retrieve an old input item.
+         * Save the session data to storage.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return bool 
          * @static 
-         */
-        public static function old($key = null, $default = null){
-            return \Illuminate\Http\Request::old($key, $default);
+         */ 
+        public static function save()
+        {
+            return \Illuminate\Session\Store::save();
         }
         
         /**
-         * Flash the input for the current request to the session.
+         * Age the flash data for the session.
          *
          * @return void 
          * @static 
-         */
-        public static function flash(){
-            \Illuminate\Http\Request::flash();
+         */ 
+        public static function ageFlashData()
+        {
+            \Illuminate\Session\Store::ageFlashData();
         }
         
         /**
-         * Flash only some of the input to the session.
+         * Get all of the session data.
          *
-         * @param array|mixed $keys
-         * @return void 
+         * @return array 
          * @static 
-         */
-        public static function flashOnly($keys){
-            \Illuminate\Http\Request::flashOnly($keys);
+         */ 
+        public static function all()
+        {
+            return \Illuminate\Session\Store::all();
         }
         
         /**
-         * Flash only some of the input to the session.
+         * Checks if a key exists.
          *
-         * @param array|mixed $keys
-         * @return void 
+         * @param string|array $key
+         * @return bool 
          * @static 
-         */
-        public static function flashExcept($keys){
-            \Illuminate\Http\Request::flashExcept($keys);
+         */ 
+        public static function exists($key)
+        {
+            return \Illuminate\Session\Store::exists($key);
         }
         
         /**
-         * Flush all of the old input from the session.
+         * Checks if a key is present and not null.
          *
-         * @return void 
+         * @param string|array $key
+         * @return bool 
          * @static 
-         */
-        public static function flush(){
-            \Illuminate\Http\Request::flush();
+         */ 
+        public static function has($key)
+        {
+            return \Illuminate\Session\Store::has($key);
         }
         
         /**
-         * Retrieve a server variable from the request.
+         * Get an item from the session.
          *
          * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param mixed $default
+         * @return mixed 
          * @static 
-         */
-        public static function server($key = null, $default = null){
-            return \Illuminate\Http\Request::server($key, $default);
+         */ 
+        public static function get($key, $default = null)
+        {
+            return \Illuminate\Session\Store::get($key, $default);
         }
         
         /**
-         * Determine if a header is set on the request.
+         * Get the value of a given key and then forget it.
          *
          * @param string $key
-         * @return bool 
+         * @param string $default
+         * @return mixed 
          * @static 
-         */
-        public static function hasHeader($key){
-            return \Illuminate\Http\Request::hasHeader($key);
+         */ 
+        public static function pull($key, $default = null)
+        {
+            return \Illuminate\Session\Store::pull($key, $default);
         }
         
         /**
-         * Retrieve a header from the request.
+         * Determine if the session contains old input.
          *
          * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return bool 
          * @static 
-         */
-        public static function header($key = null, $default = null){
-            return \Illuminate\Http\Request::header($key, $default);
+         */ 
+        public static function hasOldInput($key = null)
+        {
+            return \Illuminate\Session\Store::hasOldInput($key);
         }
         
         /**
-         * Get the bearer token from the request headers.
+         * Get the requested item from the flashed input array.
          *
-         * @return string|null 
+         * @param string $key
+         * @param mixed $default
+         * @return mixed 
          * @static 
-         */
-        public static function bearerToken(){
-            return \Illuminate\Http\Request::bearerToken();
+         */ 
+        public static function getOldInput($key = null, $default = null)
+        {
+            return \Illuminate\Session\Store::getOldInput($key, $default);
         }
         
         /**
-         * Determine if the request contains a given input item key.
+         * Replace the given session attributes entirely.
          *
-         * @param string|array $key
-         * @return bool 
+         * @param array $attributes
+         * @return void 
          * @static 
-         */
-        public static function exists($key){
-            return \Illuminate\Http\Request::exists($key);
+         */ 
+        public static function replace($attributes)
+        {
+            \Illuminate\Session\Store::replace($attributes);
         }
         
         /**
-         * Determine if the request contains a non-empty value for an input item.
+         * Put a key / value pair or array of key / value pairs in the session.
          *
          * @param string|array $key
-         * @return bool 
+         * @param mixed $value
+         * @return void 
          * @static 
-         */
-        public static function has($key){
-            return \Illuminate\Http\Request::has($key);
+         */ 
+        public static function put($key, $value = null)
+        {
+            \Illuminate\Session\Store::put($key, $value);
         }
         
         /**
-         * Get all of the input and files for the request.
+         * Get an item from the session, or store the default value.
          *
-         * @return array 
+         * @param string $key
+         * @param \Closure $callback
+         * @return mixed 
          * @static 
-         */
-        public static function all(){
-            return \Illuminate\Http\Request::all();
+         */ 
+        public static function remember($key, $callback)
+        {
+            return \Illuminate\Session\Store::remember($key, $callback);
         }
         
         /**
-         * Retrieve an input item from the request.
+         * Push a value onto a session array.
          *
          * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param mixed $value
+         * @return void 
          * @static 
-         */
-        public static function input($key = null, $default = null){
-            return \Illuminate\Http\Request::input($key, $default);
+         */ 
+        public static function push($key, $value)
+        {
+            \Illuminate\Session\Store::push($key, $value);
         }
         
         /**
-         * Get a subset containing the provided keys with values from the input data.
+         * Increment the value of an item in the session.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param string $key
+         * @param int $amount
+         * @return mixed 
          * @static 
-         */
-        public static function only($keys){
-            return \Illuminate\Http\Request::only($keys);
+         */ 
+        public static function increment($key, $amount = 1)
+        {
+            return \Illuminate\Session\Store::increment($key, $amount);
         }
         
         /**
-         * Get all of the input except for a specified array of items.
+         * Decrement the value of an item in the session.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param string $key
+         * @param int $amount
+         * @return int 
          * @static 
-         */
-        public static function except($keys){
-            return \Illuminate\Http\Request::except($keys);
+         */ 
+        public static function decrement($key, $amount = 1)
+        {
+            return \Illuminate\Session\Store::decrement($key, $amount);
         }
         
         /**
-         * Intersect an array of items with the input data.
+         * Flash a key / value pair to the session.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param string $key
+         * @param mixed $value
+         * @return void 
          * @static 
-         */
-        public static function intersect($keys){
-            return \Illuminate\Http\Request::intersect($keys);
+         */ 
+        public static function flash($key, $value = true)
+        {
+            \Illuminate\Session\Store::flash($key, $value);
         }
         
         /**
-         * Retrieve a query string item from the request.
+         * Flash a key / value pair to the session for immediate use.
          *
          * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param mixed $value
+         * @return void 
          * @static 
-         */
-        public static function query($key = null, $default = null){
-            return \Illuminate\Http\Request::query($key, $default);
+         */ 
+        public static function now($key, $value)
+        {
+            \Illuminate\Session\Store::now($key, $value);
         }
         
         /**
-         * Determine if a cookie is set on the request.
+         * Reflash all of the session flash data.
          *
-         * @param string $key
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function hasCookie($key){
-            return \Illuminate\Http\Request::hasCookie($key);
+         */ 
+        public static function reflash()
+        {
+            \Illuminate\Session\Store::reflash();
         }
         
         /**
-         * Retrieve a cookie from the request.
+         * Reflash a subset of the current flash data.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param array|mixed $keys
+         * @return void 
          * @static 
-         */
-        public static function cookie($key = null, $default = null){
-            return \Illuminate\Http\Request::cookie($key, $default);
+         */ 
+        public static function keep($keys = null)
+        {
+            \Illuminate\Session\Store::keep($keys);
         }
         
         /**
-         * Get an array of all of the files on the request.
+         * Flash an input array to the session.
          *
-         * @return array 
+         * @param array $value
+         * @return void 
          * @static 
-         */
-        public static function allFiles(){
-            return \Illuminate\Http\Request::allFiles();
+         */ 
+        public static function flashInput($value)
+        {
+            \Illuminate\Session\Store::flashInput($value);
         }
         
         /**
-         * Determine if the uploaded data contains a file.
+         * Remove an item from the session, returning its value.
          *
          * @param string $key
-         * @return bool 
+         * @return mixed 
          * @static 
-         */
-        public static function hasFile($key){
-            return \Illuminate\Http\Request::hasFile($key);
+         */ 
+        public static function remove($key)
+        {
+            return \Illuminate\Session\Store::remove($key);
         }
         
         /**
-         * Retrieve a file from the request.
+         * Remove one or many items from the session.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return \Illuminate\Http\UploadedFile|array|null 
+         * @param string|array $keys
+         * @return void 
          * @static 
-         */
-        public static function file($key = null, $default = null){
-            return \Illuminate\Http\Request::file($key, $default);
+         */ 
+        public static function forget($keys)
+        {
+            \Illuminate\Session\Store::forget($keys);
         }
         
         /**
-         * Register a custom macro.
+         * Remove all of the items from the session.
          *
-         * @param string $name
-         * @param callable $macro
          * @return void 
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Http\Request::macro($name, $macro);
+         */ 
+        public static function flush()
+        {
+            \Illuminate\Session\Store::flush();
         }
         
         /**
-         * Checks if macro is registered.
+         * Flush the session data and regenerate the ID.
          *
-         * @param string $name
          * @return bool 
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Http\Request::hasMacro($name);
+         */ 
+        public static function invalidate()
+        {
+            return \Illuminate\Session\Store::invalidate();
         }
         
-    }
-
-
-    class Response extends \Illuminate\Support\Facades\Response{
+        /**
+         * Generate a new session identifier.
+         *
+         * @param bool $destroy
+         * @return bool 
+         * @static 
+         */ 
+        public static function regenerate($destroy = false)
+        {
+            return \Illuminate\Session\Store::regenerate($destroy);
+        }
         
         /**
-         * Return a new response from the application.
+         * Generate a new session ID for the session.
          *
-         * @param string $content
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\Response 
+         * @param bool $destroy
+         * @return bool 
          * @static 
-         */
-        public static function make($content = '', $status = 200, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::make($content, $status, $headers);
+         */ 
+        public static function migrate($destroy = false)
+        {
+            return \Illuminate\Session\Store::migrate($destroy);
         }
         
         /**
-         * Return a new view response from the application.
+         * Determine if the session has been started.
          *
-         * @param string $view
-         * @param array $data
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\Response 
+         * @return bool 
          * @static 
-         */
-        public static function view($view, $data = array(), $status = 200, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::view($view, $data, $status, $headers);
+         */ 
+        public static function isStarted()
+        {
+            return \Illuminate\Session\Store::isStarted();
         }
         
         /**
-         * Return a new JSON response from the application.
+         * Get the name of the session.
          *
-         * @param mixed $data
-         * @param int $status
-         * @param array $headers
-         * @param int $options
-         * @return \Illuminate\Http\JsonResponse 
+         * @return string 
          * @static 
-         */
-        public static function json($data = array(), $status = 200, $headers = array(), $options = 0){
-            return \Illuminate\Routing\ResponseFactory::json($data, $status, $headers, $options);
+         */ 
+        public static function getName()
+        {
+            return \Illuminate\Session\Store::getName();
         }
         
         /**
-         * Return a new JSONP response from the application.
+         * Set the name of the session.
          *
-         * @param string $callback
-         * @param mixed $data
-         * @param int $status
-         * @param array $headers
-         * @param int $options
-         * @return \Illuminate\Http\JsonResponse 
+         * @param string $name
+         * @return void 
          * @static 
-         */
-        public static function jsonp($callback, $data = array(), $status = 200, $headers = array(), $options = 0){
-            return \Illuminate\Routing\ResponseFactory::jsonp($callback, $data, $status, $headers, $options);
+         */ 
+        public static function setName($name)
+        {
+            \Illuminate\Session\Store::setName($name);
         }
         
         /**
-         * Return a new streamed response from the application.
+         * Get the current session ID.
          *
-         * @param \Closure $callback
-         * @param int $status
-         * @param array $headers
-         * @return \Symfony\Component\HttpFoundation\StreamedResponse 
+         * @return string 
          * @static 
-         */
-        public static function stream($callback, $status = 200, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::stream($callback, $status, $headers);
+         */ 
+        public static function getId()
+        {
+            return \Illuminate\Session\Store::getId();
         }
         
         /**
-         * Create a new file download response.
+         * Set the session ID.
          *
-         * @param \SplFileInfo|string $file
-         * @param string $name
-         * @param array $headers
-         * @param string|null $disposition
-         * @return \Symfony\Component\HttpFoundation\BinaryFileResponse 
+         * @param string $id
+         * @return void 
          * @static 
-         */
-        public static function download($file, $name = null, $headers = array(), $disposition = 'attachment'){
-            return \Illuminate\Routing\ResponseFactory::download($file, $name, $headers, $disposition);
+         */ 
+        public static function setId($id)
+        {
+            \Illuminate\Session\Store::setId($id);
         }
         
         /**
-         * Return the raw contents of a binary file.
+         * Determine if this is a valid session ID.
          *
-         * @param \SplFileInfo|string $file
-         * @param array $headers
-         * @return \Symfony\Component\HttpFoundation\BinaryFileResponse 
+         * @param string $id
+         * @return bool 
          * @static 
-         */
-        public static function file($file, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::file($file, $headers);
+         */ 
+        public static function isValidId($id)
+        {
+            return \Illuminate\Session\Store::isValidId($id);
         }
         
         /**
-         * Create a new redirect response to the given path.
+         * Set the existence of the session on the handler if applicable.
          *
-         * @param string $path
-         * @param int $status
-         * @param array $headers
-         * @param bool|null $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param bool $value
+         * @return void 
          * @static 
-         */
-        public static function redirectTo($path, $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\ResponseFactory::redirectTo($path, $status, $headers, $secure);
+         */ 
+        public static function setExists($value)
+        {
+            \Illuminate\Session\Store::setExists($value);
         }
         
         /**
-         * Create a new redirect response to a named route.
+         * Get the CSRF token value.
          *
-         * @param string $route
-         * @param array $parameters
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @return string 
          * @static 
-         */
-        public static function redirectToRoute($route, $parameters = array(), $status = 302, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::redirectToRoute($route, $parameters, $status, $headers);
+         */ 
+        public static function token()
+        {
+            return \Illuminate\Session\Store::token();
         }
         
         /**
-         * Create a new redirect response to a controller action.
+         * Regenerate the CSRF token value.
          *
-         * @param string $action
-         * @param array $parameters
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @return void 
          * @static 
-         */
-        public static function redirectToAction($action, $parameters = array(), $status = 302, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::redirectToAction($action, $parameters, $status, $headers);
+         */ 
+        public static function regenerateToken()
+        {
+            \Illuminate\Session\Store::regenerateToken();
         }
         
         /**
-         * Create a new redirect response, while putting the current URL in the session.
+         * Get the previous URL from the session.
          *
-         * @param string $path
-         * @param int $status
-         * @param array $headers
-         * @param bool|null $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @return string|null 
          * @static 
-         */
-        public static function redirectGuest($path, $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\ResponseFactory::redirectGuest($path, $status, $headers, $secure);
+         */ 
+        public static function previousUrl()
+        {
+            return \Illuminate\Session\Store::previousUrl();
         }
         
         /**
-         * Create a new redirect response to the previously intended location.
+         * Set the "previous" URL in the session.
          *
-         * @param string $default
-         * @param int $status
-         * @param array $headers
-         * @param bool|null $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string $url
+         * @return void 
          * @static 
-         */
-        public static function redirectToIntended($default = '/', $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\ResponseFactory::redirectToIntended($default, $status, $headers, $secure);
+         */ 
+        public static function setPreviousUrl($url)
+        {
+            \Illuminate\Session\Store::setPreviousUrl($url);
         }
         
         /**
-         * Register a custom macro.
+         * Get the underlying session handler implementation.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @return \SessionHandlerInterface 
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Routing\ResponseFactory::macro($name, $macro);
+         */ 
+        public static function getHandler()
+        {
+            return \Illuminate\Session\Store::getHandler();
         }
         
         /**
-         * Checks if macro is registered.
+         * Determine if the session handler needs a request.
          *
-         * @param string $name
          * @return bool 
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Routing\ResponseFactory::hasMacro($name);
+         */ 
+        public static function handlerNeedsRequest()
+        {
+            return \Illuminate\Session\Store::handlerNeedsRequest();
         }
         
-    }
-
-
-    class Route extends \Illuminate\Support\Facades\Route{
-        
         /**
-         * Register a new GET route with the router.
+         * Set the request on the handler instance.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param \Illuminate\Http\Request $request
+         * @return void 
          * @static 
-         */
-        public static function get($uri, $action = null){
-            return \Illuminate\Routing\Router::get($uri, $action);
+         */ 
+        public static function setRequestOnHandler($request)
+        {
+            \Illuminate\Session\Store::setRequestOnHandler($request);
         }
+         
+    }
+
+    class Storage {
         
         /**
-         * Register a new POST route with the router.
+         * Get a filesystem instance.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param string $name
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
-         */
-        public static function post($uri, $action = null){
-            return \Illuminate\Routing\Router::post($uri, $action);
+         */ 
+        public static function drive($name = null)
+        {
+            return \Illuminate\Filesystem\FilesystemManager::drive($name);
         }
         
         /**
-         * Register a new PUT route with the router.
+         * Get a filesystem instance.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param string $name
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
-         */
-        public static function put($uri, $action = null){
-            return \Illuminate\Routing\Router::put($uri, $action);
+         */ 
+        public static function disk($name = null)
+        {
+            return \Illuminate\Filesystem\FilesystemManager::disk($name);
         }
         
         /**
-         * Register a new PATCH route with the router.
+         * Get a default cloud filesystem instance.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
-         */
-        public static function patch($uri, $action = null){
-            return \Illuminate\Routing\Router::patch($uri, $action);
+         */ 
+        public static function cloud()
+        {
+            return \Illuminate\Filesystem\FilesystemManager::cloud();
         }
         
         /**
-         * Register a new DELETE route with the router.
+         * Create an instance of the local driver.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param array $config
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
-         */
-        public static function delete($uri, $action = null){
-            return \Illuminate\Routing\Router::delete($uri, $action);
+         */ 
+        public static function createLocalDriver($config)
+        {
+            return \Illuminate\Filesystem\FilesystemManager::createLocalDriver($config);
         }
         
         /**
-         * Register a new OPTIONS route with the router.
+         * Create an instance of the ftp driver.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param array $config
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
-         */
-        public static function options($uri, $action = null){
-            return \Illuminate\Routing\Router::options($uri, $action);
+         */ 
+        public static function createFtpDriver($config)
+        {
+            return \Illuminate\Filesystem\FilesystemManager::createFtpDriver($config);
         }
         
         /**
-         * Register a new route responding to all verbs.
+         * Create an instance of the sftp driver.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param array $config
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
-         */
-        public static function any($uri, $action = null){
-            return \Illuminate\Routing\Router::any($uri, $action);
+         */ 
+        public static function createSftpDriver($config)
+        {
+            return \Illuminate\Filesystem\FilesystemManager::createSftpDriver($config);
         }
         
         /**
-         * Register a new route with the given verbs.
+         * Create an instance of the Amazon S3 driver.
          *
-         * @param array|string $methods
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param array $config
+         * @return \Illuminate\Contracts\Filesystem\Cloud 
          * @static 
-         */
-        public static function match($methods, $uri, $action = null){
-            return \Illuminate\Routing\Router::match($methods, $uri, $action);
+         */ 
+        public static function createS3Driver($config)
+        {
+            return \Illuminate\Filesystem\FilesystemManager::createS3Driver($config);
         }
         
         /**
-         * Register an array of resource controllers.
+         * Create an instance of the Rackspace driver.
          *
-         * @param array $resources
-         * @return void 
+         * @param array $config
+         * @return \Illuminate\Contracts\Filesystem\Cloud 
          * @static 
-         */
-        public static function resources($resources){
-            \Illuminate\Routing\Router::resources($resources);
+         */ 
+        public static function createRackspaceDriver($config)
+        {
+            return \Illuminate\Filesystem\FilesystemManager::createRackspaceDriver($config);
         }
         
         /**
-         * Route a resource to a controller.
+         * Set the given disk instance.
          *
          * @param string $name
-         * @param string $controller
-         * @param array $options
+         * @param mixed $disk
          * @return void 
          * @static 
-         */
-        public static function resource($name, $controller, $options = array()){
-            \Illuminate\Routing\Router::resource($name, $controller, $options);
+         */ 
+        public static function set($name, $disk)
+        {
+            \Illuminate\Filesystem\FilesystemManager::set($name, $disk);
         }
         
         /**
-         * Route an api resource to a controller.
+         * Get the default driver name.
          *
-         * @param string $name
-         * @param string $controller
-         * @param array $options
-         * @return void 
+         * @return string 
          * @static 
-         */
-        public static function apiResource($name, $controller, $options = array()){
-            \Illuminate\Routing\Router::apiResource($name, $controller, $options);
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \Illuminate\Filesystem\FilesystemManager::getDefaultDriver();
         }
         
         /**
-         * Create a route group with shared attributes.
+         * Get the default cloud driver name.
          *
-         * @param array $attributes
-         * @param \Closure|string $routes
-         * @return void 
+         * @return string 
          * @static 
-         */
-        public static function group($attributes, $routes){
-            \Illuminate\Routing\Router::group($attributes, $routes);
+         */ 
+        public static function getDefaultCloudDriver()
+        {
+            return \Illuminate\Filesystem\FilesystemManager::getDefaultCloudDriver();
         }
         
         /**
-         * Merge the given array with the last group stack.
+         * Register a custom driver creator Closure.
          *
-         * @param array $new
-         * @return array 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function mergeWithLastGroup($new){
-            return \Illuminate\Routing\Router::mergeWithLastGroup($new);
+         */ 
+        public static function extend($driver, $callback)
+        {
+            return \Illuminate\Filesystem\FilesystemManager::extend($driver, $callback);
         }
         
         /**
-         * Get the prefix from the last group on the stack.
+         * Assert that the given file exists.
          *
-         * @return string 
+         * @param string $path
+         * @return void 
          * @static 
-         */
-        public static function getLastGroupPrefix(){
-            return \Illuminate\Routing\Router::getLastGroupPrefix();
+         */ 
+        public static function assertExists($path)
+        {
+            \Illuminate\Filesystem\FilesystemAdapter::assertExists($path);
         }
         
         /**
-         * Dispatch the request to the application.
+         * Assert that the given file does not exist.
          *
-         * @param \Illuminate\Http\Request $request
-         * @return \Illuminate\Http\Response 
+         * @param string $path
+         * @return void 
          * @static 
-         */
-        public static function dispatch($request){
-            return \Illuminate\Routing\Router::dispatch($request);
+         */ 
+        public static function assertMissing($path)
+        {
+            \Illuminate\Filesystem\FilesystemAdapter::assertMissing($path);
         }
         
         /**
-         * Dispatch the request to a route and return the response.
+         * Determine if a file exists.
          *
-         * @param \Illuminate\Http\Request $request
-         * @return mixed 
+         * @param string $path
+         * @return bool 
          * @static 
-         */
-        public static function dispatchToRoute($request){
-            return \Illuminate\Routing\Router::dispatchToRoute($request);
+         */ 
+        public static function exists($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::exists($path);
         }
         
         /**
-         * Gather the middleware for the given route with resolved class names.
+         * Get the full path for the file at the given "short" path.
          *
-         * @param \Illuminate\Routing\Route $route
-         * @return array 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function gatherRouteMiddleware($route){
-            return \Illuminate\Routing\Router::gatherRouteMiddleware($route);
+         */ 
+        public static function path($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::path($path);
         }
         
         /**
-         * Create a response instance from the given value.
+         * Get the contents of a file.
          *
-         * @param \Symfony\Component\HttpFoundation\Request $request
-         * @param mixed $response
-         * @return \Illuminate\Http\Response 
+         * @param string $path
+         * @return string 
+         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
          * @static 
-         */
-        public static function prepareResponse($request, $response){
-            return \Illuminate\Routing\Router::prepareResponse($request, $response);
+         */ 
+        public static function get($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::get($path);
         }
         
         /**
-         * Substitute the route bindings onto the route.
+         * Create a streamed response for a given file.
          *
-         * @param \Illuminate\Routing\Route $route
-         * @return \Illuminate\Routing\Route 
+         * @param string $path
+         * @param string|null $name
+         * @param array|null $headers
+         * @param string|null $disposition
+         * @return \Symfony\Component\HttpFoundation\StreamedResponse 
          * @static 
-         */
-        public static function substituteBindings($route){
-            return \Illuminate\Routing\Router::substituteBindings($route);
+         */ 
+        public static function response($path, $name = null, $headers = array(), $disposition = 'inline')
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::response($path, $name, $headers, $disposition);
         }
         
         /**
-         * Substitute the implicit Eloquent model bindings for the route.
+         * Create a streamed download response for a given file.
          *
-         * @param \Illuminate\Routing\Route $route
-         * @return void 
+         * @param string $path
+         * @param string|null $name
+         * @param array|null $headers
+         * @return \Symfony\Component\HttpFoundation\StreamedResponse 
          * @static 
-         */
-        public static function substituteImplicitBindings($route){
-            \Illuminate\Routing\Router::substituteImplicitBindings($route);
+         */ 
+        public static function download($path, $name = null, $headers = array())
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::download($path, $name, $headers);
         }
         
         /**
-         * Register a route matched event listener.
+         * Write the contents of a file.
          *
-         * @param string|callable $callback
-         * @return void 
+         * @param string $path
+         * @param string|resource $contents
+         * @param mixed $options
+         * @return bool 
          * @static 
-         */
-        public static function matched($callback){
-            \Illuminate\Routing\Router::matched($callback);
+         */ 
+        public static function put($path, $contents, $options = array())
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::put($path, $contents, $options);
         }
         
         /**
-         * Get all of the defined middleware short-hand names.
+         * Store the uploaded file on the disk.
          *
-         * @return array 
+         * @param string $path
+         * @param \Illuminate\Http\File|\Illuminate\Http\UploadedFile $file
+         * @param array $options
+         * @return string|false 
          * @static 
-         */
-        public static function getMiddleware(){
-            return \Illuminate\Routing\Router::getMiddleware();
+         */ 
+        public static function putFile($path, $file, $options = array())
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::putFile($path, $file, $options);
         }
         
         /**
-         * Register a short-hand name for a middleware.
+         * Store the uploaded file on the disk with a given name.
          *
+         * @param string $path
+         * @param \Illuminate\Http\File|\Illuminate\Http\UploadedFile $file
          * @param string $name
-         * @param string $class
-         * @return $this 
+         * @param array $options
+         * @return string|false 
          * @static 
-         */
-        public static function aliasMiddleware($name, $class){
-            return \Illuminate\Routing\Router::aliasMiddleware($name, $class);
+         */ 
+        public static function putFileAs($path, $file, $name, $options = array())
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::putFileAs($path, $file, $name, $options);
         }
         
         /**
-         * Check if a middlewareGroup with the given name exists.
+         * Get the visibility for the given path.
          *
-         * @param string $name
-         * @return bool 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function hasMiddlewareGroup($name){
-            return \Illuminate\Routing\Router::hasMiddlewareGroup($name);
+         */ 
+        public static function getVisibility($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::getVisibility($path);
         }
         
         /**
-         * Get all of the defined middleware groups.
+         * Set the visibility for the given path.
          *
-         * @return array 
+         * @param string $path
+         * @param string $visibility
+         * @return void 
          * @static 
-         */
-        public static function getMiddlewareGroups(){
-            return \Illuminate\Routing\Router::getMiddlewareGroups();
+         */ 
+        public static function setVisibility($path, $visibility)
+        {
+            \Illuminate\Filesystem\FilesystemAdapter::setVisibility($path, $visibility);
         }
         
         /**
-         * Register a group of middleware.
+         * Prepend to a file.
          *
-         * @param string $name
-         * @param array $middleware
-         * @return $this 
+         * @param string $path
+         * @param string $data
+         * @param string $separator
+         * @return int 
          * @static 
-         */
-        public static function middlewareGroup($name, $middleware){
-            return \Illuminate\Routing\Router::middlewareGroup($name, $middleware);
+         */ 
+        public static function prepend($path, $data, $separator = '')
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::prepend($path, $data, $separator);
         }
         
         /**
-         * Add a middleware to the beginning of a middleware group.
-         * 
-         * If the middleware is already in the group, it will not be added again.
+         * Append to a file.
          *
-         * @param string $group
-         * @param string $middleware
-         * @return $this 
+         * @param string $path
+         * @param string $data
+         * @param string $separator
+         * @return int 
          * @static 
-         */
-        public static function prependMiddlewareToGroup($group, $middleware){
-            return \Illuminate\Routing\Router::prependMiddlewareToGroup($group, $middleware);
+         */ 
+        public static function append($path, $data, $separator = '')
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::append($path, $data, $separator);
         }
         
         /**
-         * Add a middleware to the end of a middleware group.
-         * 
-         * If the middleware is already in the group, it will not be added again.
+         * Delete the file at a given path.
          *
-         * @param string $group
-         * @param string $middleware
-         * @return $this 
+         * @param string|array $paths
+         * @return bool 
          * @static 
-         */
-        public static function pushMiddlewareToGroup($group, $middleware){
-            return \Illuminate\Routing\Router::pushMiddlewareToGroup($group, $middleware);
+         */ 
+        public static function delete($paths)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::delete($paths);
         }
         
         /**
-         * Add a new route parameter binder.
+         * Copy a file to a new location.
          *
-         * @param string $key
-         * @param string|callable $binder
-         * @return void 
+         * @param string $from
+         * @param string $to
+         * @return bool 
          * @static 
-         */
-        public static function bind($key, $binder){
-            \Illuminate\Routing\Router::bind($key, $binder);
+         */ 
+        public static function copy($from, $to)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::copy($from, $to);
         }
         
         /**
-         * Register a model binder for a wildcard.
+         * Move a file to a new location.
          *
-         * @param string $key
-         * @param string $class
-         * @param \Closure|null $callback
-         * @return void 
-         * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
+         * @param string $from
+         * @param string $to
+         * @return bool 
          * @static 
-         */
-        public static function model($key, $class, $callback = null){
-            \Illuminate\Routing\Router::model($key, $class, $callback);
+         */ 
+        public static function move($from, $to)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::move($from, $to);
         }
         
         /**
-         * Get the binding callback for a given binding.
+         * Get the file size of a given file.
          *
-         * @param string $key
-         * @return \Closure|null 
+         * @param string $path
+         * @return int 
          * @static 
-         */
-        public static function getBindingCallback($key){
-            return \Illuminate\Routing\Router::getBindingCallback($key);
+         */ 
+        public static function size($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::size($path);
         }
         
         /**
-         * Get the global "where" patterns.
+         * Get the mime-type of a given file.
          *
-         * @return array 
+         * @param string $path
+         * @return string|false 
          * @static 
-         */
-        public static function getPatterns(){
-            return \Illuminate\Routing\Router::getPatterns();
+         */ 
+        public static function mimeType($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::mimeType($path);
         }
         
         /**
-         * Set a global where pattern on all routes.
+         * Get the file's last modification time.
          *
-         * @param string $key
-         * @param string $pattern
-         * @return void 
+         * @param string $path
+         * @return int 
          * @static 
-         */
-        public static function pattern($key, $pattern){
-            \Illuminate\Routing\Router::pattern($key, $pattern);
+         */ 
+        public static function lastModified($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::lastModified($path);
         }
         
         /**
-         * Set a group of global where patterns on all routes.
+         * Get the URL for the file at the given path.
          *
-         * @param array $patterns
-         * @return void 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function patterns($patterns){
-            \Illuminate\Routing\Router::patterns($patterns);
+         */ 
+        public static function url($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::url($path);
         }
         
         /**
-         * Determine if the router currently has a group stack.
+         * Get a temporary URL for the file at the given path.
          *
-         * @return bool 
+         * @param string $path
+         * @param \DateTimeInterface $expiration
+         * @param array $options
+         * @return string 
          * @static 
-         */
-        public static function hasGroupStack(){
-            return \Illuminate\Routing\Router::hasGroupStack();
+         */ 
+        public static function temporaryUrl($path, $expiration, $options = array())
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::temporaryUrl($path, $expiration, $options);
         }
         
         /**
-         * Get the current group stack for the router.
+         * Get a temporary URL for the file at the given path.
          *
-         * @return array 
+         * @param \League\Flysystem\AwsS3v3\AwsS3Adapter $adapter
+         * @param string $path
+         * @param \DateTimeInterface $expiration
+         * @param array $options
+         * @return string 
          * @static 
-         */
-        public static function getGroupStack(){
-            return \Illuminate\Routing\Router::getGroupStack();
+         */ 
+        public static function getAwsTemporaryUrl($adapter, $path, $expiration, $options)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::getAwsTemporaryUrl($adapter, $path, $expiration, $options);
         }
         
         /**
-         * Get a route parameter for the current route.
+         * Get a temporary URL for the file at the given path.
          *
-         * @param string $key
-         * @param string $default
-         * @return mixed 
+         * @param \League\Flysystem\Rackspace\RackspaceAdapter $adapter
+         * @param string $path
+         * @param \DateTimeInterface $expiration
+         * @param array $options
+         * @return string 
          * @static 
-         */
-        public static function input($key, $default = null){
-            return \Illuminate\Routing\Router::input($key, $default);
+         */ 
+        public static function getRackspaceTemporaryUrl($adapter, $path, $expiration, $options)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::getRackspaceTemporaryUrl($adapter, $path, $expiration, $options);
         }
         
         /**
-         * Get the request currently being dispatched.
+         * Get an array of all files in a directory.
          *
-         * @return \Illuminate\Http\Request 
+         * @param string|null $directory
+         * @param bool $recursive
+         * @return array 
          * @static 
-         */
-        public static function getCurrentRequest(){
-            return \Illuminate\Routing\Router::getCurrentRequest();
+         */ 
+        public static function files($directory = null, $recursive = false)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::files($directory, $recursive);
         }
         
         /**
-         * Get the currently dispatched route instance.
+         * Get all of the files from the given directory (recursive).
          *
-         * @return \Illuminate\Routing\Route 
+         * @param string|null $directory
+         * @return array 
          * @static 
-         */
-        public static function getCurrentRoute(){
-            return \Illuminate\Routing\Router::getCurrentRoute();
+         */ 
+        public static function allFiles($directory = null)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::allFiles($directory);
         }
         
         /**
-         * Get the currently dispatched route instance.
+         * Get all of the directories within a given directory.
          *
-         * @return \Illuminate\Routing\Route 
+         * @param string|null $directory
+         * @param bool $recursive
+         * @return array 
          * @static 
-         */
-        public static function current(){
-            return \Illuminate\Routing\Router::current();
+         */ 
+        public static function directories($directory = null, $recursive = false)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::directories($directory, $recursive);
         }
         
         /**
-         * Check if a route with the given name exists.
+         * Get all (recursive) of the directories within a given directory.
          *
-         * @param string $name
-         * @return bool 
+         * @param string|null $directory
+         * @return array 
          * @static 
-         */
-        public static function has($name){
-            return \Illuminate\Routing\Router::has($name);
+         */ 
+        public static function allDirectories($directory = null)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::allDirectories($directory);
         }
         
         /**
-         * Get the current route name.
+         * Create a directory.
          *
-         * @return string|null 
+         * @param string $path
+         * @return bool 
          * @static 
-         */
-        public static function currentRouteName(){
-            return \Illuminate\Routing\Router::currentRouteName();
+         */ 
+        public static function makeDirectory($path)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::makeDirectory($path);
         }
         
         /**
-         * Alias for the "currentRouteNamed" method.
+         * Recursively delete a directory.
          *
+         * @param string $directory
          * @return bool 
          * @static 
-         */
-        public static function is(){
-            return \Illuminate\Routing\Router::is();
+         */ 
+        public static function deleteDirectory($directory)
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::deleteDirectory($directory);
         }
         
         /**
-         * Determine if the current route matches a given name.
+         * Flush the Flysystem cache.
          *
-         * @param string $name
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function currentRouteNamed($name){
-            return \Illuminate\Routing\Router::currentRouteNamed($name);
+         */ 
+        public static function flushCache()
+        {
+            \Illuminate\Filesystem\FilesystemAdapter::flushCache();
         }
         
         /**
-         * Get the current route action.
+         * Get the Flysystem driver.
          *
-         * @return string|null 
+         * @return \League\Flysystem\FilesystemInterface 
          * @static 
-         */
-        public static function currentRouteAction(){
-            return \Illuminate\Routing\Router::currentRouteAction();
+         */ 
+        public static function getDriver()
+        {
+            return \Illuminate\Filesystem\FilesystemAdapter::getDriver();
         }
+         
+    }
+
+    class URL {
         
         /**
-         * Alias for the "currentRouteUses" method.
+         * Get the full URL for the current request.
          *
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function uses(){
-            return \Illuminate\Routing\Router::uses();
+         */ 
+        public static function full()
+        {
+            return \Illuminate\Routing\UrlGenerator::full();
         }
         
         /**
-         * Determine if the current route action matches a given action.
+         * Get the current URL for the request.
          *
-         * @param string $action
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function currentRouteUses($action){
-            return \Illuminate\Routing\Router::currentRouteUses($action);
+         */ 
+        public static function current()
+        {
+            return \Illuminate\Routing\UrlGenerator::current();
         }
         
         /**
-         * Register the typical authentication routes for an application.
+         * Get the URL for the previous request.
          *
-         * @return void 
+         * @param mixed $fallback
+         * @return string 
          * @static 
-         */
-        public static function auth(){
-            \Illuminate\Routing\Router::auth();
+         */ 
+        public static function previous($fallback = false)
+        {
+            return \Illuminate\Routing\UrlGenerator::previous($fallback);
         }
         
         /**
-         * Set the unmapped global resource parameters to singular.
+         * Generate an absolute URL to the given path.
          *
-         * @param bool $singular
-         * @return void 
+         * @param string $path
+         * @param mixed $extra
+         * @param bool|null $secure
+         * @return string 
          * @static 
-         */
-        public static function singularResourceParameters($singular = true){
-            \Illuminate\Routing\Router::singularResourceParameters($singular);
+         */ 
+        public static function to($path, $extra = array(), $secure = null)
+        {
+            return \Illuminate\Routing\UrlGenerator::to($path, $extra, $secure);
         }
         
         /**
-         * Set the global resource parameter mapping.
+         * Generate a secure, absolute URL to the given path.
          *
+         * @param string $path
          * @param array $parameters
-         * @return void 
+         * @return string 
          * @static 
-         */
-        public static function resourceParameters($parameters = array()){
-            \Illuminate\Routing\Router::resourceParameters($parameters);
+         */ 
+        public static function secure($path, $parameters = array())
+        {
+            return \Illuminate\Routing\UrlGenerator::secure($path, $parameters);
         }
         
         /**
-         * Get or set the verbs used in the resource URIs.
+         * Generate the URL to an application asset.
          *
-         * @param array $verbs
-         * @return array|null 
+         * @param string $path
+         * @param bool|null $secure
+         * @return string 
          * @static 
-         */
-        public static function resourceVerbs($verbs = array()){
-            return \Illuminate\Routing\Router::resourceVerbs($verbs);
+         */ 
+        public static function asset($path, $secure = null)
+        {
+            return \Illuminate\Routing\UrlGenerator::asset($path, $secure);
         }
         
         /**
-         * Get the underlying route collection.
+         * Generate the URL to a secure asset.
          *
-         * @return \Illuminate\Routing\RouteCollection 
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function getRoutes(){
-            return \Illuminate\Routing\Router::getRoutes();
+         */ 
+        public static function secureAsset($path)
+        {
+            return \Illuminate\Routing\UrlGenerator::secureAsset($path);
         }
         
         /**
-         * Set the route collection instance.
+         * Generate the URL to an asset from a custom root domain such as CDN, etc.
          *
-         * @param \Illuminate\Routing\RouteCollection $routes
-         * @return void 
+         * @param string $root
+         * @param string $path
+         * @param bool|null $secure
+         * @return string 
          * @static 
-         */
-        public static function setRoutes($routes){
-            \Illuminate\Routing\Router::setRoutes($routes);
+         */ 
+        public static function assetFrom($root, $path, $secure = null)
+        {
+            return \Illuminate\Routing\UrlGenerator::assetFrom($root, $path, $secure);
         }
         
         /**
-         * Register a custom macro.
+         * Get the default scheme for a raw URL.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @param bool|null $secure
+         * @return string 
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Routing\Router::macro($name, $macro);
+         */ 
+        public static function formatScheme($secure)
+        {
+            return \Illuminate\Routing\UrlGenerator::formatScheme($secure);
         }
         
         /**
-         * Checks if macro is registered.
+         * Get the URL to a named route.
          *
          * @param string $name
-         * @return bool 
+         * @param mixed $parameters
+         * @param bool $absolute
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Routing\Router::hasMacro($name);
+         */ 
+        public static function route($name, $parameters = array(), $absolute = true)
+        {
+            return \Illuminate\Routing\UrlGenerator::route($name, $parameters, $absolute);
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Get the URL to a controller action.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return mixed 
-         * @throws \BadMethodCallException
+         * @param string $action
+         * @param mixed $parameters
+         * @param bool $absolute
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function macroCall($method, $parameters){
-            return \Illuminate\Routing\Router::macroCall($method, $parameters);
+         */ 
+        public static function action($action, $parameters = array(), $absolute = true)
+        {
+            return \Illuminate\Routing\UrlGenerator::action($action, $parameters, $absolute);
         }
         
-    }
-
-
-    class Schema extends \Illuminate\Support\Facades\Schema{
-        
         /**
-         * Determine if the given table exists.
+         * Format the array of URL parameters.
          *
-         * @param string $table
-         * @return bool 
+         * @param mixed|array $parameters
+         * @return array 
          * @static 
-         */
-        public static function hasTable($table){
-            return \Illuminate\Database\Schema\MySqlBuilder::hasTable($table);
+         */ 
+        public static function formatParameters($parameters)
+        {
+            return \Illuminate\Routing\UrlGenerator::formatParameters($parameters);
         }
         
         /**
-         * Get the column listing for a given table.
+         * Get the base URL for the request.
          *
-         * @param string $table
-         * @return array 
+         * @param string $scheme
+         * @param string $root
+         * @return string 
          * @static 
-         */
-        public static function getColumnListing($table){
-            return \Illuminate\Database\Schema\MySqlBuilder::getColumnListing($table);
+         */ 
+        public static function formatRoot($scheme, $root = null)
+        {
+            return \Illuminate\Routing\UrlGenerator::formatRoot($scheme, $root);
         }
         
         /**
-         * Set the default string length for migrations.
+         * Format the given URL segments into a single URL.
          *
-         * @param int $length
-         * @return void 
+         * @param string $root
+         * @param string $path
+         * @return string 
          * @static 
-         */
-        public static function defaultStringLength($length){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            \Illuminate\Database\Schema\MySqlBuilder::defaultStringLength($length);
+         */ 
+        public static function format($root, $path)
+        {
+            return \Illuminate\Routing\UrlGenerator::format($root, $path);
         }
         
         /**
-         * Determine if the given table has a given column.
+         * Determine if the given path is a valid URL.
          *
-         * @param string $table
-         * @param string $column
+         * @param string $path
          * @return bool 
          * @static 
-         */
-        public static function hasColumn($table, $column){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::hasColumn($table, $column);
+         */ 
+        public static function isValidUrl($path)
+        {
+            return \Illuminate\Routing\UrlGenerator::isValidUrl($path);
         }
         
         /**
-         * Determine if the given table has given columns.
+         * Set the default named parameters used by the URL generator.
          *
-         * @param string $table
-         * @param array $columns
-         * @return bool 
+         * @param array $defaults
+         * @return void 
          * @static 
-         */
-        public static function hasColumns($table, $columns){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::hasColumns($table, $columns);
+         */ 
+        public static function defaults($defaults)
+        {
+            \Illuminate\Routing\UrlGenerator::defaults($defaults);
         }
         
         /**
-         * Get the data type for the given column name.
+         * Get the default named parameters used by the URL generator.
          *
-         * @param string $table
-         * @param string $column
-         * @return string 
+         * @return array 
          * @static 
-         */
-        public static function getColumnType($table, $column){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::getColumnType($table, $column);
+         */ 
+        public static function getDefaultParameters()
+        {
+            return \Illuminate\Routing\UrlGenerator::getDefaultParameters();
         }
         
         /**
-         * Modify a table on the schema.
+         * Force the scheme for URLs.
          *
-         * @param string $table
-         * @param \Closure $callback
+         * @param string $schema
          * @return void 
          * @static 
-         */
-        public static function table($table, $callback){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            \Illuminate\Database\Schema\MySqlBuilder::table($table, $callback);
+         */ 
+        public static function forceScheme($schema)
+        {
+            \Illuminate\Routing\UrlGenerator::forceScheme($schema);
         }
         
         /**
-         * Create a new table on the schema.
+         * Set the forced root URL.
          *
-         * @param string $table
-         * @param \Closure $callback
+         * @param string $root
          * @return void 
          * @static 
-         */
-        public static function create($table, $callback){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            \Illuminate\Database\Schema\MySqlBuilder::create($table, $callback);
+         */ 
+        public static function forceRootUrl($root)
+        {
+            \Illuminate\Routing\UrlGenerator::forceRootUrl($root);
         }
         
         /**
-         * Drop a table from the schema.
+         * Set a callback to be used to format the host of generated URLs.
          *
-         * @param string $table
-         * @return void 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function drop($table){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            \Illuminate\Database\Schema\MySqlBuilder::drop($table);
+         */ 
+        public static function formatHostUsing($callback)
+        {
+            return \Illuminate\Routing\UrlGenerator::formatHostUsing($callback);
         }
         
         /**
-         * Drop a table from the schema if it exists.
+         * Set a callback to be used to format the path of generated URLs.
          *
-         * @param string $table
-         * @return void 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function dropIfExists($table){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            \Illuminate\Database\Schema\MySqlBuilder::dropIfExists($table);
+         */ 
+        public static function formatPathUsing($callback)
+        {
+            return \Illuminate\Routing\UrlGenerator::formatPathUsing($callback);
         }
         
         /**
-         * Rename a table on the schema.
+         * Get the path formatter being used by the URL generator.
          *
-         * @param string $from
-         * @param string $to
-         * @return void 
+         * @return \Closure 
          * @static 
-         */
-        public static function rename($from, $to){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            \Illuminate\Database\Schema\MySqlBuilder::rename($from, $to);
+         */ 
+        public static function pathFormatter()
+        {
+            return \Illuminate\Routing\UrlGenerator::pathFormatter();
         }
         
         /**
-         * Enable foreign key constraints.
+         * Get the request instance.
          *
-         * @return bool 
+         * @return \Illuminate\Http\Request 
          * @static 
-         */
-        public static function enableForeignKeyConstraints(){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::enableForeignKeyConstraints();
+         */ 
+        public static function getRequest()
+        {
+            return \Illuminate\Routing\UrlGenerator::getRequest();
         }
         
         /**
-         * Disable foreign key constraints.
+         * Set the current request instance.
          *
-         * @return bool 
+         * @param \Illuminate\Http\Request $request
+         * @return void 
          * @static 
-         */
-        public static function disableForeignKeyConstraints(){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::disableForeignKeyConstraints();
+         */ 
+        public static function setRequest($request)
+        {
+            \Illuminate\Routing\UrlGenerator::setRequest($request);
         }
         
         /**
-         * Get the database connection instance.
+         * Set the route collection.
          *
-         * @return \Illuminate\Database\Connection 
+         * @param \Illuminate\Routing\RouteCollection $routes
+         * @return $this 
          * @static 
-         */
-        public static function getConnection(){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::getConnection();
+         */ 
+        public static function setRoutes($routes)
+        {
+            return \Illuminate\Routing\UrlGenerator::setRoutes($routes);
         }
         
         /**
-         * Set the database connection instance.
+         * Set the session resolver for the generator.
          *
-         * @param \Illuminate\Database\Connection $connection
+         * @param callable $sessionResolver
          * @return $this 
          * @static 
-         */
-        public static function setConnection($connection){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::setConnection($connection);
+         */ 
+        public static function setSessionResolver($sessionResolver)
+        {
+            return \Illuminate\Routing\UrlGenerator::setSessionResolver($sessionResolver);
         }
         
         /**
-         * Set the Schema Blueprint resolver callback.
+         * Set the root controller namespace.
          *
-         * @param \Closure $resolver
-         * @return void 
+         * @param string $rootNamespace
+         * @return $this 
          * @static 
-         */
-        public static function blueprintResolver($resolver){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            \Illuminate\Database\Schema\MySqlBuilder::blueprintResolver($resolver);
+         */ 
+        public static function setRootControllerNamespace($rootNamespace)
+        {
+            return \Illuminate\Routing\UrlGenerator::setRootControllerNamespace($rootNamespace);
         }
         
-    }
-
-
-    class Session extends \Illuminate\Support\Facades\Session{
-        
         /**
-         * Get the session configuration.
+         * Register a custom macro.
          *
-         * @return array 
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function getSessionConfig(){
-            return \Illuminate\Session\SessionManager::getSessionConfig();
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Illuminate\Routing\UrlGenerator::macro($name, $macro);
         }
         
         /**
-         * Get the default session driver name.
+         * Mix another object into the class.
          *
-         * @return string 
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function getDefaultDriver(){
-            return \Illuminate\Session\SessionManager::getDefaultDriver();
+         */ 
+        public static function mixin($mixin)
+        {
+            \Illuminate\Routing\UrlGenerator::mixin($mixin);
         }
         
         /**
-         * Set the default session driver name.
+         * Checks if macro is registered.
          *
          * @param string $name
-         * @return void 
+         * @return bool 
          * @static 
-         */
-        public static function setDefaultDriver($name){
-            \Illuminate\Session\SessionManager::setDefaultDriver($name);
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Illuminate\Routing\UrlGenerator::hasMacro($name);
         }
+         
+    }
+
+    class Validator {
         
         /**
-         * Get a driver instance.
+         * Create a new Validator instance.
          *
-         * @param string $driver
-         * @return mixed 
+         * @param array $data
+         * @param array $rules
+         * @param array $messages
+         * @param array $customAttributes
+         * @return \Illuminate\Validation\Validator 
          * @static 
-         */
-        public static function driver($driver = null){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Session\SessionManager::driver($driver);
+         */ 
+        public static function make($data, $rules, $messages = array(), $customAttributes = array())
+        {
+            return \Illuminate\Validation\Factory::make($data, $rules, $messages, $customAttributes);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Validate the given data against the provided rules.
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @param array $data
+         * @param array $rules
+         * @param array $messages
+         * @param array $customAttributes
+         * @return void 
+         * @throws \Illuminate\Validation\ValidationException
          * @static 
-         */
-        public static function extend($driver, $callback){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Session\SessionManager::extend($driver, $callback);
+         */ 
+        public static function validate($data, $rules, $messages = array(), $customAttributes = array())
+        {
+            \Illuminate\Validation\Factory::validate($data, $rules, $messages, $customAttributes);
         }
         
         /**
-         * Get all of the created "drivers".
+         * Register a custom validator extension.
          *
-         * @return array 
+         * @param string $rule
+         * @param \Closure|string $extension
+         * @param string $message
+         * @return void 
          * @static 
-         */
-        public static function getDrivers(){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Session\SessionManager::getDrivers();
+         */ 
+        public static function extend($rule, $extension, $message = null)
+        {
+            \Illuminate\Validation\Factory::extend($rule, $extension, $message);
         }
         
         /**
-         * Start the session, reading the data from a handler.
+         * Register a custom implicit validator extension.
          *
-         * @return bool 
+         * @param string $rule
+         * @param \Closure|string $extension
+         * @param string $message
+         * @return void 
          * @static 
-         */
-        public static function start(){
-            return \Illuminate\Session\Store::start();
+         */ 
+        public static function extendImplicit($rule, $extension, $message = null)
+        {
+            \Illuminate\Validation\Factory::extendImplicit($rule, $extension, $message);
         }
         
         /**
-         * Save the session data to storage.
+         * Register a custom dependent validator extension.
          *
-         * @return bool 
+         * @param string $rule
+         * @param \Closure|string $extension
+         * @param string $message
+         * @return void 
          * @static 
-         */
-        public static function save(){
-            return \Illuminate\Session\Store::save();
+         */ 
+        public static function extendDependent($rule, $extension, $message = null)
+        {
+            \Illuminate\Validation\Factory::extendDependent($rule, $extension, $message);
         }
         
         /**
-         * Age the flash data for the session.
+         * Register a custom validator message replacer.
          *
+         * @param string $rule
+         * @param \Closure|string $replacer
          * @return void 
          * @static 
-         */
-        public static function ageFlashData(){
-            \Illuminate\Session\Store::ageFlashData();
+         */ 
+        public static function replacer($rule, $replacer)
+        {
+            \Illuminate\Validation\Factory::replacer($rule, $replacer);
         }
         
         /**
-         * Get all of the session data.
+         * Set the Validator instance resolver.
          *
-         * @return array 
+         * @param \Closure $resolver
+         * @return void 
          * @static 
-         */
-        public static function all(){
-            return \Illuminate\Session\Store::all();
+         */ 
+        public static function resolver($resolver)
+        {
+            \Illuminate\Validation\Factory::resolver($resolver);
         }
         
         /**
-         * Checks if a key exists.
+         * Get the Translator implementation.
          *
-         * @param string|array $key
-         * @return bool 
+         * @return \Illuminate\Contracts\Translation\Translator 
          * @static 
-         */
-        public static function exists($key){
-            return \Illuminate\Session\Store::exists($key);
+         */ 
+        public static function getTranslator()
+        {
+            return \Illuminate\Validation\Factory::getTranslator();
         }
         
         /**
-         * Checks if a key is present and not null.
+         * Get the Presence Verifier implementation.
          *
-         * @param string|array $key
-         * @return bool 
+         * @return \Illuminate\Validation\PresenceVerifierInterface 
          * @static 
-         */
-        public static function has($key){
-            return \Illuminate\Session\Store::has($key);
+         */ 
+        public static function getPresenceVerifier()
+        {
+            return \Illuminate\Validation\Factory::getPresenceVerifier();
         }
         
         /**
-         * Get an item from the session.
+         * Set the Presence Verifier implementation.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param \Illuminate\Validation\PresenceVerifierInterface $presenceVerifier
+         * @return void 
          * @static 
-         */
-        public static function get($key, $default = null){
-            return \Illuminate\Session\Store::get($key, $default);
+         */ 
+        public static function setPresenceVerifier($presenceVerifier)
+        {
+            \Illuminate\Validation\Factory::setPresenceVerifier($presenceVerifier);
         }
+         
+    }
+
+    class View {
         
         /**
-         * Get the value of a given key and then forget it.
+         * Get the evaluated view contents for the given view.
          *
-         * @param string $key
-         * @param string $default
-         * @return mixed 
+         * @param string $path
+         * @param array $data
+         * @param array $mergeData
+         * @return \Illuminate\Contracts\View\View 
          * @static 
-         */
-        public static function pull($key, $default = null){
-            return \Illuminate\Session\Store::pull($key, $default);
+         */ 
+        public static function file($path, $data = array(), $mergeData = array())
+        {
+            return \Illuminate\View\Factory::file($path, $data, $mergeData);
         }
         
         /**
-         * Determine if the session contains old input.
+         * Get the evaluated view contents for the given view.
          *
-         * @param string $key
-         * @return bool 
+         * @param string $view
+         * @param array $data
+         * @param array $mergeData
+         * @return \Illuminate\Contracts\View\View 
          * @static 
-         */
-        public static function hasOldInput($key = null){
-            return \Illuminate\Session\Store::hasOldInput($key);
+         */ 
+        public static function make($view, $data = array(), $mergeData = array())
+        {
+            return \Illuminate\View\Factory::make($view, $data, $mergeData);
         }
         
         /**
-         * Get the requested item from the flashed input array.
+         * Get the first view that actually exists from the given list.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param array $views
+         * @param array $data
+         * @param array $mergeData
+         * @return \Illuminate\Contracts\View\View 
          * @static 
-         */
-        public static function getOldInput($key = null, $default = null){
-            return \Illuminate\Session\Store::getOldInput($key, $default);
+         */ 
+        public static function first($views, $data = array(), $mergeData = array())
+        {
+            return \Illuminate\View\Factory::first($views, $data, $mergeData);
         }
         
         /**
-         * Replace the given session attributes entirely.
+         * Get the rendered content of the view based on a given condition.
          *
-         * @param array $attributes
-         * @return void 
+         * @param bool $condition
+         * @param string $view
+         * @param array $data
+         * @param array $mergeData
+         * @return string 
          * @static 
-         */
-        public static function replace($attributes){
-            \Illuminate\Session\Store::replace($attributes);
+         */ 
+        public static function renderWhen($condition, $view, $data = array(), $mergeData = array())
+        {
+            return \Illuminate\View\Factory::renderWhen($condition, $view, $data, $mergeData);
         }
         
         /**
-         * Put a key / value pair or array of key / value pairs in the session.
+         * Get the rendered contents of a partial from a loop.
          *
-         * @param string|array $key
-         * @param mixed $value
-         * @return void 
+         * @param string $view
+         * @param array $data
+         * @param string $iterator
+         * @param string $empty
+         * @return string 
          * @static 
-         */
-        public static function put($key, $value = null){
-            \Illuminate\Session\Store::put($key, $value);
+         */ 
+        public static function renderEach($view, $data, $iterator, $empty = 'raw|')
+        {
+            return \Illuminate\View\Factory::renderEach($view, $data, $iterator, $empty);
         }
         
         /**
-         * Get an item from the session, or store the default value.
+         * Determine if a given view exists.
          *
-         * @param string $key
-         * @param \Closure $callback
-         * @return mixed 
+         * @param string $view
+         * @return bool 
          * @static 
-         */
-        public static function remember($key, $callback){
-            return \Illuminate\Session\Store::remember($key, $callback);
+         */ 
+        public static function exists($view)
+        {
+            return \Illuminate\View\Factory::exists($view);
         }
         
         /**
-         * Push a value onto a session array.
+         * Get the appropriate view engine for the given path.
          *
-         * @param string $key
-         * @param mixed $value
-         * @return void 
+         * @param string $path
+         * @return \Illuminate\Contracts\View\Engine 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function push($key, $value){
-            \Illuminate\Session\Store::push($key, $value);
+         */ 
+        public static function getEngineFromPath($path)
+        {
+            return \Illuminate\View\Factory::getEngineFromPath($path);
         }
         
         /**
-         * Increment the value of an item in the session.
+         * Add a piece of shared data to the environment.
          *
-         * @param string $key
-         * @param int $amount
+         * @param array|string $key
+         * @param mixed $value
          * @return mixed 
          * @static 
-         */
-        public static function increment($key, $amount = 1){
-            return \Illuminate\Session\Store::increment($key, $amount);
+         */ 
+        public static function share($key, $value = null)
+        {
+            return \Illuminate\View\Factory::share($key, $value);
         }
         
         /**
-         * Decrement the value of an item in the session.
+         * Increment the rendering counter.
          *
-         * @param string $key
-         * @param int $amount
-         * @return int 
+         * @return void 
          * @static 
-         */
-        public static function decrement($key, $amount = 1){
-            return \Illuminate\Session\Store::decrement($key, $amount);
+         */ 
+        public static function incrementRender()
+        {
+            \Illuminate\View\Factory::incrementRender();
         }
         
         /**
-         * Flash a key / value pair to the session.
+         * Decrement the rendering counter.
          *
-         * @param string $key
-         * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function flash($key, $value){
-            \Illuminate\Session\Store::flash($key, $value);
+         */ 
+        public static function decrementRender()
+        {
+            \Illuminate\View\Factory::decrementRender();
         }
         
         /**
-         * Flash a key / value pair to the session for immediate use.
+         * Check if there are no active render operations.
          *
-         * @param string $key
-         * @param mixed $value
-         * @return void 
+         * @return bool 
          * @static 
-         */
-        public static function now($key, $value){
-            \Illuminate\Session\Store::now($key, $value);
+         */ 
+        public static function doneRendering()
+        {
+            return \Illuminate\View\Factory::doneRendering();
         }
         
         /**
-         * Reflash all of the session flash data.
+         * Add a location to the array of view locations.
          *
+         * @param string $location
          * @return void 
          * @static 
-         */
-        public static function reflash(){
-            \Illuminate\Session\Store::reflash();
+         */ 
+        public static function addLocation($location)
+        {
+            \Illuminate\View\Factory::addLocation($location);
         }
         
         /**
-         * Reflash a subset of the current flash data.
+         * Add a new namespace to the loader.
          *
-         * @param array|mixed $keys
-         * @return void 
+         * @param string $namespace
+         * @param string|array $hints
+         * @return $this 
          * @static 
-         */
-        public static function keep($keys = null){
-            \Illuminate\Session\Store::keep($keys);
+         */ 
+        public static function addNamespace($namespace, $hints)
+        {
+            return \Illuminate\View\Factory::addNamespace($namespace, $hints);
         }
         
         /**
-         * Flash an input array to the session.
+         * Prepend a new namespace to the loader.
          *
-         * @param array $value
-         * @return void 
+         * @param string $namespace
+         * @param string|array $hints
+         * @return $this 
          * @static 
-         */
-        public static function flashInput($value){
-            \Illuminate\Session\Store::flashInput($value);
+         */ 
+        public static function prependNamespace($namespace, $hints)
+        {
+            return \Illuminate\View\Factory::prependNamespace($namespace, $hints);
         }
         
         /**
-         * Remove an item from the session, returning its value.
+         * Replace the namespace hints for the given namespace.
          *
-         * @param string $key
-         * @return mixed 
+         * @param string $namespace
+         * @param string|array $hints
+         * @return $this 
          * @static 
-         */
-        public static function remove($key){
-            return \Illuminate\Session\Store::remove($key);
+         */ 
+        public static function replaceNamespace($namespace, $hints)
+        {
+            return \Illuminate\View\Factory::replaceNamespace($namespace, $hints);
         }
         
         /**
-         * Remove one or many items from the session.
+         * Register a valid view extension and its engine.
          *
-         * @param string|array $keys
+         * @param string $extension
+         * @param string $engine
+         * @param \Closure $resolver
          * @return void 
          * @static 
-         */
-        public static function forget($keys){
-            \Illuminate\Session\Store::forget($keys);
+         */ 
+        public static function addExtension($extension, $engine, $resolver = null)
+        {
+            \Illuminate\View\Factory::addExtension($extension, $engine, $resolver);
         }
         
         /**
-         * Remove all of the items from the session.
+         * Flush all of the factory state like sections and stacks.
          *
          * @return void 
          * @static 
-         */
-        public static function flush(){
-            \Illuminate\Session\Store::flush();
+         */ 
+        public static function flushState()
+        {
+            \Illuminate\View\Factory::flushState();
         }
         
         /**
-         * Flush the session data and regenerate the ID.
+         * Flush all of the section contents if done rendering.
          *
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function invalidate(){
-            return \Illuminate\Session\Store::invalidate();
+         */ 
+        public static function flushStateIfDoneRendering()
+        {
+            \Illuminate\View\Factory::flushStateIfDoneRendering();
         }
         
         /**
-         * Generate a new session identifier.
+         * Get the extension to engine bindings.
          *
-         * @param bool $destroy
-         * @return bool 
+         * @return array 
          * @static 
-         */
-        public static function regenerate($destroy = false){
-            return \Illuminate\Session\Store::regenerate($destroy);
+         */ 
+        public static function getExtensions()
+        {
+            return \Illuminate\View\Factory::getExtensions();
         }
         
         /**
-         * Generate a new session ID for the session.
+         * Get the engine resolver instance.
          *
-         * @param bool $destroy
-         * @return bool 
+         * @return \Illuminate\View\Engines\EngineResolver 
          * @static 
-         */
-        public static function migrate($destroy = false){
-            return \Illuminate\Session\Store::migrate($destroy);
+         */ 
+        public static function getEngineResolver()
+        {
+            return \Illuminate\View\Factory::getEngineResolver();
         }
         
         /**
-         * Determine if the session has been started.
+         * Get the view finder instance.
          *
-         * @return bool 
+         * @return \Illuminate\View\ViewFinderInterface 
          * @static 
-         */
-        public static function isStarted(){
-            return \Illuminate\Session\Store::isStarted();
+         */ 
+        public static function getFinder()
+        {
+            return \Illuminate\View\Factory::getFinder();
         }
         
         /**
-         * Get the name of the session.
+         * Set the view finder instance.
          *
-         * @return string 
+         * @param \Illuminate\View\ViewFinderInterface $finder
+         * @return void 
          * @static 
-         */
-        public static function getName(){
-            return \Illuminate\Session\Store::getName();
+         */ 
+        public static function setFinder($finder)
+        {
+            \Illuminate\View\Factory::setFinder($finder);
         }
         
         /**
-         * Set the name of the session.
+         * Flush the cache of views located by the finder.
          *
-         * @param string $name
          * @return void 
          * @static 
-         */
-        public static function setName($name){
-            \Illuminate\Session\Store::setName($name);
+         */ 
+        public static function flushFinderCache()
+        {
+            \Illuminate\View\Factory::flushFinderCache();
         }
         
         /**
-         * Get the current session ID.
+         * Get the event dispatcher instance.
          *
-         * @return string 
+         * @return \Illuminate\Contracts\Events\Dispatcher 
          * @static 
-         */
-        public static function getId(){
-            return \Illuminate\Session\Store::getId();
+         */ 
+        public static function getDispatcher()
+        {
+            return \Illuminate\View\Factory::getDispatcher();
         }
         
         /**
-         * Set the session ID.
+         * Set the event dispatcher instance.
          *
-         * @param string $id
+         * @param \Illuminate\Contracts\Events\Dispatcher $events
          * @return void 
          * @static 
-         */
-        public static function setId($id){
-            \Illuminate\Session\Store::setId($id);
+         */ 
+        public static function setDispatcher($events)
+        {
+            \Illuminate\View\Factory::setDispatcher($events);
         }
         
         /**
-         * Determine if this is a valid session ID.
+         * Get the IoC container instance.
          *
-         * @param string $id
-         * @return bool 
+         * @return \Illuminate\Contracts\Container\Container 
          * @static 
-         */
-        public static function isValidId($id){
-            return \Illuminate\Session\Store::isValidId($id);
+         */ 
+        public static function getContainer()
+        {
+            return \Illuminate\View\Factory::getContainer();
         }
         
         /**
-         * Set the existence of the session on the handler if applicable.
+         * Set the IoC container instance.
          *
-         * @param bool $value
+         * @param \Illuminate\Contracts\Container\Container $container
          * @return void 
          * @static 
-         */
-        public static function setExists($value){
-            \Illuminate\Session\Store::setExists($value);
+         */ 
+        public static function setContainer($container)
+        {
+            \Illuminate\View\Factory::setContainer($container);
         }
         
         /**
-         * Get the CSRF token value.
+         * Get an item from the shared data.
          *
-         * @return string 
+         * @param string $key
+         * @param mixed $default
+         * @return mixed 
          * @static 
-         */
-        public static function token(){
-            return \Illuminate\Session\Store::token();
+         */ 
+        public static function shared($key, $default = null)
+        {
+            return \Illuminate\View\Factory::shared($key, $default);
         }
         
         /**
-         * Regenerate the CSRF token value.
+         * Get all of the shared data for the environment.
+         *
+         * @return array 
+         * @static 
+         */ 
+        public static function getShared()
+        {
+            return \Illuminate\View\Factory::getShared();
+        }
+        
+        /**
+         * Start a component rendering process.
          *
+         * @param string $name
+         * @param array $data
          * @return void 
          * @static 
-         */
-        public static function regenerateToken(){
-            \Illuminate\Session\Store::regenerateToken();
+         */ 
+        public static function startComponent($name, $data = array())
+        {
+            \Illuminate\View\Factory::startComponent($name, $data);
         }
         
         /**
-         * Get the previous URL from the session.
+         * Render the current component.
          *
-         * @return string|null 
+         * @return string 
          * @static 
-         */
-        public static function previousUrl(){
-            return \Illuminate\Session\Store::previousUrl();
+         */ 
+        public static function renderComponent()
+        {
+            return \Illuminate\View\Factory::renderComponent();
         }
         
         /**
-         * Set the "previous" URL in the session.
+         * Start the slot rendering process.
          *
-         * @param string $url
+         * @param string $name
+         * @param string|null $content
          * @return void 
          * @static 
-         */
-        public static function setPreviousUrl($url){
-            \Illuminate\Session\Store::setPreviousUrl($url);
+         */ 
+        public static function slot($name, $content = null)
+        {
+            \Illuminate\View\Factory::slot($name, $content);
         }
         
         /**
-         * Get the underlying session handler implementation.
+         * Save the slot content for rendering.
          *
-         * @return \SessionHandlerInterface 
+         * @return void 
          * @static 
-         */
-        public static function getHandler(){
-            return \Illuminate\Session\Store::getHandler();
+         */ 
+        public static function endSlot()
+        {
+            \Illuminate\View\Factory::endSlot();
         }
         
         /**
-         * Determine if the session handler needs a request.
+         * Register a view creator event.
          *
-         * @return bool 
+         * @param array|string $views
+         * @param \Closure|string $callback
+         * @return array 
          * @static 
-         */
-        public static function handlerNeedsRequest(){
-            return \Illuminate\Session\Store::handlerNeedsRequest();
+         */ 
+        public static function creator($views, $callback)
+        {
+            return \Illuminate\View\Factory::creator($views, $callback);
         }
         
         /**
-         * Set the request on the handler instance.
+         * Register multiple view composers via an array.
          *
-         * @param \Illuminate\Http\Request $request
-         * @return void 
+         * @param array $composers
+         * @return array 
          * @static 
-         */
-        public static function setRequestOnHandler($request){
-            \Illuminate\Session\Store::setRequestOnHandler($request);
+         */ 
+        public static function composers($composers)
+        {
+            return \Illuminate\View\Factory::composers($composers);
         }
         
-    }
-
-
-    class Storage extends \Illuminate\Support\Facades\Storage{
-        
         /**
-         * Get a filesystem instance.
+         * Register a view composer event.
          *
-         * @param string $name
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param array|string $views
+         * @param \Closure|string $callback
+         * @return array 
          * @static 
-         */
-        public static function drive($name = null){
-            return \Illuminate\Filesystem\FilesystemManager::drive($name);
+         */ 
+        public static function composer($views, $callback)
+        {
+            return \Illuminate\View\Factory::composer($views, $callback);
         }
         
         /**
-         * Get a filesystem instance.
+         * Call the composer for a given view.
          *
-         * @param string $name
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param \Illuminate\Contracts\View\View $view
+         * @return void 
          * @static 
-         */
-        public static function disk($name = null){
-            return \Illuminate\Filesystem\FilesystemManager::disk($name);
+         */ 
+        public static function callComposer($view)
+        {
+            \Illuminate\View\Factory::callComposer($view);
         }
         
         /**
-         * Get a default cloud filesystem instance.
+         * Call the creator for a given view.
          *
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param \Illuminate\Contracts\View\View $view
+         * @return void 
          * @static 
-         */
-        public static function cloud(){
-            return \Illuminate\Filesystem\FilesystemManager::cloud();
+         */ 
+        public static function callCreator($view)
+        {
+            \Illuminate\View\Factory::callCreator($view);
         }
         
         /**
-         * Create an instance of the local driver.
+         * Start injecting content into a section.
          *
-         * @param array $config
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param string $section
+         * @param string|null $content
+         * @return void 
          * @static 
-         */
-        public static function createLocalDriver($config){
-            return \Illuminate\Filesystem\FilesystemManager::createLocalDriver($config);
+         */ 
+        public static function startSection($section, $content = null)
+        {
+            \Illuminate\View\Factory::startSection($section, $content);
         }
         
         /**
-         * Create an instance of the ftp driver.
+         * Inject inline content into a section.
          *
-         * @param array $config
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param string $section
+         * @param string $content
+         * @return void 
          * @static 
-         */
-        public static function createFtpDriver($config){
-            return \Illuminate\Filesystem\FilesystemManager::createFtpDriver($config);
+         */ 
+        public static function inject($section, $content)
+        {
+            \Illuminate\View\Factory::inject($section, $content);
         }
         
         /**
-         * Create an instance of the Amazon S3 driver.
+         * Stop injecting content into a section and return its contents.
          *
-         * @param array $config
-         * @return \Illuminate\Contracts\Filesystem\Cloud 
+         * @return string 
          * @static 
-         */
-        public static function createS3Driver($config){
-            return \Illuminate\Filesystem\FilesystemManager::createS3Driver($config);
+         */ 
+        public static function yieldSection()
+        {
+            return \Illuminate\View\Factory::yieldSection();
         }
         
         /**
-         * Create an instance of the Rackspace driver.
+         * Stop injecting content into a section.
          *
-         * @param array $config
-         * @return \Illuminate\Contracts\Filesystem\Cloud 
+         * @param bool $overwrite
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function createRackspaceDriver($config){
-            return \Illuminate\Filesystem\FilesystemManager::createRackspaceDriver($config);
+         */ 
+        public static function stopSection($overwrite = false)
+        {
+            return \Illuminate\View\Factory::stopSection($overwrite);
         }
         
         /**
-         * Set the given disk instance.
+         * Stop injecting content into a section and append it.
          *
-         * @param string $name
-         * @param mixed $disk
-         * @return void 
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function set($name, $disk){
-            \Illuminate\Filesystem\FilesystemManager::set($name, $disk);
+         */ 
+        public static function appendSection()
+        {
+            return \Illuminate\View\Factory::appendSection();
         }
         
         /**
-         * Get the default driver name.
+         * Get the string contents of a section.
          *
+         * @param string $section
+         * @param string $default
          * @return string 
          * @static 
-         */
-        public static function getDefaultDriver(){
-            return \Illuminate\Filesystem\FilesystemManager::getDefaultDriver();
+         */ 
+        public static function yieldContent($section, $default = '')
+        {
+            return \Illuminate\View\Factory::yieldContent($section, $default);
         }
         
         /**
-         * Get the default cloud driver name.
+         * Get the parent placeholder for the current request.
          *
+         * @param string $section
          * @return string 
          * @static 
-         */
-        public static function getDefaultCloudDriver(){
-            return \Illuminate\Filesystem\FilesystemManager::getDefaultCloudDriver();
+         */ 
+        public static function parentPlaceholder($section = '')
+        {
+            return \Illuminate\View\Factory::parentPlaceholder($section);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Check if section exists.
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function extend($driver, $callback){
-            return \Illuminate\Filesystem\FilesystemManager::extend($driver, $callback);
+         */ 
+        public static function hasSection($name)
+        {
+            return \Illuminate\View\Factory::hasSection($name);
         }
         
         /**
-         * Assert that the given file exists.
+         * Get the contents of a section.
          *
-         * @param string $path
-         * @return void 
+         * @param string $name
+         * @param string $default
+         * @return mixed 
          * @static 
-         */
-        public static function assertExists($path){
-            \Illuminate\Filesystem\FilesystemAdapter::assertExists($path);
+         */ 
+        public static function getSection($name, $default = null)
+        {
+            return \Illuminate\View\Factory::getSection($name, $default);
         }
         
         /**
-         * Assert that the given file does not exist.
+         * Get the entire array of sections.
          *
-         * @param string $path
-         * @return void 
+         * @return array 
          * @static 
-         */
-        public static function assertMissing($path){
-            \Illuminate\Filesystem\FilesystemAdapter::assertMissing($path);
+         */ 
+        public static function getSections()
+        {
+            return \Illuminate\View\Factory::getSections();
         }
         
         /**
-         * Determine if a file exists.
+         * Flush all of the sections.
          *
-         * @param string $path
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function exists($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::exists($path);
+         */ 
+        public static function flushSections()
+        {
+            \Illuminate\View\Factory::flushSections();
         }
         
         /**
-         * Get the contents of a file.
+         * Add new loop to the stack.
          *
-         * @param string $path
-         * @return string 
-         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
+         * @param \Countable|array $data
+         * @return void 
          * @static 
-         */
-        public static function get($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::get($path);
+         */ 
+        public static function addLoop($data)
+        {
+            \Illuminate\View\Factory::addLoop($data);
         }
         
         /**
-         * Write the contents of a file.
+         * Increment the top loop's indices.
          *
-         * @param string $path
-         * @param string|resource $contents
-         * @param array $options
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function put($path, $contents, $options = array()){
-            return \Illuminate\Filesystem\FilesystemAdapter::put($path, $contents, $options);
+         */ 
+        public static function incrementLoopIndices()
+        {
+            \Illuminate\View\Factory::incrementLoopIndices();
         }
         
         /**
-         * Store the uploaded file on the disk.
+         * Pop a loop from the top of the loop stack.
          *
-         * @param string $path
-         * @param \Illuminate\Http\File|\Illuminate\Http\UploadedFile $file
-         * @param array $options
-         * @return string|false 
+         * @return void 
          * @static 
-         */
-        public static function putFile($path, $file, $options = array()){
-            return \Illuminate\Filesystem\FilesystemAdapter::putFile($path, $file, $options);
+         */ 
+        public static function popLoop()
+        {
+            \Illuminate\View\Factory::popLoop();
         }
         
         /**
-         * Store the uploaded file on the disk with a given name.
+         * Get an instance of the last loop in the stack.
          *
-         * @param string $path
-         * @param \Illuminate\Http\File|\Illuminate\Http\UploadedFile $file
-         * @param string $name
-         * @param array $options
-         * @return string|false 
+         * @return \stdClass|null 
          * @static 
-         */
-        public static function putFileAs($path, $file, $name, $options = array()){
-            return \Illuminate\Filesystem\FilesystemAdapter::putFileAs($path, $file, $name, $options);
+         */ 
+        public static function getLastLoop()
+        {
+            return \Illuminate\View\Factory::getLastLoop();
         }
         
         /**
-         * Get the visibility for the given path.
+         * Get the entire loop stack.
          *
-         * @param string $path
-         * @return string 
+         * @return array 
          * @static 
-         */
-        public static function getVisibility($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::getVisibility($path);
+         */ 
+        public static function getLoopStack()
+        {
+            return \Illuminate\View\Factory::getLoopStack();
         }
         
         /**
-         * Set the visibility for the given path.
+         * Start injecting content into a push section.
          *
-         * @param string $path
-         * @param string $visibility
+         * @param string $section
+         * @param string $content
          * @return void 
          * @static 
-         */
-        public static function setVisibility($path, $visibility){
-            \Illuminate\Filesystem\FilesystemAdapter::setVisibility($path, $visibility);
+         */ 
+        public static function startPush($section, $content = '')
+        {
+            \Illuminate\View\Factory::startPush($section, $content);
         }
         
         /**
-         * Prepend to a file.
+         * Stop injecting content into a push section.
          *
-         * @param string $path
-         * @param string $data
-         * @param string $separator
-         * @return int 
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function prepend($path, $data, $separator = ''){
-            return \Illuminate\Filesystem\FilesystemAdapter::prepend($path, $data, $separator);
+         */ 
+        public static function stopPush()
+        {
+            return \Illuminate\View\Factory::stopPush();
         }
         
         /**
-         * Append to a file.
+         * Start prepending content into a push section.
          *
-         * @param string $path
-         * @param string $data
-         * @param string $separator
-         * @return int 
+         * @param string $section
+         * @param string $content
+         * @return void 
          * @static 
-         */
-        public static function append($path, $data, $separator = ''){
-            return \Illuminate\Filesystem\FilesystemAdapter::append($path, $data, $separator);
+         */ 
+        public static function startPrepend($section, $content = '')
+        {
+            \Illuminate\View\Factory::startPrepend($section, $content);
         }
         
         /**
-         * Delete the file at a given path.
+         * Stop prepending content into a push section.
          *
-         * @param string|array $paths
-         * @return bool 
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function delete($paths){
-            return \Illuminate\Filesystem\FilesystemAdapter::delete($paths);
+         */ 
+        public static function stopPrepend()
+        {
+            return \Illuminate\View\Factory::stopPrepend();
         }
         
         /**
-         * Copy a file to a new location.
+         * Get the string contents of a push section.
          *
-         * @param string $from
-         * @param string $to
-         * @return bool 
+         * @param string $section
+         * @param string $default
+         * @return string 
          * @static 
-         */
-        public static function copy($from, $to){
-            return \Illuminate\Filesystem\FilesystemAdapter::copy($from, $to);
+         */ 
+        public static function yieldPushContent($section, $default = '')
+        {
+            return \Illuminate\View\Factory::yieldPushContent($section, $default);
         }
         
         /**
-         * Move a file to a new location.
+         * Flush all of the stacks.
          *
-         * @param string $from
-         * @param string $to
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function move($from, $to){
-            return \Illuminate\Filesystem\FilesystemAdapter::move($from, $to);
+         */ 
+        public static function flushStacks()
+        {
+            \Illuminate\View\Factory::flushStacks();
         }
         
         /**
-         * Get the file size of a given file.
+         * Start a translation block.
          *
-         * @param string $path
-         * @return int 
+         * @param array $replacements
+         * @return void 
          * @static 
-         */
-        public static function size($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::size($path);
+         */ 
+        public static function startTranslation($replacements = array())
+        {
+            \Illuminate\View\Factory::startTranslation($replacements);
         }
         
         /**
-         * Get the mime-type of a given file.
+         * Render the current translation.
          *
-         * @param string $path
-         * @return string|false 
+         * @return string 
          * @static 
-         */
-        public static function mimeType($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::mimeType($path);
+         */ 
+        public static function renderTranslation()
+        {
+            return \Illuminate\View\Factory::renderTranslation();
         }
+         
+    }
+
+    class Notification {
         
         /**
-         * Get the file's last modification time.
+         * Send the given notification to the given notifiable entities.
          *
-         * @param string $path
-         * @return int 
+         * @param \Illuminate\Support\Collection|array|mixed $notifiables
+         * @param mixed $notification
+         * @return void 
          * @static 
-         */
-        public static function lastModified($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::lastModified($path);
+         */ 
+        public static function send($notifiables, $notification)
+        {
+            \Illuminate\Notifications\ChannelManager::send($notifiables, $notification);
         }
         
         /**
-         * Get the URL for the file at the given path.
+         * Send the given notification immediately.
          *
-         * @param string $path
-         * @return string 
+         * @param \Illuminate\Support\Collection|array|mixed $notifiables
+         * @param mixed $notification
+         * @param array|null $channels
+         * @return void 
          * @static 
-         */
-        public static function url($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::url($path);
+         */ 
+        public static function sendNow($notifiables, $notification, $channels = null)
+        {
+            \Illuminate\Notifications\ChannelManager::sendNow($notifiables, $notification, $channels);
         }
         
         /**
-         * Get an array of all files in a directory.
+         * Get a channel instance.
          *
-         * @param string|null $directory
-         * @param bool $recursive
-         * @return array 
+         * @param string|null $name
+         * @return mixed 
          * @static 
-         */
-        public static function files($directory = null, $recursive = false){
-            return \Illuminate\Filesystem\FilesystemAdapter::files($directory, $recursive);
+         */ 
+        public static function channel($name = null)
+        {
+            return \Illuminate\Notifications\ChannelManager::channel($name);
         }
         
         /**
-         * Get all of the files from the given directory (recursive).
+         * Get the default channel driver name.
          *
-         * @param string|null $directory
-         * @return array 
+         * @return string 
          * @static 
-         */
-        public static function allFiles($directory = null){
-            return \Illuminate\Filesystem\FilesystemAdapter::allFiles($directory);
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \Illuminate\Notifications\ChannelManager::getDefaultDriver();
         }
         
         /**
-         * Get all of the directories within a given directory.
+         * Get the default channel driver name.
          *
-         * @param string|null $directory
-         * @param bool $recursive
-         * @return array 
+         * @return string 
          * @static 
-         */
-        public static function directories($directory = null, $recursive = false){
-            return \Illuminate\Filesystem\FilesystemAdapter::directories($directory, $recursive);
+         */ 
+        public static function deliversVia()
+        {
+            return \Illuminate\Notifications\ChannelManager::deliversVia();
         }
         
         /**
-         * Get all (recursive) of the directories within a given directory.
+         * Set the default channel driver name.
          *
-         * @param string|null $directory
-         * @return array 
+         * @param string $channel
+         * @return void 
          * @static 
-         */
-        public static function allDirectories($directory = null){
-            return \Illuminate\Filesystem\FilesystemAdapter::allDirectories($directory);
+         */ 
+        public static function deliverVia($channel)
+        {
+            \Illuminate\Notifications\ChannelManager::deliverVia($channel);
         }
         
         /**
-         * Create a directory.
+         * Get a driver instance.
          *
-         * @param string $path
-         * @return bool 
+         * @param string $driver
+         * @return mixed 
          * @static 
-         */
-        public static function makeDirectory($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::makeDirectory($path);
+         */ 
+        public static function driver($driver = null)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Notifications\ChannelManager::driver($driver);
         }
         
         /**
-         * Recursively delete a directory.
+         * Register a custom driver creator Closure.
          *
-         * @param string $directory
-         * @return bool 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function deleteDirectory($directory){
-            return \Illuminate\Filesystem\FilesystemAdapter::deleteDirectory($directory);
+         */ 
+        public static function extend($driver, $callback)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Notifications\ChannelManager::extend($driver, $callback);
         }
         
         /**
-         * Get the Flysystem driver.
+         * Get all of the created "drivers".
          *
-         * @return \League\Flysystem\FilesystemInterface 
+         * @return array 
          * @static 
-         */
-        public static function getDriver(){
-            return \Illuminate\Filesystem\FilesystemAdapter::getDriver();
+         */ 
+        public static function getDrivers()
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Notifications\ChannelManager::getDrivers();
         }
-        
+         
+    }
+ 
+}
+
+namespace Illuminate\Foundation { 
+
+    class Inspiring {
+         
     }
+ 
+}
 
+namespace Proengsoft\JsValidation\Facades { 
 
-    class URL extends \Illuminate\Support\Facades\URL{
+    class JsValidatorFacade {
         
         /**
-         * Get the full URL for the current request.
+         * Creates JsValidator instance based on rules and message arrays.
          *
-         * @return string 
+         * @param array $rules
+         * @param array $messages
+         * @param array $customAttributes
+         * @param null|string $selector
+         * @return \Proengsoft\JsValidation\JavascriptValidator 
          * @static 
-         */
-        public static function full(){
-            return \Illuminate\Routing\UrlGenerator::full();
+         */ 
+        public static function make($rules, $messages = array(), $customAttributes = array(), $selector = null)
+        {
+            return \Proengsoft\JsValidation\JsValidatorFactory::make($rules, $messages, $customAttributes, $selector);
         }
         
         /**
-         * Get the current URL for the request.
+         * Creates JsValidator instance based on FormRequest.
          *
-         * @return string 
+         * @param $formRequest
+         * @param null $selector
+         * @return \Proengsoft\JsValidation\JavascriptValidator 
+         * @throws FormRequestArgumentException
          * @static 
-         */
-        public static function current(){
-            return \Illuminate\Routing\UrlGenerator::current();
+         */ 
+        public static function formRequest($formRequest, $selector = null)
+        {
+            return \Proengsoft\JsValidation\JsValidatorFactory::formRequest($formRequest, $selector);
         }
         
         /**
-         * Get the URL for the previous request.
+         * Creates JsValidator instance based on Validator.
          *
-         * @param mixed $fallback
-         * @return string 
+         * @param \Illuminate\Validation\Validator $validator
+         * @param string|null $selector
+         * @return \Proengsoft\JsValidation\JavascriptValidator 
          * @static 
-         */
-        public static function previous($fallback = false){
-            return \Illuminate\Routing\UrlGenerator::previous($fallback);
+         */ 
+        public static function validator($validator, $selector = null)
+        {
+            return \Proengsoft\JsValidation\JsValidatorFactory::validator($validator, $selector);
         }
+         
+    }
+ 
+}
+
+namespace Laravel\Socialite\Facades { 
+
+    class Socialite {
         
         /**
-         * Generate an absolute URL to the given path.
+         * Get a driver instance.
          *
-         * @param string $path
-         * @param mixed $extra
-         * @param bool|null $secure
-         * @return string 
+         * @param string $driver
+         * @return mixed 
          * @static 
-         */
-        public static function to($path, $extra = array(), $secure = null){
-            return \Illuminate\Routing\UrlGenerator::to($path, $extra, $secure);
+         */ 
+        public static function with($driver)
+        {
+            return \Laravel\Socialite\SocialiteManager::with($driver);
         }
         
         /**
-         * Generate a secure, absolute URL to the given path.
+         * Build an OAuth 2 provider instance.
          *
-         * @param string $path
-         * @param array $parameters
-         * @return string 
+         * @param string $provider
+         * @param array $config
+         * @return \Laravel\Socialite\Two\AbstractProvider 
          * @static 
-         */
-        public static function secure($path, $parameters = array()){
-            return \Illuminate\Routing\UrlGenerator::secure($path, $parameters);
+         */ 
+        public static function buildProvider($provider, $config)
+        {
+            return \Laravel\Socialite\SocialiteManager::buildProvider($provider, $config);
         }
         
         /**
-         * Generate the URL to an application asset.
+         * Format the server configuration.
          *
-         * @param string $path
-         * @param bool|null $secure
-         * @return string 
+         * @param array $config
+         * @return array 
          * @static 
-         */
-        public static function asset($path, $secure = null){
-            return \Illuminate\Routing\UrlGenerator::asset($path, $secure);
+         */ 
+        public static function formatConfig($config)
+        {
+            return \Laravel\Socialite\SocialiteManager::formatConfig($config);
         }
         
         /**
-         * Generate the URL to a secure asset.
+         * Get the default driver name.
          *
-         * @param string $path
+         * @throws \InvalidArgumentException
          * @return string 
          * @static 
-         */
-        public static function secureAsset($path){
-            return \Illuminate\Routing\UrlGenerator::secureAsset($path);
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \Laravel\Socialite\SocialiteManager::getDefaultDriver();
         }
         
         /**
-         * Generate the URL to an asset from a custom root domain such as CDN, etc.
+         * Get a driver instance.
          *
-         * @param string $root
-         * @param string $path
-         * @param bool|null $secure
-         * @return string 
+         * @param string $driver
+         * @return mixed 
          * @static 
-         */
-        public static function assetFrom($root, $path, $secure = null){
-            return \Illuminate\Routing\UrlGenerator::assetFrom($root, $path, $secure);
+         */ 
+        public static function driver($driver = null)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Laravel\Socialite\SocialiteManager::driver($driver);
         }
         
         /**
-         * Get the default scheme for a raw URL.
+         * Register a custom driver creator Closure.
          *
-         * @param bool|null $secure
-         * @return string 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function formatScheme($secure){
-            return \Illuminate\Routing\UrlGenerator::formatScheme($secure);
+         */ 
+        public static function extend($driver, $callback)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Laravel\Socialite\SocialiteManager::extend($driver, $callback);
         }
         
         /**
-         * Get the URL to a named route.
+         * Get all of the created "drivers".
          *
-         * @param string $name
-         * @param mixed $parameters
-         * @param bool $absolute
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @return array 
          * @static 
-         */
-        public static function route($name, $parameters = array(), $absolute = true){
-            return \Illuminate\Routing\UrlGenerator::route($name, $parameters, $absolute);
+         */ 
+        public static function getDrivers()
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Laravel\Socialite\SocialiteManager::getDrivers();
         }
+         
+    }
+ 
+}
+
+namespace Collective\Html { 
+
+    class FormFacade {
         
         /**
-         * Get the URL to a controller action.
+         * Open up a new HTML form.
          *
-         * @param string $action
-         * @param mixed $parameters
-         * @param bool $absolute
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function action($action, $parameters = array(), $absolute = true){
-            return \Illuminate\Routing\UrlGenerator::action($action, $parameters, $absolute);
+         */ 
+        public static function open($options = array())
+        {
+            return \Collective\Html\FormBuilder::open($options);
         }
         
         /**
-         * Format the array of URL parameters.
+         * Create a new model based form builder.
          *
-         * @param mixed|array $parameters
-         * @return array 
+         * @param mixed $model
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function formatParameters($parameters){
-            return \Illuminate\Routing\UrlGenerator::formatParameters($parameters);
+         */ 
+        public static function model($model, $options = array())
+        {
+            return \Collective\Html\FormBuilder::model($model, $options);
         }
         
         /**
-         * Get the base URL for the request.
+         * Set the model instance on the form builder.
          *
-         * @param string $scheme
-         * @param string $root
-         * @return string 
+         * @param mixed $model
+         * @return void 
          * @static 
-         */
-        public static function formatRoot($scheme, $root = null){
-            return \Illuminate\Routing\UrlGenerator::formatRoot($scheme, $root);
+         */ 
+        public static function setModel($model)
+        {
+            \Collective\Html\FormBuilder::setModel($model);
         }
         
         /**
-         * Format the given URL segments into a single URL.
+         * Get the current model instance on the form builder.
          *
-         * @param string $root
-         * @param string $path
-         * @return string 
+         * @return mixed $model
          * @static 
-         */
-        public static function format($root, $path){
-            return \Illuminate\Routing\UrlGenerator::format($root, $path);
+         */ 
+        public static function getModel()
+        {
+            return \Collective\Html\FormBuilder::getModel();
         }
         
         /**
-         * Determine if the given path is a valid URL.
+         * Close the current form.
          *
-         * @param string $path
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function isValidUrl($path){
-            return \Illuminate\Routing\UrlGenerator::isValidUrl($path);
+         */ 
+        public static function close()
+        {
+            return \Collective\Html\FormBuilder::close();
         }
         
         /**
-         * Set the default named parameters used by the URL generator.
+         * Generate a hidden field with the current CSRF token.
          *
-         * @param array $defaults
-         * @return void 
+         * @return string 
          * @static 
-         */
-        public static function defaults($defaults){
-            \Illuminate\Routing\UrlGenerator::defaults($defaults);
+         */ 
+        public static function token()
+        {
+            return \Collective\Html\FormBuilder::token();
         }
         
         /**
-         * Force the scheme for URLs.
+         * Create a form label element.
          *
-         * @param string $schema
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @param bool $escape_html
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function forceScheme($schema){
-            \Illuminate\Routing\UrlGenerator::forceScheme($schema);
+         */ 
+        public static function label($name, $value = null, $options = array(), $escape_html = true)
+        {
+            return \Collective\Html\FormBuilder::label($name, $value, $options, $escape_html);
         }
         
         /**
-         * Set the forced root URL.
+         * Create a form input field.
          *
-         * @param string $root
-         * @return void 
+         * @param string $type
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function forceRootUrl($root){
-            \Illuminate\Routing\UrlGenerator::forceRootUrl($root);
+         */ 
+        public static function input($type, $name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::input($type, $name, $value, $options);
         }
         
         /**
-         * Set a callback to be used to format the host of generated URLs.
+         * Create a text input field.
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function formatHostUsing($callback){
-            return \Illuminate\Routing\UrlGenerator::formatHostUsing($callback);
+         */ 
+        public static function text($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::text($name, $value, $options);
         }
         
         /**
-         * Set a callback to be used to format the path of generated URLs.
+         * Create a password input field.
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $name
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function formatPathUsing($callback){
-            return \Illuminate\Routing\UrlGenerator::formatPathUsing($callback);
+         */ 
+        public static function password($name, $options = array())
+        {
+            return \Collective\Html\FormBuilder::password($name, $options);
         }
         
         /**
-         * Get the path formatter being used by the URL generator.
+         * Create a hidden input field.
          *
-         * @return \Closure 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function pathFormatter(){
-            return \Illuminate\Routing\UrlGenerator::pathFormatter();
+         */ 
+        public static function hidden($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::hidden($name, $value, $options);
         }
         
         /**
-         * Get the request instance.
+         * Create a search input field.
          *
-         * @return \Illuminate\Http\Request 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getRequest(){
-            return \Illuminate\Routing\UrlGenerator::getRequest();
+         */ 
+        public static function search($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::search($name, $value, $options);
         }
         
         /**
-         * Set the current request instance.
+         * Create an e-mail input field.
          *
-         * @param \Illuminate\Http\Request $request
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function setRequest($request){
-            \Illuminate\Routing\UrlGenerator::setRequest($request);
+         */ 
+        public static function email($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::email($name, $value, $options);
         }
         
         /**
-         * Set the route collection.
+         * Create a tel input field.
          *
-         * @param \Illuminate\Routing\RouteCollection $routes
-         * @return $this 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function setRoutes($routes){
-            return \Illuminate\Routing\UrlGenerator::setRoutes($routes);
+         */ 
+        public static function tel($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::tel($name, $value, $options);
         }
         
         /**
-         * Set the session resolver for the generator.
+         * Create a number input field.
          *
-         * @param callable $sessionResolver
-         * @return $this 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function setSessionResolver($sessionResolver){
-            return \Illuminate\Routing\UrlGenerator::setSessionResolver($sessionResolver);
+         */ 
+        public static function number($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::number($name, $value, $options);
         }
         
         /**
-         * Set the root controller namespace.
+         * Create a date input field.
          *
-         * @param string $rootNamespace
-         * @return $this 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function setRootControllerNamespace($rootNamespace){
-            return \Illuminate\Routing\UrlGenerator::setRootControllerNamespace($rootNamespace);
+         */ 
+        public static function date($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::date($name, $value, $options);
         }
         
         /**
-         * Register a custom macro.
+         * Create a datetime input field.
          *
          * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Illuminate\Routing\UrlGenerator::macro($name, $macro);
+         */ 
+        public static function datetime($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::datetime($name, $value, $options);
         }
         
         /**
-         * Checks if macro is registered.
+         * Create a datetime-local input field.
          *
          * @param string $name
-         * @return bool 
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Illuminate\Routing\UrlGenerator::hasMacro($name);
+         */ 
+        public static function datetimeLocal($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::datetimeLocal($name, $value, $options);
         }
         
-    }
-
-
-    class Validator extends \Illuminate\Support\Facades\Validator{
-        
         /**
-         * Create a new Validator instance.
+         * Create a time input field.
          *
-         * @param array $data
-         * @param array $rules
-         * @param array $messages
-         * @param array $customAttributes
-         * @return \Illuminate\Validation\Validator 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function make($data, $rules, $messages = array(), $customAttributes = array()){
-            return \Illuminate\Validation\Factory::make($data, $rules, $messages, $customAttributes);
+         */ 
+        public static function time($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::time($name, $value, $options);
         }
         
         /**
-         * Validate the given data against the provided rules.
+         * Create a url input field.
          *
-         * @param array $data
-         * @param array $rules
-         * @param array $messages
-         * @param array $customAttributes
-         * @return void 
-         * @throws \Illuminate\Validation\ValidationException
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function validate($data, $rules, $messages = array(), $customAttributes = array()){
-            \Illuminate\Validation\Factory::validate($data, $rules, $messages, $customAttributes);
+         */ 
+        public static function url($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::url($name, $value, $options);
         }
         
         /**
-         * Register a custom validator extension.
+         * Create a file input field.
          *
-         * @param string $rule
-         * @param \Closure|string $extension
-         * @param string $message
-         * @return void 
+         * @param string $name
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function extend($rule, $extension, $message = null){
-            \Illuminate\Validation\Factory::extend($rule, $extension, $message);
+         */ 
+        public static function file($name, $options = array())
+        {
+            return \Collective\Html\FormBuilder::file($name, $options);
         }
         
         /**
-         * Register a custom implicit validator extension.
+         * Create a textarea input field.
          *
-         * @param string $rule
-         * @param \Closure|string $extension
-         * @param string $message
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function extendImplicit($rule, $extension, $message = null){
-            \Illuminate\Validation\Factory::extendImplicit($rule, $extension, $message);
+         */ 
+        public static function textarea($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::textarea($name, $value, $options);
         }
         
         /**
-         * Register a custom dependent validator extension.
+         * Create a select box field.
          *
-         * @param string $rule
-         * @param \Closure|string $extension
-         * @param string $message
-         * @return void 
+         * @param string $name
+         * @param array $list
+         * @param string|bool $selected
+         * @param array $selectAttributes
+         * @param array $optionsAttributes
+         * @param array $optgroupsAttributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function extendDependent($rule, $extension, $message = null){
-            \Illuminate\Validation\Factory::extendDependent($rule, $extension, $message);
+         */ 
+        public static function select($name, $list = array(), $selected = null, $selectAttributes = array(), $optionsAttributes = array(), $optgroupsAttributes = array())
+        {
+            return \Collective\Html\FormBuilder::select($name, $list, $selected, $selectAttributes, $optionsAttributes, $optgroupsAttributes);
         }
         
         /**
-         * Register a custom validator message replacer.
+         * Create a select range field.
          *
-         * @param string $rule
-         * @param \Closure|string $replacer
-         * @return void 
+         * @param string $name
+         * @param string $begin
+         * @param string $end
+         * @param string $selected
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function replacer($rule, $replacer){
-            \Illuminate\Validation\Factory::replacer($rule, $replacer);
+         */ 
+        public static function selectRange($name, $begin, $end, $selected = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::selectRange($name, $begin, $end, $selected, $options);
         }
         
         /**
-         * Set the Validator instance resolver.
+         * Create a select year field.
          *
-         * @param \Closure $resolver
-         * @return void 
+         * @param string $name
+         * @param string $begin
+         * @param string $end
+         * @param string $selected
+         * @param array $options
+         * @return mixed 
          * @static 
-         */
-        public static function resolver($resolver){
-            \Illuminate\Validation\Factory::resolver($resolver);
+         */ 
+        public static function selectYear()
+        {
+            return \Collective\Html\FormBuilder::selectYear();
         }
         
         /**
-         * Get the Translator implementation.
+         * Create a select month field.
          *
-         * @return \Illuminate\Contracts\Translation\Translator 
+         * @param string $name
+         * @param string $selected
+         * @param array $options
+         * @param string $format
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getTranslator(){
-            return \Illuminate\Validation\Factory::getTranslator();
+         */ 
+        public static function selectMonth($name, $selected = null, $options = array(), $format = '%B')
+        {
+            return \Collective\Html\FormBuilder::selectMonth($name, $selected, $options, $format);
         }
         
         /**
-         * Get the Presence Verifier implementation.
+         * Get the select option for the given value.
          *
-         * @return \Illuminate\Validation\PresenceVerifierInterface 
+         * @param string $display
+         * @param string $value
+         * @param string $selected
+         * @param array $attributes
+         * @param array $optgroupAttributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getPresenceVerifier(){
-            return \Illuminate\Validation\Factory::getPresenceVerifier();
+         */ 
+        public static function getSelectOption($display, $value, $selected, $attributes = array(), $optgroupAttributes = array())
+        {
+            return \Collective\Html\FormBuilder::getSelectOption($display, $value, $selected, $attributes, $optgroupAttributes);
         }
         
         /**
-         * Set the Presence Verifier implementation.
+         * Create a checkbox input field.
          *
-         * @param \Illuminate\Validation\PresenceVerifierInterface $presenceVerifier
-         * @return void 
+         * @param string $name
+         * @param mixed $value
+         * @param bool $checked
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function setPresenceVerifier($presenceVerifier){
-            \Illuminate\Validation\Factory::setPresenceVerifier($presenceVerifier);
+         */ 
+        public static function checkbox($name, $value = 1, $checked = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::checkbox($name, $value, $checked, $options);
         }
         
-    }
-
-
-    class View extends \Illuminate\Support\Facades\View{
-        
         /**
-         * Get the evaluated view contents for the given view.
+         * Create a radio button input field.
          *
-         * @param string $path
-         * @param array $data
-         * @param array $mergeData
-         * @return \Illuminate\Contracts\View\View 
+         * @param string $name
+         * @param mixed $value
+         * @param bool $checked
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function file($path, $data = array(), $mergeData = array()){
-            return \Illuminate\View\Factory::file($path, $data, $mergeData);
+         */ 
+        public static function radio($name, $value = null, $checked = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::radio($name, $value, $checked, $options);
         }
         
         /**
-         * Get the evaluated view contents for the given view.
+         * Create a HTML reset input element.
          *
-         * @param string $view
-         * @param array $data
-         * @param array $mergeData
-         * @return \Illuminate\Contracts\View\View 
+         * @param string $value
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function make($view, $data = array(), $mergeData = array()){
-            return \Illuminate\View\Factory::make($view, $data, $mergeData);
+         */ 
+        public static function reset($value, $attributes = array())
+        {
+            return \Collective\Html\FormBuilder::reset($value, $attributes);
         }
         
         /**
-         * Get the rendered content of the view based on a given condition.
+         * Create a HTML image input element.
          *
-         * @param bool $condition
-         * @param string $view
-         * @param array $data
-         * @param array $mergeData
-         * @return string 
+         * @param string $url
+         * @param string $name
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function renderWhen($condition, $view, $data = array(), $mergeData = array()){
-            return \Illuminate\View\Factory::renderWhen($condition, $view, $data, $mergeData);
+         */ 
+        public static function image($url, $name = null, $attributes = array())
+        {
+            return \Collective\Html\FormBuilder::image($url, $name, $attributes);
         }
         
         /**
-         * Get the rendered contents of a partial from a loop.
+         * Create a color input field.
          *
-         * @param string $view
-         * @param array $data
-         * @param string $iterator
-         * @param string $empty
-         * @return string 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function renderEach($view, $data, $iterator, $empty = 'raw|'){
-            return \Illuminate\View\Factory::renderEach($view, $data, $iterator, $empty);
+         */ 
+        public static function color($name, $value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::color($name, $value, $options);
         }
         
         /**
-         * Determine if a given view exists.
+         * Create a submit button element.
          *
-         * @param string $view
-         * @return bool 
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function exists($view){
-            return \Illuminate\View\Factory::exists($view);
+         */ 
+        public static function submit($value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::submit($value, $options);
         }
         
         /**
-         * Get the appropriate view engine for the given path.
+         * Create a button element.
          *
-         * @param string $path
-         * @return \Illuminate\View\Engines\EngineInterface 
-         * @throws \InvalidArgumentException
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getEngineFromPath($path){
-            return \Illuminate\View\Factory::getEngineFromPath($path);
+         */ 
+        public static function button($value = null, $options = array())
+        {
+            return \Collective\Html\FormBuilder::button($value, $options);
         }
         
         /**
-         * Add a piece of shared data to the environment.
+         * Get the ID attribute for a field name.
          *
-         * @param array|string $key
-         * @param mixed $value
-         * @return mixed 
+         * @param string $name
+         * @param array $attributes
+         * @return string 
          * @static 
-         */
-        public static function share($key, $value = null){
-            return \Illuminate\View\Factory::share($key, $value);
+         */ 
+        public static function getIdAttribute($name, $attributes)
+        {
+            return \Collective\Html\FormBuilder::getIdAttribute($name, $attributes);
         }
         
         /**
-         * Increment the rendering counter.
+         * Get the value that should be assigned to the field.
          *
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @return mixed 
          * @static 
-         */
-        public static function incrementRender(){
-            \Illuminate\View\Factory::incrementRender();
+         */ 
+        public static function getValueAttribute($name, $value = null)
+        {
+            return \Collective\Html\FormBuilder::getValueAttribute($name, $value);
         }
         
         /**
-         * Decrement the rendering counter.
+         * Get a value from the session's old input.
          *
-         * @return void 
+         * @param string $name
+         * @return mixed 
          * @static 
-         */
-        public static function decrementRender(){
-            \Illuminate\View\Factory::decrementRender();
+         */ 
+        public static function old($name)
+        {
+            return \Collective\Html\FormBuilder::old($name);
         }
         
         /**
-         * Check if there are no active render operations.
+         * Determine if the old input is empty.
          *
          * @return bool 
          * @static 
-         */
-        public static function doneRendering(){
-            return \Illuminate\View\Factory::doneRendering();
+         */ 
+        public static function oldInputIsEmpty()
+        {
+            return \Collective\Html\FormBuilder::oldInputIsEmpty();
         }
         
         /**
-         * Add a location to the array of view locations.
+         * Get the session store implementation.
          *
-         * @param string $location
-         * @return void 
+         * @return \Illuminate\Contracts\Session\Session $session
          * @static 
-         */
-        public static function addLocation($location){
-            \Illuminate\View\Factory::addLocation($location);
+         */ 
+        public static function getSessionStore()
+        {
+            return \Collective\Html\FormBuilder::getSessionStore();
         }
         
         /**
-         * Add a new namespace to the loader.
+         * Set the session store implementation.
          *
-         * @param string $namespace
-         * @param string|array $hints
+         * @param \Illuminate\Contracts\Session\Session $session
          * @return $this 
          * @static 
-         */
-        public static function addNamespace($namespace, $hints){
-            return \Illuminate\View\Factory::addNamespace($namespace, $hints);
+         */ 
+        public static function setSessionStore($session)
+        {
+            return \Collective\Html\FormBuilder::setSessionStore($session);
         }
         
         /**
-         * Prepend a new namespace to the loader.
+         * Register a custom macro.
          *
-         * @param string $namespace
-         * @param string|array $hints
-         * @return $this 
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function prependNamespace($namespace, $hints){
-            return \Illuminate\View\Factory::prependNamespace($namespace, $hints);
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Collective\Html\FormBuilder::macro($name, $macro);
         }
         
         /**
-         * Replace the namespace hints for the given namespace.
+         * Mix another object into the class.
          *
-         * @param string $namespace
-         * @param string|array $hints
-         * @return $this 
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function replaceNamespace($namespace, $hints){
-            return \Illuminate\View\Factory::replaceNamespace($namespace, $hints);
+         */ 
+        public static function mixin($mixin)
+        {
+            \Collective\Html\FormBuilder::mixin($mixin);
         }
         
         /**
-         * Register a valid view extension and its engine.
+         * Checks if macro is registered.
          *
-         * @param string $extension
-         * @param string $engine
-         * @param \Closure $resolver
-         * @return void 
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function addExtension($extension, $engine, $resolver = null){
-            \Illuminate\View\Factory::addExtension($extension, $engine, $resolver);
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Collective\Html\FormBuilder::hasMacro($name);
         }
         
         /**
-         * Flush all of the factory state like sections and stacks.
+         * Dynamically handle calls to the class.
          *
-         * @return void 
+         * @param string $method
+         * @param array $parameters
+         * @return mixed 
+         * @throws \BadMethodCallException
          * @static 
-         */
-        public static function flushState(){
-            \Illuminate\View\Factory::flushState();
+         */ 
+        public static function macroCall($method, $parameters)
+        {
+            return \Collective\Html\FormBuilder::macroCall($method, $parameters);
         }
         
         /**
-         * Flush all of the section contents if done rendering.
+         * Register a custom component.
          *
+         * @param $name
+         * @param $view
+         * @param array $signature
          * @return void 
          * @static 
-         */
-        public static function flushStateIfDoneRendering(){
-            \Illuminate\View\Factory::flushStateIfDoneRendering();
+         */ 
+        public static function component($name, $view, $signature)
+        {
+            \Collective\Html\FormBuilder::component($name, $view, $signature);
         }
         
         /**
-         * Get the extension to engine bindings.
+         * Check if a component is registered.
          *
-         * @return array 
+         * @param $name
+         * @return bool 
          * @static 
-         */
-        public static function getExtensions(){
-            return \Illuminate\View\Factory::getExtensions();
+         */ 
+        public static function hasComponent($name)
+        {
+            return \Collective\Html\FormBuilder::hasComponent($name);
         }
         
         /**
-         * Get the engine resolver instance.
+         * Dynamically handle calls to the class.
          *
-         * @return \Illuminate\View\Engines\EngineResolver 
+         * @param string $method
+         * @param array $parameters
+         * @return \Illuminate\Contracts\View\View|mixed 
+         * @throws \BadMethodCallException
          * @static 
-         */
-        public static function getEngineResolver(){
-            return \Illuminate\View\Factory::getEngineResolver();
+         */ 
+        public static function componentCall($method, $parameters)
+        {
+            return \Collective\Html\FormBuilder::componentCall($method, $parameters);
         }
         
         /**
-         * Get the view finder instance.
+         * 
          *
-         * @return \Illuminate\View\ViewFinderInterface 
          * @static 
-         */
-        public static function getFinder(){
-            return \Illuminate\View\Factory::getFinder();
+         */ 
+        public static function captcha($attributes = array())
+        {
+            return \Collective\Html\FormBuilder::captcha($attributes);
         }
+         
+    }
+
+    class HtmlFacade {
         
         /**
-         * Set the view finder instance.
+         * Convert an HTML string to entities.
          *
-         * @param \Illuminate\View\ViewFinderInterface $finder
-         * @return void 
+         * @param string $value
+         * @return string 
          * @static 
-         */
-        public static function setFinder($finder){
-            \Illuminate\View\Factory::setFinder($finder);
+         */ 
+        public static function entities($value)
+        {
+            return \Collective\Html\HtmlBuilder::entities($value);
         }
         
         /**
-         * Flush the cache of views located by the finder.
+         * Convert entities to HTML characters.
          *
-         * @return void 
+         * @param string $value
+         * @return string 
          * @static 
-         */
-        public static function flushFinderCache(){
-            \Illuminate\View\Factory::flushFinderCache();
+         */ 
+        public static function decode($value)
+        {
+            return \Collective\Html\HtmlBuilder::decode($value);
         }
         
         /**
-         * Get the event dispatcher instance.
+         * Generate a link to a JavaScript file.
          *
-         * @return \Illuminate\Contracts\Events\Dispatcher 
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getDispatcher(){
-            return \Illuminate\View\Factory::getDispatcher();
+         */ 
+        public static function script($url, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::script($url, $attributes, $secure);
         }
         
         /**
-         * Set the event dispatcher instance.
+         * Generate a link to a CSS file.
          *
-         * @param \Illuminate\Contracts\Events\Dispatcher $events
-         * @return void 
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function setDispatcher($events){
-            \Illuminate\View\Factory::setDispatcher($events);
+         */ 
+        public static function style($url, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::style($url, $attributes, $secure);
         }
         
         /**
-         * Get the IoC container instance.
+         * Generate an HTML image element.
          *
-         * @return \Illuminate\Contracts\Container\Container 
+         * @param string $url
+         * @param string $alt
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getContainer(){
-            return \Illuminate\View\Factory::getContainer();
+         */ 
+        public static function image($url, $alt = null, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::image($url, $alt, $attributes, $secure);
         }
         
         /**
-         * Set the IoC container instance.
+         * Generate a link to a Favicon file.
          *
-         * @param \Illuminate\Contracts\Container\Container $container
-         * @return void 
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function setContainer($container){
-            \Illuminate\View\Factory::setContainer($container);
+         */ 
+        public static function favicon($url, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::favicon($url, $attributes, $secure);
         }
         
         /**
-         * Get an item from the shared data.
+         * Generate a HTML link.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @param bool $secure
+         * @param bool $escape
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function shared($key, $default = null){
-            return \Illuminate\View\Factory::shared($key, $default);
+         */ 
+        public static function link($url, $title = null, $attributes = array(), $secure = null, $escape = true)
+        {
+            return \Collective\Html\HtmlBuilder::link($url, $title, $attributes, $secure, $escape);
         }
         
         /**
-         * Get all of the shared data for the environment.
+         * Generate a HTTPS HTML link.
          *
-         * @return array 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getShared(){
-            return \Illuminate\View\Factory::getShared();
+         */ 
+        public static function secureLink($url, $title = null, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::secureLink($url, $title, $attributes);
         }
         
         /**
-         * Register a view composer event.
+         * Generate a HTML link to an asset.
          *
-         * @param array|string $views
-         * @param \Closure|string $callback
-         * @return array 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function composer($views, $callback){
-            return \Illuminate\View\Factory::composer($views, $callback);
+         */ 
+        public static function linkAsset($url, $title = null, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::linkAsset($url, $title, $attributes, $secure);
         }
         
         /**
-         * Register a view creator event.
+         * Generate a HTTPS HTML link to an asset.
          *
-         * @param array|string $views
-         * @param \Closure|string $callback
-         * @return array 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function creator($views, $callback){
-            return \Illuminate\View\Factory::creator($views, $callback);
+         */ 
+        public static function linkSecureAsset($url, $title = null, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::linkSecureAsset($url, $title, $attributes);
         }
         
         /**
-         * Start a component rendering process.
+         * Generate a HTML link to a named route.
          *
          * @param string $name
-         * @param array $data
-         * @return void 
+         * @param string $title
+         * @param array $parameters
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function startComponent($name, $data = array()){
-            \Illuminate\View\Factory::startComponent($name, $data);
+         */ 
+        public static function linkRoute($name, $title = null, $parameters = array(), $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::linkRoute($name, $title, $parameters, $attributes);
         }
         
         /**
-         * Render the current component.
+         * Generate a HTML link to a controller action.
          *
-         * @return string 
+         * @param string $action
+         * @param string $title
+         * @param array $parameters
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function renderComponent(){
-            return \Illuminate\View\Factory::renderComponent();
+         */ 
+        public static function linkAction($action, $title = null, $parameters = array(), $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::linkAction($action, $title, $parameters, $attributes);
         }
         
         /**
-         * Start the slot rendering process.
+         * Generate a HTML link to an email address.
          *
-         * @param string $name
-         * @param string|null $content
-         * @return void 
+         * @param string $email
+         * @param string $title
+         * @param array $attributes
+         * @param bool $escape
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function slot($name, $content = null){
-            \Illuminate\View\Factory::slot($name, $content);
+         */ 
+        public static function mailto($email, $title = null, $attributes = array(), $escape = true)
+        {
+            return \Collective\Html\HtmlBuilder::mailto($email, $title, $attributes, $escape);
         }
         
         /**
-         * Save the slot content for rendering.
+         * Obfuscate an e-mail address to prevent spam-bots from sniffing it.
          *
-         * @return void 
+         * @param string $email
+         * @return string 
          * @static 
-         */
-        public static function endSlot(){
-            \Illuminate\View\Factory::endSlot();
+         */ 
+        public static function email($email)
+        {
+            return \Collective\Html\HtmlBuilder::email($email);
         }
         
         /**
-         * Register multiple view composers via an array.
+         * Generates non-breaking space entities based on number supplied.
          *
-         * @param array $composers
-         * @return array 
+         * @param int $num
+         * @return string 
          * @static 
-         */
-        public static function composers($composers){
-            return \Illuminate\View\Factory::composers($composers);
+         */ 
+        public static function nbsp($num = 1)
+        {
+            return \Collective\Html\HtmlBuilder::nbsp($num);
         }
         
         /**
-         * Call the composer for a given view.
+         * Generate an ordered list of items.
          *
-         * @param \Illuminate\Contracts\View\View $view
-         * @return void 
+         * @param array $list
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString|string 
          * @static 
-         */
-        public static function callComposer($view){
-            \Illuminate\View\Factory::callComposer($view);
+         */ 
+        public static function ol($list, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::ol($list, $attributes);
         }
         
         /**
-         * Call the creator for a given view.
+         * Generate an un-ordered list of items.
          *
-         * @param \Illuminate\Contracts\View\View $view
-         * @return void 
+         * @param array $list
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString|string 
          * @static 
-         */
-        public static function callCreator($view){
-            \Illuminate\View\Factory::callCreator($view);
+         */ 
+        public static function ul($list, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::ul($list, $attributes);
         }
         
         /**
-         * Start injecting content into a section.
+         * Generate a description list of items.
          *
-         * @param string $section
-         * @param string|null $content
-         * @return void 
+         * @param array $list
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function startSection($section, $content = null){
-            \Illuminate\View\Factory::startSection($section, $content);
+         */ 
+        public static function dl($list, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::dl($list, $attributes);
         }
         
         /**
-         * Inject inline content into a section.
+         * Build an HTML attribute string from an array.
          *
-         * @param string $section
-         * @param string $content
-         * @return void 
+         * @param array $attributes
+         * @return string 
          * @static 
-         */
-        public static function inject($section, $content){
-            \Illuminate\View\Factory::inject($section, $content);
+         */ 
+        public static function attributes($attributes)
+        {
+            return \Collective\Html\HtmlBuilder::attributes($attributes);
         }
         
         /**
-         * Stop injecting content into a section and return its contents.
+         * Obfuscate a string to prevent spam-bots from sniffing it.
          *
+         * @param string $value
          * @return string 
          * @static 
-         */
-        public static function yieldSection(){
-            return \Illuminate\View\Factory::yieldSection();
+         */ 
+        public static function obfuscate($value)
+        {
+            return \Collective\Html\HtmlBuilder::obfuscate($value);
         }
         
         /**
-         * Stop injecting content into a section.
+         * Generate a meta tag.
          *
-         * @param bool $overwrite
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @param string $name
+         * @param string $content
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function stopSection($overwrite = false){
-            return \Illuminate\View\Factory::stopSection($overwrite);
+         */ 
+        public static function meta($name, $content, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::meta($name, $content, $attributes);
         }
         
         /**
-         * Stop injecting content into a section and append it.
+         * Generate an html tag.
          *
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @param string $tag
+         * @param mixed $content
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function appendSection(){
-            return \Illuminate\View\Factory::appendSection();
+         */ 
+        public static function tag($tag, $content, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::tag($tag, $content, $attributes);
         }
         
         /**
-         * Get the string contents of a section.
+         * Register a custom macro.
          *
-         * @param string $section
-         * @param string $default
-         * @return string 
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function yieldContent($section, $default = ''){
-            return \Illuminate\View\Factory::yieldContent($section, $default);
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Collective\Html\HtmlBuilder::macro($name, $macro);
         }
         
         /**
-         * Get the parent placeholder for the current request.
+         * Mix another object into the class.
          *
-         * @param string $section
-         * @return string 
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function parentPlaceholder($section = ''){
-            return \Illuminate\View\Factory::parentPlaceholder($section);
+         */ 
+        public static function mixin($mixin)
+        {
+            \Collective\Html\HtmlBuilder::mixin($mixin);
         }
         
         /**
-         * Check if section exists.
+         * Checks if macro is registered.
          *
          * @param string $name
          * @return bool 
          * @static 
-         */
-        public static function hasSection($name){
-            return \Illuminate\View\Factory::hasSection($name);
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Collective\Html\HtmlBuilder::hasMacro($name);
         }
         
         /**
-         * Get the contents of a section.
+         * Dynamically handle calls to the class.
          *
-         * @param string $name
-         * @param string $default
+         * @param string $method
+         * @param array $parameters
          * @return mixed 
+         * @throws \BadMethodCallException
          * @static 
-         */
-        public static function getSection($name, $default = null){
-            return \Illuminate\View\Factory::getSection($name, $default);
+         */ 
+        public static function macroCall($method, $parameters)
+        {
+            return \Collective\Html\HtmlBuilder::macroCall($method, $parameters);
         }
         
         /**
-         * Get the entire array of sections.
+         * Register a custom component.
          *
-         * @return array 
+         * @param $name
+         * @param $view
+         * @param array $signature
+         * @return void 
          * @static 
-         */
-        public static function getSections(){
-            return \Illuminate\View\Factory::getSections();
+         */ 
+        public static function component($name, $view, $signature)
+        {
+            \Collective\Html\HtmlBuilder::component($name, $view, $signature);
         }
         
         /**
-         * Flush all of the sections.
+         * Check if a component is registered.
          *
-         * @return void 
+         * @param $name
+         * @return bool 
          * @static 
-         */
-        public static function flushSections(){
-            \Illuminate\View\Factory::flushSections();
+         */ 
+        public static function hasComponent($name)
+        {
+            return \Collective\Html\HtmlBuilder::hasComponent($name);
         }
         
         /**
-         * Add new loop to the stack.
+         * Dynamically handle calls to the class.
          *
-         * @param \Countable|array $data
-         * @return void 
+         * @param string $method
+         * @param array $parameters
+         * @return \Illuminate\Contracts\View\View|mixed 
+         * @throws \BadMethodCallException
          * @static 
-         */
-        public static function addLoop($data){
-            \Illuminate\View\Factory::addLoop($data);
+         */ 
+        public static function componentCall($method, $parameters)
+        {
+            return \Collective\Html\HtmlBuilder::componentCall($method, $parameters);
         }
+         
+    }
+
+    class HtmlFacade {
         
         /**
-         * Increment the top loop's indices.
+         * Convert an HTML string to entities.
          *
-         * @return void 
+         * @param string $value
+         * @return string 
          * @static 
-         */
-        public static function incrementLoopIndices(){
-            \Illuminate\View\Factory::incrementLoopIndices();
+         */ 
+        public static function entities($value)
+        {
+            return \Collective\Html\HtmlBuilder::entities($value);
         }
         
         /**
-         * Pop a loop from the top of the loop stack.
+         * Convert entities to HTML characters.
          *
-         * @return void 
+         * @param string $value
+         * @return string 
          * @static 
-         */
-        public static function popLoop(){
-            \Illuminate\View\Factory::popLoop();
+         */ 
+        public static function decode($value)
+        {
+            return \Collective\Html\HtmlBuilder::decode($value);
         }
         
         /**
-         * Get an instance of the last loop in the stack.
+         * Generate a link to a JavaScript file.
          *
-         * @return \stdClass|null 
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getLastLoop(){
-            return \Illuminate\View\Factory::getLastLoop();
+         */ 
+        public static function script($url, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::script($url, $attributes, $secure);
         }
         
         /**
-         * Get the entire loop stack.
+         * Generate a link to a CSS file.
          *
-         * @return array 
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getLoopStack(){
-            return \Illuminate\View\Factory::getLoopStack();
+         */ 
+        public static function style($url, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::style($url, $attributes, $secure);
         }
         
         /**
-         * Start injecting content into a push section.
+         * Generate an HTML image element.
          *
-         * @param string $section
-         * @param string $content
-         * @return void 
+         * @param string $url
+         * @param string $alt
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function startPush($section, $content = ''){
-            \Illuminate\View\Factory::startPush($section, $content);
+         */ 
+        public static function image($url, $alt = null, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::image($url, $alt, $attributes, $secure);
         }
         
         /**
-         * Stop injecting content into a push section.
+         * Generate a link to a Favicon file.
          *
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function stopPush(){
-            return \Illuminate\View\Factory::stopPush();
+         */ 
+        public static function favicon($url, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::favicon($url, $attributes, $secure);
         }
         
         /**
-         * Start prepending content into a push section.
+         * Generate a HTML link.
          *
-         * @param string $section
-         * @param string $content
-         * @return void 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @param bool $secure
+         * @param bool $escape
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function startPrepend($section, $content = ''){
-            \Illuminate\View\Factory::startPrepend($section, $content);
+         */ 
+        public static function link($url, $title = null, $attributes = array(), $secure = null, $escape = true)
+        {
+            return \Collective\Html\HtmlBuilder::link($url, $title, $attributes, $secure, $escape);
         }
         
         /**
-         * Stop prepending content into a push section.
+         * Generate a HTTPS HTML link.
          *
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function stopPrepend(){
-            return \Illuminate\View\Factory::stopPrepend();
+         */ 
+        public static function secureLink($url, $title = null, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::secureLink($url, $title, $attributes);
         }
         
         /**
-         * Get the string contents of a push section.
+         * Generate a HTML link to an asset.
          *
-         * @param string $section
-         * @param string $default
-         * @return string 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function yieldPushContent($section, $default = ''){
-            return \Illuminate\View\Factory::yieldPushContent($section, $default);
+         */ 
+        public static function linkAsset($url, $title = null, $attributes = array(), $secure = null)
+        {
+            return \Collective\Html\HtmlBuilder::linkAsset($url, $title, $attributes, $secure);
         }
         
         /**
-         * Flush all of the stacks.
+         * Generate a HTTPS HTML link to an asset.
          *
-         * @return void 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function flushStacks(){
-            \Illuminate\View\Factory::flushStacks();
+         */ 
+        public static function linkSecureAsset($url, $title = null, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::linkSecureAsset($url, $title, $attributes);
         }
         
         /**
-         * Start a translation block.
+         * Generate a HTML link to a named route.
          *
-         * @param array $replacements
-         * @return void 
+         * @param string $name
+         * @param string $title
+         * @param array $parameters
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function startTranslation($replacements = array()){
-            \Illuminate\View\Factory::startTranslation($replacements);
+         */ 
+        public static function linkRoute($name, $title = null, $parameters = array(), $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::linkRoute($name, $title, $parameters, $attributes);
         }
         
         /**
-         * Render the current translation.
+         * Generate a HTML link to a controller action.
          *
-         * @return string 
+         * @param string $action
+         * @param string $title
+         * @param array $parameters
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function renderTranslation(){
-            return \Illuminate\View\Factory::renderTranslation();
+         */ 
+        public static function linkAction($action, $title = null, $parameters = array(), $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::linkAction($action, $title, $parameters, $attributes);
         }
         
-    }
-
-
-    class Notification extends \Illuminate\Support\Facades\Notification{
+        /**
+         * Generate a HTML link to an email address.
+         *
+         * @param string $email
+         * @param string $title
+         * @param array $attributes
+         * @param bool $escape
+         * @return \Illuminate\Support\HtmlString 
+         * @static 
+         */ 
+        public static function mailto($email, $title = null, $attributes = array(), $escape = true)
+        {
+            return \Collective\Html\HtmlBuilder::mailto($email, $title, $attributes, $escape);
+        }
         
         /**
-         * Send the given notification to the given notifiable entities.
+         * Obfuscate an e-mail address to prevent spam-bots from sniffing it.
          *
-         * @param \Illuminate\Support\Collection|array|mixed $notifiables
-         * @param mixed $notification
-         * @return void 
+         * @param string $email
+         * @return string 
          * @static 
-         */
-        public static function send($notifiables, $notification){
-            \Illuminate\Notifications\ChannelManager::send($notifiables, $notification);
+         */ 
+        public static function email($email)
+        {
+            return \Collective\Html\HtmlBuilder::email($email);
         }
         
         /**
-         * Send the given notification immediately.
+         * Generates non-breaking space entities based on number supplied.
          *
-         * @param \Illuminate\Support\Collection|array|mixed $notifiables
-         * @param mixed $notification
-         * @param array|null $channels
-         * @return void 
+         * @param int $num
+         * @return string 
          * @static 
-         */
-        public static function sendNow($notifiables, $notification, $channels = null){
-            \Illuminate\Notifications\ChannelManager::sendNow($notifiables, $notification, $channels);
+         */ 
+        public static function nbsp($num = 1)
+        {
+            return \Collective\Html\HtmlBuilder::nbsp($num);
         }
         
         /**
-         * Get a channel instance.
+         * Generate an ordered list of items.
          *
-         * @param string|null $name
-         * @return mixed 
+         * @param array $list
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString|string 
          * @static 
-         */
-        public static function channel($name = null){
-            return \Illuminate\Notifications\ChannelManager::channel($name);
+         */ 
+        public static function ol($list, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::ol($list, $attributes);
         }
         
         /**
-         * Get the default channel driver name.
+         * Generate an un-ordered list of items.
          *
-         * @return string 
+         * @param array $list
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString|string 
          * @static 
-         */
-        public static function getDefaultDriver(){
-            return \Illuminate\Notifications\ChannelManager::getDefaultDriver();
+         */ 
+        public static function ul($list, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::ul($list, $attributes);
         }
         
         /**
-         * Get the default channel driver name.
+         * Generate a description list of items.
          *
-         * @return string 
+         * @param array $list
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function deliversVia(){
-            return \Illuminate\Notifications\ChannelManager::deliversVia();
+         */ 
+        public static function dl($list, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::dl($list, $attributes);
         }
         
         /**
-         * Set the default channel driver name.
+         * Build an HTML attribute string from an array.
          *
-         * @param string $channel
-         * @return void 
+         * @param array $attributes
+         * @return string 
          * @static 
-         */
-        public static function deliverVia($channel){
-            \Illuminate\Notifications\ChannelManager::deliverVia($channel);
+         */ 
+        public static function attributes($attributes)
+        {
+            return \Collective\Html\HtmlBuilder::attributes($attributes);
         }
         
         /**
-         * Get a driver instance.
+         * Obfuscate a string to prevent spam-bots from sniffing it.
          *
-         * @param string $driver
-         * @return mixed 
+         * @param string $value
+         * @return string 
          * @static 
-         */
-        public static function driver($driver = null){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Notifications\ChannelManager::driver($driver);
+         */ 
+        public static function obfuscate($value)
+        {
+            return \Collective\Html\HtmlBuilder::obfuscate($value);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Generate a meta tag.
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $name
+         * @param string $content
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function extend($driver, $callback){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Notifications\ChannelManager::extend($driver, $callback);
+         */ 
+        public static function meta($name, $content, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::meta($name, $content, $attributes);
         }
         
         /**
-         * Get all of the created "drivers".
+         * Generate an html tag.
          *
-         * @return array 
+         * @param string $tag
+         * @param mixed $content
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
-         */
-        public static function getDrivers(){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Notifications\ChannelManager::getDrivers();
+         */ 
+        public static function tag($tag, $content, $attributes = array())
+        {
+            return \Collective\Html\HtmlBuilder::tag($tag, $content, $attributes);
         }
         
-    }
-
-
-    class JsValidator extends \Proengsoft\JsValidation\Facades\JsValidatorFacade{
-        
         /**
-         * Creates JsValidator instance based on rules and message arrays.
+         * Register a custom macro.
          *
-         * @param array $rules
-         * @param array $messages
-         * @param array $customAttributes
-         * @param null|string $selector
-         * @return \Proengsoft\JsValidation\JavascriptValidator 
+         * @param string $name
+         * @param object|callable $macro
+         * @return void 
          * @static 
-         */
-        public static function make($rules, $messages = array(), $customAttributes = array(), $selector = null){
-            return \Proengsoft\JsValidation\JsValidatorFactory::make($rules, $messages, $customAttributes, $selector);
+         */ 
+        public static function macro($name, $macro)
+        {
+            \Collective\Html\HtmlBuilder::macro($name, $macro);
         }
         
         /**
-         * Creates JsValidator instance based on FormRequest.
+         * Mix another object into the class.
          *
-         * @param $formRequest
-         * @param null $selector
-         * @return \Proengsoft\JsValidation\JavascriptValidator 
-         * @throws FormRequestArgumentException
+         * @param object $mixin
+         * @return void 
          * @static 
-         */
-        public static function formRequest($formRequest, $selector = null){
-            return \Proengsoft\JsValidation\JsValidatorFactory::formRequest($formRequest, $selector);
+         */ 
+        public static function mixin($mixin)
+        {
+            \Collective\Html\HtmlBuilder::mixin($mixin);
         }
         
         /**
-         * Creates JsValidator instance based on Validator.
+         * Checks if macro is registered.
          *
-         * @param \Illuminate\Validation\Validator $validator
-         * @param string|null $selector
-         * @return \Proengsoft\JsValidation\JavascriptValidator 
+         * @param string $name
+         * @return bool 
          * @static 
-         */
-        public static function validator($validator, $selector = null){
-            return \Proengsoft\JsValidation\JsValidatorFactory::validator($validator, $selector);
+         */ 
+        public static function hasMacro($name)
+        {
+            return \Collective\Html\HtmlBuilder::hasMacro($name);
         }
         
-    }
-
-
-    class Socialite extends \Laravel\Socialite\Facades\Socialite{
-        
         /**
-         * Get a driver instance.
+         * Dynamically handle calls to the class.
          *
-         * @param string $driver
+         * @param string $method
+         * @param array $parameters
          * @return mixed 
+         * @throws \BadMethodCallException
          * @static 
-         */
-        public static function with($driver){
-            return \Laravel\Socialite\SocialiteManager::with($driver);
+         */ 
+        public static function macroCall($method, $parameters)
+        {
+            return \Collective\Html\HtmlBuilder::macroCall($method, $parameters);
         }
         
         /**
-         * Build an OAuth 2 provider instance.
+         * Register a custom component.
          *
-         * @param string $provider
-         * @param array $config
-         * @return \Laravel\Socialite\Two\AbstractProvider 
+         * @param $name
+         * @param $view
+         * @param array $signature
+         * @return void 
          * @static 
-         */
-        public static function buildProvider($provider, $config){
-            return \Laravel\Socialite\SocialiteManager::buildProvider($provider, $config);
+         */ 
+        public static function component($name, $view, $signature)
+        {
+            \Collective\Html\HtmlBuilder::component($name, $view, $signature);
         }
         
         /**
-         * Format the server configuration.
+         * Check if a component is registered.
          *
-         * @param array $config
-         * @return array 
+         * @param $name
+         * @return bool 
          * @static 
-         */
-        public static function formatConfig($config){
-            return \Laravel\Socialite\SocialiteManager::formatConfig($config);
+         */ 
+        public static function hasComponent($name)
+        {
+            return \Collective\Html\HtmlBuilder::hasComponent($name);
         }
         
         /**
-         * Get the default driver name.
+         * Dynamically handle calls to the class.
          *
-         * @throws \InvalidArgumentException
-         * @return string 
+         * @param string $method
+         * @param array $parameters
+         * @return \Illuminate\Contracts\View\View|mixed 
+         * @throws \BadMethodCallException
          * @static 
-         */
-        public static function getDefaultDriver(){
-            return \Laravel\Socialite\SocialiteManager::getDefaultDriver();
+         */ 
+        public static function componentCall($method, $parameters)
+        {
+            return \Collective\Html\HtmlBuilder::componentCall($method, $parameters);
         }
+         
+    }
+ 
+}
+
+namespace Webpatser\Countries { 
+
+    class CountriesFacade {
         
         /**
-         * Get a driver instance.
+         * Returns one country
          *
-         * @param string $driver
-         * @return mixed 
+         * @param string $id The country id
+         * @return array 
          * @static 
-         */
-        public static function driver($driver = null){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Laravel\Socialite\SocialiteManager::driver($driver);
+         */ 
+        public static function getOne($id)
+        {
+            return \Webpatser\Countries\Countries::getOne($id);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Returns a list of countries
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @param string  sort
+         * @return array 
          * @static 
-         */
-        public static function extend($driver, $callback){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Laravel\Socialite\SocialiteManager::extend($driver, $callback);
+         */ 
+        public static function getList($sort = null)
+        {
+            return \Webpatser\Countries\Countries::getList($sort);
         }
         
         /**
-         * Get all of the created "drivers".
+         * Returns a list of countries suitable to use with a select element in Laravelcollective\html
+         * Will show the value and sort by the column specified in the display attribute
          *
+         * @param string  display
          * @return array 
          * @static 
-         */
-        public static function getDrivers(){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Laravel\Socialite\SocialiteManager::getDrivers();
+         */ 
+        public static function getListForSelect($display = 'name')
+        {
+            return \Webpatser\Countries\Countries::getListForSelect($display);
         }
         
-    }
-
-
-    class Form extends \Collective\Html\FormFacade{
-        
         /**
-         * Open up a new HTML form.
+         * Clear the list of booted models so they will be re-booted.
          *
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return void 
          * @static 
-         */
-        public static function open($options = array()){
-            return \Collective\Html\FormBuilder::open($options);
+         */ 
+        public static function clearBootedModels()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::clearBootedModels();
         }
         
         /**
-         * Create a new model based form builder.
+         * Fill the model with an array of attributes.
          *
-         * @param mixed $model
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $attributes
+         * @return $this 
+         * @throws \Illuminate\Database\Eloquent\MassAssignmentException
          * @static 
-         */
-        public static function model($model, $options = array()){
-            return \Collective\Html\FormBuilder::model($model, $options);
+         */ 
+        public static function fill($attributes)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::fill($attributes);
         }
         
         /**
-         * Set the model instance on the form builder.
+         * Fill the model with an array of attributes. Force mass assignment.
          *
-         * @param mixed $model
-         * @return void 
+         * @param array $attributes
+         * @return $this 
          * @static 
-         */
-        public static function setModel($model){
-            \Collective\Html\FormBuilder::setModel($model);
+         */ 
+        public static function forceFill($attributes)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::forceFill($attributes);
         }
         
         /**
-         * Close the current form.
+         * Qualify the given column name by the model's table.
          *
+         * @param string $column
          * @return string 
          * @static 
-         */
-        public static function close(){
-            return \Collective\Html\FormBuilder::close();
+         */ 
+        public static function qualifyColumn($column)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::qualifyColumn($column);
         }
         
         /**
-         * Generate a hidden field with the current CSRF token.
+         * Create a new instance of the given model.
          *
-         * @return string 
+         * @param array $attributes
+         * @param bool $exists
+         * @return static 
          * @static 
-         */
-        public static function token(){
-            return \Collective\Html\FormBuilder::token();
+         */ 
+        public static function newInstance($attributes = array(), $exists = false)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newInstance($attributes, $exists);
         }
         
         /**
-         * Create a form label element.
+         * Create a new model instance that is existing.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @param bool $escape_html
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $attributes
+         * @param string|null $connection
+         * @return static 
          * @static 
-         */
-        public static function label($name, $value = null, $options = array(), $escape_html = true){
-            return \Collective\Html\FormBuilder::label($name, $value, $options, $escape_html);
+         */ 
+        public static function newFromBuilder($attributes = array(), $connection = null)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newFromBuilder($attributes, $connection);
         }
         
         /**
-         * Create a form input field.
+         * Begin querying the model on a given connection.
          *
-         * @param string $type
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param string|null $connection
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
-         */
-        public static function input($type, $name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::input($type, $name, $value, $options);
+         */ 
+        public static function on($connection = null)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::on($connection);
         }
         
         /**
-         * Create a text input field.
+         * Begin querying the model on the write connection.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return \Illuminate\Database\Query\Builder 
          * @static 
-         */
-        public static function text($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::text($name, $value, $options);
+         */ 
+        public static function onWriteConnection()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::onWriteConnection();
         }
         
         /**
-         * Create a password input field.
+         * Get all of the models from the database.
          *
-         * @param string $name
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|mixed $columns
+         * @return \Illuminate\Database\Eloquent\Collection|static[] 
          * @static 
-         */
-        public static function password($name, $options = array()){
-            return \Collective\Html\FormBuilder::password($name, $options);
+         */ 
+        public static function all($columns = array())
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::all($columns);
         }
         
         /**
-         * Create a hidden input field.
+         * Begin querying a model with eager loading.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|string $relations
+         * @return \Illuminate\Database\Eloquent\Builder|static 
          * @static 
-         */
-        public static function hidden($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::hidden($name, $value, $options);
+         */ 
+        public static function with($relations)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::with($relations);
         }
         
         /**
-         * Create a search input field.
+         * Eager load relations on the model.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|string $relations
+         * @return $this 
          * @static 
-         */
-        public static function search($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::search($name, $value, $options);
+         */ 
+        public static function load($relations)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::load($relations);
         }
         
         /**
-         * Create an e-mail input field.
+         * Eager load relations on the model if they are not already eager loaded.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|string $relations
+         * @return $this 
          * @static 
-         */
-        public static function email($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::email($name, $value, $options);
+         */ 
+        public static function loadMissing($relations)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::loadMissing($relations);
         }
         
         /**
-         * Create a tel input field.
+         * Update the model in the database.
          *
-         * @param string $name
-         * @param string $value
+         * @param array $attributes
          * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool 
          * @static 
-         */
-        public static function tel($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::tel($name, $value, $options);
+         */ 
+        public static function update($attributes = array(), $options = array())
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::update($attributes, $options);
         }
         
         /**
-         * Create a number input field.
+         * Save the model and all of its relationships.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool 
          * @static 
-         */
-        public static function number($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::number($name, $value, $options);
+         */ 
+        public static function push()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::push();
         }
         
         /**
-         * Create a date input field.
+         * Save the model to the database.
          *
-         * @param string $name
-         * @param string $value
          * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool 
          * @static 
-         */
-        public static function date($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::date($name, $value, $options);
+         */ 
+        public static function save($options = array())
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::save($options);
         }
         
         /**
-         * Create a datetime input field.
+         * Save the model to the database using transaction.
          *
-         * @param string $name
-         * @param string $value
          * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool 
+         * @throws \Throwable
          * @static 
-         */
-        public static function datetime($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::datetime($name, $value, $options);
+         */ 
+        public static function saveOrFail($options = array())
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::saveOrFail($options);
         }
         
         /**
-         * Create a datetime-local input field.
+         * Destroy the models for the given IDs.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|int $ids
+         * @return int 
          * @static 
-         */
-        public static function datetimeLocal($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::datetimeLocal($name, $value, $options);
+         */ 
+        public static function destroy($ids)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::destroy($ids);
         }
         
         /**
-         * Create a time input field.
+         * Delete the model from the database.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool|null 
+         * @throws \Exception
          * @static 
-         */
-        public static function time($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::time($name, $value, $options);
+         */ 
+        public static function delete()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::delete();
         }
         
         /**
-         * Create a url input field.
+         * Force a hard delete on a soft deleted model.
+         * 
+         * This method protects developers from running forceDelete when trait is missing.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool|null 
          * @static 
-         */
-        public static function url($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::url($name, $value, $options);
+         */ 
+        public static function forceDelete()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::forceDelete();
         }
         
         /**
-         * Create a file input field.
+         * Begin querying the model.
          *
-         * @param string $name
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
-         */
-        public static function file($name, $options = array()){
-            return \Collective\Html\FormBuilder::file($name, $options);
+         */ 
+        public static function query()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::query();
         }
         
         /**
-         * Create a textarea input field.
+         * Get a new query builder for the model's table.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
-         */
-        public static function textarea($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::textarea($name, $value, $options);
+         */ 
+        public static function newQuery()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newQuery();
         }
         
         /**
-         * Create a select box field.
+         * Get a new query builder with no relationships loaded.
          *
-         * @param string $name
-         * @param array $list
-         * @param string $selected
-         * @param array $selectAttributes
-         * @param array $optionsAttributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
-         */
-        public static function select($name, $list = array(), $selected = null, $selectAttributes = array(), $optionsAttributes = array()){
-            return \Collective\Html\FormBuilder::select($name, $list, $selected, $selectAttributes, $optionsAttributes);
+         */ 
+        public static function newQueryWithoutRelationships()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newQueryWithoutRelationships();
         }
         
         /**
-         * Create a select range field.
+         * Register the global scopes for this builder instance.
          *
-         * @param string $name
-         * @param string $begin
-         * @param string $end
-         * @param string $selected
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param \Illuminate\Database\Eloquent\Builder $builder
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
-         */
-        public static function selectRange($name, $begin, $end, $selected = null, $options = array()){
-            return \Collective\Html\FormBuilder::selectRange($name, $begin, $end, $selected, $options);
+         */ 
+        public static function registerGlobalScopes($builder)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::registerGlobalScopes($builder);
         }
         
         /**
-         * Create a select year field.
+         * Get a new query builder that doesn't have any global scopes.
          *
-         * @param string $name
-         * @param string $begin
-         * @param string $end
-         * @param string $selected
-         * @param array $options
-         * @return mixed 
+         * @return \Illuminate\Database\Eloquent\Builder|static 
          * @static 
-         */
-        public static function selectYear(){
-            return \Collective\Html\FormBuilder::selectYear();
+         */ 
+        public static function newQueryWithoutScopes()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newQueryWithoutScopes();
         }
         
         /**
-         * Create a select month field.
+         * Get a new query instance without a given scope.
          *
-         * @param string $name
-         * @param string $selected
-         * @param array $options
-         * @param string $format
-         * @return \Illuminate\Support\HtmlString 
+         * @param \Illuminate\Database\Eloquent\Scope|string $scope
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
-         */
-        public static function selectMonth($name, $selected = null, $options = array(), $format = '%B'){
-            return \Collective\Html\FormBuilder::selectMonth($name, $selected, $options, $format);
+         */ 
+        public static function newQueryWithoutScope($scope)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newQueryWithoutScope($scope);
         }
         
         /**
-         * Get the select option for the given value.
+         * Get a new query to restore one or more models by their queueable IDs.
          *
-         * @param string $display
-         * @param string $value
-         * @param string $selected
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|int $ids
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
-         */
-        public static function getSelectOption($display, $value, $selected, $attributes = array()){
-            return \Collective\Html\FormBuilder::getSelectOption($display, $value, $selected, $attributes);
+         */ 
+        public static function newQueryForRestoration($ids)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newQueryForRestoration($ids);
         }
         
         /**
-         * Create a checkbox input field.
+         * Create a new Eloquent query builder for the model.
          *
-         * @param string $name
-         * @param mixed $value
-         * @param bool $checked
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param \Illuminate\Database\Query\Builder $query
+         * @return \Illuminate\Database\Eloquent\Builder|static 
          * @static 
-         */
-        public static function checkbox($name, $value = 1, $checked = null, $options = array()){
-            return \Collective\Html\FormBuilder::checkbox($name, $value, $checked, $options);
+         */ 
+        public static function newEloquentBuilder($query)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newEloquentBuilder($query);
         }
         
         /**
-         * Create a radio button input field.
+         * Create a new Eloquent Collection instance.
          *
-         * @param string $name
-         * @param mixed $value
-         * @param bool $checked
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $models
+         * @return \Illuminate\Database\Eloquent\Collection 
          * @static 
-         */
-        public static function radio($name, $value = null, $checked = null, $options = array()){
-            return \Collective\Html\FormBuilder::radio($name, $value, $checked, $options);
+         */ 
+        public static function newCollection($models = array())
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newCollection($models);
         }
         
         /**
-         * Create a HTML reset input element.
+         * Create a new pivot model instance.
          *
-         * @param string $value
+         * @param \Illuminate\Database\Eloquent\Model $parent
          * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @param string $table
+         * @param bool $exists
+         * @param string|null $using
+         * @return \Illuminate\Database\Eloquent\Relations\Pivot 
          * @static 
-         */
-        public static function reset($value, $attributes = array()){
-            return \Collective\Html\FormBuilder::reset($value, $attributes);
+         */ 
+        public static function newPivot($parent, $attributes, $table, $exists, $using = null)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newPivot($parent, $attributes, $table, $exists, $using);
         }
         
         /**
-         * Create a HTML image input element.
+         * Convert the model instance to an array.
          *
-         * @param string $url
-         * @param string $name
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return array 
          * @static 
-         */
-        public static function image($url, $name = null, $attributes = array()){
-            return \Collective\Html\FormBuilder::image($url, $name, $attributes);
+         */ 
+        public static function toArray()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::toArray();
         }
         
         /**
-         * Create a color input field.
+         * Convert the model instance to JSON.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param int $options
+         * @return string 
+         * @throws \Illuminate\Database\Eloquent\JsonEncodingException
          * @static 
-         */
-        public static function color($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::color($name, $value, $options);
+         */ 
+        public static function toJson($options = 0)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::toJson($options);
         }
         
         /**
-         * Create a submit button element.
+         * Convert the object into something JSON serializable.
          *
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return array 
          * @static 
-         */
-        public static function submit($value = null, $options = array()){
-            return \Collective\Html\FormBuilder::submit($value, $options);
+         */ 
+        public static function jsonSerialize()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::jsonSerialize();
         }
         
         /**
-         * Create a button element.
+         * Reload a fresh model instance from the database.
          *
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|string $with
+         * @return static|null 
          * @static 
-         */
-        public static function button($value = null, $options = array()){
-            return \Collective\Html\FormBuilder::button($value, $options);
+         */ 
+        public static function fresh($with = array())
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::fresh($with);
         }
         
         /**
-         * Get the ID attribute for a field name.
+         * Reload the current model instance with fresh attributes from the database.
          *
-         * @param string $name
-         * @param array $attributes
-         * @return string 
+         * @return $this 
+         * @static 
+         */ 
+        public static function refresh()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::refresh();
+        }
+        
+        /**
+         * Clone the model into a new, non-existing instance.
+         *
+         * @param array|null $except
+         * @return \Illuminate\Database\Eloquent\Model 
          * @static 
-         */
-        public static function getIdAttribute($name, $attributes){
-            return \Collective\Html\FormBuilder::getIdAttribute($name, $attributes);
+         */ 
+        public static function replicate($except = null)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::replicate($except);
         }
         
         /**
-         * Get the value that should be assigned to the field.
+         * Determine if two models have the same ID and belong to the same table.
          *
-         * @param string $name
-         * @param string $value
-         * @return mixed 
+         * @param \Illuminate\Database\Eloquent\Model|null $model
+         * @return bool 
          * @static 
-         */
-        public static function getValueAttribute($name, $value = null){
-            return \Collective\Html\FormBuilder::getValueAttribute($name, $value);
+         */ 
+        public static function is($model)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::is($model);
         }
         
         /**
-         * Get a value from the session's old input.
+         * Determine if two models are not the same.
          *
-         * @param string $name
-         * @return mixed 
+         * @param \Illuminate\Database\Eloquent\Model|null $model
+         * @return bool 
          * @static 
-         */
-        public static function old($name){
-            return \Collective\Html\FormBuilder::old($name);
+         */ 
+        public static function isNot($model)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::isNot($model);
         }
         
         /**
-         * Determine if the old input is empty.
+         * Get the database connection for the model.
          *
-         * @return bool 
+         * @return \Illuminate\Database\Connection 
          * @static 
-         */
-        public static function oldInputIsEmpty(){
-            return \Collective\Html\FormBuilder::oldInputIsEmpty();
+         */ 
+        public static function getConnection()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getConnection();
         }
         
         /**
-         * Get the session store implementation.
+         * Get the current connection name for the model.
          *
-         * @return \Illuminate\Contracts\Session\Session $session
+         * @return string 
          * @static 
-         */
-        public static function getSessionStore(){
-            return \Collective\Html\FormBuilder::getSessionStore();
+         */ 
+        public static function getConnectionName()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getConnectionName();
         }
         
         /**
-         * Set the session store implementation.
+         * Set the connection associated with the model.
          *
-         * @param \Illuminate\Contracts\Session\Session $session
+         * @param string $name
          * @return $this 
          * @static 
-         */
-        public static function setSessionStore($session){
-            return \Collective\Html\FormBuilder::setSessionStore($session);
+         */ 
+        public static function setConnection($name)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setConnection($name);
         }
         
         /**
-         * Register a custom macro.
+         * Resolve a connection instance.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @param string|null $connection
+         * @return \Illuminate\Database\Connection 
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Collective\Html\FormBuilder::macro($name, $macro);
+         */ 
+        public static function resolveConnection($connection = null)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::resolveConnection($connection);
         }
         
         /**
-         * Checks if macro is registered.
+         * Get the connection resolver instance.
          *
-         * @param string $name
-         * @return bool 
+         * @return \Illuminate\Database\ConnectionResolverInterface 
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Collective\Html\FormBuilder::hasMacro($name);
+         */ 
+        public static function getConnectionResolver()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getConnectionResolver();
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Set the connection resolver instance.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return mixed 
-         * @throws \BadMethodCallException
+         * @param \Illuminate\Database\ConnectionResolverInterface $resolver
+         * @return void 
          * @static 
-         */
-        public static function macroCall($method, $parameters){
-            return \Collective\Html\FormBuilder::macroCall($method, $parameters);
+         */ 
+        public static function setConnectionResolver($resolver)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::setConnectionResolver($resolver);
         }
         
         /**
-         * Register a custom component.
+         * Unset the connection resolver for models.
          *
-         * @param $name
-         * @param $view
-         * @param array $signature
          * @return void 
          * @static 
-         */
-        public static function component($name, $view, $signature){
-            \Collective\Html\FormBuilder::component($name, $view, $signature);
+         */ 
+        public static function unsetConnectionResolver()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::unsetConnectionResolver();
         }
         
         /**
-         * Check if a component is registered.
+         * Get the table associated with the model.
          *
-         * @param $name
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function hasComponent($name){
-            return \Collective\Html\FormBuilder::hasComponent($name);
+         */ 
+        public static function getTable()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getTable();
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Set the table associated with the model.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return \Illuminate\Contracts\View\View|mixed 
-         * @throws \BadMethodCallException
+         * @param string $table
+         * @return $this 
          * @static 
-         */
-        public static function componentCall($method, $parameters){
-            return \Collective\Html\FormBuilder::componentCall($method, $parameters);
+         */ 
+        public static function setTable($table)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setTable($table);
         }
         
-    }
-
-
-    class HTML extends \Collective\Html\HtmlFacade{
-        
         /**
-         * Convert an HTML string to entities.
+         * Get the primary key for the model.
          *
-         * @param string $value
          * @return string 
          * @static 
-         */
-        public static function entities($value){
-            return \Collective\Html\HtmlBuilder::entities($value);
+         */ 
+        public static function getKeyName()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getKeyName();
         }
         
         /**
-         * Convert entities to HTML characters.
+         * Set the primary key for the model.
          *
-         * @param string $value
-         * @return string 
+         * @param string $key
+         * @return $this 
          * @static 
-         */
-        public static function decode($value){
-            return \Collective\Html\HtmlBuilder::decode($value);
+         */ 
+        public static function setKeyName($key)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setKeyName($key);
         }
         
         /**
-         * Generate a link to a JavaScript file.
+         * Get the table qualified key name.
          *
-         * @param string $url
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @return string 
          * @static 
-         */
-        public static function script($url, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::script($url, $attributes, $secure);
+         */ 
+        public static function getQualifiedKeyName()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getQualifiedKeyName();
         }
         
         /**
-         * Generate a link to a CSS file.
+         * Get the auto-incrementing key type.
          *
-         * @param string $url
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @return string 
          * @static 
-         */
-        public static function style($url, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::style($url, $attributes, $secure);
+         */ 
+        public static function getKeyType()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getKeyType();
         }
         
         /**
-         * Generate an HTML image element.
+         * Set the data type for the primary key.
          *
-         * @param string $url
-         * @param string $alt
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @param string $type
+         * @return $this 
          * @static 
-         */
-        public static function image($url, $alt = null, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::image($url, $alt, $attributes, $secure);
+         */ 
+        public static function setKeyType($type)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setKeyType($type);
         }
         
         /**
-         * Generate a link to a Favicon file.
+         * Get the value indicating whether the IDs are incrementing.
          *
-         * @param string $url
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool 
          * @static 
-         */
-        public static function favicon($url, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::favicon($url, $attributes, $secure);
+         */ 
+        public static function getIncrementing()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getIncrementing();
         }
         
         /**
-         * Generate a HTML link.
+         * Set whether IDs are incrementing.
          *
-         * @param string $url
-         * @param string $title
-         * @param array $attributes
-         * @param bool $secure
-         * @param bool $escape
-         * @return \Illuminate\Support\HtmlString 
+         * @param bool $value
+         * @return $this 
          * @static 
-         */
-        public static function link($url, $title = null, $attributes = array(), $secure = null, $escape = true){
-            return \Collective\Html\HtmlBuilder::link($url, $title, $attributes, $secure, $escape);
+         */ 
+        public static function setIncrementing($value)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setIncrementing($value);
         }
         
         /**
-         * Generate a HTTPS HTML link.
+         * Get the value of the model's primary key.
          *
-         * @param string $url
-         * @param string $title
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return mixed 
          * @static 
-         */
-        public static function secureLink($url, $title = null, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::secureLink($url, $title, $attributes);
+         */ 
+        public static function getKey()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getKey();
         }
         
         /**
-         * Generate a HTML link to an asset.
+         * Get the queueable identity for the entity.
          *
-         * @param string $url
-         * @param string $title
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @return mixed 
          * @static 
-         */
-        public static function linkAsset($url, $title = null, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::linkAsset($url, $title, $attributes, $secure);
+         */ 
+        public static function getQueueableId()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getQueueableId();
         }
         
         /**
-         * Generate a HTTPS HTML link to an asset.
+         * Get the queueable relationships for the entity.
          *
-         * @param string $url
-         * @param string $title
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return array 
          * @static 
-         */
-        public static function linkSecureAsset($url, $title = null, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::linkSecureAsset($url, $title, $attributes);
+         */ 
+        public static function getQueueableRelations()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getQueueableRelations();
         }
         
         /**
-         * Generate a HTML link to a named route.
+         * Get the queueable connection for the entity.
          *
-         * @param string $name
-         * @param string $title
-         * @param array $parameters
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return mixed 
          * @static 
-         */
-        public static function linkRoute($name, $title = null, $parameters = array(), $attributes = array()){
-            return \Collective\Html\HtmlBuilder::linkRoute($name, $title, $parameters, $attributes);
+         */ 
+        public static function getQueueableConnection()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getQueueableConnection();
         }
         
         /**
-         * Generate a HTML link to a controller action.
+         * Get the value of the model's route key.
          *
-         * @param string $action
-         * @param string $title
-         * @param array $parameters
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return mixed 
          * @static 
-         */
-        public static function linkAction($action, $title = null, $parameters = array(), $attributes = array()){
-            return \Collective\Html\HtmlBuilder::linkAction($action, $title, $parameters, $attributes);
+         */ 
+        public static function getRouteKey()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getRouteKey();
         }
         
         /**
-         * Generate a HTML link to an email address.
+         * Get the route key for the model.
          *
-         * @param string $email
-         * @param string $title
-         * @param array $attributes
-         * @param bool $escape
-         * @return \Illuminate\Support\HtmlString 
+         * @return string 
          * @static 
-         */
-        public static function mailto($email, $title = null, $attributes = array(), $escape = true){
-            return \Collective\Html\HtmlBuilder::mailto($email, $title, $attributes, $escape);
+         */ 
+        public static function getRouteKeyName()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getRouteKeyName();
         }
         
         /**
-         * Obfuscate an e-mail address to prevent spam-bots from sniffing it.
+         * Retrieve the model for a bound value.
          *
-         * @param string $email
-         * @return string 
+         * @param mixed $value
+         * @return \Illuminate\Database\Eloquent\Model|null 
          * @static 
-         */
-        public static function email($email){
-            return \Collective\Html\HtmlBuilder::email($email);
+         */ 
+        public static function resolveRouteBinding($value)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::resolveRouteBinding($value);
         }
         
         /**
-         * Generates non-breaking space entities based on number supplied.
+         * Get the default foreign key name for the model.
          *
-         * @param int $num
          * @return string 
          * @static 
-         */
-        public static function nbsp($num = 1){
-            return \Collective\Html\HtmlBuilder::nbsp($num);
+         */ 
+        public static function getForeignKey()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getForeignKey();
         }
         
         /**
-         * Generate an ordered list of items.
+         * Get the number of models to return per page.
          *
-         * @param array $list
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString|string 
+         * @return int 
          * @static 
-         */
-        public static function ol($list, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::ol($list, $attributes);
+         */ 
+        public static function getPerPage()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getPerPage();
         }
         
         /**
-         * Generate an un-ordered list of items.
+         * Set the number of models to return per page.
          *
-         * @param array $list
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString|string 
+         * @param int $perPage
+         * @return $this 
          * @static 
-         */
-        public static function ul($list, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::ul($list, $attributes);
+         */ 
+        public static function setPerPage($perPage)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setPerPage($perPage);
         }
         
         /**
-         * Generate a description list of items.
+         * Determine if the given attribute exists.
          *
-         * @param array $list
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @param mixed $offset
+         * @return bool 
          * @static 
-         */
-        public static function dl($list, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::dl($list, $attributes);
+         */ 
+        public static function offsetExists($offset)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::offsetExists($offset);
         }
         
         /**
-         * Build an HTML attribute string from an array.
+         * Get the value for a given offset.
          *
-         * @param array $attributes
-         * @return string 
+         * @param mixed $offset
+         * @return mixed 
          * @static 
-         */
-        public static function attributes($attributes){
-            return \Collective\Html\HtmlBuilder::attributes($attributes);
+         */ 
+        public static function offsetGet($offset)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::offsetGet($offset);
         }
         
         /**
-         * Obfuscate a string to prevent spam-bots from sniffing it.
+         * Set the value for a given offset.
          *
-         * @param string $value
-         * @return string 
+         * @param mixed $offset
+         * @param mixed $value
+         * @return void 
          * @static 
-         */
-        public static function obfuscate($value){
-            return \Collective\Html\HtmlBuilder::obfuscate($value);
+         */ 
+        public static function offsetSet($offset, $value)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::offsetSet($offset, $value);
         }
         
         /**
-         * Generate a meta tag.
+         * Unset the value for a given offset.
          *
-         * @param string $name
-         * @param string $content
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @param mixed $offset
+         * @return void 
          * @static 
-         */
-        public static function meta($name, $content, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::meta($name, $content, $attributes);
+         */ 
+        public static function offsetUnset($offset)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::offsetUnset($offset);
         }
         
         /**
-         * Generate an html tag.
+         * Convert the model's attributes to an array.
          *
-         * @param string $tag
-         * @param mixed $content
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return array 
          * @static 
-         */
-        public static function tag($tag, $content, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::tag($tag, $content, $attributes);
+         */ 
+        public static function attributesToArray()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::attributesToArray();
         }
         
         /**
-         * Register a custom macro.
+         * Get the model's relationships in array form.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @return array 
          * @static 
-         */
-        public static function macro($name, $macro){
-            \Collective\Html\HtmlBuilder::macro($name, $macro);
+         */ 
+        public static function relationsToArray()
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::relationsToArray();
         }
         
         /**
-         * Checks if macro is registered.
+         * Get an attribute from the model.
          *
-         * @param string $name
-         * @return bool 
+         * @param string $key
+         * @return mixed 
          * @static 
-         */
-        public static function hasMacro($name){
-            return \Collective\Html\HtmlBuilder::hasMacro($name);
+         */ 
+        public static function getAttribute($key)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getAttribute($key);
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Get a plain attribute (not a relationship).
          *
-         * @param string $method
-         * @param array $parameters
+         * @param string $key
          * @return mixed 
-         * @throws \BadMethodCallException
          * @static 
-         */
-        public static function macroCall($method, $parameters){
-            return \Collective\Html\HtmlBuilder::macroCall($method, $parameters);
+         */ 
+        public static function getAttributeValue($key)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getAttributeValue($key);
         }
         
         /**
-         * Register a custom component.
+         * Get a relationship.
          *
-         * @param $name
-         * @param $view
-         * @param array $signature
-         * @return void 
+         * @param string $key
+         * @return mixed 
          * @static 
-         */
-        public static function component($name, $view, $signature){
-            \Collective\Html\HtmlBuilder::component($name, $view, $signature);
+         */ 
+        public static function getRelationValue($key)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getRelationValue($key);
         }
         
         /**
-         * Check if a component is registered.
+         * Determine if a get mutator exists for an attribute.
          *
-         * @param $name
+         * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function hasComponent($name){
-            return \Collective\Html\HtmlBuilder::hasComponent($name);
+         */ 
+        public static function hasGetMutator($key)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::hasGetMutator($key);
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Set a given attribute on the model.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return \Illuminate\Contracts\View\View|mixed 
-         * @throws \BadMethodCallException
+         * @param string $key
+         * @param mixed $value
+         * @return $this 
          * @static 
-         */
-        public static function componentCall($method, $parameters){
-            return \Collective\Html\HtmlBuilder::componentCall($method, $parameters);
+         */ 
+        public static function setAttribute($key, $value)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setAttribute($key, $value);
         }
         
-    }
-
-
-    class Countries extends \Webpatser\Countries\CountriesFacade{
+        /**
+         * Determine if a set mutator exists for an attribute.
+         *
+         * @param string $key
+         * @return bool 
+         * @static 
+         */ 
+        public static function hasSetMutator($key)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::hasSetMutator($key);
+        }
         
         /**
-         * Returns one country
+         * Set a given JSON attribute on the model.
          *
-         * @param string $id The country id
-         * @return array 
+         * @param string $key
+         * @param mixed $value
+         * @return $this 
          * @static 
-         */
-        public static function getOne($id){
-            return \Webpatser\Countries\Countries::getOne($id);
+         */ 
+        public static function fillJsonAttribute($key, $value)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::fillJsonAttribute($key, $value);
         }
         
         /**
-         * Returns a list of countries
+         * Decode the given JSON back into an array or object.
          *
-         * @param string  sort
-         * @return array 
+         * @param string $value
+         * @param bool $asObject
+         * @return mixed 
          * @static 
-         */
-        public static function getList($sort = null){
-            return \Webpatser\Countries\Countries::getList($sort);
+         */ 
+        public static function fromJson($value, $asObject = false)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::fromJson($value, $asObject);
         }
         
         /**
-         * Returns a list of countries suitable to use with a select element in Laravelcollective\html
-         * Will show the value and sort by the column specified in the display attribute
+         * Convert a DateTime to a storable string.
          *
-         * @param string  display
-         * @return array 
+         * @param \DateTime|int $value
+         * @return string 
          * @static 
-         */
-        public static function getListForSelect($display = 'name'){
-            return \Webpatser\Countries\Countries::getListForSelect($display);
+         */ 
+        public static function fromDateTime($value)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::fromDateTime($value);
         }
         
         /**
-         * Clear the list of booted models so they will be re-booted.
+         * Get the attributes that should be converted to dates.
          *
-         * @return void 
+         * @return array 
          * @static 
-         */
-        public static function clearBootedModels(){
+         */ 
+        public static function getDates()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::clearBootedModels();
+            return \Webpatser\Countries\Countries::getDates();
         }
         
         /**
-         * Fill the model with an array of attributes.
+         * Get the format for database stored dates.
          *
-         * @param array $attributes
-         * @return $this 
-         * @throws \Illuminate\Database\Eloquent\MassAssignmentException
+         * @return string 
          * @static 
-         */
-        public static function fill($attributes){
+         */ 
+        public static function getDateFormat()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fill($attributes);
+            return \Webpatser\Countries\Countries::getDateFormat();
         }
         
         /**
-         * Fill the model with an array of attributes. Force mass assignment.
+         * Set the date format used by the model.
          *
-         * @param array $attributes
+         * @param string $format
          * @return $this 
          * @static 
-         */
-        public static function forceFill($attributes){
+         */ 
+        public static function setDateFormat($format)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::forceFill($attributes);
+            return \Webpatser\Countries\Countries::setDateFormat($format);
         }
         
         /**
-         * Create a new instance of the given model.
+         * Determine whether an attribute should be cast to a native type.
          *
-         * @param array $attributes
-         * @param bool $exists
-         * @return static 
+         * @param string $key
+         * @param array|string|null $types
+         * @return bool 
          * @static 
-         */
-        public static function newInstance($attributes = array(), $exists = false){
+         */ 
+        public static function hasCast($key, $types = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newInstance($attributes, $exists);
+            return \Webpatser\Countries\Countries::hasCast($key, $types);
         }
         
         /**
-         * Create a new model instance that is existing.
+         * Get the casts array.
          *
-         * @param array $attributes
-         * @param string|null $connection
-         * @return static 
+         * @return array 
          * @static 
-         */
-        public static function newFromBuilder($attributes = array(), $connection = null){
+         */ 
+        public static function getCasts()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newFromBuilder($attributes, $connection);
+            return \Webpatser\Countries\Countries::getCasts();
         }
         
         /**
-         * Begin querying the model on a given connection.
+         * Get all of the current attributes on the model.
          *
-         * @param string|null $connection
-         * @return \Illuminate\Database\Eloquent\Builder 
+         * @return array 
          * @static 
-         */
-        public static function on($connection = null){
+         */ 
+        public static function getAttributes()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::on($connection);
+            return \Webpatser\Countries\Countries::getAttributes();
         }
         
         /**
-         * Begin querying the model on the write connection.
+         * Set the array of model attributes. No checking is done.
          *
-         * @return \Illuminate\Database\Query\Builder 
+         * @param array $attributes
+         * @param bool $sync
+         * @return $this 
          * @static 
-         */
-        public static function onWriteConnection(){
+         */ 
+        public static function setRawAttributes($attributes, $sync = false)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::onWriteConnection();
+            return \Webpatser\Countries\Countries::setRawAttributes($attributes, $sync);
         }
         
         /**
-         * Get all of the models from the database.
+         * Get the model's original attribute values.
          *
-         * @param array|mixed $columns
-         * @return \Illuminate\Database\Eloquent\Collection|static[] 
+         * @param string|null $key
+         * @param mixed $default
+         * @return mixed|array 
          * @static 
-         */
-        public static function all($columns = array()){
+         */ 
+        public static function getOriginal($key = null, $default = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::all($columns);
+            return \Webpatser\Countries\Countries::getOriginal($key, $default);
         }
         
         /**
-         * Begin querying a model with eager loading.
+         * Get a subset of the model's attributes.
          *
-         * @param array|string $relations
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param array|mixed $attributes
+         * @return array 
          * @static 
-         */
-        public static function with($relations){
+         */ 
+        public static function only($attributes)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::with($relations);
+            return \Webpatser\Countries\Countries::only($attributes);
         }
         
         /**
-         * Eager load relations on the model.
+         * Sync the original attributes with the current.
          *
-         * @param array|string $relations
          * @return $this 
          * @static 
-         */
-        public static function load($relations){
+         */ 
+        public static function syncOriginal()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::load($relations);
+            return \Webpatser\Countries\Countries::syncOriginal();
         }
         
         /**
-         * Update the model in the database.
+         * Sync a single original attribute with its current value.
          *
-         * @param array $attributes
-         * @param array $options
-         * @return bool 
+         * @param string $attribute
+         * @return $this 
          * @static 
-         */
-        public static function update($attributes = array(), $options = array()){
+         */ 
+        public static function syncOriginalAttribute($attribute)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::update($attributes, $options);
+            return \Webpatser\Countries\Countries::syncOriginalAttribute($attribute);
         }
         
         /**
-         * Save the model and all of its relationships.
+         * Sync the changed attributes.
          *
-         * @return bool 
+         * @return $this 
          * @static 
-         */
-        public static function push(){
+         */ 
+        public static function syncChanges()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::push();
+            return \Webpatser\Countries\Countries::syncChanges();
         }
         
         /**
-         * Save the model to the database.
+         * Determine if the model or given attribute(s) have been modified.
          *
-         * @param array $options
+         * @param array|string|null $attributes
          * @return bool 
          * @static 
-         */
-        public static function save($options = array()){
+         */ 
+        public static function isDirty($attributes = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::save($options);
+            return \Webpatser\Countries\Countries::isDirty($attributes);
         }
         
         /**
-         * Save the model to the database using transaction.
+         * Determine if the model or given attribute(s) have remained the same.
          *
-         * @param array $options
+         * @param array|string|null $attributes
          * @return bool 
-         * @throws \Throwable
          * @static 
-         */
-        public static function saveOrFail($options = array()){
+         */ 
+        public static function isClean($attributes = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::saveOrFail($options);
+            return \Webpatser\Countries\Countries::isClean($attributes);
         }
         
         /**
-         * Destroy the models for the given IDs.
+         * Determine if the model or given attribute(s) have been modified.
          *
-         * @param array|int $ids
-         * @return int 
+         * @param array|string|null $attributes
+         * @return bool 
          * @static 
-         */
-        public static function destroy($ids){
+         */ 
+        public static function wasChanged($attributes = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::destroy($ids);
+            return \Webpatser\Countries\Countries::wasChanged($attributes);
         }
         
         /**
-         * Delete the model from the database.
+         * Get the attributes that have been changed since last sync.
          *
-         * @return bool|null 
-         * @throws \Exception
+         * @return array 
          * @static 
-         */
-        public static function delete(){
+         */ 
+        public static function getDirty()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::delete();
+            return \Webpatser\Countries\Countries::getDirty();
         }
         
         /**
-         * Force a hard delete on a soft deleted model.
-         * 
-         * This method protects developers from running forceDelete when trait is missing.
+         * Get the attributes that were changed.
          *
-         * @return bool|null 
+         * @return array 
          * @static 
-         */
-        public static function forceDelete(){
+         */ 
+        public static function getChanges()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::forceDelete();
+            return \Webpatser\Countries\Countries::getChanges();
         }
         
         /**
-         * Begin querying the model.
+         * Append attributes to query when building a query.
          *
-         * @return \Illuminate\Database\Eloquent\Builder 
+         * @param array|string $attributes
+         * @return $this 
          * @static 
-         */
-        public static function query(){
+         */ 
+        public static function append($attributes)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::query();
+            return \Webpatser\Countries\Countries::append($attributes);
         }
         
         /**
-         * Get a new query builder for the model's table.
+         * Set the accessors to append to model arrays.
          *
-         * @return \Illuminate\Database\Eloquent\Builder 
+         * @param array $appends
+         * @return $this 
          * @static 
-         */
-        public static function newQuery(){
+         */ 
+        public static function setAppends($appends)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newQuery();
+            return \Webpatser\Countries\Countries::setAppends($appends);
         }
         
         /**
-         * Get a new query builder that doesn't have any global scopes.
+         * Get the mutated attributes for a given instance.
          *
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @return array 
          * @static 
-         */
-        public static function newQueryWithoutScopes(){
+         */ 
+        public static function getMutatedAttributes()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newQueryWithoutScopes();
+            return \Webpatser\Countries\Countries::getMutatedAttributes();
         }
         
         /**
-         * Get a new query instance without a given scope.
+         * Extract and cache all the mutated attributes of a class.
          *
-         * @param \Illuminate\Database\Eloquent\Scope|string $scope
-         * @return \Illuminate\Database\Eloquent\Builder 
+         * @param string $class
+         * @return void 
          * @static 
-         */
-        public static function newQueryWithoutScope($scope){
+         */ 
+        public static function cacheMutatedAttributes($class)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newQueryWithoutScope($scope);
+            \Webpatser\Countries\Countries::cacheMutatedAttributes($class);
         }
         
         /**
-         * Create a new Eloquent query builder for the model.
+         * Register an observer with the Model.
          *
-         * @param \Illuminate\Database\Query\Builder $query
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param object|string $class
+         * @return void 
          * @static 
-         */
-        public static function newEloquentBuilder($query){
+         */ 
+        public static function observe($class)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newEloquentBuilder($query);
+            \Webpatser\Countries\Countries::observe($class);
         }
         
         /**
-         * Create a new Eloquent Collection instance.
+         * Get the observable event names.
          *
-         * @param array $models
-         * @return \Illuminate\Database\Eloquent\Collection 
+         * @return array 
          * @static 
-         */
-        public static function newCollection($models = array()){
+         */ 
+        public static function getObservableEvents()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newCollection($models);
+            return \Webpatser\Countries\Countries::getObservableEvents();
         }
         
         /**
-         * Create a new pivot model instance.
+         * Set the observable event names.
          *
-         * @param \Illuminate\Database\Eloquent\Model $parent
-         * @param array $attributes
-         * @param string $table
-         * @param bool $exists
-         * @param string|null $using
-         * @return \Illuminate\Database\Eloquent\Relations\Pivot 
+         * @param array $observables
+         * @return $this 
          * @static 
-         */
-        public static function newPivot($parent, $attributes, $table, $exists, $using = null){
+         */ 
+        public static function setObservableEvents($observables)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newPivot($parent, $attributes, $table, $exists, $using);
+            return \Webpatser\Countries\Countries::setObservableEvents($observables);
         }
         
         /**
-         * Convert the model instance to an array.
+         * Add an observable event name.
          *
-         * @return array 
+         * @param array|mixed $observables
+         * @return void 
          * @static 
-         */
-        public static function toArray(){
+         */ 
+        public static function addObservableEvents($observables)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::toArray();
+            \Webpatser\Countries\Countries::addObservableEvents($observables);
         }
         
         /**
-         * Convert the model instance to JSON.
+         * Remove an observable event name.
          *
-         * @param int $options
-         * @return string 
-         * @throws \Illuminate\Database\Eloquent\JsonEncodingException
+         * @param array|mixed $observables
+         * @return void 
          * @static 
-         */
-        public static function toJson($options = 0){
+         */ 
+        public static function removeObservableEvents($observables)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::toJson($options);
+            \Webpatser\Countries\Countries::removeObservableEvents($observables);
         }
         
         /**
-         * Convert the object into something JSON serializable.
+         * Register a retrieved model event with the dispatcher.
          *
-         * @return array 
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function jsonSerialize(){
+         */ 
+        public static function retrieved($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::jsonSerialize();
+            \Webpatser\Countries\Countries::retrieved($callback);
         }
         
         /**
-         * Reload a fresh model instance from the database.
+         * Register a saving model event with the dispatcher.
          *
-         * @param array|string $with
-         * @return static|null 
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function fresh($with = array()){
+         */ 
+        public static function saving($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fresh($with);
+            \Webpatser\Countries\Countries::saving($callback);
         }
         
         /**
-         * Reload the current model instance with fresh attributes from the database.
+         * Register a saved model event with the dispatcher.
          *
+         * @param \Closure|string $callback
          * @return void 
          * @static 
-         */
-        public static function refresh(){
+         */ 
+        public static function saved($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::refresh();
+            \Webpatser\Countries\Countries::saved($callback);
         }
         
         /**
-         * Clone the model into a new, non-existing instance.
+         * Register an updating model event with the dispatcher.
          *
-         * @param array|null $except
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function replicate($except = null){
+         */ 
+        public static function updating($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::replicate($except);
+            \Webpatser\Countries\Countries::updating($callback);
         }
         
         /**
-         * Determine if two models have the same ID and belong to the same table.
+         * Register an updated model event with the dispatcher.
          *
-         * @param \Illuminate\Database\Eloquent\Model $model
-         * @return bool 
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function is($model){
+         */ 
+        public static function updated($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::is($model);
+            \Webpatser\Countries\Countries::updated($callback);
         }
         
         /**
-         * Get the database connection for the model.
+         * Register a creating model event with the dispatcher.
          *
-         * @return \Illuminate\Database\Connection 
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function getConnection(){
+         */ 
+        public static function creating($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getConnection();
+            \Webpatser\Countries\Countries::creating($callback);
         }
         
         /**
-         * Get the current connection name for the model.
+         * Register a created model event with the dispatcher.
          *
-         * @return string 
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function getConnectionName(){
+         */ 
+        public static function created($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getConnectionName();
+            \Webpatser\Countries\Countries::created($callback);
         }
         
         /**
-         * Set the connection associated with the model.
+         * Register a deleting model event with the dispatcher.
          *
-         * @param string $name
-         * @return $this 
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function setConnection($name){
+         */ 
+        public static function deleting($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setConnection($name);
+            \Webpatser\Countries\Countries::deleting($callback);
         }
         
         /**
-         * Resolve a connection instance.
+         * Register a deleted model event with the dispatcher.
          *
-         * @param string|null $connection
-         * @return \Illuminate\Database\Connection 
+         * @param \Closure|string $callback
+         * @return void 
          * @static 
-         */
-        public static function resolveConnection($connection = null){
+         */ 
+        public static function deleted($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::resolveConnection($connection);
+            \Webpatser\Countries\Countries::deleted($callback);
         }
         
         /**
-         * Get the connection resolver instance.
+         * Remove all of the event listeners for the model.
          *
-         * @return \Illuminate\Database\ConnectionResolverInterface 
+         * @return void 
          * @static 
-         */
-        public static function getConnectionResolver(){
+         */ 
+        public static function flushEventListeners()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getConnectionResolver();
+            \Webpatser\Countries\Countries::flushEventListeners();
         }
         
         /**
-         * Set the connection resolver instance.
+         * Get the event dispatcher instance.
          *
-         * @param \Illuminate\Database\ConnectionResolverInterface $resolver
-         * @return void 
+         * @return \Illuminate\Contracts\Events\Dispatcher 
          * @static 
-         */
-        public static function setConnectionResolver($resolver){
+         */ 
+        public static function getEventDispatcher()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::setConnectionResolver($resolver);
+            return \Webpatser\Countries\Countries::getEventDispatcher();
         }
         
         /**
-         * Unset the connection resolver for models.
+         * Set the event dispatcher instance.
          *
+         * @param \Illuminate\Contracts\Events\Dispatcher $dispatcher
          * @return void 
          * @static 
-         */
-        public static function unsetConnectionResolver(){
+         */ 
+        public static function setEventDispatcher($dispatcher)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::unsetConnectionResolver();
+            \Webpatser\Countries\Countries::setEventDispatcher($dispatcher);
         }
         
         /**
-         * Get the table associated with the model.
+         * Unset the event dispatcher for models.
          *
-         * @return string 
+         * @return void 
          * @static 
-         */
-        public static function getTable(){
+         */ 
+        public static function unsetEventDispatcher()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getTable();
+            \Webpatser\Countries\Countries::unsetEventDispatcher();
         }
         
         /**
-         * Set the table associated with the model.
+         * Register a new global scope on the model.
          *
-         * @param string $table
-         * @return $this 
+         * @param \Illuminate\Database\Eloquent\Scope|\Closure|string $scope
+         * @param \Closure|null $implementation
+         * @return mixed 
+         * @throws \InvalidArgumentException
          * @static 
-         */
-        public static function setTable($table){
+         */ 
+        public static function addGlobalScope($scope, $implementation = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setTable($table);
+            return \Webpatser\Countries\Countries::addGlobalScope($scope, $implementation);
         }
         
         /**
-         * Get the primary key for the model.
+         * Determine if a model has a global scope.
          *
-         * @return string 
+         * @param \Illuminate\Database\Eloquent\Scope|string $scope
+         * @return bool 
          * @static 
-         */
-        public static function getKeyName(){
+         */ 
+        public static function hasGlobalScope($scope)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getKeyName();
+            return \Webpatser\Countries\Countries::hasGlobalScope($scope);
         }
         
         /**
-         * Set the primary key for the model.
+         * Get a global scope registered with the model.
          *
-         * @param string $key
-         * @return $this 
+         * @param \Illuminate\Database\Eloquent\Scope|string $scope
+         * @return \Illuminate\Database\Eloquent\Scope|\Closure|null 
          * @static 
-         */
-        public static function setKeyName($key){
+         */ 
+        public static function getGlobalScope($scope)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setKeyName($key);
+            return \Webpatser\Countries\Countries::getGlobalScope($scope);
         }
         
         /**
-         * Get the table qualified key name.
+         * Get the global scopes for this class instance.
          *
-         * @return string 
+         * @return array 
          * @static 
-         */
-        public static function getQualifiedKeyName(){
+         */ 
+        public static function getGlobalScopes()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getQualifiedKeyName();
+            return \Webpatser\Countries\Countries::getGlobalScopes();
         }
         
         /**
-         * Get the auto-incrementing key type.
+         * Define a one-to-one relationship.
          *
-         * @return string 
+         * @param string $related
+         * @param string $foreignKey
+         * @param string $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\HasOne 
          * @static 
-         */
-        public static function getKeyType(){
+         */ 
+        public static function hasOne($related, $foreignKey = null, $localKey = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getKeyType();
+            return \Webpatser\Countries\Countries::hasOne($related, $foreignKey, $localKey);
         }
         
         /**
-         * Set the data type for the primary key.
+         * Define a polymorphic one-to-one relationship.
          *
+         * @param string $related
+         * @param string $name
          * @param string $type
-         * @return $this 
+         * @param string $id
+         * @param string $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\MorphOne 
          * @static 
-         */
-        public static function setKeyType($type){
+         */ 
+        public static function morphOne($related, $name, $type = null, $id = null, $localKey = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setKeyType($type);
+            return \Webpatser\Countries\Countries::morphOne($related, $name, $type, $id, $localKey);
         }
         
         /**
-         * Get the value indicating whether the IDs are incrementing.
+         * Define an inverse one-to-one or many relationship.
          *
-         * @return bool 
+         * @param string $related
+         * @param string $foreignKey
+         * @param string $ownerKey
+         * @param string $relation
+         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo 
          * @static 
-         */
-        public static function getIncrementing(){
+         */ 
+        public static function belongsTo($related, $foreignKey = null, $ownerKey = null, $relation = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getIncrementing();
+            return \Webpatser\Countries\Countries::belongsTo($related, $foreignKey, $ownerKey, $relation);
         }
         
         /**
-         * Set whether IDs are incrementing.
+         * Define a polymorphic, inverse one-to-one or many relationship.
          *
-         * @param bool $value
-         * @return $this 
+         * @param string $name
+         * @param string $type
+         * @param string $id
+         * @param string $ownerKey
+         * @return \Illuminate\Database\Eloquent\Relations\MorphTo 
          * @static 
-         */
-        public static function setIncrementing($value){
+         */ 
+        public static function morphTo($name = null, $type = null, $id = null, $ownerKey = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setIncrementing($value);
+            return \Webpatser\Countries\Countries::morphTo($name, $type, $id, $ownerKey);
         }
         
         /**
-         * Get the value of the model's primary key.
+         * Retrieve the actual class name for a given morph class.
          *
-         * @return mixed 
+         * @param string $class
+         * @return string 
          * @static 
-         */
-        public static function getKey(){
+         */ 
+        public static function getActualClassNameForMorph($class)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getKey();
+            return \Webpatser\Countries\Countries::getActualClassNameForMorph($class);
         }
         
         /**
-         * Get the queueable identity for the entity.
+         * Define a one-to-many relationship.
          *
-         * @return mixed 
+         * @param string $related
+         * @param string $foreignKey
+         * @param string $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\HasMany 
          * @static 
-         */
-        public static function getQueueableId(){
+         */ 
+        public static function hasMany($related, $foreignKey = null, $localKey = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getQueueableId();
+            return \Webpatser\Countries\Countries::hasMany($related, $foreignKey, $localKey);
         }
         
         /**
-         * Get the value of the model's route key.
+         * Define a has-many-through relationship.
          *
-         * @return mixed 
+         * @param string $related
+         * @param string $through
+         * @param string|null $firstKey
+         * @param string|null $secondKey
+         * @param string|null $localKey
+         * @param string|null $secondLocalKey
+         * @return \Illuminate\Database\Eloquent\Relations\HasManyThrough 
          * @static 
-         */
-        public static function getRouteKey(){
+         */ 
+        public static function hasManyThrough($related, $through, $firstKey = null, $secondKey = null, $localKey = null, $secondLocalKey = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRouteKey();
+            return \Webpatser\Countries\Countries::hasManyThrough($related, $through, $firstKey, $secondKey, $localKey, $secondLocalKey);
         }
         
         /**
-         * Get the route key for the model.
+         * Define a polymorphic one-to-many relationship.
          *
-         * @return string 
+         * @param string $related
+         * @param string $name
+         * @param string $type
+         * @param string $id
+         * @param string $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\MorphMany 
          * @static 
-         */
-        public static function getRouteKeyName(){
+         */ 
+        public static function morphMany($related, $name, $type = null, $id = null, $localKey = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRouteKeyName();
+            return \Webpatser\Countries\Countries::morphMany($related, $name, $type, $id, $localKey);
         }
         
         /**
-         * Get the default foreign key name for the model.
+         * Define a many-to-many relationship.
          *
-         * @return string 
+         * @param string $related
+         * @param string $table
+         * @param string $foreignPivotKey
+         * @param string $relatedPivotKey
+         * @param string $parentKey
+         * @param string $relatedKey
+         * @param string $relation
+         * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany 
          * @static 
-         */
-        public static function getForeignKey(){
+         */ 
+        public static function belongsToMany($related, $table = null, $foreignPivotKey = null, $relatedPivotKey = null, $parentKey = null, $relatedKey = null, $relation = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getForeignKey();
+            return \Webpatser\Countries\Countries::belongsToMany($related, $table, $foreignPivotKey, $relatedPivotKey, $parentKey, $relatedKey, $relation);
         }
         
         /**
-         * Get the number of models to return per page.
+         * Define a polymorphic many-to-many relationship.
          *
-         * @return int 
+         * @param string $related
+         * @param string $name
+         * @param string $table
+         * @param string $foreignPivotKey
+         * @param string $relatedPivotKey
+         * @param string $parentKey
+         * @param string $relatedKey
+         * @param bool $inverse
+         * @return \Illuminate\Database\Eloquent\Relations\MorphToMany 
          * @static 
-         */
-        public static function getPerPage(){
+         */ 
+        public static function morphToMany($related, $name, $table = null, $foreignPivotKey = null, $relatedPivotKey = null, $parentKey = null, $relatedKey = null, $inverse = false)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getPerPage();
+            return \Webpatser\Countries\Countries::morphToMany($related, $name, $table, $foreignPivotKey, $relatedPivotKey, $parentKey, $relatedKey, $inverse);
         }
         
         /**
-         * Set the number of models to return per page.
+         * Define a polymorphic, inverse many-to-many relationship.
          *
-         * @param int $perPage
-         * @return $this 
+         * @param string $related
+         * @param string $name
+         * @param string $table
+         * @param string $foreignPivotKey
+         * @param string $relatedPivotKey
+         * @param string $parentKey
+         * @param string $relatedKey
+         * @return \Illuminate\Database\Eloquent\Relations\MorphToMany 
          * @static 
-         */
-        public static function setPerPage($perPage){
+         */ 
+        public static function morphedByMany($related, $name, $table = null, $foreignPivotKey = null, $relatedPivotKey = null, $parentKey = null, $relatedKey = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setPerPage($perPage);
+            return \Webpatser\Countries\Countries::morphedByMany($related, $name, $table, $foreignPivotKey, $relatedPivotKey, $parentKey, $relatedKey);
         }
         
         /**
-         * Determine if the given attribute exists.
+         * Get the joining table name for a many-to-many relation.
          *
-         * @param mixed $offset
-         * @return bool 
+         * @param string $related
+         * @return string 
          * @static 
-         */
-        public static function offsetExists($offset){
+         */ 
+        public static function joiningTable($related)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::offsetExists($offset);
+            return \Webpatser\Countries\Countries::joiningTable($related);
         }
         
         /**
-         * Get the value for a given offset.
+         * Determine if the model touches a given relation.
          *
-         * @param mixed $offset
-         * @return mixed 
+         * @param string $relation
+         * @return bool 
          * @static 
-         */
-        public static function offsetGet($offset){
+         */ 
+        public static function touches($relation)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::offsetGet($offset);
+            return \Webpatser\Countries\Countries::touches($relation);
         }
         
         /**
-         * Set the value for a given offset.
+         * Touch the owning relations of the model.
          *
-         * @param mixed $offset
-         * @param mixed $value
          * @return void 
          * @static 
-         */
-        public static function offsetSet($offset, $value){
+         */ 
+        public static function touchOwners()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::offsetSet($offset, $value);
+            \Webpatser\Countries\Countries::touchOwners();
         }
         
         /**
-         * Unset the value for a given offset.
+         * Get the class name for polymorphic relations.
          *
-         * @param mixed $offset
-         * @return void 
+         * @return string 
          * @static 
-         */
-        public static function offsetUnset($offset){
+         */ 
+        public static function getMorphClass()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::offsetUnset($offset);
+            return \Webpatser\Countries\Countries::getMorphClass();
         }
         
         /**
-         * Convert the model's attributes to an array.
+         * Get all the loaded relations for the instance.
          *
          * @return array 
          * @static 
-         */
-        public static function attributesToArray(){
+         */ 
+        public static function getRelations()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::attributesToArray();
+            return \Webpatser\Countries\Countries::getRelations();
         }
         
         /**
-         * Get the model's relationships in array form.
+         * Get a specified relationship.
          *
-         * @return array 
+         * @param string $relation
+         * @return mixed 
          * @static 
-         */
-        public static function relationsToArray(){
+         */ 
+        public static function getRelation($relation)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::relationsToArray();
+            return \Webpatser\Countries\Countries::getRelation($relation);
         }
         
         /**
-         * Get an attribute from the model.
+         * Determine if the given relation is loaded.
          *
          * @param string $key
-         * @return mixed 
+         * @return bool 
          * @static 
-         */
-        public static function getAttribute($key){
+         */ 
+        public static function relationLoaded($key)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getAttribute($key);
+            return \Webpatser\Countries\Countries::relationLoaded($key);
         }
         
         /**
-         * Get a plain attribute (not a relationship).
+         * Set the specific relationship in the model.
          *
-         * @param string $key
-         * @return mixed 
+         * @param string $relation
+         * @param mixed $value
+         * @return $this 
          * @static 
-         */
-        public static function getAttributeValue($key){
+         */ 
+        public static function setRelation($relation, $value)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getAttributeValue($key);
+            return \Webpatser\Countries\Countries::setRelation($relation, $value);
         }
         
         /**
-         * Get a relationship.
+         * Set the entire relations array on the model.
          *
-         * @param string $key
-         * @return mixed 
+         * @param array $relations
+         * @return $this 
          * @static 
-         */
-        public static function getRelationValue($key){
+         */ 
+        public static function setRelations($relations)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRelationValue($key);
+            return \Webpatser\Countries\Countries::setRelations($relations);
         }
         
         /**
-         * Determine if a get mutator exists for an attribute.
+         * Get the relationships that are touched on save.
          *
-         * @param string $key
-         * @return bool 
+         * @return array 
          * @static 
-         */
-        public static function hasGetMutator($key){
+         */ 
+        public static function getTouchedRelations()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasGetMutator($key);
+            return \Webpatser\Countries\Countries::getTouchedRelations();
         }
         
         /**
-         * Set a given attribute on the model.
+         * Set the relationships that are touched on save.
          *
-         * @param string $key
-         * @param mixed $value
+         * @param array $touches
          * @return $this 
          * @static 
-         */
-        public static function setAttribute($key, $value){
+         */ 
+        public static function setTouchedRelations($touches)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setAttribute($key, $value);
+            return \Webpatser\Countries\Countries::setTouchedRelations($touches);
         }
         
         /**
-         * Determine if a set mutator exists for an attribute.
+         * Update the model's update timestamp.
          *
-         * @param string $key
          * @return bool 
          * @static 
-         */
-        public static function hasSetMutator($key){
+         */ 
+        public static function touch()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasSetMutator($key);
+            return \Webpatser\Countries\Countries::touch();
         }
         
         /**
-         * Set a given JSON attribute on the model.
+         * Set the value of the "created at" attribute.
          *
-         * @param string $key
          * @param mixed $value
          * @return $this 
          * @static 
-         */
-        public static function fillJsonAttribute($key, $value){
+         */ 
+        public static function setCreatedAt($value)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fillJsonAttribute($key, $value);
+            return \Webpatser\Countries\Countries::setCreatedAt($value);
         }
         
         /**
-         * Decode the given JSON back into an array or object.
+         * Set the value of the "updated at" attribute.
          *
-         * @param string $value
-         * @param bool $asObject
-         * @return mixed 
+         * @param mixed $value
+         * @return $this 
          * @static 
-         */
-        public static function fromJson($value, $asObject = false){
+         */ 
+        public static function setUpdatedAt($value)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fromJson($value, $asObject);
+            return \Webpatser\Countries\Countries::setUpdatedAt($value);
         }
         
         /**
-         * Convert a DateTime to a storable string.
+         * Get a fresh timestamp for the model.
          *
-         * @param \DateTime|int $value
-         * @return string 
+         * @return \Illuminate\Support\Carbon 
          * @static 
-         */
-        public static function fromDateTime($value){
+         */ 
+        public static function freshTimestamp()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fromDateTime($value);
+            return \Webpatser\Countries\Countries::freshTimestamp();
         }
         
         /**
-         * Get the attributes that should be converted to dates.
+         * Get a fresh timestamp for the model.
          *
-         * @return array 
+         * @return string 
          * @static 
-         */
-        public static function getDates(){
+         */ 
+        public static function freshTimestampString()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getDates();
+            return \Webpatser\Countries\Countries::freshTimestampString();
         }
         
         /**
-         * Set the date format used by the model.
+         * Determine if the model uses timestamps.
          *
-         * @param string $format
-         * @return $this 
+         * @return bool 
          * @static 
-         */
-        public static function setDateFormat($format){
+         */ 
+        public static function usesTimestamps()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setDateFormat($format);
+            return \Webpatser\Countries\Countries::usesTimestamps();
         }
         
         /**
-         * Determine whether an attribute should be cast to a native type.
+         * Get the name of the "created at" column.
          *
-         * @param string $key
-         * @param array|string|null $types
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function hasCast($key, $types = null){
+         */ 
+        public static function getCreatedAtColumn()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasCast($key, $types);
+            return \Webpatser\Countries\Countries::getCreatedAtColumn();
         }
         
         /**
-         * Get the casts array.
+         * Get the name of the "updated at" column.
          *
-         * @return array 
+         * @return string 
          * @static 
-         */
-        public static function getCasts(){
+         */ 
+        public static function getUpdatedAtColumn()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getCasts();
+            return \Webpatser\Countries\Countries::getUpdatedAtColumn();
         }
         
         /**
-         * Get all of the current attributes on the model.
+         * Get the hidden attributes for the model.
          *
          * @return array 
          * @static 
-         */
-        public static function getAttributes(){
+         */ 
+        public static function getHidden()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getAttributes();
+            return \Webpatser\Countries\Countries::getHidden();
         }
         
         /**
-         * Set the array of model attributes. No checking is done.
+         * Set the hidden attributes for the model.
          *
-         * @param array $attributes
-         * @param bool $sync
+         * @param array $hidden
          * @return $this 
          * @static 
-         */
-        public static function setRawAttributes($attributes, $sync = false){
+         */ 
+        public static function setHidden($hidden)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setRawAttributes($attributes, $sync);
+            return \Webpatser\Countries\Countries::setHidden($hidden);
         }
         
         /**
-         * Get the model's original attribute values.
+         * Add hidden attributes for the model.
          *
-         * @param string|null $key
-         * @param mixed $default
-         * @return mixed|array 
+         * @param array|string|null $attributes
+         * @return void 
          * @static 
-         */
-        public static function getOriginal($key = null, $default = null){
+         */ 
+        public static function addHidden($attributes = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getOriginal($key, $default);
+            \Webpatser\Countries\Countries::addHidden($attributes);
         }
         
         /**
-         * Sync the original attributes with the current.
+         * Get the visible attributes for the model.
          *
-         * @return $this 
+         * @return array 
          * @static 
-         */
-        public static function syncOriginal(){
+         */ 
+        public static function getVisible()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::syncOriginal();
+            return \Webpatser\Countries\Countries::getVisible();
         }
         
         /**
-         * Sync a single original attribute with its current value.
+         * Set the visible attributes for the model.
          *
-         * @param string $attribute
+         * @param array $visible
          * @return $this 
          * @static 
-         */
-        public static function syncOriginalAttribute($attribute){
+         */ 
+        public static function setVisible($visible)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::syncOriginalAttribute($attribute);
+            return \Webpatser\Countries\Countries::setVisible($visible);
         }
         
         /**
-         * Determine if the model or given attribute(s) have been modified.
+         * Add visible attributes for the model.
          *
          * @param array|string|null $attributes
-         * @return bool 
+         * @return void 
          * @static 
-         */
-        public static function isDirty($attributes = null){
+         */ 
+        public static function addVisible($attributes = null)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::isDirty($attributes);
+            \Webpatser\Countries\Countries::addVisible($attributes);
         }
         
         /**
-         * Determine if the model or given attribute(s) have remained the same.
+         * Make the given, typically hidden, attributes visible.
          *
-         * @param array|string|null $attributes
-         * @return bool 
+         * @param array|string $attributes
+         * @return $this 
          * @static 
-         */
-        public static function isClean($attributes = null){
+         */ 
+        public static function makeVisible($attributes)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::isClean($attributes);
+            return \Webpatser\Countries\Countries::makeVisible($attributes);
         }
         
         /**
-         * Get the attributes that have been changed since last sync.
+         * Make the given, typically visible, attributes hidden.
          *
-         * @return array 
+         * @param array|string $attributes
+         * @return $this 
          * @static 
-         */
-        public static function getDirty(){
+         */ 
+        public static function makeHidden($attributes)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getDirty();
+            return \Webpatser\Countries\Countries::makeHidden($attributes);
         }
         
         /**
-         * Append attributes to query when building a query.
+         * Get the fillable attributes for the model.
          *
-         * @param array|string $attributes
-         * @return $this 
+         * @return array 
          * @static 
-         */
-        public static function append($attributes){
+         */ 
+        public static function getFillable()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::append($attributes);
+            return \Webpatser\Countries\Countries::getFillable();
         }
         
         /**
-         * Set the accessors to append to model arrays.
+         * Set the fillable attributes for the model.
          *
-         * @param array $appends
+         * @param array $fillable
          * @return $this 
          * @static 
-         */
-        public static function setAppends($appends){
+         */ 
+        public static function fillable($fillable)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setAppends($appends);
+            return \Webpatser\Countries\Countries::fillable($fillable);
         }
         
         /**
-         * Get the mutated attributes for a given instance.
+         * Get the guarded attributes for the model.
          *
          * @return array 
          * @static 
-         */
-        public static function getMutatedAttributes(){
+         */ 
+        public static function getGuarded()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getMutatedAttributes();
+            return \Webpatser\Countries\Countries::getGuarded();
+        }
+        
+        /**
+         * Set the guarded attributes for the model.
+         *
+         * @param array $guarded
+         * @return $this 
+         * @static 
+         */ 
+        public static function guard($guarded)
+        {
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::guard($guarded);
         }
         
         /**
-         * Extract and cache all the mutated attributes of a class.
+         * Disable all mass assignable restrictions.
          *
-         * @param string $class
+         * @param bool $state
          * @return void 
          * @static 
-         */
-        public static function cacheMutatedAttributes($class){
+         */ 
+        public static function unguard($state = true)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::cacheMutatedAttributes($class);
+            \Webpatser\Countries\Countries::unguard($state);
         }
         
         /**
-         * Register an observer with the Model.
+         * Enable the mass assignment restrictions.
          *
-         * @param object|string $class
          * @return void 
          * @static 
-         */
-        public static function observe($class){
+         */ 
+        public static function reguard()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::observe($class);
+            \Webpatser\Countries\Countries::reguard();
         }
         
         /**
-         * Get the observable event names.
+         * Determine if current state is "unguarded".
          *
-         * @return array 
+         * @return bool 
          * @static 
-         */
-        public static function getObservableEvents(){
+         */ 
+        public static function isUnguarded()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getObservableEvents();
+            return \Webpatser\Countries\Countries::isUnguarded();
         }
         
         /**
-         * Set the observable event names.
+         * Run the given callable while being unguarded.
          *
-         * @param array $observables
-         * @return $this 
+         * @param callable $callback
+         * @return mixed 
          * @static 
-         */
-        public static function setObservableEvents($observables){
+         */ 
+        public static function unguarded($callback)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setObservableEvents($observables);
+            return \Webpatser\Countries\Countries::unguarded($callback);
         }
         
         /**
-         * Add an observable event name.
+         * Determine if the given attribute may be mass assigned.
          *
-         * @param array|mixed $observables
-         * @return void 
+         * @param string $key
+         * @return bool 
          * @static 
-         */
-        public static function addObservableEvents($observables){
+         */ 
+        public static function isFillable($key)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::addObservableEvents($observables);
+            return \Webpatser\Countries\Countries::isFillable($key);
         }
         
         /**
-         * Remove an observable event name.
+         * Determine if the given key is guarded.
          *
-         * @param array|mixed $observables
-         * @return void 
+         * @param string $key
+         * @return bool 
          * @static 
-         */
-        public static function removeObservableEvents($observables){
+         */ 
+        public static function isGuarded($key)
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::removeObservableEvents($observables);
+            return \Webpatser\Countries\Countries::isGuarded($key);
         }
         
         /**
-         * Register a saving model event with the dispatcher.
+         * Determine if the model is totally guarded.
          *
-         * @param \Closure|string $callback
-         * @return void 
+         * @return bool 
          * @static 
-         */
-        public static function saving($callback){
+         */ 
+        public static function totallyGuarded()
+        {
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::saving($callback);
+            return \Webpatser\Countries\Countries::totallyGuarded();
         }
+         
+    }
+ 
+}
+
+namespace Intervention\Image\Facades { 
+
+    class Image {
         
         /**
-         * Register a saved model event with the dispatcher.
+         * Overrides configuration settings
          *
-         * @param \Closure|string $callback
-         * @return void 
+         * @param array $config
          * @static 
-         */
-        public static function saved($callback){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::saved($callback);
+         */ 
+        public static function configure($config = array())
+        {
+            return \Intervention\Image\ImageManager::configure($config);
         }
         
         /**
-         * Register an updating model event with the dispatcher.
+         * Initiates an Image instance from different input types
          *
-         * @param \Closure|string $callback
-         * @return void 
+         * @param mixed $data
+         * @return \Intervention\Image\Image 
          * @static 
-         */
-        public static function updating($callback){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::updating($callback);
+         */ 
+        public static function make($data)
+        {
+            return \Intervention\Image\ImageManager::make($data);
         }
         
         /**
-         * Register an updated model event with the dispatcher.
+         * Creates an empty image canvas
          *
-         * @param \Closure|string $callback
-         * @return void 
+         * @param integer $width
+         * @param integer $height
+         * @param mixed $background
+         * @return \Intervention\Image\Image 
          * @static 
-         */
-        public static function updated($callback){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::updated($callback);
+         */ 
+        public static function canvas($width, $height, $background = null)
+        {
+            return \Intervention\Image\ImageManager::canvas($width, $height, $background);
         }
         
         /**
-         * Register a creating model event with the dispatcher.
+         * Create new cached image and run callback
+         * (requires additional package intervention/imagecache)
          *
-         * @param \Closure|string $callback
-         * @return void 
+         * @param \Closure $callback
+         * @param integer $lifetime
+         * @param boolean $returnObj
+         * @return \Image 
          * @static 
-         */
-        public static function creating($callback){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::creating($callback);
+         */ 
+        public static function cache($callback, $lifetime = null, $returnObj = false)
+        {
+            return \Intervention\Image\ImageManager::cache($callback, $lifetime, $returnObj);
         }
+         
+    }
+ 
+}
+
+namespace anlutro\LaravelSettings { 
+
+    class Facade {
         
         /**
-         * Register a created model event with the dispatcher.
+         * 
          *
-         * @param \Closure|string $callback
-         * @return void 
          * @static 
-         */
-        public static function created($callback){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::created($callback);
+         */ 
+        public static function getDefaultDriver()
+        {
+            return \anlutro\LaravelSettings\SettingsManager::getDefaultDriver();
         }
         
         /**
-         * Register a deleting model event with the dispatcher.
+         * 
          *
-         * @param \Closure|string $callback
-         * @return void 
          * @static 
-         */
-        public static function deleting($callback){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::deleting($callback);
+         */ 
+        public static function createJsonDriver()
+        {
+            return \anlutro\LaravelSettings\SettingsManager::createJsonDriver();
         }
         
         /**
-         * Register a deleted model event with the dispatcher.
+         * 
          *
-         * @param \Closure|string $callback
-         * @return void 
          * @static 
-         */
-        public static function deleted($callback){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::deleted($callback);
+         */ 
+        public static function createDatabaseDriver()
+        {
+            return \anlutro\LaravelSettings\SettingsManager::createDatabaseDriver();
         }
         
         /**
-         * Remove all of the event listeners for the model.
+         * 
          *
-         * @return void 
          * @static 
-         */
-        public static function flushEventListeners(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::flushEventListeners();
+         */ 
+        public static function createMemoryDriver()
+        {
+            return \anlutro\LaravelSettings\SettingsManager::createMemoryDriver();
         }
         
         /**
-         * Get the event dispatcher instance.
+         * 
          *
-         * @return \Illuminate\Contracts\Events\Dispatcher 
          * @static 
-         */
-        public static function getEventDispatcher(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getEventDispatcher();
+         */ 
+        public static function createArrayDriver()
+        {
+            return \anlutro\LaravelSettings\SettingsManager::createArrayDriver();
         }
         
         /**
-         * Set the event dispatcher instance.
+         * Get a driver instance.
          *
-         * @param \Illuminate\Contracts\Events\Dispatcher $dispatcher
-         * @return void 
+         * @param string $driver
+         * @return mixed 
          * @static 
-         */
-        public static function setEventDispatcher($dispatcher){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::setEventDispatcher($dispatcher);
+         */ 
+        public static function driver($driver = null)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \anlutro\LaravelSettings\SettingsManager::driver($driver);
         }
         
         /**
-         * Unset the event dispatcher for models.
+         * Register a custom driver creator Closure.
          *
-         * @return void 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
-         */
-        public static function unsetEventDispatcher(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::unsetEventDispatcher();
+         */ 
+        public static function extend($driver, $callback)
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \anlutro\LaravelSettings\SettingsManager::extend($driver, $callback);
         }
         
         /**
-         * Register a new global scope on the model.
+         * Get all of the created "drivers".
          *
-         * @param \Illuminate\Database\Eloquent\Scope|\Closure|string $scope
-         * @param \Closure|null $implementation
-         * @return mixed 
-         * @throws \InvalidArgumentException
+         * @return array 
          * @static 
-         */
-        public static function addGlobalScope($scope, $implementation = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::addGlobalScope($scope, $implementation);
+         */ 
+        public static function getDrivers()
+        {
+            //Method inherited from \Illuminate\Support\Manager            
+            return \anlutro\LaravelSettings\SettingsManager::getDrivers();
         }
+         
+    }
+ 
+}
+
+namespace Vanguard\Services\Auth\TwoFactor { 
+
+    class Facade {
         
         /**
-         * Determine if a model has a global scope.
+         * Determine if the given user has two-factor authentication enabled.
          *
-         * @param \Illuminate\Database\Eloquent\Scope|string $scope
+         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
          * @return bool 
          * @static 
-         */
-        public static function hasGlobalScope($scope){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasGlobalScope($scope);
+         */ 
+        public static function isEnabled($user)
+        {
+            return \Vanguard\Services\Auth\TwoFactor\Authy::isEnabled($user);
         }
         
         /**
-         * Get a global scope registered with the model.
+         * Register the given user with the provider.
          *
-         * @param \Illuminate\Database\Eloquent\Scope|string $scope
-         * @return \Illuminate\Database\Eloquent\Scope|\Closure|null 
+         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
          * @static 
-         */
-        public static function getGlobalScope($scope){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getGlobalScope($scope);
+         */ 
+        public static function register($user)
+        {
+            return \Vanguard\Services\Auth\TwoFactor\Authy::register($user);
         }
         
         /**
-         * Get the global scopes for this class instance.
+         * Determine if the given token is valid for the given user.
          *
-         * @return array 
+         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
+         * @param string $token
+         * @return bool 
          * @static 
-         */
-        public static function getGlobalScopes(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getGlobalScopes();
+         */ 
+        public static function tokenIsValid($user, $token)
+        {
+            return \Vanguard\Services\Auth\TwoFactor\Authy::tokenIsValid($user, $token);
         }
         
         /**
-         * Define a one-to-one relationship.
+         * Delete the given user from the provider.
          *
-         * @param string $related
-         * @param string $foreignKey
-         * @param string $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\HasOne 
+         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
+         * @return bool 
          * @static 
-         */
-        public static function hasOne($related, $foreignKey = null, $localKey = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasOne($related, $foreignKey, $localKey);
+         */ 
+        public static function delete($user)
+        {
+            return \Vanguard\Services\Auth\TwoFactor\Authy::delete($user);
         }
+         
+    }
+ 
+}
+
+namespace Tymon\JWTAuth\Facades { 
+
+    class JWTAuth {
         
         /**
-         * Define a polymorphic one-to-one relationship.
+         * Attempt to authenticate the user and return the token.
          *
-         * @param string $related
-         * @param string $name
-         * @param string $type
-         * @param string $id
-         * @param string $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\MorphOne 
+         * @param array $credentials
+         * @return false|string 
          * @static 
-         */
-        public static function morphOne($related, $name, $type = null, $id = null, $localKey = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphOne($related, $name, $type, $id, $localKey);
+         */ 
+        public static function attempt($credentials)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWTAuth            
+            return \Vanguard\Services\Auth\Api\JWTAuth::attempt($credentials);
         }
         
         /**
-         * Define an inverse one-to-one or many relationship.
+         * Authenticate a user via a token.
          *
-         * @param string $related
-         * @param string $foreignKey
-         * @param string $ownerKey
-         * @param string $relation
-         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo 
+         * @return \Tymon\JWTAuth\Contracts\JWTSubject|false 
          * @static 
-         */
-        public static function belongsTo($related, $foreignKey = null, $ownerKey = null, $relation = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::belongsTo($related, $foreignKey, $ownerKey, $relation);
+         */ 
+        public static function authenticate()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWTAuth            
+            return \Vanguard\Services\Auth\Api\JWTAuth::authenticate();
         }
         
         /**
-         * Define a polymorphic, inverse one-to-one or many relationship.
+         * Alias for authenticate().
          *
-         * @param string $name
-         * @param string $type
-         * @param string $id
-         * @return \Illuminate\Database\Eloquent\Relations\MorphTo 
+         * @return \Tymon\JWTAuth\Contracts\JWTSubject|false 
          * @static 
-         */
-        public static function morphTo($name = null, $type = null, $id = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphTo($name, $type, $id);
+         */ 
+        public static function toUser()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWTAuth            
+            return \Vanguard\Services\Auth\Api\JWTAuth::toUser();
         }
         
         /**
-         * Retrieve the actual class name for a given morph class.
+         * Get the authenticated user.
          *
-         * @param string $class
-         * @return string 
+         * @return \Tymon\JWTAuth\Contracts\JWTSubject 
          * @static 
-         */
-        public static function getActualClassNameForMorph($class){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getActualClassNameForMorph($class);
+         */ 
+        public static function user()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWTAuth            
+            return \Vanguard\Services\Auth\Api\JWTAuth::user();
         }
         
         /**
-         * Define a one-to-many relationship.
-         *
-         * @param string $related
-         * @param string $foreignKey
-         * @param string $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\HasMany 
+         * Generate a token for a given subject.
+         *
+         * @param \Tymon\JWTAuth\Contracts\JWTSubject $subject
+         * @return string 
          * @static 
-         */
-        public static function hasMany($related, $foreignKey = null, $localKey = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasMany($related, $foreignKey, $localKey);
+         */ 
+        public static function fromSubject($subject)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::fromSubject($subject);
         }
         
         /**
-         * Define a has-many-through relationship.
+         * Alias to generate a token for a given user.
          *
-         * @param string $related
-         * @param string $through
-         * @param string|null $firstKey
-         * @param string|null $secondKey
-         * @param string|null $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\HasManyThrough 
+         * @param \Tymon\JWTAuth\Contracts\JWTSubject $user
+         * @return string 
          * @static 
-         */
-        public static function hasManyThrough($related, $through, $firstKey = null, $secondKey = null, $localKey = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasManyThrough($related, $through, $firstKey, $secondKey, $localKey);
+         */ 
+        public static function fromUser($user)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::fromUser($user);
         }
         
         /**
-         * Define a polymorphic one-to-many relationship.
+         * Refresh an expired token.
          *
-         * @param string $related
-         * @param string $name
-         * @param string $type
-         * @param string $id
-         * @param string $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\MorphMany 
+         * @param bool $forceForever
+         * @param bool $resetClaims
+         * @return string 
          * @static 
-         */
-        public static function morphMany($related, $name, $type = null, $id = null, $localKey = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphMany($related, $name, $type, $id, $localKey);
+         */ 
+        public static function refresh($forceForever = false, $resetClaims = false)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::refresh($forceForever, $resetClaims);
         }
         
         /**
-         * Define a many-to-many relationship.
+         * Invalidate a token (add it to the blacklist).
          *
-         * @param string $related
-         * @param string $table
-         * @param string $foreignKey
-         * @param string $relatedKey
-         * @param string $relation
-         * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany 
+         * @param bool $forceForever
+         * @return $this 
          * @static 
-         */
-        public static function belongsToMany($related, $table = null, $foreignKey = null, $relatedKey = null, $relation = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::belongsToMany($related, $table, $foreignKey, $relatedKey, $relation);
+         */ 
+        public static function invalidate($forceForever = true)
+        {
+            return \Vanguard\Services\Auth\Api\JWTAuth::invalidate($forceForever);
         }
         
         /**
-         * Define a polymorphic many-to-many relationship.
+         * Alias to get the payload, and as a result checks that
+         * the token is valid i.e. not expired or blacklisted.
          *
-         * @param string $related
-         * @param string $name
-         * @param string $table
-         * @param string $foreignKey
-         * @param string $relatedKey
-         * @param bool $inverse
-         * @return \Illuminate\Database\Eloquent\Relations\MorphToMany 
+         * @throws \Tymon\JWTAuth\Exceptions\JWTException
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
-         */
-        public static function morphToMany($related, $name, $table = null, $foreignKey = null, $relatedKey = null, $inverse = false){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphToMany($related, $name, $table, $foreignKey, $relatedKey, $inverse);
+         */ 
+        public static function checkOrFail()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::checkOrFail();
         }
         
         /**
-         * Define a polymorphic, inverse many-to-many relationship.
+         * Check that the token is valid.
          *
-         * @param string $related
-         * @param string $name
-         * @param string $table
-         * @param string $foreignKey
-         * @param string $relatedKey
-         * @return \Illuminate\Database\Eloquent\Relations\MorphToMany 
+         * @param bool $getPayload
+         * @return \Tymon\JWTAuth\Payload|bool 
          * @static 
-         */
-        public static function morphedByMany($related, $name, $table = null, $foreignKey = null, $relatedKey = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphedByMany($related, $name, $table, $foreignKey, $relatedKey);
+         */ 
+        public static function check($getPayload = false)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::check($getPayload);
         }
         
         /**
-         * Get the joining table name for a many-to-many relation.
+         * Get the token.
          *
-         * @param string $related
-         * @return string 
+         * @return \Tymon\JWTAuth\Token|null 
          * @static 
-         */
-        public static function joiningTable($related){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::joiningTable($related);
+         */ 
+        public static function getToken()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::getToken();
         }
         
         /**
-         * Determine if the model touches a given relation.
+         * Parse the token from the request.
          *
-         * @param string $relation
-         * @return bool 
+         * @throws \Tymon\JWTAuth\Exceptions\JWTException
+         * @return $this 
          * @static 
-         */
-        public static function touches($relation){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::touches($relation);
+         */ 
+        public static function parseToken()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::parseToken();
         }
         
         /**
-         * Touch the owning relations of the model.
+         * Get the raw Payload instance.
          *
-         * @return void 
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
-         */
-        public static function touchOwners(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::touchOwners();
+         */ 
+        public static function getPayload()
+        {
+            return \Vanguard\Services\Auth\Api\JWTAuth::getPayload();
         }
         
         /**
-         * Get the class name for polymorphic relations.
+         * Alias for getPayload().
          *
-         * @return string 
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
-         */
-        public static function getMorphClass(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getMorphClass();
+         */ 
+        public static function payload()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::payload();
         }
         
         /**
-         * Get all the loaded relations for the instance.
+         * Convenience method to get a claim value.
          *
-         * @return array 
+         * @param string $claim
+         * @return mixed 
          * @static 
-         */
-        public static function getRelations(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRelations();
+         */ 
+        public static function getClaim($claim)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::getClaim($claim);
         }
         
         /**
-         * Get a specified relationship.
+         * Create a Payload instance.
          *
-         * @param string $relation
-         * @return mixed 
+         * @param \Tymon\JWTAuth\Contracts\JWTSubject $subject
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
-         */
-        public static function getRelation($relation){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRelation($relation);
+         */ 
+        public static function makePayload($subject)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::makePayload($subject);
         }
         
         /**
-         * Determine if the given relation is loaded.
+         * Check if the subject model matches the one saved in the token.
          *
-         * @param string $key
+         * @param string|object $model
          * @return bool 
          * @static 
-         */
-        public static function relationLoaded($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::relationLoaded($key);
+         */ 
+        public static function checkSubjectModel($model)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::checkSubjectModel($model);
         }
         
         /**
-         * Set the specific relationship in the model.
+         * Set the token.
          *
-         * @param string $relation
-         * @param mixed $value
+         * @param \Tymon\JWTAuth\Token|string $token
          * @return $this 
          * @static 
-         */
-        public static function setRelation($relation, $value){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setRelation($relation, $value);
+         */ 
+        public static function setToken($token)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::setToken($token);
         }
         
         /**
-         * Set the entire relations array on the model.
+         * Unset the current token.
          *
-         * @param array $relations
          * @return $this 
          * @static 
-         */
-        public static function setRelations($relations){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setRelations($relations);
+         */ 
+        public static function unsetToken()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::unsetToken();
         }
         
         /**
-         * Get the relationships that are touched on save.
+         * Set the request instance.
          *
-         * @return array 
+         * @param \Illuminate\Http\Request $request
+         * @return $this 
          * @static 
-         */
-        public static function getTouchedRelations(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getTouchedRelations();
+         */ 
+        public static function setRequest($request)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::setRequest($request);
         }
         
         /**
-         * Set the relationships that are touched on save.
+         * Set whether the subject should be "locked".
          *
-         * @param array $touches
+         * @param bool $lock
          * @return $this 
          * @static 
-         */
-        public static function setTouchedRelations($touches){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setTouchedRelations($touches);
+         */ 
+        public static function lockSubject($lock)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::lockSubject($lock);
         }
         
         /**
-         * Update the model's update timestamp.
+         * Get the Manager instance.
          *
-         * @return bool 
+         * @return \Tymon\JWTAuth\Manager 
          * @static 
-         */
-        public static function touch(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::touch();
+         */ 
+        public static function manager()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::manager();
         }
         
         /**
-         * Set the value of the "created at" attribute.
+         * Get the Parser instance.
          *
-         * @param mixed $value
-         * @return $this 
+         * @return \Tymon\JWTAuth\Http\Parser\Parser 
          * @static 
-         */
-        public static function setCreatedAt($value){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setCreatedAt($value);
+         */ 
+        public static function parser()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::parser();
         }
         
         /**
-         * Set the value of the "updated at" attribute.
+         * Get the Payload Factory.
          *
-         * @param mixed $value
-         * @return $this 
+         * @return \Tymon\JWTAuth\Factory 
          * @static 
-         */
-        public static function setUpdatedAt($value){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setUpdatedAt($value);
+         */ 
+        public static function factory()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::factory();
         }
         
         /**
-         * Get a fresh timestamp for the model.
+         * Get the Blacklist.
          *
-         * @return \Carbon\Carbon 
+         * @return \Tymon\JWTAuth\Blacklist 
          * @static 
-         */
-        public static function freshTimestamp(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::freshTimestamp();
+         */ 
+        public static function blacklist()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::blacklist();
         }
         
         /**
-         * Get a fresh timestamp for the model.
+         * Set the custom claims.
          *
-         * @return string 
+         * @param array $customClaims
+         * @return $this 
          * @static 
-         */
-        public static function freshTimestampString(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::freshTimestampString();
+         */ 
+        public static function customClaims($customClaims)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::customClaims($customClaims);
         }
         
         /**
-         * Determine if the model uses timestamps.
+         * Alias to set the custom claims.
          *
-         * @return bool 
+         * @param array $customClaims
+         * @return $this 
          * @static 
-         */
-        public static function usesTimestamps(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::usesTimestamps();
+         */ 
+        public static function claims($customClaims)
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::claims($customClaims);
         }
         
         /**
-         * Get the name of the "created at" column.
+         * Get the custom claims.
          *
-         * @return string 
+         * @return array 
          * @static 
-         */
-        public static function getCreatedAtColumn(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getCreatedAtColumn();
+         */ 
+        public static function getCustomClaims()
+        {
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::getCustomClaims();
         }
+         
+    }
+
+    class JWTFactory {
         
         /**
-         * Get the name of the "updated at" column.
+         * Create the Payload instance.
          *
-         * @return string 
+         * @param bool $resetClaims
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
-         */
-        public static function getUpdatedAtColumn(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getUpdatedAtColumn();
+         */ 
+        public static function make($resetClaims = false)
+        {
+            return \Tymon\JWTAuth\Factory::make($resetClaims);
         }
         
         /**
-         * Get the hidden attributes for the model.
+         * Empty the claims collection.
          *
-         * @return array 
+         * @return $this 
          * @static 
-         */
-        public static function getHidden(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getHidden();
+         */ 
+        public static function emptyClaims()
+        {
+            return \Tymon\JWTAuth\Factory::emptyClaims();
         }
         
         /**
-         * Set the hidden attributes for the model.
+         * Build and get the Claims Collection.
          *
-         * @param array $hidden
-         * @return $this 
+         * @return \Tymon\JWTAuth\Claims\Collection 
          * @static 
-         */
-        public static function setHidden($hidden){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setHidden($hidden);
+         */ 
+        public static function buildClaimsCollection()
+        {
+            return \Tymon\JWTAuth\Factory::buildClaimsCollection();
         }
         
         /**
-         * Add hidden attributes for the model.
+         * Get a Payload instance with a claims collection.
          *
-         * @param array|string|null $attributes
-         * @return void 
+         * @param \Tymon\JWTAuth\Claims\Collection $claims
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
-         */
-        public static function addHidden($attributes = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::addHidden($attributes);
+         */ 
+        public static function withClaims($claims)
+        {
+            return \Tymon\JWTAuth\Factory::withClaims($claims);
         }
         
         /**
-         * Get the visible attributes for the model.
+         * Set the default claims to be added to the Payload.
          *
-         * @return array 
+         * @param array $claims
+         * @return $this 
          * @static 
-         */
-        public static function getVisible(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getVisible();
+         */ 
+        public static function setDefaultClaims($claims)
+        {
+            return \Tymon\JWTAuth\Factory::setDefaultClaims($claims);
         }
         
         /**
-         * Set the visible attributes for the model.
+         * Helper to set the ttl.
          *
-         * @param array $visible
+         * @param int $ttl
          * @return $this 
          * @static 
-         */
-        public static function setVisible($visible){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setVisible($visible);
+         */ 
+        public static function setTTL($ttl)
+        {
+            return \Tymon\JWTAuth\Factory::setTTL($ttl);
         }
         
         /**
-         * Add visible attributes for the model.
+         * Helper to get the ttl.
          *
-         * @param array|string|null $attributes
-         * @return void 
+         * @return int 
          * @static 
-         */
-        public static function addVisible($attributes = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::addVisible($attributes);
+         */ 
+        public static function getTTL()
+        {
+            return \Tymon\JWTAuth\Factory::getTTL();
         }
         
         /**
-         * Make the given, typically hidden, attributes visible.
+         * Get the default claims.
          *
-         * @param array|string $attributes
-         * @return $this 
+         * @return array 
          * @static 
-         */
-        public static function makeVisible($attributes){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::makeVisible($attributes);
+         */ 
+        public static function getDefaultClaims()
+        {
+            return \Tymon\JWTAuth\Factory::getDefaultClaims();
         }
         
         /**
-         * Make the given, typically visible, attributes hidden.
+         * Get the PayloadValidator instance.
          *
-         * @param array|string $attributes
-         * @return $this 
+         * @return \Tymon\JWTAuth\Validators\PayloadValidator 
          * @static 
-         */
-        public static function makeHidden($attributes){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::makeHidden($attributes);
+         */ 
+        public static function validator()
+        {
+            return \Tymon\JWTAuth\Factory::validator();
         }
         
         /**
-         * Get the fillable attributes for the model.
+         * Set the custom claims.
          *
-         * @return array 
+         * @param array $customClaims
+         * @return $this 
          * @static 
-         */
-        public static function getFillable(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getFillable();
+         */ 
+        public static function customClaims($customClaims)
+        {
+            return \Tymon\JWTAuth\Factory::customClaims($customClaims);
         }
         
         /**
-         * Set the fillable attributes for the model.
+         * Alias to set the custom claims.
          *
-         * @param array $fillable
+         * @param array $customClaims
          * @return $this 
          * @static 
-         */
-        public static function fillable($fillable){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fillable($fillable);
+         */ 
+        public static function claims($customClaims)
+        {
+            return \Tymon\JWTAuth\Factory::claims($customClaims);
         }
         
         /**
-         * Get the guarded attributes for the model.
+         * Get the custom claims.
          *
          * @return array 
          * @static 
-         */
-        public static function getGuarded(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getGuarded();
+         */ 
+        public static function getCustomClaims()
+        {
+            return \Tymon\JWTAuth\Factory::getCustomClaims();
         }
         
         /**
-         * Set the guarded attributes for the model.
+         * Set the refresh flow flag.
          *
-         * @param array $guarded
+         * @param bool $refreshFlow
          * @return $this 
          * @static 
-         */
-        public static function guard($guarded){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::guard($guarded);
+         */ 
+        public static function setRefreshFlow($refreshFlow = true)
+        {
+            return \Tymon\JWTAuth\Factory::setRefreshFlow($refreshFlow);
         }
+         
+    }
+ 
+}
+
+namespace Jenssegers\Agent\Facades { 
+
+    class Agent {
         
         /**
-         * Disable all mass assignable restrictions.
+         * Get all detection rules. These rules include the additional
+         * platforms and browsers.
          *
-         * @param bool $state
-         * @return void 
+         * @return array 
          * @static 
-         */
-        public static function unguard($state = true){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::unguard($state);
+         */ 
+        public static function getDetectionRulesExtended()
+        {
+            return \Jenssegers\Agent\Agent::getDetectionRulesExtended();
         }
         
         /**
-         * Enable the mass assignment restrictions.
+         * 
          *
-         * @return void 
+         * @inheritdoc 
          * @static 
-         */
-        public static function reguard(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::reguard();
+         */ 
+        public static function getRules()
+        {
+            return \Jenssegers\Agent\Agent::getRules();
         }
         
         /**
-         * Determine if current state is "unguarded".
+         * 
          *
-         * @return bool 
+         * @return \Jenssegers\Agent\CrawlerDetect 
          * @static 
-         */
-        public static function isUnguarded(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::isUnguarded();
+         */ 
+        public static function getCrawlerDetect()
+        {
+            return \Jenssegers\Agent\Agent::getCrawlerDetect();
         }
         
         /**
-         * Run the given callable while being unguarded.
+         * Get accept languages.
          *
-         * @param callable $callback
-         * @return mixed 
+         * @param string $acceptLanguage
+         * @return array 
          * @static 
-         */
-        public static function unguarded($callback){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::unguarded($callback);
+         */ 
+        public static function languages($acceptLanguage = null)
+        {
+            return \Jenssegers\Agent\Agent::languages($acceptLanguage);
         }
         
         /**
-         * Determine if the given attribute may be mass assigned.
+         * Get the browser name.
          *
-         * @param string $key
-         * @return bool 
+         * @param null $userAgent
+         * @return string 
          * @static 
-         */
-        public static function isFillable($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::isFillable($key);
+         */ 
+        public static function browser($userAgent = null)
+        {
+            return \Jenssegers\Agent\Agent::browser($userAgent);
         }
         
         /**
-         * Determine if the given key is guarded.
+         * Get the platform name.
          *
-         * @param string $key
-         * @return bool 
+         * @param string $userAgent
+         * @return string 
          * @static 
-         */
-        public static function isGuarded($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::isGuarded($key);
+         */ 
+        public static function platform($userAgent = null)
+        {
+            return \Jenssegers\Agent\Agent::platform($userAgent);
         }
         
         /**
-         * Determine if the model is totally guarded.
+         * Get the device name.
          *
-         * @return bool 
+         * @param string $userAgent
+         * @return string 
          * @static 
-         */
-        public static function totallyGuarded(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::totallyGuarded();
+         */ 
+        public static function device($userAgent = null)
+        {
+            return \Jenssegers\Agent\Agent::device($userAgent);
         }
         
-    }
-
-
-    class Image extends \Intervention\Image\Facades\Image{
-        
         /**
-         * Overrides configuration settings
+         * Check if the device is a desktop computer.
          *
-         * @param array $config
+         * @param string $userAgent deprecated
+         * @param array $httpHeaders deprecated
+         * @return bool 
          * @static 
-         */
-        public static function configure($config = array()){
-            return \Intervention\Image\ImageManager::configure($config);
+         */ 
+        public static function isDesktop($userAgent = null, $httpHeaders = null)
+        {
+            return \Jenssegers\Agent\Agent::isDesktop($userAgent, $httpHeaders);
         }
         
         /**
-         * Initiates an Image instance from different input types
+         * Check if the device is a mobile phone.
          *
-         * @param mixed $data
-         * @return \Intervention\Image\Image 
+         * @param string $userAgent deprecated
+         * @param array $httpHeaders deprecated
+         * @return bool 
          * @static 
-         */
-        public static function make($data){
-            return \Intervention\Image\ImageManager::make($data);
+         */ 
+        public static function isPhone($userAgent = null, $httpHeaders = null)
+        {
+            return \Jenssegers\Agent\Agent::isPhone($userAgent, $httpHeaders);
         }
         
         /**
-         * Creates an empty image canvas
+         * Get the robot name.
          *
-         * @param integer $width
-         * @param integer $height
-         * @param mixed $background
-         * @return \Intervention\Image\Image 
+         * @param string $userAgent
+         * @return string|bool 
          * @static 
-         */
-        public static function canvas($width, $height, $background = null){
-            return \Intervention\Image\ImageManager::canvas($width, $height, $background);
+         */ 
+        public static function robot($userAgent = null)
+        {
+            return \Jenssegers\Agent\Agent::robot($userAgent);
         }
         
         /**
-         * Create new cached image and run callback
-         * (requires additional package intervention/imagecache)
+         * Check if device is a robot.
          *
-         * @param \Closure $callback
-         * @param integer $lifetime
-         * @param boolean $returnObj
-         * @return \Image 
+         * @param string $userAgent
+         * @return bool 
          * @static 
-         */
-        public static function cache($callback, $lifetime = null, $returnObj = false){
-            return \Intervention\Image\ImageManager::cache($callback, $lifetime, $returnObj);
+         */ 
+        public static function isRobot($userAgent = null)
+        {
+            return \Jenssegers\Agent\Agent::isRobot($userAgent);
         }
         
-    }
-
-
-    class Settings extends \anlutro\LaravelSettings\Facade{
-        
         /**
          * 
          *
+         * @inheritdoc 
          * @static 
-         */
-        public static function getDefaultDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::getDefaultDriver();
+         */ 
+        public static function version($propertyName, $type = 'text')
+        {
+            return \Jenssegers\Agent\Agent::version($propertyName, $type);
         }
         
         /**
+         * Get the current script version.
          * 
+         * This is useful for the demo.php file,
+         * so people can check on what version they are testing
+         * for mobile devices.
          *
+         * @return string The version number in semantic version format.
          * @static 
-         */
-        public static function createJsonDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::createJsonDriver();
+         */ 
+        public static function getScriptVersion()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getScriptVersion();
         }
         
         /**
-         * 
+         * Set the HTTP Headers. Must be PHP-flavored. This method will reset existing headers.
          *
+         * @param array $httpHeaders The headers to set. If null, then using PHP's _SERVER to extract
+         *                           the headers. The default null is left for backwards compatibility.
          * @static 
-         */
-        public static function createDatabaseDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::createDatabaseDriver();
+         */ 
+        public static function setHttpHeaders($httpHeaders = null)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::setHttpHeaders($httpHeaders);
         }
         
         /**
-         * 
+         * Retrieves the HTTP headers.
          *
+         * @return array 
          * @static 
-         */
-        public static function createMemoryDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::createMemoryDriver();
+         */ 
+        public static function getHttpHeaders()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getHttpHeaders();
         }
         
         /**
+         * Retrieves a particular header. If it doesn't exist, no exception/error is caused.
          * 
+         * Simply null is returned.
          *
+         * @param string $header The name of the header to retrieve. Can be HTTP compliant such as
+         *                       "User-Agent" or "X-Device-User-Agent" or can be php-esque with the
+         *                       all-caps, HTTP_ prefixed, underscore seperated awesomeness.
+         * @return string|null The value of the header.
          * @static 
-         */
-        public static function createArrayDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::createArrayDriver();
+         */ 
+        public static function getHttpHeader($header)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getHttpHeader($header);
         }
         
         /**
-         * Get a driver instance.
+         * 
          *
-         * @param string $driver
-         * @return mixed 
          * @static 
-         */
-        public static function driver($driver = null){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \anlutro\LaravelSettings\SettingsManager::driver($driver);
+         */ 
+        public static function getMobileHeaders()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMobileHeaders();
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Get all possible HTTP headers that
+         * can contain the User-Agent string.
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @return array List of HTTP headers.
          * @static 
-         */
-        public static function extend($driver, $callback){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \anlutro\LaravelSettings\SettingsManager::extend($driver, $callback);
+         */ 
+        public static function getUaHttpHeaders()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getUaHttpHeaders();
         }
         
         /**
-         * Get all of the created "drivers".
+         * Set CloudFront headers
+         * http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-device
          *
-         * @return array 
+         * @param array $cfHeaders List of HTTP headers
+         * @return boolean If there were CloudFront headers to be set
          * @static 
-         */
-        public static function getDrivers(){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \anlutro\LaravelSettings\SettingsManager::getDrivers();
+         */ 
+        public static function setCfHeaders($cfHeaders = null)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::setCfHeaders($cfHeaders);
         }
         
-    }
-
-
-    class Authy extends \Vanguard\Services\Auth\TwoFactor\Facade{
-        
         /**
-         * Determine if the given user has two-factor authentication enabled.
+         * Retrieves the cloudfront headers.
          *
-         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
-         * @return bool 
+         * @return array 
          * @static 
-         */
-        public static function isEnabled($user){
-            return \Vanguard\Services\Auth\TwoFactor\Authy::isEnabled($user);
+         */ 
+        public static function getCfHeaders()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getCfHeaders();
         }
         
         /**
-         * Register the given user with the provider.
+         * Set the User-Agent to be used.
          *
-         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
+         * @param string $userAgent The user agent string to set.
+         * @return string|null 
          * @static 
-         */
-        public static function register($user){
-            return \Vanguard\Services\Auth\TwoFactor\Authy::register($user);
+         */ 
+        public static function setUserAgent($userAgent = null)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::setUserAgent($userAgent);
         }
         
         /**
-         * Determine if the given token is valid for the given user.
+         * Retrieve the User-Agent.
          *
-         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
-         * @param string $token
-         * @return bool 
+         * @return string|null The user agent if it's set.
          * @static 
-         */
-        public static function tokenIsValid($user, $token){
-            return \Vanguard\Services\Auth\TwoFactor\Authy::tokenIsValid($user, $token);
+         */ 
+        public static function getUserAgent()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getUserAgent();
         }
         
         /**
-         * Delete the given user from the provider.
+         * Set the detection type. Must be one of self::DETECTION_TYPE_MOBILE or
+         * self::DETECTION_TYPE_EXTENDED. Otherwise, nothing is set.
          *
-         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
-         * @return bool 
+         * @deprecated since version 2.6.9
+         * @param string $type The type. Must be a self::DETECTION_TYPE_* constant. The default
+         *                     parameter is null which will default to self::DETECTION_TYPE_MOBILE.
          * @static 
-         */
-        public static function delete($user){
-            return \Vanguard\Services\Auth\TwoFactor\Authy::delete($user);
+         */ 
+        public static function setDetectionType($type = null)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::setDetectionType($type);
         }
         
-    }
-
-
-    class JWTAuth extends \Tymon\JWTAuth\Facades\JWTAuth{
-        
         /**
-         * Authenticate a user via a token.
+         * 
          *
-         * @return \Tymon\JWTAuth\Contracts\JWTSubject|false 
          * @static 
-         */
-        public static function authenticate(){
-            return \Vanguard\Services\Auth\Api\JWTAuth::authenticate();
+         */ 
+        public static function getMatchingRegex()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMatchingRegex();
         }
         
         /**
-         * Attempt to authenticate the user and return the token.
+         * 
          *
-         * @param array $credentials
-         * @return false|string 
          * @static 
-         */
-        public static function attempt($credentials){
-            //Method inherited from \Tymon\JWTAuth\JWTAuth            
-            return \Vanguard\Services\Auth\Api\JWTAuth::attempt($credentials);
+         */ 
+        public static function getMatchesArray()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMatchesArray();
         }
         
         /**
-         * Alias for authenticate().
+         * Retrieve the list of known phone devices.
          *
-         * @return \Tymon\JWTAuth\Contracts\JWTSubject|false 
+         * @return array List of phone devices.
          * @static 
-         */
-        public static function toUser(){
-            //Method inherited from \Tymon\JWTAuth\JWTAuth            
-            return \Vanguard\Services\Auth\Api\JWTAuth::toUser();
+         */ 
+        public static function getPhoneDevices()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getPhoneDevices();
         }
         
         /**
-         * Get the authenticated user.
+         * Retrieve the list of known tablet devices.
          *
-         * @return \Tymon\JWTAuth\Contracts\JWTSubject 
+         * @return array List of tablet devices.
          * @static 
-         */
-        public static function user(){
-            //Method inherited from \Tymon\JWTAuth\JWTAuth            
-            return \Vanguard\Services\Auth\Api\JWTAuth::user();
+         */ 
+        public static function getTabletDevices()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getTabletDevices();
         }
         
         /**
-         * Generate a token for a given subject.
+         * Alias for getBrowsers() method.
          *
-         * @param \Tymon\JWTAuth\Contracts\JWTSubject $subject
-         * @return string 
+         * @return array List of user agents.
          * @static 
-         */
-        public static function fromSubject($subject){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::fromSubject($subject);
+         */ 
+        public static function getUserAgents()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getUserAgents();
         }
         
         /**
-         * Alias to generate a token for a given user.
+         * Retrieve the list of known browsers. Specifically, the user agents.
          *
-         * @param \Tymon\JWTAuth\Contracts\JWTSubject $user
-         * @return string 
+         * @return array List of browsers / user agents.
          * @static 
-         */
-        public static function fromUser($user){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::fromUser($user);
+         */ 
+        public static function getBrowsers()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getBrowsers();
         }
         
         /**
-         * Refresh an expired token.
+         * Retrieve the list of known utilities.
          *
-         * @param bool $forceForever
-         * @param bool $resetClaims
-         * @return string 
+         * @return array List of utilities.
          * @static 
-         */
-        public static function refresh($forceForever = false, $resetClaims = false){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::refresh($forceForever, $resetClaims);
+         */ 
+        public static function getUtilities()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getUtilities();
         }
         
         /**
-         * Invalidate a token (add it to the blacklist).
+         * Method gets the mobile detection rules. This method is used for the magic methods $detect->is*().
          *
-         * @param bool $forceForever
-         * @return $this 
+         * @deprecated since version 2.6.9
+         * @return array All the rules (but not extended).
          * @static 
-         */
-        public static function invalidate($forceForever = false){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::invalidate($forceForever);
+         */ 
+        public static function getMobileDetectionRules()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMobileDetectionRules();
         }
         
         /**
-         * Alias to get the payload, and as a result checks that
-         * the token is valid i.e. not expired or blacklisted.
+         * Method gets the mobile detection rules + utilities.
+         * 
+         * The reason this is separate is because utilities rules
+         * don't necessary imply mobile. This method is used inside
+         * the new $detect->is('stuff') method.
          *
-         * @throws \Tymon\JWTAuth\Exceptions\JWTException
-         * @return \Tymon\JWTAuth\Payload 
+         * @deprecated since version 2.6.9
+         * @return array All the rules + extended.
          * @static 
-         */
-        public static function checkOrFail(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::checkOrFail();
+         */ 
+        public static function getMobileDetectionRulesExtended()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMobileDetectionRulesExtended();
         }
         
         /**
-         * Check that the token is valid.
+         * Retrieve the list of mobile operating systems.
          *
-         * @return bool 
+         * @return array The list of mobile operating systems.
          * @static 
-         */
-        public static function check(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::check();
+         */ 
+        public static function getOperatingSystems()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getOperatingSystems();
         }
         
         /**
-         * Get the token.
+         * Check the HTTP headers for signs of mobile.
+         * 
+         * This is the fastest mobile check possible; it's used
+         * inside isMobile() method.
          *
-         * @return \Tymon\JWTAuth\Token|false 
+         * @return bool 
          * @static 
-         */
-        public static function getToken(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::getToken();
+         */ 
+        public static function checkHttpHeadersForMobile()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::checkHttpHeadersForMobile();
         }
         
         /**
-         * Parse the token from the request.
+         * Check if the device is mobile.
+         * 
+         * Returns true if any type of mobile device detected, including special ones
          *
-         * @throws \Tymon\JWTAuth\Exceptions\JWTException
-         * @return $this 
+         * @param null $userAgent deprecated
+         * @param null $httpHeaders deprecated
+         * @return bool 
          * @static 
-         */
-        public static function parseToken(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::parseToken();
+         */ 
+        public static function isMobile($userAgent = null, $httpHeaders = null)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::isMobile($userAgent, $httpHeaders);
         }
         
         /**
-         * Get the raw Payload instance.
+         * Check if the device is a tablet.
+         * 
+         * Return true if any type of tablet device is detected.
          *
-         * @return \Tymon\JWTAuth\Payload 
+         * @param string $userAgent deprecated
+         * @param array $httpHeaders deprecated
+         * @return bool 
          * @static 
-         */
-        public static function getPayload(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::getPayload();
+         */ 
+        public static function isTablet($userAgent = null, $httpHeaders = null)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::isTablet($userAgent, $httpHeaders);
         }
         
         /**
-         * Alias for getPayload().
+         * This method checks for a certain property in the
+         * userAgent.
          *
-         * @return \Tymon\JWTAuth\Payload 
+         * @todo : The httpHeaders part is not yet used.
+         * @param string $key
+         * @param string $userAgent deprecated
+         * @param string $httpHeaders deprecated
+         * @return bool|int|null 
          * @static 
-         */
-        public static function payload(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::payload();
+         */ 
+        public static function is($key, $userAgent = null, $httpHeaders = null)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::is($key, $userAgent, $httpHeaders);
         }
         
         /**
-         * Convenience method to get a claim value.
+         * Some detection rules are relative (not standard),
+         * because of the diversity of devices, vendors and
+         * their conventions in representing the User-Agent or
+         * the HTTP headers.
+         * 
+         * This method will be used to check custom regexes against
+         * the User-Agent string.
          *
-         * @param string $claim
-         * @return mixed 
+         * @param $regex
+         * @param string $userAgent
+         * @return bool 
+         * @todo : search in the HTTP headers too.
          * @static 
-         */
-        public static function getClaim($claim){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::getClaim($claim);
+         */ 
+        public static function match($regex, $userAgent = null)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::match($regex, $userAgent);
         }
         
         /**
-         * Create a Payload instance.
+         * Get the properties array.
          *
-         * @param \Tymon\JWTAuth\Contracts\JWTSubject $subject
-         * @return \Tymon\JWTAuth\Payload 
+         * @return array 
          * @static 
-         */
-        public static function makePayload($subject){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::makePayload($subject);
+         */ 
+        public static function getProperties()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getProperties();
         }
         
         /**
-         * Set the token.
+         * Prepare the version number.
          *
-         * @param \Tymon\JWTAuth\Token|string $token
-         * @return $this 
+         * @todo Remove the error supression from str_replace() call.
+         * @param string $ver The string version, like "2.6.21.2152";
+         * @return float 
          * @static 
-         */
-        public static function setToken($token){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::setToken($token);
+         */ 
+        public static function prepareVersionNo($ver)
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::prepareVersionNo($ver);
         }
         
         /**
-         * Unset the current token.
+         * Retrieve the mobile grading, using self::MOBILE_GRADE_* constants.
          *
-         * @return $this 
+         * @return string One of the self::MOBILE_GRADE_* constants.
          * @static 
-         */
-        public static function unsetToken(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::unsetToken();
+         */ 
+        public static function mobileGrade()
+        {
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::mobileGrade();
         }
+         
+    }
+ 
+}
+
+namespace Anhskohbo\NoCaptcha\Facades { 
+
+    class NoCaptcha {
         
         /**
-         * Set the request instance.
+         * Render HTML captcha.
          *
-         * @param \Illuminate\Http\Request $request
-         * @return $this 
+         * @param array $attributes
+         * @return string 
          * @static 
-         */
-        public static function setRequest($request){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::setRequest($request);
+         */ 
+        public static function display($attributes = array())
+        {
+            return \Anhskohbo\NoCaptcha\NoCaptcha::display($attributes);
         }
         
         /**
-         * Get the Manager instance.
+         * Render js source
          *
-         * @return \Tymon\JWTAuth\Manager 
+         * @param null $lang
+         * @param bool $callback
+         * @param string $onLoadClass
+         * @return string 
          * @static 
-         */
-        public static function manager(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::manager();
+         */ 
+        public static function renderJs($lang = null, $callback = false, $onLoadClass = 'onloadCallBack')
+        {
+            return \Anhskohbo\NoCaptcha\NoCaptcha::renderJs($lang, $callback, $onLoadClass);
         }
         
         /**
-         * Get the Parser instance.
+         * Verify no-captcha response.
          *
-         * @return \Tymon\JWTAuth\Http\Parser\Parser 
+         * @param string $response
+         * @param string $clientIp
+         * @return bool 
          * @static 
-         */
-        public static function parser(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::parser();
+         */ 
+        public static function verifyResponse($response, $clientIp = null)
+        {
+            return \Anhskohbo\NoCaptcha\NoCaptcha::verifyResponse($response, $clientIp);
         }
         
         /**
-         * Get the Payload Factory.
+         * Verify no-captcha response by Symfony Request.
          *
-         * @return \Tymon\JWTAuth\Factory 
+         * @param \Request $request
+         * @return bool 
          * @static 
-         */
-        public static function factory(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::factory();
+         */ 
+        public static function verifyRequest($request)
+        {
+            return \Anhskohbo\NoCaptcha\NoCaptcha::verifyRequest($request);
         }
         
         /**
-         * Get the Blacklist.
+         * Get recaptcha js link.
          *
-         * @return \Tymon\JWTAuth\Blacklist 
+         * @param string $lang
+         * @param boolean $callback
+         * @param string $onLoadClass
+         * @return string 
          * @static 
-         */
-        public static function blacklist(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::blacklist();
+         */ 
+        public static function getJsLink($lang = null, $callback = false, $onLoadClass = 'onloadCallBack')
+        {
+            return \Anhskohbo\NoCaptcha\NoCaptcha::getJsLink($lang, $callback, $onLoadClass);
         }
+         
+    }
+ 
+}
+
+namespace Barryvdh\Debugbar { 
+
+    class Facade {
         
         /**
-         * Set the custom claims.
+         * Enable the Debugbar and boot, if not already booted.
          *
-         * @param array $customClaims
-         * @return $this 
          * @static 
-         */
-        public static function customClaims($customClaims){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::customClaims($customClaims);
+         */ 
+        public static function enable()
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::enable();
         }
         
         /**
-         * Alias to set the custom claims.
+         * Boot the debugbar (add collectors, renderer and listener)
          *
-         * @param array $customClaims
-         * @return $this 
          * @static 
-         */
-        public static function claims($customClaims){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::claims($customClaims);
+         */ 
+        public static function boot()
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::boot();
         }
         
         /**
-         * Get the custom claims.
+         * 
          *
-         * @return array 
          * @static 
-         */
-        public static function getCustomClaims(){
-            //Method inherited from \Tymon\JWTAuth\JWT            
-            return \Vanguard\Services\Auth\Api\JWTAuth::getCustomClaims();
+         */ 
+        public static function shouldCollect($name, $default = false)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::shouldCollect($name, $default);
         }
         
-    }
-
-
-    class Agent extends \Jenssegers\Agent\Facades\Agent{
-        
         /**
-         * Get all detection rules. These rules include the additional
-         * platforms and browsers.
+         * Adds a data collector
          *
-         * @return array 
+         * @param \Barryvdh\Debugbar\DataCollectorInterface $collector
+         * @throws DebugBarException
+         * @return $this 
          * @static 
-         */
-        public static function getDetectionRulesExtended(){
-            return \Jenssegers\Agent\Agent::getDetectionRulesExtended();
+         */ 
+        public static function addCollector($collector)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::addCollector($collector);
         }
         
         /**
-         * 
+         * Handle silenced errors
          *
-         * @inheritdoc 
+         * @param $level
+         * @param $message
+         * @param string $file
+         * @param int $line
+         * @param array $context
+         * @throws \ErrorException
          * @static 
-         */
-        public static function getRules(){
-            return \Jenssegers\Agent\Agent::getRules();
+         */ 
+        public static function handleError($level, $message, $file = '', $line = 0, $context = array())
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::handleError($level, $message, $file, $line, $context);
         }
         
         /**
-         * 
+         * Starts a measure
          *
-         * @return \Jenssegers\Agent\CrawlerDetect 
+         * @param string $name Internal name, used to stop the measure
+         * @param string $label Public name
          * @static 
-         */
-        public static function getCrawlerDetect(){
-            return \Jenssegers\Agent\Agent::getCrawlerDetect();
+         */ 
+        public static function startMeasure($name, $label = null)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::startMeasure($name, $label);
         }
         
         /**
-         * Get accept languages.
+         * Stops a measure
          *
-         * @param string $acceptLanguage
-         * @return array 
+         * @param string $name
          * @static 
-         */
-        public static function languages($acceptLanguage = null){
-            return \Jenssegers\Agent\Agent::languages($acceptLanguage);
+         */ 
+        public static function stopMeasure($name)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::stopMeasure($name);
         }
         
         /**
-         * Get the browser name.
+         * Adds an exception to be profiled in the debug bar
          *
-         * @param null $userAgent
-         * @return string 
+         * @param \Exception $e
+         * @deprecated in favor of addThrowable
          * @static 
-         */
-        public static function browser($userAgent = null){
-            return \Jenssegers\Agent\Agent::browser($userAgent);
+         */ 
+        public static function addException($e)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::addException($e);
         }
         
         /**
-         * Get the platform name.
+         * Adds an exception to be profiled in the debug bar
          *
-         * @param string $userAgent
-         * @return string 
+         * @param \Exception $e
          * @static 
-         */
-        public static function platform($userAgent = null){
-            return \Jenssegers\Agent\Agent::platform($userAgent);
+         */ 
+        public static function addThrowable($e)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::addThrowable($e);
         }
         
         /**
-         * Get the device name.
+         * Returns a JavascriptRenderer for this instance
          *
-         * @param string $userAgent
-         * @return string 
+         * @param string $baseUrl
+         * @param string $basePathng
+         * @return \Barryvdh\Debugbar\JavascriptRenderer 
          * @static 
-         */
-        public static function device($userAgent = null){
-            return \Jenssegers\Agent\Agent::device($userAgent);
+         */ 
+        public static function getJavascriptRenderer($baseUrl = null, $basePath = null)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::getJavascriptRenderer($baseUrl, $basePath);
         }
         
         /**
-         * Check if the device is a desktop computer.
+         * Modify the response and inject the debugbar (or data in headers)
          *
-         * @param string $userAgent deprecated
-         * @param array $httpHeaders deprecated
-         * @return bool 
+         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @param \Symfony\Component\HttpFoundation\Response $response
+         * @return \Symfony\Component\HttpFoundation\Response 
          * @static 
-         */
-        public static function isDesktop($userAgent = null, $httpHeaders = null){
-            return \Jenssegers\Agent\Agent::isDesktop($userAgent, $httpHeaders);
+         */ 
+        public static function modifyResponse($request, $response)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::modifyResponse($request, $response);
         }
         
         /**
-         * Check if the device is a mobile phone.
+         * Check if the Debugbar is enabled
          *
-         * @param string $userAgent deprecated
-         * @param array $httpHeaders deprecated
-         * @return bool 
+         * @return boolean 
          * @static 
-         */
-        public static function isPhone($userAgent = null, $httpHeaders = null){
-            return \Jenssegers\Agent\Agent::isPhone($userAgent, $httpHeaders);
+         */ 
+        public static function isEnabled()
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::isEnabled();
         }
         
         /**
-         * Get the robot name.
+         * Collects the data from the collectors
          *
-         * @param string $userAgent
-         * @return string|bool 
+         * @return array 
          * @static 
-         */
-        public static function robot($userAgent = null){
-            return \Jenssegers\Agent\Agent::robot($userAgent);
+         */ 
+        public static function collect()
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::collect();
         }
         
         /**
-         * Check if device is a robot.
+         * Injects the web debug toolbar into the given Response.
          *
-         * @param string $userAgent
-         * @return bool 
+         * @param \Symfony\Component\HttpFoundation\Response $response A Response instance
+         * Based on https://github.com/symfony/WebProfilerBundle/blob/master/EventListener/WebDebugToolbarListener.php
          * @static 
-         */
-        public static function isRobot($userAgent = null){
-            return \Jenssegers\Agent\Agent::isRobot($userAgent);
+         */ 
+        public static function injectDebugbar($response)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::injectDebugbar($response);
         }
         
         /**
-         * 
+         * Disable the Debugbar
          *
-         * @inheritdoc 
          * @static 
-         */
-        public static function version($propertyName, $type = 'text'){
-            return \Jenssegers\Agent\Agent::version($propertyName, $type);
+         */ 
+        public static function disable()
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::disable();
         }
         
         /**
-         * Get the current script version.
-         * 
-         * This is useful for the demo.php file,
-         * so people can check on what version they are testing
-         * for mobile devices.
+         * Adds a measure
          *
-         * @return string The version number in semantic version format.
+         * @param string $label
+         * @param float $start
+         * @param float $end
          * @static 
-         */
-        public static function getScriptVersion(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getScriptVersion();
+         */ 
+        public static function addMeasure($label, $start, $end)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::addMeasure($label, $start, $end);
         }
         
         /**
-         * Set the HTTP Headers. Must be PHP-flavored. This method will reset existing headers.
+         * Utility function to measure the execution of a Closure
          *
-         * @param array $httpHeaders The headers to set. If null, then using PHP's _SERVER to extract
-         *                           the headers. The default null is left for backwards compatibility.
+         * @param string $label
+         * @param \Closure $closure
          * @static 
-         */
-        public static function setHttpHeaders($httpHeaders = null){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::setHttpHeaders($httpHeaders);
+         */ 
+        public static function measure($label, $closure)
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::measure($label, $closure);
         }
         
         /**
-         * Retrieves the HTTP headers.
+         * Collect data in a CLI request
          *
          * @return array 
          * @static 
-         */
-        public static function getHttpHeaders(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getHttpHeaders();
+         */ 
+        public static function collectConsole()
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::collectConsole();
         }
         
         /**
-         * Retrieves a particular header. If it doesn't exist, no exception/error is caused.
+         * Adds a message to the MessagesCollector
          * 
-         * Simply null is returned.
+         * A message can be anything from an object to a string
          *
-         * @param string $header The name of the header to retrieve. Can be HTTP compliant such as
-         *                       "User-Agent" or "X-Device-User-Agent" or can be php-esque with the
-         *                       all-caps, HTTP_ prefixed, underscore seperated awesomeness.
-         * @return string|null The value of the header.
+         * @param mixed $message
+         * @param string $label
          * @static 
-         */
-        public static function getHttpHeader($header){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getHttpHeader($header);
+         */ 
+        public static function addMessage($message, $label = 'info')
+        {
+            return \Barryvdh\Debugbar\LaravelDebugbar::addMessage($message, $label);
         }
         
         /**
-         * 
+         * Checks if a data collector has been added
          *
+         * @param string $name
+         * @return boolean 
          * @static 
-         */
-        public static function getMobileHeaders(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getMobileHeaders();
+         */ 
+        public static function hasCollector($name)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::hasCollector($name);
         }
         
         /**
-         * Get all possible HTTP headers that
-         * can contain the User-Agent string.
+         * Returns a data collector
          *
-         * @return array List of HTTP headers.
+         * @param string $name
+         * @return \DebugBar\DataCollectorInterface 
+         * @throws DebugBarException
          * @static 
-         */
-        public static function getUaHttpHeaders(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getUaHttpHeaders();
+         */ 
+        public static function getCollector($name)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getCollector($name);
         }
         
         /**
-         * Set CloudFront headers
-         * http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-device
+         * Returns an array of all data collectors
          *
-         * @param array $cfHeaders List of HTTP headers
-         * @return boolean If there were CloudFront headers to be set
+         * @return \DebugBar\array[DataCollectorInterface] 
          * @static 
-         */
-        public static function setCfHeaders($cfHeaders = null){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::setCfHeaders($cfHeaders);
+         */ 
+        public static function getCollectors()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getCollectors();
         }
         
         /**
-         * Retrieves the cloudfront headers.
+         * Sets the request id generator
          *
-         * @return array 
+         * @param \DebugBar\RequestIdGeneratorInterface $generator
+         * @return $this 
          * @static 
-         */
-        public static function getCfHeaders(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getCfHeaders();
+         */ 
+        public static function setRequestIdGenerator($generator)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::setRequestIdGenerator($generator);
         }
         
         /**
-         * Set the User-Agent to be used.
+         * 
          *
-         * @param string $userAgent The user agent string to set.
-         * @return string|null 
+         * @return \DebugBar\RequestIdGeneratorInterface 
          * @static 
-         */
-        public static function setUserAgent($userAgent = null){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::setUserAgent($userAgent);
+         */ 
+        public static function getRequestIdGenerator()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getRequestIdGenerator();
         }
         
         /**
-         * Retrieve the User-Agent.
+         * Returns the id of the current request
          *
-         * @return string|null The user agent if it's set.
+         * @return string 
          * @static 
-         */
-        public static function getUserAgent(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getUserAgent();
+         */ 
+        public static function getCurrentRequestId()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getCurrentRequestId();
         }
         
         /**
-         * Set the detection type. Must be one of self::DETECTION_TYPE_MOBILE or
-         * self::DETECTION_TYPE_EXTENDED. Otherwise, nothing is set.
+         * Sets the storage backend to use to store the collected data
          *
-         * @deprecated since version 2.6.9
-         * @param string $type The type. Must be a self::DETECTION_TYPE_* constant. The default
-         *                     parameter is null which will default to self::DETECTION_TYPE_MOBILE.
+         * @param \DebugBar\StorageInterface $storage
+         * @return $this 
          * @static 
-         */
-        public static function setDetectionType($type = null){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::setDetectionType($type);
+         */ 
+        public static function setStorage($storage = null)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::setStorage($storage);
         }
         
         /**
          * 
          *
+         * @return \DebugBar\StorageInterface 
          * @static 
-         */
-        public static function getMatchingRegex(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getMatchingRegex();
+         */ 
+        public static function getStorage()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getStorage();
         }
         
         /**
-         * 
+         * Checks if the data will be persisted
          *
+         * @return boolean 
          * @static 
-         */
-        public static function getMatchesArray(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getMatchesArray();
+         */ 
+        public static function isDataPersisted()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::isDataPersisted();
         }
         
         /**
-         * Retrieve the list of known phone devices.
+         * Sets the HTTP driver
          *
-         * @return array List of phone devices.
+         * @param \DebugBar\HttpDriverInterface $driver
+         * @return $this 
          * @static 
-         */
-        public static function getPhoneDevices(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getPhoneDevices();
+         */ 
+        public static function setHttpDriver($driver)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::setHttpDriver($driver);
         }
         
         /**
-         * Retrieve the list of known tablet devices.
+         * Returns the HTTP driver
+         * 
+         * If no http driver where defined, a PhpHttpDriver is automatically created
          *
-         * @return array List of tablet devices.
+         * @return \DebugBar\HttpDriverInterface 
          * @static 
-         */
-        public static function getTabletDevices(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getTabletDevices();
+         */ 
+        public static function getHttpDriver()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getHttpDriver();
         }
         
         /**
-         * Alias for getBrowsers() method.
+         * Returns collected data
+         * 
+         * Will collect the data if none have been collected yet
          *
-         * @return array List of user agents.
+         * @return array 
          * @static 
-         */
-        public static function getUserAgents(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getUserAgents();
+         */ 
+        public static function getData()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getData();
         }
         
         /**
-         * Retrieve the list of known browsers. Specifically, the user agents.
+         * Returns an array of HTTP headers containing the data
          *
-         * @return array List of browsers / user agents.
+         * @param string $headerName
+         * @param integer $maxHeaderLength
+         * @return array 
          * @static 
-         */
-        public static function getBrowsers(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getBrowsers();
+         */ 
+        public static function getDataAsHeaders($headerName = 'phpdebugbar', $maxHeaderLength = 4096, $maxTotalHeaderLength = 250000)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getDataAsHeaders($headerName, $maxHeaderLength, $maxTotalHeaderLength);
         }
         
         /**
-         * Retrieve the list of known utilities.
+         * Sends the data through the HTTP headers
          *
-         * @return array List of utilities.
+         * @param bool $useOpenHandler
+         * @param string $headerName
+         * @param integer $maxHeaderLength
+         * @return $this 
          * @static 
-         */
-        public static function getUtilities(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getUtilities();
+         */ 
+        public static function sendDataInHeaders($useOpenHandler = null, $headerName = 'phpdebugbar', $maxHeaderLength = 4096)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::sendDataInHeaders($useOpenHandler, $headerName, $maxHeaderLength);
         }
         
         /**
-         * Method gets the mobile detection rules. This method is used for the magic methods $detect->is*().
+         * Stacks the data in the session for later rendering
          *
-         * @deprecated since version 2.6.9
-         * @return array All the rules (but not extended).
          * @static 
-         */
-        public static function getMobileDetectionRules(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getMobileDetectionRules();
+         */ 
+        public static function stackData()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::stackData();
         }
         
         /**
-         * Method gets the mobile detection rules + utilities.
-         * 
-         * The reason this is separate is because utilities rules
-         * don't necessary imply mobile. This method is used inside
-         * the new $detect->is('stuff') method.
+         * Checks if there is stacked data in the session
          *
-         * @deprecated since version 2.6.9
-         * @return array All the rules + extended.
+         * @return boolean 
          * @static 
-         */
-        public static function getMobileDetectionRulesExtended(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getMobileDetectionRulesExtended();
+         */ 
+        public static function hasStackedData()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::hasStackedData();
         }
         
         /**
-         * Retrieve the list of mobile operating systems.
+         * Returns the data stacked in the session
          *
-         * @return array The list of mobile operating systems.
+         * @param boolean $delete Whether to delete the data in the session
+         * @return array 
          * @static 
-         */
-        public static function getOperatingSystems(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getOperatingSystems();
+         */ 
+        public static function getStackedData($delete = true)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getStackedData($delete);
         }
         
         /**
-         * Check the HTTP headers for signs of mobile.
-         * 
-         * This is the fastest mobile check possible; it's used
-         * inside isMobile() method.
+         * Sets the key to use in the $_SESSION array
          *
-         * @return bool 
+         * @param string $ns
+         * @return $this 
          * @static 
-         */
-        public static function checkHttpHeadersForMobile(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::checkHttpHeadersForMobile();
+         */ 
+        public static function setStackDataSessionNamespace($ns)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::setStackDataSessionNamespace($ns);
         }
         
         /**
-         * Check if the device is mobile.
-         * 
-         * Returns true if any type of mobile device detected, including special ones
+         * Returns the key used in the $_SESSION array
          *
-         * @param null $userAgent deprecated
-         * @param null $httpHeaders deprecated
-         * @return bool 
+         * @return string 
          * @static 
-         */
-        public static function isMobile($userAgent = null, $httpHeaders = null){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::isMobile($userAgent, $httpHeaders);
+         */ 
+        public static function getStackDataSessionNamespace()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::getStackDataSessionNamespace();
         }
         
         /**
-         * Check if the device is a tablet.
-         * 
-         * Return true if any type of tablet device is detected.
+         * Sets whether to only use the session to store stacked data even
+         * if a storage is enabled
          *
-         * @param string $userAgent deprecated
-         * @param array $httpHeaders deprecated
-         * @return bool 
+         * @param boolean $enabled
+         * @return $this 
          * @static 
-         */
-        public static function isTablet($userAgent = null, $httpHeaders = null){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::isTablet($userAgent, $httpHeaders);
+         */ 
+        public static function setStackAlwaysUseSessionStorage($enabled = true)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::setStackAlwaysUseSessionStorage($enabled);
         }
         
         /**
-         * This method checks for a certain property in the
-         * userAgent.
+         * Checks if the session is always used to store stacked data
+         * even if a storage is enabled
          *
-         * @todo : The httpHeaders part is not yet used.
-         * @param string $key
-         * @param string $userAgent deprecated
-         * @param string $httpHeaders deprecated
-         * @return bool|int|null 
+         * @return boolean 
          * @static 
-         */
-        public static function is($key, $userAgent = null, $httpHeaders = null){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::is($key, $userAgent, $httpHeaders);
+         */ 
+        public static function isStackAlwaysUseSessionStorage()
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::isStackAlwaysUseSessionStorage();
         }
         
         /**
-         * Some detection rules are relative (not standard),
-         * because of the diversity of devices, vendors and
-         * their conventions in representing the User-Agent or
-         * the HTTP headers.
          * 
-         * This method will be used to check custom regexes against
-         * the User-Agent string.
          *
-         * @param $regex
-         * @param string $userAgent
-         * @return bool 
-         * @todo : search in the HTTP headers too.
          * @static 
-         */
-        public static function match($regex, $userAgent = null){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::match($regex, $userAgent);
+         */ 
+        public static function offsetSet($key, $value)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::offsetSet($key, $value);
         }
         
         /**
-         * Get the properties array.
+         * 
          *
-         * @return array 
          * @static 
-         */
-        public static function getProperties(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::getProperties();
+         */ 
+        public static function offsetGet($key)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::offsetGet($key);
         }
         
         /**
-         * Prepare the version number.
+         * 
          *
-         * @todo Remove the error supression from str_replace() call.
-         * @param string $ver The string version, like "2.6.21.2152";
-         * @return float 
          * @static 
-         */
-        public static function prepareVersionNo($ver){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::prepareVersionNo($ver);
+         */ 
+        public static function offsetExists($key)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::offsetExists($key);
         }
         
         /**
-         * Retrieve the mobile grading, using self::MOBILE_GRADE_* constants.
+         * 
          *
-         * @return string One of the self::MOBILE_GRADE_* constants.
          * @static 
-         */
-        public static function mobileGrade(){
-            //Method inherited from \Mobile_Detect            
-            return \Jenssegers\Agent\Agent::mobileGrade();
+         */ 
+        public static function offsetUnset($key)
+        {
+            //Method inherited from \DebugBar\DebugBar            
+            return \Barryvdh\Debugbar\LaravelDebugbar::offsetUnset($key);
         }
-        
+         
     }
+ 
+}
+
+
+namespace  { 
+
+    class App extends \Illuminate\Support\Facades\App {}
+
+    class Artisan extends \Illuminate\Support\Facades\Artisan {}
+
+    class Auth extends \Illuminate\Support\Facades\Auth {}
+
+    class Blade extends \Illuminate\Support\Facades\Blade {}
+
+    class Bus extends \Illuminate\Support\Facades\Bus {}
+
+    class Cache extends \Illuminate\Support\Facades\Cache {}
+
+    class Config extends \Illuminate\Support\Facades\Config {}
+
+    class Cookie extends \Illuminate\Support\Facades\Cookie {}
+
+    class Crypt extends \Illuminate\Support\Facades\Crypt {}
+
+    class DB extends \Illuminate\Support\Facades\DB {}
+
+    class Eloquent extends \Illuminate\Database\Eloquent\Model {         
+            /**
+             * Create and return an un-saved model instance.
+             *
+             * @param array $attributes
+             * @return \Illuminate\Database\Eloquent\Model 
+             * @static 
+             */ 
+            public static function make($attributes = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::make($attributes);
+            }
+         
+            /**
+             * Register a new global scope.
+             *
+             * @param string $identifier
+             * @param \Illuminate\Database\Eloquent\Scope|\Closure $scope
+             * @return $this 
+             * @static 
+             */ 
+            public static function withGlobalScope($identifier, $scope)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::withGlobalScope($identifier, $scope);
+            }
+         
+            /**
+             * Remove a registered global scope.
+             *
+             * @param \Illuminate\Database\Eloquent\Scope|string $scope
+             * @return $this 
+             * @static 
+             */ 
+            public static function withoutGlobalScope($scope)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::withoutGlobalScope($scope);
+            }
+         
+            /**
+             * Remove all or passed registered global scopes.
+             *
+             * @param array|null $scopes
+             * @return $this 
+             * @static 
+             */ 
+            public static function withoutGlobalScopes($scopes = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::withoutGlobalScopes($scopes);
+            }
+         
+            /**
+             * Get an array of global scopes that were removed from the query.
+             *
+             * @return array 
+             * @static 
+             */ 
+            public static function removedScopes()
+            {    
+                return \Illuminate\Database\Eloquent\Builder::removedScopes();
+            }
+         
+            /**
+             * Add a where clause on the primary key to the query.
+             *
+             * @param mixed $id
+             * @return $this 
+             * @static 
+             */ 
+            public static function whereKey($id)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::whereKey($id);
+            }
+         
+            /**
+             * Add a where clause on the primary key to the query.
+             *
+             * @param mixed $id
+             * @return $this 
+             * @static 
+             */ 
+            public static function whereKeyNot($id)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::whereKeyNot($id);
+            }
+         
+            /**
+             * Add a basic where clause to the query.
+             *
+             * @param string|array|\Closure $column
+             * @param string $operator
+             * @param mixed $value
+             * @param string $boolean
+             * @return $this 
+             * @static 
+             */ 
+            public static function where($column, $operator = null, $value = null, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Eloquent\Builder::where($column, $operator, $value, $boolean);
+            }
+         
+            /**
+             * Add an "or where" clause to the query.
+             *
+             * @param \Closure|array|string $column
+             * @param string $operator
+             * @param mixed $value
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function orWhere($column, $operator = null, $value = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::orWhere($column, $operator, $value);
+            }
+         
+            /**
+             * Create a collection of models from plain arrays.
+             *
+             * @param array $items
+             * @return \Illuminate\Database\Eloquent\Collection 
+             * @static 
+             */ 
+            public static function hydrate($items)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::hydrate($items);
+            }
+         
+            /**
+             * Create a collection of models from a raw query.
+             *
+             * @param string $query
+             * @param array $bindings
+             * @return \Illuminate\Database\Eloquent\Collection 
+             * @static 
+             */ 
+            public static function fromQuery($query, $bindings = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::fromQuery($query, $bindings);
+            }
+         
+            /**
+             * Find a model by its primary key.
+             *
+             * @param mixed $id
+             * @param array $columns
+             * @return \Illuminate\Database\Eloquent\Model|\Illuminate\Database\Eloquent\Collection|static[]|static|null 
+             * @static 
+             */ 
+            public static function find($id, $columns = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::find($id, $columns);
+            }
+         
+            /**
+             * Find multiple models by their primary keys.
+             *
+             * @param \Illuminate\Contracts\Support\Arrayable|array $ids
+             * @param array $columns
+             * @return \Illuminate\Database\Eloquent\Collection 
+             * @static 
+             */ 
+            public static function findMany($ids, $columns = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::findMany($ids, $columns);
+            }
+         
+            /**
+             * Find a model by its primary key or throw an exception.
+             *
+             * @param mixed $id
+             * @param array $columns
+             * @return \Illuminate\Database\Eloquent\Model|\Illuminate\Database\Eloquent\Collection 
+             * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
+             * @static 
+             */ 
+            public static function findOrFail($id, $columns = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::findOrFail($id, $columns);
+            }
+         
+            /**
+             * Find a model by its primary key or return fresh model instance.
+             *
+             * @param mixed $id
+             * @param array $columns
+             * @return \Illuminate\Database\Eloquent\Model 
+             * @static 
+             */ 
+            public static function findOrNew($id, $columns = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::findOrNew($id, $columns);
+            }
+         
+            /**
+             * Get the first record matching the attributes or instantiate it.
+             *
+             * @param array $attributes
+             * @param array $values
+             * @return \Illuminate\Database\Eloquent\Model 
+             * @static 
+             */ 
+            public static function firstOrNew($attributes, $values = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::firstOrNew($attributes, $values);
+            }
+         
+            /**
+             * Get the first record matching the attributes or create it.
+             *
+             * @param array $attributes
+             * @param array $values
+             * @return \Illuminate\Database\Eloquent\Model 
+             * @static 
+             */ 
+            public static function firstOrCreate($attributes, $values = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::firstOrCreate($attributes, $values);
+            }
+         
+            /**
+             * Create or update a record matching the attributes, and fill it with values.
+             *
+             * @param array $attributes
+             * @param array $values
+             * @return \Illuminate\Database\Eloquent\Model 
+             * @static 
+             */ 
+            public static function updateOrCreate($attributes, $values = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::updateOrCreate($attributes, $values);
+            }
+         
+            /**
+             * Execute the query and get the first result or throw an exception.
+             *
+             * @param array $columns
+             * @return \Illuminate\Database\Eloquent\Model|static 
+             * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
+             * @static 
+             */ 
+            public static function firstOrFail($columns = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::firstOrFail($columns);
+            }
+         
+            /**
+             * Execute the query and get the first result or call a callback.
+             *
+             * @param \Closure|array $columns
+             * @param \Closure|null $callback
+             * @return \Illuminate\Database\Eloquent\Model|static|mixed 
+             * @static 
+             */ 
+            public static function firstOr($columns = array(), $callback = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::firstOr($columns, $callback);
+            }
+         
+            /**
+             * Get a single column's value from the first result of a query.
+             *
+             * @param string $column
+             * @return mixed 
+             * @static 
+             */ 
+            public static function value($column)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::value($column);
+            }
+         
+            /**
+             * Execute the query as a "select" statement.
+             *
+             * @param array $columns
+             * @return \Illuminate\Database\Eloquent\Collection|static[] 
+             * @static 
+             */ 
+            public static function get($columns = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::get($columns);
+            }
+         
+            /**
+             * Get the hydrated models without eager loading.
+             *
+             * @param array $columns
+             * @return \Illuminate\Database\Eloquent\Model[] 
+             * @static 
+             */ 
+            public static function getModels($columns = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::getModels($columns);
+            }
+         
+            /**
+             * Eager load the relationships for the models.
+             *
+             * @param array $models
+             * @return array 
+             * @static 
+             */ 
+            public static function eagerLoadRelations($models)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::eagerLoadRelations($models);
+            }
+         
+            /**
+             * Get a generator for the given query.
+             *
+             * @return \Generator 
+             * @static 
+             */ 
+            public static function cursor()
+            {    
+                return \Illuminate\Database\Eloquent\Builder::cursor();
+            }
+         
+            /**
+             * Chunk the results of a query by comparing numeric IDs.
+             *
+             * @param int $count
+             * @param callable $callback
+             * @param string $column
+             * @param string|null $alias
+             * @return bool 
+             * @static 
+             */ 
+            public static function chunkById($count, $callback, $column = null, $alias = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::chunkById($count, $callback, $column, $alias);
+            }
+         
+            /**
+             * Get an array with the values of a given column.
+             *
+             * @param string $column
+             * @param string|null $key
+             * @return \Illuminate\Support\Collection 
+             * @static 
+             */ 
+            public static function pluck($column, $key = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::pluck($column, $key);
+            }
+         
+            /**
+             * Paginate the given query.
+             *
+             * @param int $perPage
+             * @param array $columns
+             * @param string $pageName
+             * @param int|null $page
+             * @return \Illuminate\Contracts\Pagination\LengthAwarePaginator 
+             * @throws \InvalidArgumentException
+             * @static 
+             */ 
+            public static function paginate($perPage = null, $columns = array(), $pageName = 'page', $page = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::paginate($perPage, $columns, $pageName, $page);
+            }
+         
+            /**
+             * Paginate the given query into a simple paginator.
+             *
+             * @param int $perPage
+             * @param array $columns
+             * @param string $pageName
+             * @param int|null $page
+             * @return \Illuminate\Contracts\Pagination\Paginator 
+             * @static 
+             */ 
+            public static function simplePaginate($perPage = null, $columns = array(), $pageName = 'page', $page = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::simplePaginate($perPage, $columns, $pageName, $page);
+            }
+         
+            /**
+             * Save a new model and return the instance.
+             *
+             * @param array $attributes
+             * @return \Illuminate\Database\Eloquent\Model|$this 
+             * @static 
+             */ 
+            public static function create($attributes = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::create($attributes);
+            }
+         
+            /**
+             * Save a new model and return the instance. Allow mass-assignment.
+             *
+             * @param array $attributes
+             * @return \Illuminate\Database\Eloquent\Model|$this 
+             * @static 
+             */ 
+            public static function forceCreate($attributes)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::forceCreate($attributes);
+            }
+         
+            /**
+             * Register a replacement for the default delete function.
+             *
+             * @param \Closure $callback
+             * @return void 
+             * @static 
+             */ 
+            public static function onDelete($callback)
+            {    
+                \Illuminate\Database\Eloquent\Builder::onDelete($callback);
+            }
+         
+            /**
+             * Call the given local model scopes.
+             *
+             * @param array $scopes
+             * @return mixed 
+             * @static 
+             */ 
+            public static function scopes($scopes)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::scopes($scopes);
+            }
+         
+            /**
+             * Apply the scopes to the Eloquent builder instance and return it.
+             *
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function applyScopes()
+            {    
+                return \Illuminate\Database\Eloquent\Builder::applyScopes();
+            }
+         
+            /**
+             * Prevent the specified relations from being eager loaded.
+             *
+             * @param mixed $relations
+             * @return $this 
+             * @static 
+             */ 
+            public static function without($relations)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::without($relations);
+            }
+         
+            /**
+             * Create a new instance of the model being queried.
+             *
+             * @param array $attributes
+             * @return \Illuminate\Database\Eloquent\Model 
+             * @static 
+             */ 
+            public static function newModelInstance($attributes = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::newModelInstance($attributes);
+            }
+         
+            /**
+             * Get the underlying query builder instance.
+             *
+             * @return \Illuminate\Database\Query\Builder 
+             * @static 
+             */ 
+            public static function getQuery()
+            {    
+                return \Illuminate\Database\Eloquent\Builder::getQuery();
+            }
+         
+            /**
+             * Set the underlying query builder instance.
+             *
+             * @param \Illuminate\Database\Query\Builder $query
+             * @return $this 
+             * @static 
+             */ 
+            public static function setQuery($query)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::setQuery($query);
+            }
+         
+            /**
+             * Get a base query builder instance.
+             *
+             * @return \Illuminate\Database\Query\Builder 
+             * @static 
+             */ 
+            public static function toBase()
+            {    
+                return \Illuminate\Database\Eloquent\Builder::toBase();
+            }
+         
+            /**
+             * Get the relationships being eagerly loaded.
+             *
+             * @return array 
+             * @static 
+             */ 
+            public static function getEagerLoads()
+            {    
+                return \Illuminate\Database\Eloquent\Builder::getEagerLoads();
+            }
+         
+            /**
+             * Set the relationships being eagerly loaded.
+             *
+             * @param array $eagerLoad
+             * @return $this 
+             * @static 
+             */ 
+            public static function setEagerLoads($eagerLoad)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::setEagerLoads($eagerLoad);
+            }
+         
+            /**
+             * Get the model instance being queried.
+             *
+             * @return \Illuminate\Database\Eloquent\Model 
+             * @static 
+             */ 
+            public static function getModel()
+            {    
+                return \Illuminate\Database\Eloquent\Builder::getModel();
+            }
+         
+            /**
+             * Set a model instance for the model being queried.
+             *
+             * @param \Illuminate\Database\Eloquent\Model $model
+             * @return $this 
+             * @static 
+             */ 
+            public static function setModel($model)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::setModel($model);
+            }
+         
+            /**
+             * Get the given macro by name.
+             *
+             * @param string $name
+             * @return \Closure 
+             * @static 
+             */ 
+            public static function getMacro($name)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::getMacro($name);
+            }
+         
+            /**
+             * Chunk the results of the query.
+             *
+             * @param int $count
+             * @param callable $callback
+             * @return bool 
+             * @static 
+             */ 
+            public static function chunk($count, $callback)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::chunk($count, $callback);
+            }
+         
+            /**
+             * Execute a callback over each item while chunking.
+             *
+             * @param callable $callback
+             * @param int $count
+             * @return bool 
+             * @static 
+             */ 
+            public static function each($callback, $count = 1000)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::each($callback, $count);
+            }
+         
+            /**
+             * Execute the query and get the first result.
+             *
+             * @param array $columns
+             * @return \Illuminate\Database\Eloquent\Model|object|static|null 
+             * @static 
+             */ 
+            public static function first($columns = array())
+            {    
+                return \Illuminate\Database\Eloquent\Builder::first($columns);
+            }
+         
+            /**
+             * Apply the callback's query changes if the given "value" is true.
+             *
+             * @param mixed $value
+             * @param callable $callback
+             * @param callable $default
+             * @return mixed 
+             * @static 
+             */ 
+            public static function when($value, $callback, $default = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::when($value, $callback, $default);
+            }
+         
+            /**
+             * Pass the query to a given callback.
+             *
+             * @param \Closure $callback
+             * @return \Illuminate\Database\Query\Builder 
+             * @static 
+             */ 
+            public static function tap($callback)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::tap($callback);
+            }
+         
+            /**
+             * Apply the callback's query changes if the given "value" is false.
+             *
+             * @param mixed $value
+             * @param callable $callback
+             * @param callable $default
+             * @return mixed 
+             * @static 
+             */ 
+            public static function unless($value, $callback, $default = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::unless($value, $callback, $default);
+            }
+         
+            /**
+             * Add a relationship count / exists condition to the query.
+             *
+             * @param string $relation
+             * @param string $operator
+             * @param int $count
+             * @param string $boolean
+             * @param \Closure|null $callback
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function has($relation, $operator = '>=', $count = 1, $boolean = 'and', $callback = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::has($relation, $operator, $count, $boolean, $callback);
+            }
+         
+            /**
+             * Add a relationship count / exists condition to the query with an "or".
+             *
+             * @param string $relation
+             * @param string $operator
+             * @param int $count
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function orHas($relation, $operator = '>=', $count = 1)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::orHas($relation, $operator, $count);
+            }
+         
+            /**
+             * Add a relationship count / exists condition to the query.
+             *
+             * @param string $relation
+             * @param string $boolean
+             * @param \Closure|null $callback
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function doesntHave($relation, $boolean = 'and', $callback = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::doesntHave($relation, $boolean, $callback);
+            }
+         
+            /**
+             * Add a relationship count / exists condition to the query with an "or".
+             *
+             * @param string $relation
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function orDoesntHave($relation)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::orDoesntHave($relation);
+            }
+         
+            /**
+             * Add a relationship count / exists condition to the query with where clauses.
+             *
+             * @param string $relation
+             * @param \Closure|null $callback
+             * @param string $operator
+             * @param int $count
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function whereHas($relation, $callback = null, $operator = '>=', $count = 1)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::whereHas($relation, $callback, $operator, $count);
+            }
+         
+            /**
+             * Add a relationship count / exists condition to the query with where clauses and an "or".
+             *
+             * @param string $relation
+             * @param \Closure $callback
+             * @param string $operator
+             * @param int $count
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereHas($relation, $callback = null, $operator = '>=', $count = 1)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::orWhereHas($relation, $callback, $operator, $count);
+            }
+         
+            /**
+             * Add a relationship count / exists condition to the query with where clauses.
+             *
+             * @param string $relation
+             * @param \Closure|null $callback
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function whereDoesntHave($relation, $callback = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::whereDoesntHave($relation, $callback);
+            }
+         
+            /**
+             * Add a relationship count / exists condition to the query with where clauses and an "or".
+             *
+             * @param string $relation
+             * @param \Closure $callback
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereDoesntHave($relation, $callback = null)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::orWhereDoesntHave($relation, $callback);
+            }
+         
+            /**
+             * Add subselect queries to count the relations.
+             *
+             * @param mixed $relations
+             * @return $this 
+             * @static 
+             */ 
+            public static function withCount($relations)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::withCount($relations);
+            }
+         
+            /**
+             * Merge the where constraints from another query to the current query.
+             *
+             * @param \Illuminate\Database\Eloquent\Builder $from
+             * @return \Illuminate\Database\Eloquent\Builder|static 
+             * @static 
+             */ 
+            public static function mergeConstraintsFrom($from)
+            {    
+                return \Illuminate\Database\Eloquent\Builder::mergeConstraintsFrom($from);
+            }
+         
+            /**
+             * Set the columns to be selected.
+             *
+             * @param array|mixed $columns
+             * @return $this 
+             * @static 
+             */ 
+            public static function select($columns = array())
+            {    
+                return \Illuminate\Database\Query\Builder::select($columns);
+            }
+         
+            /**
+             * Add a new "raw" select expression to the query.
+             *
+             * @param string $expression
+             * @param array $bindings
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function selectRaw($expression, $bindings = array())
+            {    
+                return \Illuminate\Database\Query\Builder::selectRaw($expression, $bindings);
+            }
+         
+            /**
+             * Add a subselect expression to the query.
+             *
+             * @param \Closure|\Illuminate\Database\Query\Builder|string $query
+             * @param string $as
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @throws \InvalidArgumentException
+             * @static 
+             */ 
+            public static function selectSub($query, $as)
+            {    
+                return \Illuminate\Database\Query\Builder::selectSub($query, $as);
+            }
+         
+            /**
+             * Add a new select column to the query.
+             *
+             * @param array|mixed $column
+             * @return $this 
+             * @static 
+             */ 
+            public static function addSelect($column)
+            {    
+                return \Illuminate\Database\Query\Builder::addSelect($column);
+            }
+         
+            /**
+             * Force the query to only return distinct results.
+             *
+             * @return $this 
+             * @static 
+             */ 
+            public static function distinct()
+            {    
+                return \Illuminate\Database\Query\Builder::distinct();
+            }
+         
+            /**
+             * Set the table which the query is targeting.
+             *
+             * @param string $table
+             * @return $this 
+             * @static 
+             */ 
+            public static function from($table)
+            {    
+                return \Illuminate\Database\Query\Builder::from($table);
+            }
+         
+            /**
+             * Add a join clause to the query.
+             *
+             * @param string $table
+             * @param string $first
+             * @param string|null $operator
+             * @param string|null $second
+             * @param string $type
+             * @param bool $where
+             * @return $this 
+             * @static 
+             */ 
+            public static function join($table, $first, $operator = null, $second = null, $type = 'inner', $where = false)
+            {    
+                return \Illuminate\Database\Query\Builder::join($table, $first, $operator, $second, $type, $where);
+            }
+         
+            /**
+             * Add a "join where" clause to the query.
+             *
+             * @param string $table
+             * @param string $first
+             * @param string $operator
+             * @param string $second
+             * @param string $type
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function joinWhere($table, $first, $operator, $second, $type = 'inner')
+            {    
+                return \Illuminate\Database\Query\Builder::joinWhere($table, $first, $operator, $second, $type);
+            }
+         
+            /**
+             * Add a left join to the query.
+             *
+             * @param string $table
+             * @param string $first
+             * @param string|null $operator
+             * @param string|null $second
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function leftJoin($table, $first, $operator = null, $second = null)
+            {    
+                return \Illuminate\Database\Query\Builder::leftJoin($table, $first, $operator, $second);
+            }
+         
+            /**
+             * Add a "join where" clause to the query.
+             *
+             * @param string $table
+             * @param string $first
+             * @param string $operator
+             * @param string $second
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function leftJoinWhere($table, $first, $operator, $second)
+            {    
+                return \Illuminate\Database\Query\Builder::leftJoinWhere($table, $first, $operator, $second);
+            }
+         
+            /**
+             * Add a right join to the query.
+             *
+             * @param string $table
+             * @param string $first
+             * @param string|null $operator
+             * @param string|null $second
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function rightJoin($table, $first, $operator = null, $second = null)
+            {    
+                return \Illuminate\Database\Query\Builder::rightJoin($table, $first, $operator, $second);
+            }
+         
+            /**
+             * Add a "right join where" clause to the query.
+             *
+             * @param string $table
+             * @param string $first
+             * @param string $operator
+             * @param string $second
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function rightJoinWhere($table, $first, $operator, $second)
+            {    
+                return \Illuminate\Database\Query\Builder::rightJoinWhere($table, $first, $operator, $second);
+            }
+         
+            /**
+             * Add a "cross join" clause to the query.
+             *
+             * @param string $table
+             * @param string|null $first
+             * @param string|null $operator
+             * @param string|null $second
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function crossJoin($table, $first = null, $operator = null, $second = null)
+            {    
+                return \Illuminate\Database\Query\Builder::crossJoin($table, $first, $operator, $second);
+            }
+         
+            /**
+             * Merge an array of where clauses and bindings.
+             *
+             * @param array $wheres
+             * @param array $bindings
+             * @return void 
+             * @static 
+             */ 
+            public static function mergeWheres($wheres, $bindings)
+            {    
+                \Illuminate\Database\Query\Builder::mergeWheres($wheres, $bindings);
+            }
+         
+            /**
+             * Prepare the value and operator for a where clause.
+             *
+             * @param string $value
+             * @param string $operator
+             * @param bool $useDefault
+             * @return array 
+             * @throws \InvalidArgumentException
+             * @static 
+             */ 
+            public static function prepareValueAndOperator($value, $operator, $useDefault = false)
+            {    
+                return \Illuminate\Database\Query\Builder::prepareValueAndOperator($value, $operator, $useDefault);
+            }
+         
+            /**
+             * Add a "where" clause comparing two columns to the query.
+             *
+             * @param string|array $first
+             * @param string|null $operator
+             * @param string|null $second
+             * @param string|null $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereColumn($first, $operator = null, $second = null, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereColumn($first, $operator, $second, $boolean);
+            }
+         
+            /**
+             * Add an "or where" clause comparing two columns to the query.
+             *
+             * @param string|array $first
+             * @param string|null $operator
+             * @param string|null $second
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereColumn($first, $operator = null, $second = null)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereColumn($first, $operator, $second);
+            }
+         
+            /**
+             * Add a raw where clause to the query.
+             *
+             * @param string $sql
+             * @param mixed $bindings
+             * @param string $boolean
+             * @return $this 
+             * @static 
+             */ 
+            public static function whereRaw($sql, $bindings = array(), $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereRaw($sql, $bindings, $boolean);
+            }
+         
+            /**
+             * Add a raw or where clause to the query.
+             *
+             * @param string $sql
+             * @param mixed $bindings
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereRaw($sql, $bindings = array())
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereRaw($sql, $bindings);
+            }
+         
+            /**
+             * Add a "where in" clause to the query.
+             *
+             * @param string $column
+             * @param mixed $values
+             * @param string $boolean
+             * @param bool $not
+             * @return $this 
+             * @static 
+             */ 
+            public static function whereIn($column, $values, $boolean = 'and', $not = false)
+            {    
+                return \Illuminate\Database\Query\Builder::whereIn($column, $values, $boolean, $not);
+            }
+         
+            /**
+             * Add an "or where in" clause to the query.
+             *
+             * @param string $column
+             * @param mixed $values
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereIn($column, $values)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereIn($column, $values);
+            }
+         
+            /**
+             * Add a "where not in" clause to the query.
+             *
+             * @param string $column
+             * @param mixed $values
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereNotIn($column, $values, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereNotIn($column, $values, $boolean);
+            }
+         
+            /**
+             * Add an "or where not in" clause to the query.
+             *
+             * @param string $column
+             * @param mixed $values
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereNotIn($column, $values)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereNotIn($column, $values);
+            }
+         
+            /**
+             * Add a "where null" clause to the query.
+             *
+             * @param string $column
+             * @param string $boolean
+             * @param bool $not
+             * @return $this 
+             * @static 
+             */ 
+            public static function whereNull($column, $boolean = 'and', $not = false)
+            {    
+                return \Illuminate\Database\Query\Builder::whereNull($column, $boolean, $not);
+            }
+         
+            /**
+             * Add an "or where null" clause to the query.
+             *
+             * @param string $column
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereNull($column)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereNull($column);
+            }
+         
+            /**
+             * Add a "where not null" clause to the query.
+             *
+             * @param string $column
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereNotNull($column, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereNotNull($column, $boolean);
+            }
+         
+            /**
+             * Add a where between statement to the query.
+             *
+             * @param string $column
+             * @param array $values
+             * @param string $boolean
+             * @param bool $not
+             * @return $this 
+             * @static 
+             */ 
+            public static function whereBetween($column, $values, $boolean = 'and', $not = false)
+            {    
+                return \Illuminate\Database\Query\Builder::whereBetween($column, $values, $boolean, $not);
+            }
+         
+            /**
+             * Add an or where between statement to the query.
+             *
+             * @param string $column
+             * @param array $values
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereBetween($column, $values)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereBetween($column, $values);
+            }
+         
+            /**
+             * Add a where not between statement to the query.
+             *
+             * @param string $column
+             * @param array $values
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereNotBetween($column, $values, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereNotBetween($column, $values, $boolean);
+            }
+         
+            /**
+             * Add an or where not between statement to the query.
+             *
+             * @param string $column
+             * @param array $values
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereNotBetween($column, $values)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereNotBetween($column, $values);
+            }
+         
+            /**
+             * Add an "or where not null" clause to the query.
+             *
+             * @param string $column
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereNotNull($column)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereNotNull($column);
+            }
+         
+            /**
+             * Add a "where date" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereDate($column, $operator, $value = null, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereDate($column, $operator, $value, $boolean);
+            }
+         
+            /**
+             * Add an "or where date" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param string $value
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereDate($column, $operator, $value)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereDate($column, $operator, $value);
+            }
+         
+            /**
+             * Add a "where time" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereTime($column, $operator, $value = null, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereTime($column, $operator, $value, $boolean);
+            }
+         
+            /**
+             * Add an "or where time" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereTime($column, $operator, $value = null)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereTime($column, $operator, $value);
+            }
+         
+            /**
+             * Add a "where day" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereDay($column, $operator, $value = null, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereDay($column, $operator, $value, $boolean);
+            }
+         
+            /**
+             * Add an "or where day" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereDay($column, $operator, $value = null)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereDay($column, $operator, $value);
+            }
+         
+            /**
+             * Add a "where month" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereMonth($column, $operator, $value = null, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereMonth($column, $operator, $value, $boolean);
+            }
+         
+            /**
+             * Add an "or where month" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereMonth($column, $operator, $value = null)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereMonth($column, $operator, $value);
+            }
+         
+            /**
+             * Add a "where year" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereYear($column, $operator, $value = null, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereYear($column, $operator, $value, $boolean);
+            }
+         
+            /**
+             * Add an "or where year" statement to the query.
+             *
+             * @param string $column
+             * @param string $operator
+             * @param mixed $value
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereYear($column, $operator, $value = null)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereYear($column, $operator, $value);
+            }
+         
+            /**
+             * Add a nested where statement to the query.
+             *
+             * @param \Closure $callback
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereNested($callback, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereNested($callback, $boolean);
+            }
+         
+            /**
+             * Create a new query instance for nested where condition.
+             *
+             * @return \Illuminate\Database\Query\Builder 
+             * @static 
+             */ 
+            public static function forNestedWhere()
+            {    
+                return \Illuminate\Database\Query\Builder::forNestedWhere();
+            }
+         
+            /**
+             * Add another query builder as a nested where to the query builder.
+             *
+             * @param \Illuminate\Database\Query\Builder|static $query
+             * @param string $boolean
+             * @return $this 
+             * @static 
+             */ 
+            public static function addNestedWhereQuery($query, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::addNestedWhereQuery($query, $boolean);
+            }
+         
+            /**
+             * Add an exists clause to the query.
+             *
+             * @param \Closure $callback
+             * @param string $boolean
+             * @param bool $not
+             * @return $this 
+             * @static 
+             */ 
+            public static function whereExists($callback, $boolean = 'and', $not = false)
+            {    
+                return \Illuminate\Database\Query\Builder::whereExists($callback, $boolean, $not);
+            }
+         
+            /**
+             * Add an or exists clause to the query.
+             *
+             * @param \Closure $callback
+             * @param bool $not
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereExists($callback, $not = false)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereExists($callback, $not);
+            }
+         
+            /**
+             * Add a where not exists clause to the query.
+             *
+             * @param \Closure $callback
+             * @param string $boolean
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function whereNotExists($callback, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereNotExists($callback, $boolean);
+            }
+         
+            /**
+             * Add a where not exists clause to the query.
+             *
+             * @param \Closure $callback
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orWhereNotExists($callback)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereNotExists($callback);
+            }
+         
+            /**
+             * Add an exists clause to the query.
+             *
+             * @param \Illuminate\Database\Query\Builder $query
+             * @param string $boolean
+             * @param bool $not
+             * @return $this 
+             * @static 
+             */ 
+            public static function addWhereExistsQuery($query, $boolean = 'and', $not = false)
+            {    
+                return \Illuminate\Database\Query\Builder::addWhereExistsQuery($query, $boolean, $not);
+            }
+         
+            /**
+             * Adds a where condition using row values.
+             *
+             * @param array $columns
+             * @param string $operator
+             * @param array $values
+             * @param string $boolean
+             * @return $this 
+             * @static 
+             */ 
+            public static function whereRowValues($columns, $operator, $values, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::whereRowValues($columns, $operator, $values, $boolean);
+            }
+         
+            /**
+             * Adds a or where condition using row values.
+             *
+             * @param array $columns
+             * @param string $operator
+             * @param array $values
+             * @return $this 
+             * @static 
+             */ 
+            public static function orWhereRowValues($columns, $operator, $values)
+            {    
+                return \Illuminate\Database\Query\Builder::orWhereRowValues($columns, $operator, $values);
+            }
+         
+            /**
+             * Handles dynamic "where" clauses to the query.
+             *
+             * @param string $method
+             * @param string $parameters
+             * @return $this 
+             * @static 
+             */ 
+            public static function dynamicWhere($method, $parameters)
+            {    
+                return \Illuminate\Database\Query\Builder::dynamicWhere($method, $parameters);
+            }
+         
+            /**
+             * Add a "group by" clause to the query.
+             *
+             * @param array $groups
+             * @return $this 
+             * @static 
+             */ 
+            public static function groupBy($groups = null)
+            {    
+                return \Illuminate\Database\Query\Builder::groupBy($groups);
+            }
+         
+            /**
+             * Add a "having" clause to the query.
+             *
+             * @param string $column
+             * @param string|null $operator
+             * @param string|null $value
+             * @param string $boolean
+             * @return $this 
+             * @static 
+             */ 
+            public static function having($column, $operator = null, $value = null, $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::having($column, $operator, $value, $boolean);
+            }
+         
+            /**
+             * Add a "or having" clause to the query.
+             *
+             * @param string $column
+             * @param string|null $operator
+             * @param string|null $value
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orHaving($column, $operator = null, $value = null)
+            {    
+                return \Illuminate\Database\Query\Builder::orHaving($column, $operator, $value);
+            }
+         
+            /**
+             * Add a raw having clause to the query.
+             *
+             * @param string $sql
+             * @param array $bindings
+             * @param string $boolean
+             * @return $this 
+             * @static 
+             */ 
+            public static function havingRaw($sql, $bindings = array(), $boolean = 'and')
+            {    
+                return \Illuminate\Database\Query\Builder::havingRaw($sql, $bindings, $boolean);
+            }
+         
+            /**
+             * Add a raw or having clause to the query.
+             *
+             * @param string $sql
+             * @param array $bindings
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function orHavingRaw($sql, $bindings = array())
+            {    
+                return \Illuminate\Database\Query\Builder::orHavingRaw($sql, $bindings);
+            }
+         
+            /**
+             * Add an "order by" clause to the query.
+             *
+             * @param string $column
+             * @param string $direction
+             * @return $this 
+             * @static 
+             */ 
+            public static function orderBy($column, $direction = 'asc')
+            {    
+                return \Illuminate\Database\Query\Builder::orderBy($column, $direction);
+            }
+         
+            /**
+             * Add a descending "order by" clause to the query.
+             *
+             * @param string $column
+             * @return $this 
+             * @static 
+             */ 
+            public static function orderByDesc($column)
+            {    
+                return \Illuminate\Database\Query\Builder::orderByDesc($column);
+            }
+         
+            /**
+             * Add an "order by" clause for a timestamp to the query.
+             *
+             * @param string $column
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function latest($column = 'created_at')
+            {    
+                return \Illuminate\Database\Query\Builder::latest($column);
+            }
+         
+            /**
+             * Add an "order by" clause for a timestamp to the query.
+             *
+             * @param string $column
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function oldest($column = 'created_at')
+            {    
+                return \Illuminate\Database\Query\Builder::oldest($column);
+            }
+         
+            /**
+             * Put the query's results in random order.
+             *
+             * @param string $seed
+             * @return $this 
+             * @static 
+             */ 
+            public static function inRandomOrder($seed = '')
+            {    
+                return \Illuminate\Database\Query\Builder::inRandomOrder($seed);
+            }
+         
+            /**
+             * Add a raw "order by" clause to the query.
+             *
+             * @param string $sql
+             * @param array $bindings
+             * @return $this 
+             * @static 
+             */ 
+            public static function orderByRaw($sql, $bindings = array())
+            {    
+                return \Illuminate\Database\Query\Builder::orderByRaw($sql, $bindings);
+            }
+         
+            /**
+             * Alias to set the "offset" value of the query.
+             *
+             * @param int $value
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function skip($value)
+            {    
+                return \Illuminate\Database\Query\Builder::skip($value);
+            }
+         
+            /**
+             * Set the "offset" value of the query.
+             *
+             * @param int $value
+             * @return $this 
+             * @static 
+             */ 
+            public static function offset($value)
+            {    
+                return \Illuminate\Database\Query\Builder::offset($value);
+            }
+         
+            /**
+             * Alias to set the "limit" value of the query.
+             *
+             * @param int $value
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function take($value)
+            {    
+                return \Illuminate\Database\Query\Builder::take($value);
+            }
+         
+            /**
+             * Set the "limit" value of the query.
+             *
+             * @param int $value
+             * @return $this 
+             * @static 
+             */ 
+            public static function limit($value)
+            {    
+                return \Illuminate\Database\Query\Builder::limit($value);
+            }
+         
+            /**
+             * Set the limit and offset for a given page.
+             *
+             * @param int $page
+             * @param int $perPage
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function forPage($page, $perPage = 15)
+            {    
+                return \Illuminate\Database\Query\Builder::forPage($page, $perPage);
+            }
+         
+            /**
+             * Constrain the query to the next "page" of results after a given ID.
+             *
+             * @param int $perPage
+             * @param int $lastId
+             * @param string $column
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function forPageAfterId($perPage = 15, $lastId = 0, $column = 'id')
+            {    
+                return \Illuminate\Database\Query\Builder::forPageAfterId($perPage, $lastId, $column);
+            }
+         
+            /**
+             * Add a union statement to the query.
+             *
+             * @param \Illuminate\Database\Query\Builder|\Closure $query
+             * @param bool $all
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function union($query, $all = false)
+            {    
+                return \Illuminate\Database\Query\Builder::union($query, $all);
+            }
+         
+            /**
+             * Add a union all statement to the query.
+             *
+             * @param \Illuminate\Database\Query\Builder|\Closure $query
+             * @return \Illuminate\Database\Query\Builder|static 
+             * @static 
+             */ 
+            public static function unionAll($query)
+            {    
+                return \Illuminate\Database\Query\Builder::unionAll($query);
+            }
+         
+            /**
+             * Lock the selected rows in the table.
+             *
+             * @param string|bool $value
+             * @return $this 
+             * @static 
+             */ 
+            public static function lock($value = true)
+            {    
+                return \Illuminate\Database\Query\Builder::lock($value);
+            }
+         
+            /**
+             * Lock the selected rows in the table for updating.
+             *
+             * @return \Illuminate\Database\Query\Builder 
+             * @static 
+             */ 
+            public static function lockForUpdate()
+            {    
+                return \Illuminate\Database\Query\Builder::lockForUpdate();
+            }
+         
+            /**
+             * Share lock the selected rows in the table.
+             *
+             * @return \Illuminate\Database\Query\Builder 
+             * @static 
+             */ 
+            public static function sharedLock()
+            {    
+                return \Illuminate\Database\Query\Builder::sharedLock();
+            }
+         
+            /**
+             * Get the SQL representation of the query.
+             *
+             * @return string 
+             * @static 
+             */ 
+            public static function toSql()
+            {    
+                return \Illuminate\Database\Query\Builder::toSql();
+            }
+         
+            /**
+             * Get the count of the total records for the paginator.
+             *
+             * @param array $columns
+             * @return int 
+             * @static 
+             */ 
+            public static function getCountForPagination($columns = array())
+            {    
+                return \Illuminate\Database\Query\Builder::getCountForPagination($columns);
+            }
+         
+            /**
+             * Concatenate values of a given column as a string.
+             *
+             * @param string $column
+             * @param string $glue
+             * @return string 
+             * @static 
+             */ 
+            public static function implode($column, $glue = '')
+            {    
+                return \Illuminate\Database\Query\Builder::implode($column, $glue);
+            }
+         
+            /**
+             * Determine if any rows exist for the current query.
+             *
+             * @return bool 
+             * @static 
+             */ 
+            public static function exists()
+            {    
+                return \Illuminate\Database\Query\Builder::exists();
+            }
+         
+            /**
+             * Determine if no rows exist for the current query.
+             *
+             * @return bool 
+             * @static 
+             */ 
+            public static function doesntExist()
+            {    
+                return \Illuminate\Database\Query\Builder::doesntExist();
+            }
+         
+            /**
+             * Retrieve the "count" result of the query.
+             *
+             * @param string $columns
+             * @return int 
+             * @static 
+             */ 
+            public static function count($columns = '*')
+            {    
+                return \Illuminate\Database\Query\Builder::count($columns);
+            }
+         
+            /**
+             * Retrieve the minimum value of a given column.
+             *
+             * @param string $column
+             * @return mixed 
+             * @static 
+             */ 
+            public static function min($column)
+            {    
+                return \Illuminate\Database\Query\Builder::min($column);
+            }
+         
+            /**
+             * Retrieve the maximum value of a given column.
+             *
+             * @param string $column
+             * @return mixed 
+             * @static 
+             */ 
+            public static function max($column)
+            {    
+                return \Illuminate\Database\Query\Builder::max($column);
+            }
+         
+            /**
+             * Retrieve the sum of the values of a given column.
+             *
+             * @param string $column
+             * @return mixed 
+             * @static 
+             */ 
+            public static function sum($column)
+            {    
+                return \Illuminate\Database\Query\Builder::sum($column);
+            }
+         
+            /**
+             * Retrieve the average of the values of a given column.
+             *
+             * @param string $column
+             * @return mixed 
+             * @static 
+             */ 
+            public static function avg($column)
+            {    
+                return \Illuminate\Database\Query\Builder::avg($column);
+            }
+         
+            /**
+             * Alias for the "avg" method.
+             *
+             * @param string $column
+             * @return mixed 
+             * @static 
+             */ 
+            public static function average($column)
+            {    
+                return \Illuminate\Database\Query\Builder::average($column);
+            }
+         
+            /**
+             * Execute an aggregate function on the database.
+             *
+             * @param string $function
+             * @param array $columns
+             * @return mixed 
+             * @static 
+             */ 
+            public static function aggregate($function, $columns = array())
+            {    
+                return \Illuminate\Database\Query\Builder::aggregate($function, $columns);
+            }
+         
+            /**
+             * Execute a numeric aggregate function on the database.
+             *
+             * @param string $function
+             * @param array $columns
+             * @return float|int 
+             * @static 
+             */ 
+            public static function numericAggregate($function, $columns = array())
+            {    
+                return \Illuminate\Database\Query\Builder::numericAggregate($function, $columns);
+            }
+         
+            /**
+             * Insert a new record into the database.
+             *
+             * @param array $values
+             * @return bool 
+             * @static 
+             */ 
+            public static function insert($values)
+            {    
+                return \Illuminate\Database\Query\Builder::insert($values);
+            }
+         
+            /**
+             * Insert a new record and get the value of the primary key.
+             *
+             * @param array $values
+             * @param string|null $sequence
+             * @return int 
+             * @static 
+             */ 
+            public static function insertGetId($values, $sequence = null)
+            {    
+                return \Illuminate\Database\Query\Builder::insertGetId($values, $sequence);
+            }
+         
+            /**
+             * Insert or update a record matching the attributes, and fill it with values.
+             *
+             * @param array $attributes
+             * @param array $values
+             * @return bool 
+             * @static 
+             */ 
+            public static function updateOrInsert($attributes, $values = array())
+            {    
+                return \Illuminate\Database\Query\Builder::updateOrInsert($attributes, $values);
+            }
+         
+            /**
+             * Run a truncate statement on the table.
+             *
+             * @return void 
+             * @static 
+             */ 
+            public static function truncate()
+            {    
+                \Illuminate\Database\Query\Builder::truncate();
+            }
+         
+            /**
+             * Create a raw database expression.
+             *
+             * @param mixed $value
+             * @return \Illuminate\Database\Query\Expression 
+             * @static 
+             */ 
+            public static function raw($value)
+            {    
+                return \Illuminate\Database\Query\Builder::raw($value);
+            }
+         
+            /**
+             * Get the current query value bindings in a flattened array.
+             *
+             * @return array 
+             * @static 
+             */ 
+            public static function getBindings()
+            {    
+                return \Illuminate\Database\Query\Builder::getBindings();
+            }
+         
+            /**
+             * Get the raw array of bindings.
+             *
+             * @return array 
+             * @static 
+             */ 
+            public static function getRawBindings()
+            {    
+                return \Illuminate\Database\Query\Builder::getRawBindings();
+            }
+         
+            /**
+             * Set the bindings on the query builder.
+             *
+             * @param array $bindings
+             * @param string $type
+             * @return $this 
+             * @throws \InvalidArgumentException
+             * @static 
+             */ 
+            public static function setBindings($bindings, $type = 'where')
+            {    
+                return \Illuminate\Database\Query\Builder::setBindings($bindings, $type);
+            }
+         
+            /**
+             * Add a binding to the query.
+             *
+             * @param mixed $value
+             * @param string $type
+             * @return $this 
+             * @throws \InvalidArgumentException
+             * @static 
+             */ 
+            public static function addBinding($value, $type = 'where')
+            {    
+                return \Illuminate\Database\Query\Builder::addBinding($value, $type);
+            }
+         
+            /**
+             * Merge an array of bindings into our bindings.
+             *
+             * @param \Illuminate\Database\Query\Builder $query
+             * @return $this 
+             * @static 
+             */ 
+            public static function mergeBindings($query)
+            {    
+                return \Illuminate\Database\Query\Builder::mergeBindings($query);
+            }
+         
+            /**
+             * Get the database query processor instance.
+             *
+             * @return \Illuminate\Database\Query\Processors\Processor 
+             * @static 
+             */ 
+            public static function getProcessor()
+            {    
+                return \Illuminate\Database\Query\Builder::getProcessor();
+            }
+         
+            /**
+             * Get the query grammar instance.
+             *
+             * @return \Illuminate\Database\Query\Grammars\Grammar 
+             * @static 
+             */ 
+            public static function getGrammar()
+            {    
+                return \Illuminate\Database\Query\Builder::getGrammar();
+            }
+         
+            /**
+             * Use the write pdo for query.
+             *
+             * @return $this 
+             * @static 
+             */ 
+            public static function useWritePdo()
+            {    
+                return \Illuminate\Database\Query\Builder::useWritePdo();
+            }
+         
+            /**
+             * Clone the query without the given properties.
+             *
+             * @param array $properties
+             * @return static 
+             * @static 
+             */ 
+            public static function cloneWithout($properties)
+            {    
+                return \Illuminate\Database\Query\Builder::cloneWithout($properties);
+            }
+         
+            /**
+             * Clone the query without the given bindings.
+             *
+             * @param array $except
+             * @return static 
+             * @static 
+             */ 
+            public static function cloneWithoutBindings($except)
+            {    
+                return \Illuminate\Database\Query\Builder::cloneWithoutBindings($except);
+            }
+         
+            /**
+             * Register a custom macro.
+             *
+             * @param string $name
+             * @param object|callable $macro
+             * @return void 
+             * @static 
+             */ 
+            public static function macro($name, $macro)
+            {    
+                \Illuminate\Database\Query\Builder::macro($name, $macro);
+            }
+         
+            /**
+             * Mix another object into the class.
+             *
+             * @param object $mixin
+             * @return void 
+             * @static 
+             */ 
+            public static function mixin($mixin)
+            {    
+                \Illuminate\Database\Query\Builder::mixin($mixin);
+            }
+         
+            /**
+             * Checks if macro is registered.
+             *
+             * @param string $name
+             * @return bool 
+             * @static 
+             */ 
+            public static function hasMacro($name)
+            {    
+                return \Illuminate\Database\Query\Builder::hasMacro($name);
+            }
+         
+            /**
+             * Dynamically handle calls to the class.
+             *
+             * @param string $method
+             * @param array $parameters
+             * @return mixed 
+             * @throws \BadMethodCallException
+             * @static 
+             */ 
+            public static function macroCall($method, $parameters)
+            {    
+                return \Illuminate\Database\Query\Builder::macroCall($method, $parameters);
+            }
+        }
+
+    class Event extends \Illuminate\Support\Facades\Event {}
+
+    class File extends \Illuminate\Support\Facades\File {}
+
+    class Gate extends \Illuminate\Support\Facades\Gate {}
+
+    class Hash extends \Illuminate\Support\Facades\Hash {}
+
+    class Input extends \Illuminate\Support\Facades\Input {}
+
+    class Inspiring extends \Illuminate\Foundation\Inspiring {}
+
+    class Lang extends \Illuminate\Support\Facades\Lang {}
+
+    class Log extends \Illuminate\Support\Facades\Log {}
+
+    class Mail extends \Illuminate\Support\Facades\Mail {}
+
+    class Password extends \Illuminate\Support\Facades\Password {}
+
+    class Queue extends \Illuminate\Support\Facades\Queue {}
+
+    class Redirect extends \Illuminate\Support\Facades\Redirect {}
+
+    class Request extends \Illuminate\Support\Facades\Request {}
+
+    class Response extends \Illuminate\Support\Facades\Response {}
+
+    class Route extends \Illuminate\Support\Facades\Route {}
+
+    class Schema extends \Illuminate\Support\Facades\Schema {}
+
+    class Session extends \Illuminate\Support\Facades\Session {}
+
+    class Storage extends \Illuminate\Support\Facades\Storage {}
+
+    class URL extends \Illuminate\Support\Facades\URL {}
+
+    class Validator extends \Illuminate\Support\Facades\Validator {}
+
+    class View extends \Illuminate\Support\Facades\View {}
+
+    class Notification extends \Illuminate\Support\Facades\Notification {}
+
+    class JsValidator extends \Proengsoft\JsValidation\Facades\JsValidatorFacade {}
+
+    class Socialite extends \Laravel\Socialite\Facades\Socialite {}
+
+    class Form extends \Collective\Html\FormFacade {}
+
+    class HTML extends \Collective\Html\HtmlFacade {}
+
+    class Countries extends \Webpatser\Countries\CountriesFacade {}
+
+    class Image extends \Intervention\Image\Facades\Image {}
+
+    class Settings extends \anlutro\LaravelSettings\Facade {}
+
+    class Authy extends \Vanguard\Services\Auth\TwoFactor\Facade {}
+
+    class JWTAuth extends \Tymon\JWTAuth\Facades\JWTAuth {}
+
+    class Agent extends \Jenssegers\Agent\Facades\Agent {}
+
+    class NoCaptcha extends \Anhskohbo\NoCaptcha\Facades\NoCaptcha {}
+
+    class Debugbar extends \Barryvdh\Debugbar\Facade {}
 
+    class Html extends \Collective\Html\HtmlFacade {}
 
+    class JWTFactory extends \Tymon\JWTAuth\Facades\JWTFactory {}
+ 
 }
 
 
diff --git a/app/Http/Controllers/Api/Auth/AuthController.php b/app/Http/Controllers/Api/Auth/AuthController.php
index a2fea93..83c1b03 100644
--- a/app/Http/Controllers/Api/Auth/AuthController.php
+++ b/app/Http/Controllers/Api/Auth/AuthController.php
@@ -30,7 +30,7 @@ class AuthController extends ApiController
      */
     public function login(LoginRequest $request)
     {
-        $credentials = $request->only('username', 'password');
+        $credentials = $request->getCredentials();
 
         try {
             if (! $token = JWTAuth::attempt($credentials)) {
diff --git a/app/Http/Controllers/Api/StatsController.php b/app/Http/Controllers/Api/StatsController.php
index 289c7c6..1b98c5d 100644
--- a/app/Http/Controllers/Api/StatsController.php
+++ b/app/Http/Controllers/Api/StatsController.php
@@ -52,8 +52,8 @@ class StatsController extends ApiController
     private function adminStats()
     {
         $usersPerMonth = $this->users->countOfNewUsersPerMonth(
-            Carbon::now()->startOfYear(),
-            Carbon::now()
+            Carbon::now()->subYear()->startOfMonth(),
+            Carbon::now()->endOfMonth()
         );
 
         $usersPerStatus = [
diff --git a/app/Http/Controllers/Web/Auth/AuthController.php b/app/Http/Controllers/Web/Auth/AuthController.php
index ed557be..85b2346 100644
--- a/app/Http/Controllers/Web/Auth/AuthController.php
+++ b/app/Http/Controllers/Web/Auth/AuthController.php
@@ -70,7 +70,7 @@ class AuthController extends Controller
             return $this->sendLockoutResponse($request);
         }
 
-        $credentials = $this->getCredentials($request);
+        $credentials = $request->getCredentials();
 
         if (! Auth::validate($credentials)) {
             // If the login attempt was unsuccessful we will increment the number of attempts
@@ -169,30 +169,6 @@ class AuthController extends Controller
         return redirect()->intended('/');
     }
 
-    /**
-     * Get the needed authorization credentials from the request.
-     *
-     * @param  Request  $request
-     * @return array
-     */
-    protected function getCredentials(Request $request)
-    {
-        // The form field for providing username or password
-        // have name of "username", however, in order to support
-        // logging users in with both (username and email)
-        // we have to check if user has entered one or another
-        $usernameOrEmail = $request->get($this->loginUsername());
-
-        if ($this->isEmail($usernameOrEmail)) {
-            return [
-                'email' => $usernameOrEmail,
-                'password' => $request->get('password')
-            ];
-        }
-
-        return $request->only($this->loginUsername(), 'password');
-    }
-
     /**
      * Log the user out of the application.
      *
@@ -200,7 +176,7 @@ class AuthController extends Controller
      */
     public function getLogout()
     {
-        event(new LoggedOut(Auth::user()));
+        event(new LoggedOut);
 
         Auth::logout();
 
@@ -394,18 +370,4 @@ class AuthController extends Controller
         return redirect()->to('login')
             ->withErrors(trans('app.wrong_confirmation_token'));
     }
-
-    /**
-     * Validate if provided parameter is valid email.
-     *
-     * @param $param
-     * @return bool
-     */
-    private function isEmail($param)
-    {
-        return ! Validator::make(
-            ['username' => $param],
-            ['username' => 'email']
-        )->fails();
-    }
 }
diff --git a/app/Http/Controllers/Web/DashboardController.php b/app/Http/Controllers/Web/DashboardController.php
index 8a76603..7f0da89 100644
--- a/app/Http/Controllers/Web/DashboardController.php
+++ b/app/Http/Controllers/Web/DashboardController.php
@@ -54,8 +54,8 @@ class DashboardController extends Controller
     private function adminDashboard()
     {
         $usersPerMonth = $this->users->countOfNewUsersPerMonth(
-            Carbon::now()->subYear(),
-            Carbon::now()
+            Carbon::now()->subYear()->startOfMonth(),
+            Carbon::now()->endOfMonth()
         );
 
         $stats = [
diff --git a/app/Http/Kernel.php b/app/Http/Kernel.php
index c786c18..7fcad59 100644
--- a/app/Http/Kernel.php
+++ b/app/Http/Kernel.php
@@ -58,5 +58,6 @@ class Kernel extends HttpKernel
         'can' => \Illuminate\Auth\Middleware\Authorize::class,
         'bindings' => \Illuminate\Routing\Middleware\SubstituteBindings::class,
         'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
+        'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
     ];
 }
diff --git a/app/Http/Middleware/TrustProxies.php b/app/Http/Middleware/TrustProxies.php
index ecde46a..3833d55 100644
--- a/app/Http/Middleware/TrustProxies.php
+++ b/app/Http/Middleware/TrustProxies.php
@@ -19,11 +19,5 @@ class TrustProxies extends Middleware
      *
      * @var array
      */
-    protected $headers = [
-        Request::HEADER_FORWARDED => 'FORWARDED',
-        Request::HEADER_X_FORWARDED_FOR => 'X_FORWARDED_FOR',
-        Request::HEADER_X_FORWARDED_HOST => 'X_FORWARDED_HOST',
-        Request::HEADER_X_FORWARDED_PORT => 'X_FORWARDED_PORT',
-        Request::HEADER_X_FORWARDED_PROTO => 'X_FORWARDED_PROTO',
-    ];
+    protected $headers = Request::HEADER_X_FORWARDED_ALL;
 }
diff --git a/app/Http/Requests/Auth/LoginRequest.php b/app/Http/Requests/Auth/LoginRequest.php
index 1152612..f4279d6 100644
--- a/app/Http/Requests/Auth/LoginRequest.php
+++ b/app/Http/Requests/Auth/LoginRequest.php
@@ -3,6 +3,7 @@
 namespace Vanguard\Http\Requests\Auth;
 
 use Vanguard\Http\Requests\Request;
+use Illuminate\Contracts\Validation\Factory as ValidationFactory;
 
 class LoginRequest extends Request
 {
@@ -18,4 +19,43 @@ class LoginRequest extends Request
             'password' => 'required'
         ];
     }
+
+    /**
+     * Get the needed authorization credentials from the request.
+     *
+     * @return array
+     */
+    public function getCredentials()
+    {
+        // The form field for providing username or password
+        // have name of "username", however, in order to support
+        // logging users in with both (username and email)
+        // we have to check if user has entered one or another
+        $username = $this->get('username');
+
+        if ($this->isEmail($username)) {
+            return [
+                'email' => $username,
+                'password' => $this->get('password')
+            ];
+        }
+
+        return $this->only('username', 'password');
+    }
+
+    /**
+     * Validate if provided parameter is valid email.
+     *
+     * @param $param
+     * @return bool
+     */
+    private function isEmail($param)
+    {
+        $factory = $this->container->make(ValidationFactory::class);
+
+        return ! $factory->make(
+            ['username' => $param],
+            ['username' => 'email']
+        )->fails();
+    }
 }
diff --git a/app/Repositories/User/EloquentUser.php b/app/Repositories/User/EloquentUser.php
index 6e5f49a..341ad26 100644
--- a/app/Repositories/User/EloquentUser.php
+++ b/app/Repositories/User/EloquentUser.php
@@ -188,6 +188,7 @@ class EloquentUser implements UserRepository
     public function countOfNewUsersPerMonth(Carbon $from, Carbon $to)
     {
         $result = User::whereBetween('created_at', [$from, $to])
+            ->orderBy('created_at')
             ->get(['created_at'])
             ->groupBy(function ($user) {
                 return $user->created_at->format("Y_n");
diff --git a/app/Services/Auth/TwoFactor/Authy.php b/app/Services/Auth/TwoFactor/Authy.php
index 2853d51..e835830 100644
--- a/app/Services/Auth/TwoFactor/Authy.php
+++ b/app/Services/Auth/TwoFactor/Authy.php
@@ -27,7 +27,7 @@ class Authy implements Provider
      */
     public function register(TwoFactorAuthenticatable $user)
     {
-        $key = env('AUTHY_KEY');
+        $key = config('services.authy.key');
 
         $response = json_decode((new HttpClient)->post('https://api.authy.com/protected/json/users/new?api_key='.$key, [
             'form_params' => [
@@ -54,7 +54,7 @@ class Authy implements Provider
     public function tokenIsValid(TwoFactorAuthenticatable $user, $token)
     {
         try {
-            $key = env('AUTHY_KEY');
+            $key = config('services.authy.key');
 
             $options = $user->getTwoFactorAuthProviderOptions();
 
@@ -76,7 +76,7 @@ class Authy implements Provider
      */
     public function delete(TwoFactorAuthenticatable $user)
     {
-        $key = env('AUTHY_KEY');
+        $key = config('services.authy.key');
 
         $options = $user->getTwoFactorAuthProviderOptions();
 
@@ -86,4 +86,4 @@ class Authy implements Provider
 
         $user->setTwoFactorAuthProviderOptions([]);
     }
-}
\ No newline at end of file
+}
diff --git a/app/Services/Auth/TwoFactor/Contracts/Provider.php b/app/Services/Auth/TwoFactor/Contracts/Provider.php
index d87726f..a473f2f 100644
--- a/app/Services/Auth/TwoFactor/Contracts/Provider.php
+++ b/app/Services/Auth/TwoFactor/Contracts/Provider.php
@@ -37,5 +37,4 @@ interface Provider
      * @return bool
      */
     public function delete(TwoFactorAuthenticatable $user);
-
-}
\ No newline at end of file
+}
diff --git a/app/User.php b/app/User.php
index e4b5e44..e40c868 100644
--- a/app/User.php
+++ b/app/User.php
@@ -2,11 +2,9 @@
 
 namespace Vanguard;
 
-use Carbon\Carbon;
 use Illuminate\Notifications\Notifiable;
 use Tymon\JWTAuth\Contracts\JWTSubject;
 use Vanguard\Presenters\UserPresenter;
-use Vanguard\Services\Auth\Api\Token;
 use Vanguard\Services\Auth\Api\TokenFactory;
 use Vanguard\Services\Auth\TwoFactor\Authenticatable as TwoFactorAuthenticatable;
 use Vanguard\Services\Auth\TwoFactor\Contracts\Authenticatable as TwoFactorAuthenticatableContract;
diff --git a/composer.json b/composer.json
index eafb2d5..0892d9b 100644
--- a/composer.json
+++ b/composer.json
@@ -3,32 +3,38 @@
     "description": "Advanced PHP Login and User Management",
     "keywords": ["advanced", "secure", "login", "user management", "authentication", "authorization", "register"],
     "type": "project",
+    "repositories": [
+        {
+            "type": "vcs",
+            "url": "https://github.com/loshmis/laravel-countries"
+        }
+    ],
     "require": {
-        "php": ">=7.0.0",
-        "laravel/framework": "5.5.*",
-        "proengsoft/laravel-jsvalidation": "2.1.*",
+        "php": ">=7.1.3",
+        "laravel/framework": "5.6.*",
+        "proengsoft/laravel-jsvalidation": "2.2.*",
         "laravel/socialite": "^3.0",
         "laracasts/presenter": "^0.2.1",
         "laravelcollective/html": "^5.1",
-        "webpatser/laravel-countries": "^1.4",
+        "webpatser/laravel-countries": "dev-master",
         "paragonie/random_compat": "~1.4",
         "intervention/image": "^2.3",
         "anlutro/l4-settings": "^0.4.6",
-        "anhskohbo/no-captcha": "2.*",
-        "tymon/jwt-auth": "1.0.0-rc.1",
+        "anhskohbo/no-captcha": "3.*",
+        "tymon/jwt-auth": "1.0.0-rc.2",
         "league/fractal": "^0.16.0",
         "jenssegers/agent": "^2.5",
-        "fideloper/proxy": "~3.3"
+        "fideloper/proxy": "~4.0"
     },
     "require-dev": {
-        "symfony/css-selector": "~3.0",
-        "symfony/dom-crawler": "~3.0",
+        "symfony/css-selector": "~4.0",
+        "symfony/dom-crawler": "~4.0",
         "fzaninotto/faker": "~1.4",
         "mockery/mockery": "0.9.*",
-        "phpunit/phpunit": "~6.0",
+        "phpunit/phpunit": "~7.0",
         "barryvdh/laravel-ide-helper": "2.4.*",
         "barryvdh/laravel-debugbar": "3.1.*",
-        "laravel/browser-kit-testing": "^2.0",
+        "laravel/browser-kit-testing": "^4.0",
         "filp/whoops": "~2.0"
     },
     "autoload": {
diff --git a/composer.lock b/composer.lock
index bf3f1df..6bb0f2a 100644
--- a/composer.lock
+++ b/composer.lock
@@ -4,28 +4,30 @@
         "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file",
         "This file is @generated automatically"
     ],
-    "hash": "0afb12c3312468c30411247ef607b23d",
-    "content-hash": "692a122461ca79eec69ce3e6bb636b56",
+    "content-hash": "ca2180aaaec517b1dc33238e113e99ed",
     "packages": [
         {
             "name": "anhskohbo/no-captcha",
-            "version": "2.4.0",
+            "version": "3.0.1",
             "source": {
                 "type": "git",
                 "url": "https://github.com/anhskohbo/no-captcha.git",
-                "reference": "cc0bacff1bb59f518af135ee3beae39bed079724"
+                "reference": "f6c3a006b8c74f692d232d861c3e104621f50dcc"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/anhskohbo/no-captcha/zipball/cc0bacff1bb59f518af135ee3beae39bed079724",
-                "reference": "cc0bacff1bb59f518af135ee3beae39bed079724",
+                "url": "https://api.github.com/repos/anhskohbo/no-captcha/zipball/f6c3a006b8c74f692d232d861c3e104621f50dcc",
+                "reference": "f6c3a006b8c74f692d232d861c3e104621f50dcc",
                 "shasum": ""
             },
             "require": {
                 "guzzlehttp/guzzle": "^6.2",
-                "illuminate/support": "5.0.*|5.1.*|5.2.*|5.3.*|5.4.*|5.5.*",
+                "illuminate/support": "5.0.*|5.1.*|5.2.*|5.3.*|5.4.*|5.5.*|5.6.*",
                 "php": ">=5.5.5"
             },
+            "require-dev": {
+                "phpunit/phpunit": "~4.8"
+            },
             "type": "library",
             "extra": {
                 "laravel": {
@@ -61,7 +63,7 @@
                 "no-captcha",
                 "recaptcha"
             ],
-            "time": "2017-08-30 18:36:57"
+            "time": "2018-02-09T02:04:49+00:00"
         },
         {
             "name": "anlutro/l4-settings",
@@ -107,24 +109,24 @@
                 }
             ],
             "description": "Persistent settings in Laravel.",
-            "time": "2016-08-24 14:06:54"
+            "time": "2016-08-24T14:06:54+00:00"
         },
         {
             "name": "doctrine/inflector",
-            "version": "v1.2.0",
+            "version": "v1.3.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/doctrine/inflector.git",
-                "reference": "e11d84c6e018beedd929cff5220969a3c6d1d462"
+                "reference": "5527a48b7313d15261292c149e55e26eae771b0a"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/doctrine/inflector/zipball/e11d84c6e018beedd929cff5220969a3c6d1d462",
-                "reference": "e11d84c6e018beedd929cff5220969a3c6d1d462",
+                "url": "https://api.github.com/repos/doctrine/inflector/zipball/5527a48b7313d15261292c149e55e26eae771b0a",
+                "reference": "5527a48b7313d15261292c149e55e26eae771b0a",
                 "shasum": ""
             },
             "require": {
-                "php": "^7.0"
+                "php": "^7.1"
             },
             "require-dev": {
                 "phpunit/phpunit": "^6.2"
@@ -132,7 +134,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "1.2.x-dev"
+                    "dev-master": "1.3.x-dev"
                 }
             },
             "autoload": {
@@ -174,7 +176,7 @@
                 "singularize",
                 "string"
             ],
-            "time": "2017-07-22 12:18:28"
+            "time": "2018-01-09T20:05:19+00:00"
         },
         {
             "name": "doctrine/lexer",
@@ -228,7 +230,56 @@
                 "lexer",
                 "parser"
             ],
-            "time": "2014-09-09 13:34:57"
+            "time": "2014-09-09T13:34:57+00:00"
+        },
+        {
+            "name": "dragonmantank/cron-expression",
+            "version": "v2.0.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/dragonmantank/cron-expression.git",
+                "reference": "8a84aee649c3a3ba03a721c1fb080e08dfbcd68b"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/dragonmantank/cron-expression/zipball/8a84aee649c3a3ba03a721c1fb080e08dfbcd68b",
+                "reference": "8a84aee649c3a3ba03a721c1fb080e08dfbcd68b",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=7.0.0"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "~5.7"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "Cron\\": "src/Cron/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Michael Dowling",
+                    "email": "mtdowling@gmail.com",
+                    "homepage": "https://github.com/mtdowling"
+                },
+                {
+                    "name": "Chris Tankersley",
+                    "email": "chris@ctankersley.com",
+                    "homepage": "https://github.com/dragonmantank"
+                }
+            ],
+            "description": "CRON for PHP: Calculate the next or previous run date and determine if a CRON expression is due",
+            "keywords": [
+                "cron",
+                "schedule"
+            ],
+            "time": "2017-10-12T15:59:13+00:00"
         },
         {
             "name": "egulias/email-validator",
@@ -285,23 +336,24 @@
                 "validation",
                 "validator"
             ],
-            "time": "2017-11-15 23:40:40"
+            "time": "2017-11-15T23:40:40+00:00"
         },
         {
             "name": "erusev/parsedown",
-            "version": "1.6.4",
+            "version": "1.7.1",
             "source": {
                 "type": "git",
                 "url": "https://github.com/erusev/parsedown.git",
-                "reference": "fbe3fe878f4fe69048bb8a52783a09802004f548"
+                "reference": "92e9c27ba0e74b8b028b111d1b6f956a15c01fc1"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/erusev/parsedown/zipball/fbe3fe878f4fe69048bb8a52783a09802004f548",
-                "reference": "fbe3fe878f4fe69048bb8a52783a09802004f548",
+                "url": "https://api.github.com/repos/erusev/parsedown/zipball/92e9c27ba0e74b8b028b111d1b6f956a15c01fc1",
+                "reference": "92e9c27ba0e74b8b028b111d1b6f956a15c01fc1",
                 "shasum": ""
             },
             "require": {
+                "ext-mbstring": "*",
                 "php": ">=5.3.0"
             },
             "require-dev": {
@@ -330,20 +382,20 @@
                 "markdown",
                 "parser"
             ],
-            "time": "2017-11-14 20:44:03"
+            "time": "2018-03-08T01:11:30+00:00"
         },
         {
             "name": "fideloper/proxy",
-            "version": "3.3.4",
+            "version": "4.0.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/fideloper/TrustedProxy.git",
-                "reference": "9cdf6f118af58d89764249bbcc7bb260c132924f"
+                "reference": "cf8a0ca4b85659b9557e206c90110a6a4dba980a"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/fideloper/TrustedProxy/zipball/9cdf6f118af58d89764249bbcc7bb260c132924f",
-                "reference": "9cdf6f118af58d89764249bbcc7bb260c132924f",
+                "url": "https://api.github.com/repos/fideloper/TrustedProxy/zipball/cf8a0ca4b85659b9557e206c90110a6a4dba980a",
+                "reference": "cf8a0ca4b85659b9557e206c90110a6a4dba980a",
                 "shasum": ""
             },
             "require": {
@@ -351,15 +403,12 @@
                 "php": ">=5.4.0"
             },
             "require-dev": {
-                "illuminate/http": "~5.0",
-                "mockery/mockery": "~0.9.3",
-                "phpunit/phpunit": "^5.7"
+                "illuminate/http": "~5.6",
+                "mockery/mockery": "~1.0",
+                "phpunit/phpunit": "^6.0"
             },
             "type": "library",
             "extra": {
-                "branch-alias": {
-                    "dev-master": "3.3-dev"
-                },
                 "laravel": {
                     "providers": [
                         "Fideloper\\Proxy\\TrustedProxyServiceProvider"
@@ -387,7 +436,7 @@
                 "proxy",
                 "trusted proxy"
             ],
-            "time": "2017-06-15 17:19:42"
+            "time": "2018-02-07T20:20:57+00:00"
         },
         {
             "name": "guzzlehttp/guzzle",
@@ -452,7 +501,7 @@
                 "rest",
                 "web service"
             ],
-            "time": "2017-06-22 18:50:49"
+            "time": "2017-06-22T18:50:49+00:00"
         },
         {
             "name": "guzzlehttp/promises",
@@ -503,7 +552,7 @@
             "keywords": [
                 "promise"
             ],
-            "time": "2016-12-20 10:07:11"
+            "time": "2016-12-20T10:07:11+00:00"
         },
         {
             "name": "guzzlehttp/psr7",
@@ -568,7 +617,7 @@
                 "uri",
                 "url"
             ],
-            "time": "2017-03-20 17:10:46"
+            "time": "2017-03-20T17:10:46+00:00"
         },
         {
             "name": "intervention/image",
@@ -638,20 +687,20 @@
                 "thumbnail",
                 "watermark"
             ],
-            "time": "2017-09-21 16:29:17"
+            "time": "2017-09-21T16:29:17+00:00"
         },
         {
             "name": "jaybizzle/crawler-detect",
-            "version": "v1.2.54",
+            "version": "v1.2.60",
             "source": {
                 "type": "git",
                 "url": "https://github.com/JayBizzle/Crawler-Detect.git",
-                "reference": "9af25770d9382917b680009a88497162405bbe48"
+                "reference": "6e9abfe7100f1c8febfa600b3568192989f10c2e"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/JayBizzle/Crawler-Detect/zipball/9af25770d9382917b680009a88497162405bbe48",
-                "reference": "9af25770d9382917b680009a88497162405bbe48",
+                "url": "https://api.github.com/repos/JayBizzle/Crawler-Detect/zipball/6e9abfe7100f1c8febfa600b3568192989f10c2e",
+                "reference": "6e9abfe7100f1c8febfa600b3568192989f10c2e",
                 "shasum": ""
             },
             "require": {
@@ -687,7 +736,7 @@
                 "crawlerdetect",
                 "php crawler detect"
             ],
-            "time": "2017-10-28 13:05:55"
+            "time": "2018-03-05T20:50:06+00:00"
         },
         {
             "name": "jenssegers/agent",
@@ -753,7 +802,7 @@
                 "user agent",
                 "useragent"
             ],
-            "time": "2017-11-10 10:35:35"
+            "time": "2017-11-10T10:35:35+00:00"
         },
         {
             "name": "laracasts/presenter",
@@ -799,47 +848,50 @@
                 "presenter",
                 "view"
             ],
-            "time": "2014-09-13 13:18:07"
+            "time": "2014-09-13T13:18:07+00:00"
         },
         {
             "name": "laravel/framework",
-            "version": "v5.5.26",
+            "version": "v5.6.11",
             "source": {
                 "type": "git",
                 "url": "https://github.com/laravel/framework.git",
-                "reference": "d7e6a7aab600c5cfae595ea22074ac3c536cbc28"
+                "reference": "195ba6a67bdad2a23105c7ab410cd43e0f20bb73"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/laravel/framework/zipball/d7e6a7aab600c5cfae595ea22074ac3c536cbc28",
-                "reference": "d7e6a7aab600c5cfae595ea22074ac3c536cbc28",
+                "url": "https://api.github.com/repos/laravel/framework/zipball/195ba6a67bdad2a23105c7ab410cd43e0f20bb73",
+                "reference": "195ba6a67bdad2a23105c7ab410cd43e0f20bb73",
                 "shasum": ""
             },
             "require": {
                 "doctrine/inflector": "~1.1",
-                "erusev/parsedown": "~1.6",
+                "dragonmantank/cron-expression": "~2.0",
+                "erusev/parsedown": "~1.7",
                 "ext-mbstring": "*",
                 "ext-openssl": "*",
                 "league/flysystem": "~1.0",
                 "monolog/monolog": "~1.12",
-                "mtdowling/cron-expression": "~1.0",
-                "nesbot/carbon": "~1.20",
-                "php": ">=7.0",
+                "nesbot/carbon": "^1.24.1",
+                "php": "^7.1.3",
                 "psr/container": "~1.0",
                 "psr/simple-cache": "^1.0",
-                "ramsey/uuid": "~3.0",
+                "ramsey/uuid": "^3.7",
                 "swiftmailer/swiftmailer": "~6.0",
-                "symfony/console": "~3.3",
-                "symfony/debug": "~3.3",
-                "symfony/finder": "~3.3",
-                "symfony/http-foundation": "~3.3",
-                "symfony/http-kernel": "~3.3",
-                "symfony/process": "~3.3",
-                "symfony/routing": "~3.3",
-                "symfony/var-dumper": "~3.3",
-                "tijsverkoyen/css-to-inline-styles": "~2.2",
+                "symfony/console": "~4.0",
+                "symfony/debug": "~4.0",
+                "symfony/finder": "~4.0",
+                "symfony/http-foundation": "~4.0",
+                "symfony/http-kernel": "~4.0",
+                "symfony/process": "~4.0",
+                "symfony/routing": "~4.0",
+                "symfony/var-dumper": "~4.0",
+                "tijsverkoyen/css-to-inline-styles": "^2.2.1",
                 "vlucas/phpdotenv": "~2.2"
             },
+            "conflict": {
+                "tightenco/collect": "<5.5.33"
+            },
             "replace": {
                 "illuminate/auth": "self.version",
                 "illuminate/broadcasting": "self.version",
@@ -868,24 +920,24 @@
                 "illuminate/support": "self.version",
                 "illuminate/translation": "self.version",
                 "illuminate/validation": "self.version",
-                "illuminate/view": "self.version",
-                "tightenco/collect": "self.version"
+                "illuminate/view": "self.version"
             },
             "require-dev": {
                 "aws/aws-sdk-php": "~3.0",
-                "doctrine/dbal": "~2.5",
+                "doctrine/dbal": "~2.6",
                 "filp/whoops": "^2.1.4",
                 "mockery/mockery": "~1.0",
-                "orchestra/testbench-core": "3.5.*",
+                "moontoast/math": "^1.1",
+                "orchestra/testbench-core": "3.6.*",
                 "pda/pheanstalk": "~3.0",
-                "phpunit/phpunit": "~6.0",
+                "phpunit/phpunit": "~7.0",
                 "predis/predis": "^1.1.1",
-                "symfony/css-selector": "~3.3",
-                "symfony/dom-crawler": "~3.3"
+                "symfony/css-selector": "~4.0",
+                "symfony/dom-crawler": "~4.0"
             },
             "suggest": {
                 "aws/aws-sdk-php": "Required to use the SQS queue driver and SES mail driver (~3.0).",
-                "doctrine/dbal": "Required to rename columns and drop SQLite columns (~2.5).",
+                "doctrine/dbal": "Required to rename columns and drop SQLite columns (~2.6).",
                 "ext-pcntl": "Required to use all features of the queue worker.",
                 "ext-posix": "Required to use all features of the queue worker.",
                 "fzaninotto/faker": "Required to use the eloquent factory builder (~1.4).",
@@ -894,18 +946,19 @@
                 "league/flysystem-aws-s3-v3": "Required to use the Flysystem S3 driver (~1.0).",
                 "league/flysystem-cached-adapter": "Required to use Flysystem caching (~1.0).",
                 "league/flysystem-rackspace": "Required to use the Flysystem Rackspace driver (~1.0).",
+                "league/flysystem-sftp": "Required to use the Flysystem SFTP driver (~1.0).",
                 "nexmo/client": "Required to use the Nexmo transport (~1.0).",
                 "pda/pheanstalk": "Required to use the beanstalk queue driver (~3.0).",
                 "predis/predis": "Required to use the redis cache and queue drivers (~1.0).",
                 "pusher/pusher-php-server": "Required to use the Pusher broadcast driver (~3.0).",
-                "symfony/css-selector": "Required to use some of the crawler integration testing tools (~3.3).",
-                "symfony/dom-crawler": "Required to use most of the crawler integration testing tools (~3.3).",
+                "symfony/css-selector": "Required to use some of the crawler integration testing tools (~4.0).",
+                "symfony/dom-crawler": "Required to use most of the crawler integration testing tools (~4.0).",
                 "symfony/psr-http-message-bridge": "Required to psr7 bridging features (~1.0)."
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "5.5-dev"
+                    "dev-master": "5.6-dev"
                 }
             },
             "autoload": {
@@ -933,7 +986,7 @@
                 "framework",
                 "laravel"
             ],
-            "time": "2017-12-18 14:15:59"
+            "time": "2018-03-09T16:53:27+00:00"
         },
         {
             "name": "laravel/socialite",
@@ -995,37 +1048,40 @@
                 "laravel",
                 "oauth"
             ],
-            "time": "2017-11-06 16:02:48"
+            "time": "2017-11-06T16:02:48+00:00"
         },
         {
             "name": "laravelcollective/html",
-            "version": "v5.5.1",
+            "version": "v5.6.3",
             "source": {
                 "type": "git",
                 "url": "https://github.com/LaravelCollective/html.git",
-                "reference": "2f6dc39ab3655724a615fe8a652d8b7f04fc9ac6"
+                "reference": "41cd9291a69bd24f2184e504be041348a87308a8"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/LaravelCollective/html/zipball/2f6dc39ab3655724a615fe8a652d8b7f04fc9ac6",
-                "reference": "2f6dc39ab3655724a615fe8a652d8b7f04fc9ac6",
+                "url": "https://api.github.com/repos/LaravelCollective/html/zipball/41cd9291a69bd24f2184e504be041348a87308a8",
+                "reference": "41cd9291a69bd24f2184e504be041348a87308a8",
                 "shasum": ""
             },
             "require": {
-                "illuminate/http": "5.5.*",
-                "illuminate/routing": "5.5.*",
-                "illuminate/session": "5.5.*",
-                "illuminate/support": "5.5.*",
-                "illuminate/view": "5.5.*",
-                "php": ">=7.0.0"
+                "illuminate/http": "5.6.*",
+                "illuminate/routing": "5.6.*",
+                "illuminate/session": "5.6.*",
+                "illuminate/support": "5.6.*",
+                "illuminate/view": "5.6.*",
+                "php": ">=7.1.3"
             },
             "require-dev": {
-                "illuminate/database": "5.5.*",
-                "mockery/mockery": "~0.9.4",
+                "illuminate/database": "5.6.*",
+                "mockery/mockery": "~1.0",
                 "phpunit/phpunit": "~5.4"
             },
             "type": "library",
             "extra": {
+                "branch-alias": {
+                    "dev-master": "5.6-dev"
+                },
                 "laravel": {
                     "providers": [
                         "Collective\\Html\\HtmlServiceProvider"
@@ -1059,21 +1115,79 @@
                 }
             ],
             "description": "HTML and Form Builders for the Laravel Framework",
-            "homepage": "http://laravelcollective.com",
-            "time": "2017-08-31 14:46:03"
+            "homepage": "https://laravelcollective.com",
+            "time": "2018-02-12T14:19:42+00:00"
+        },
+        {
+            "name": "lcobucci/jwt",
+            "version": "3.2.2",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/lcobucci/jwt.git",
+                "reference": "0b5930be73582369e10c4d4bb7a12bac927a203c"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/lcobucci/jwt/zipball/0b5930be73582369e10c4d4bb7a12bac927a203c",
+                "reference": "0b5930be73582369e10c4d4bb7a12bac927a203c",
+                "shasum": ""
+            },
+            "require": {
+                "ext-openssl": "*",
+                "php": ">=5.5"
+            },
+            "require-dev": {
+                "mdanter/ecc": "~0.3.1",
+                "mikey179/vfsstream": "~1.5",
+                "phpmd/phpmd": "~2.2",
+                "phpunit/php-invoker": "~1.1",
+                "phpunit/phpunit": "~4.5",
+                "squizlabs/php_codesniffer": "~2.3"
+            },
+            "suggest": {
+                "mdanter/ecc": "Required to use Elliptic Curves based algorithms."
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "3.1-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Lcobucci\\JWT\\": "src"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "BSD-3-Clause"
+            ],
+            "authors": [
+                {
+                    "name": "Lus Otvio Cobucci Oblonczyk",
+                    "email": "lcobucci@gmail.com",
+                    "role": "Developer"
+                }
+            ],
+            "description": "A simple library to work with JSON Web Token and JSON Web Signature",
+            "keywords": [
+                "JWS",
+                "jwt"
+            ],
+            "time": "2017-09-01T08:23:26+00:00"
         },
         {
             "name": "league/flysystem",
-            "version": "1.0.41",
+            "version": "1.0.43",
             "source": {
                 "type": "git",
                 "url": "https://github.com/thephpleague/flysystem.git",
-                "reference": "f400aa98912c561ba625ea4065031b7a41e5a155"
+                "reference": "1ce7cc142d906ba58dc54c82915d355a9191c8a8"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/thephpleague/flysystem/zipball/f400aa98912c561ba625ea4065031b7a41e5a155",
-                "reference": "f400aa98912c561ba625ea4065031b7a41e5a155",
+                "url": "https://api.github.com/repos/thephpleague/flysystem/zipball/1ce7cc142d906ba58dc54c82915d355a9191c8a8",
+                "reference": "1ce7cc142d906ba58dc54c82915d355a9191c8a8",
                 "shasum": ""
             },
             "require": {
@@ -1084,12 +1198,13 @@
             },
             "require-dev": {
                 "ext-fileinfo": "*",
-                "mockery/mockery": "~0.9",
-                "phpspec/phpspec": "^2.2",
-                "phpunit/phpunit": "~4.8"
+                "phpspec/phpspec": "^3.4",
+                "phpunit/phpunit": "^5.7"
             },
             "suggest": {
                 "ext-fileinfo": "Required for MimeType",
+                "ext-ftp": "Allows you to use FTP server storage",
+                "ext-openssl": "Allows you to use FTPS server storage",
                 "league/flysystem-aws-s3-v2": "Allows you to use S3 storage with AWS SDK v2",
                 "league/flysystem-aws-s3-v3": "Allows you to use S3 storage with AWS SDK v3",
                 "league/flysystem-azure": "Allows you to use Windows Azure Blob storage",
@@ -1143,7 +1258,7 @@
                 "sftp",
                 "storage"
             ],
-            "time": "2017-08-06 17:41:04"
+            "time": "2018-03-01T10:27:04+00:00"
         },
         {
             "name": "league/fractal",
@@ -1207,7 +1322,7 @@
                 "league",
                 "rest"
             ],
-            "time": "2017-03-12 01:28:43"
+            "time": "2017-03-12T01:28:43+00:00"
         },
         {
             "name": "league/oauth1-client",
@@ -1270,20 +1385,20 @@
                 "tumblr",
                 "twitter"
             ],
-            "time": "2016-08-17 00:36:58"
+            "time": "2016-08-17T00:36:58+00:00"
         },
         {
             "name": "mobiledetect/mobiledetectlib",
-            "version": "2.8.30",
+            "version": "2.8.31",
             "source": {
                 "type": "git",
                 "url": "https://github.com/serbanghita/Mobile-Detect.git",
-                "reference": "5500bbbf312fe77ef0c7223858dad84fe49ee0c3"
+                "reference": "adb882ea3b9d154f087ecb2c333180dad6f4dd37"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/serbanghita/Mobile-Detect/zipball/5500bbbf312fe77ef0c7223858dad84fe49ee0c3",
-                "reference": "5500bbbf312fe77ef0c7223858dad84fe49ee0c3",
+                "url": "https://api.github.com/repos/serbanghita/Mobile-Detect/zipball/adb882ea3b9d154f087ecb2c333180dad6f4dd37",
+                "reference": "adb882ea3b9d154f087ecb2c333180dad6f4dd37",
                 "shasum": ""
             },
             "require": {
@@ -1322,7 +1437,7 @@
                 "mobile detector",
                 "php mobile detect"
             ],
-            "time": "2017-12-18 10:38:51"
+            "time": "2018-02-26T19:39:55+00:00"
         },
         {
             "name": "monolog/monolog",
@@ -1400,51 +1515,7 @@
                 "logging",
                 "psr-3"
             ],
-            "time": "2017-06-19 01:22:40"
-        },
-        {
-            "name": "mtdowling/cron-expression",
-            "version": "v1.2.1",
-            "source": {
-                "type": "git",
-                "url": "https://github.com/mtdowling/cron-expression.git",
-                "reference": "9504fa9ea681b586028adaaa0877db4aecf32bad"
-            },
-            "dist": {
-                "type": "zip",
-                "url": "https://api.github.com/repos/mtdowling/cron-expression/zipball/9504fa9ea681b586028adaaa0877db4aecf32bad",
-                "reference": "9504fa9ea681b586028adaaa0877db4aecf32bad",
-                "shasum": ""
-            },
-            "require": {
-                "php": ">=5.3.2"
-            },
-            "require-dev": {
-                "phpunit/phpunit": "~4.0|~5.0"
-            },
-            "type": "library",
-            "autoload": {
-                "psr-4": {
-                    "Cron\\": "src/Cron/"
-                }
-            },
-            "notification-url": "https://packagist.org/downloads/",
-            "license": [
-                "MIT"
-            ],
-            "authors": [
-                {
-                    "name": "Michael Dowling",
-                    "email": "mtdowling@gmail.com",
-                    "homepage": "https://github.com/mtdowling"
-                }
-            ],
-            "description": "CRON for PHP: Calculate the next or previous run date and determine if a CRON expression is due",
-            "keywords": [
-                "cron",
-                "schedule"
-            ],
-            "time": "2017-01-23 04:29:33"
+            "time": "2017-06-19T01:22:40+00:00"
         },
         {
             "name": "namshi/jose",
@@ -1507,29 +1578,29 @@
                 "jwt",
                 "token"
             ],
-            "time": "2016-12-05 07:27:31"
+            "time": "2016-12-05T07:27:31+00:00"
         },
         {
             "name": "nesbot/carbon",
-            "version": "1.22.1",
+            "version": "1.24.2",
             "source": {
                 "type": "git",
                 "url": "https://github.com/briannesbitt/Carbon.git",
-                "reference": "7cdf42c0b1cc763ab7e4c33c47a24e27c66bfccc"
+                "reference": "bba6c6e410c6b4317e37a9474aeaa753808c3875"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/briannesbitt/Carbon/zipball/7cdf42c0b1cc763ab7e4c33c47a24e27c66bfccc",
-                "reference": "7cdf42c0b1cc763ab7e4c33c47a24e27c66bfccc",
+                "url": "https://api.github.com/repos/briannesbitt/Carbon/zipball/bba6c6e410c6b4317e37a9474aeaa753808c3875",
+                "reference": "bba6c6e410c6b4317e37a9474aeaa753808c3875",
                 "shasum": ""
             },
             "require": {
-                "php": ">=5.3.0",
-                "symfony/translation": "~2.6 || ~3.0"
+                "php": ">=5.3.9",
+                "symfony/translation": "~2.6 || ~3.0 || ~4.0"
             },
             "require-dev": {
                 "friendsofphp/php-cs-fixer": "~2",
-                "phpunit/phpunit": "~4.0 || ~5.0"
+                "phpunit/phpunit": "^4.8.35 || ^5.7"
             },
             "type": "library",
             "extra": {
@@ -1560,7 +1631,7 @@
                 "datetime",
                 "time"
             ],
-            "time": "2017-01-16 07:55:07"
+            "time": "2018-03-10T10:10:14+00:00"
         },
         {
             "name": "paragonie/random_compat",
@@ -1608,30 +1679,30 @@
                 "pseudorandom",
                 "random"
             ],
-            "time": "2017-03-13 16:22:52"
+            "time": "2017-03-13T16:22:52+00:00"
         },
         {
             "name": "proengsoft/laravel-jsvalidation",
-            "version": "2.1.0",
+            "version": "2.2.1",
             "source": {
                 "type": "git",
                 "url": "https://github.com/proengsoft/laravel-jsvalidation.git",
-                "reference": "ca03bf933fa021a950b5bc6065534225c20f902c"
+                "reference": "735299cc6ce814da4de0044a5479d8aa0685f088"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/proengsoft/laravel-jsvalidation/zipball/ca03bf933fa021a950b5bc6065534225c20f902c",
-                "reference": "ca03bf933fa021a950b5bc6065534225c20f902c",
+                "url": "https://api.github.com/repos/proengsoft/laravel-jsvalidation/zipball/735299cc6ce814da4de0044a5479d8aa0685f088",
+                "reference": "735299cc6ce814da4de0044a5479d8aa0685f088",
                 "shasum": ""
             },
             "require": {
-                "illuminate/config": "5.4.*|5.5.*",
-                "illuminate/contracts": "5.4.*|5.5.*",
-                "illuminate/http": "5.4.*|5.5.*",
-                "illuminate/support": "5.4.*|5.5.*",
-                "illuminate/translation": "5.4.*|5.5.*",
-                "illuminate/validation": "5.4.*|5.5.*",
-                "illuminate/view": "5.4.*|5.5.*",
+                "illuminate/config": "5.4.*|5.5.*|5.6.*",
+                "illuminate/contracts": "5.4.*|5.5.*|5.6.*",
+                "illuminate/http": "5.4.*|5.5.*|5.6.*",
+                "illuminate/support": "5.4.*|5.5.*|5.6.*",
+                "illuminate/translation": "5.4.*|5.5.*|5.6.*",
+                "illuminate/validation": "5.4.*|5.5.*|5.6.*",
+                "illuminate/view": "5.4.*|5.5.*|5.6.*",
                 "php": ">=5.6.4"
             },
             "require-dev": {
@@ -1682,7 +1753,7 @@
                 "validation",
                 "validator"
             ],
-            "time": "2017-08-30 20:59:15"
+            "time": "2018-02-26T21:06:15+00:00"
         },
         {
             "name": "psr/container",
@@ -1731,7 +1802,7 @@
                 "container-interop",
                 "psr"
             ],
-            "time": "2017-02-14 16:28:37"
+            "time": "2017-02-14T16:28:37+00:00"
         },
         {
             "name": "psr/http-message",
@@ -1781,7 +1852,7 @@
                 "request",
                 "response"
             ],
-            "time": "2016-08-06 14:39:51"
+            "time": "2016-08-06T14:39:51+00:00"
         },
         {
             "name": "psr/log",
@@ -1828,20 +1899,20 @@
                 "psr",
                 "psr-3"
             ],
-            "time": "2016-10-10 12:19:37"
+            "time": "2016-10-10T12:19:37+00:00"
         },
         {
             "name": "psr/simple-cache",
-            "version": "1.0.0",
+            "version": "1.0.1",
             "source": {
                 "type": "git",
                 "url": "https://github.com/php-fig/simple-cache.git",
-                "reference": "753fa598e8f3b9966c886fe13f370baa45ef0e24"
+                "reference": "408d5eafb83c57f6365a3ca330ff23aa4a5fa39b"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/php-fig/simple-cache/zipball/753fa598e8f3b9966c886fe13f370baa45ef0e24",
-                "reference": "753fa598e8f3b9966c886fe13f370baa45ef0e24",
+                "url": "https://api.github.com/repos/php-fig/simple-cache/zipball/408d5eafb83c57f6365a3ca330ff23aa4a5fa39b",
+                "reference": "408d5eafb83c57f6365a3ca330ff23aa4a5fa39b",
                 "shasum": ""
             },
             "require": {
@@ -1876,20 +1947,20 @@
                 "psr-16",
                 "simple-cache"
             ],
-            "time": "2017-01-02 13:31:39"
+            "time": "2017-10-23T01:57:42+00:00"
         },
         {
             "name": "ramsey/uuid",
-            "version": "3.7.1",
+            "version": "3.7.3",
             "source": {
                 "type": "git",
                 "url": "https://github.com/ramsey/uuid.git",
-                "reference": "45cffe822057a09e05f7bd09ec5fb88eeecd2334"
+                "reference": "44abcdad877d9a46685a3a4d221e3b2c4b87cb76"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/ramsey/uuid/zipball/45cffe822057a09e05f7bd09ec5fb88eeecd2334",
-                "reference": "45cffe822057a09e05f7bd09ec5fb88eeecd2334",
+                "url": "https://api.github.com/repos/ramsey/uuid/zipball/44abcdad877d9a46685a3a4d221e3b2c4b87cb76",
+                "reference": "44abcdad877d9a46685a3a4d221e3b2c4b87cb76",
                 "shasum": ""
             },
             "require": {
@@ -1900,17 +1971,15 @@
                 "rhumsaa/uuid": "self.version"
             },
             "require-dev": {
-                "apigen/apigen": "^4.1",
-                "codeception/aspect-mock": "^1.0 | ^2.0",
+                "codeception/aspect-mock": "^1.0 | ~2.0.0",
                 "doctrine/annotations": "~1.2.0",
                 "goaop/framework": "1.0.0-alpha.2 | ^1.0 | ^2.1",
                 "ircmaxell/random-lib": "^1.1",
                 "jakub-onderka/php-parallel-lint": "^0.9.0",
-                "mockery/mockery": "^0.9.4",
+                "mockery/mockery": "^0.9.9",
                 "moontoast/math": "^1.1",
                 "php-mock/php-mock-phpunit": "^0.3|^1.1",
-                "phpunit/phpunit": "^4.7|>=5.0 <5.4",
-                "satooshi/php-coveralls": "^0.6.1",
+                "phpunit/phpunit": "^4.7|^5.0",
                 "squizlabs/php_codesniffer": "^2.3"
             },
             "suggest": {
@@ -1958,7 +2027,7 @@
                 "identifier",
                 "uuid"
             ],
-            "time": "2017-09-22 20:46:04"
+            "time": "2018-01-20T00:28:24+00:00"
         },
         {
             "name": "swiftmailer/swiftmailer",
@@ -2013,25 +2082,24 @@
                 "mail",
                 "mailer"
             ],
-            "time": "2017-09-30 22:39:41"
+            "time": "2017-09-30T22:39:41+00:00"
         },
         {
             "name": "symfony/console",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/console.git",
-                "reference": "9f21adfb92a9315b73ae2ed43138988ee4913d4e"
+                "reference": "555c8dbe0ae9e561740451eabdbed2cc554b6a51"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/console/zipball/9f21adfb92a9315b73ae2ed43138988ee4913d4e",
-                "reference": "9f21adfb92a9315b73ae2ed43138988ee4913d4e",
+                "url": "https://api.github.com/repos/symfony/console/zipball/555c8dbe0ae9e561740451eabdbed2cc554b6a51",
+                "reference": "555c8dbe0ae9e561740451eabdbed2cc554b6a51",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8",
-                "symfony/debug": "~2.8|~3.0|~4.0",
+                "php": "^7.1.3",
                 "symfony/polyfill-mbstring": "~1.0"
             },
             "conflict": {
@@ -2040,11 +2108,11 @@
             },
             "require-dev": {
                 "psr/log": "~1.0",
-                "symfony/config": "~3.3|~4.0",
+                "symfony/config": "~3.4|~4.0",
                 "symfony/dependency-injection": "~3.4|~4.0",
-                "symfony/event-dispatcher": "~2.8|~3.0|~4.0",
+                "symfony/event-dispatcher": "~3.4|~4.0",
                 "symfony/lock": "~3.4|~4.0",
-                "symfony/process": "~3.3|~4.0"
+                "symfony/process": "~3.4|~4.0"
             },
             "suggest": {
                 "psr/log": "For using the console logger",
@@ -2055,7 +2123,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2082,29 +2150,29 @@
             ],
             "description": "Symfony Console Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-14 19:40:10"
+            "time": "2018-02-26T15:55:47+00:00"
         },
         {
             "name": "symfony/css-selector",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/css-selector.git",
-                "reference": "eac760b414cf1f64362c3dd047b989e4db121332"
+                "reference": "c69f1e93aa898fd9fec627ebef467188151c8dc2"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/css-selector/zipball/eac760b414cf1f64362c3dd047b989e4db121332",
-                "reference": "eac760b414cf1f64362c3dd047b989e4db121332",
+                "url": "https://api.github.com/repos/symfony/css-selector/zipball/c69f1e93aa898fd9fec627ebef467188151c8dc2",
+                "reference": "c69f1e93aa898fd9fec627ebef467188151c8dc2",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8"
+                "php": "^7.1.3"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2135,36 +2203,36 @@
             ],
             "description": "Symfony CssSelector Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-14 19:40:10"
+            "time": "2018-02-03T14:58:37+00:00"
         },
         {
             "name": "symfony/debug",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/debug.git",
-                "reference": "543deab3ffff94402440b326fc94153bae2dfa7a"
+                "reference": "1721e4e7effb23480966690cdcdc7d2a4152d489"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/debug/zipball/543deab3ffff94402440b326fc94153bae2dfa7a",
-                "reference": "543deab3ffff94402440b326fc94153bae2dfa7a",
+                "url": "https://api.github.com/repos/symfony/debug/zipball/1721e4e7effb23480966690cdcdc7d2a4152d489",
+                "reference": "1721e4e7effb23480966690cdcdc7d2a4152d489",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8",
+                "php": "^7.1.3",
                 "psr/log": "~1.0"
             },
             "conflict": {
-                "symfony/http-kernel": ">=2.3,<2.3.24|~2.4.0|>=2.5,<2.5.9|>=2.6,<2.6.2"
+                "symfony/http-kernel": "<3.4"
             },
             "require-dev": {
-                "symfony/http-kernel": "~2.8|~3.0|~4.0"
+                "symfony/http-kernel": "~3.4|~4.0"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2191,20 +2259,20 @@
             ],
             "description": "Symfony Debug Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-12 08:27:14"
+            "time": "2018-02-28T21:50:02+00:00"
         },
         {
             "name": "symfony/event-dispatcher",
-            "version": "v4.0.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/event-dispatcher.git",
-                "reference": "d4face19ed8002eec8280bc1c5ec18130472bf43"
+                "reference": "85eaf6a8ec915487abac52e133efc4a268204428"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/event-dispatcher/zipball/d4face19ed8002eec8280bc1c5ec18130472bf43",
-                "reference": "d4face19ed8002eec8280bc1c5ec18130472bf43",
+                "url": "https://api.github.com/repos/symfony/event-dispatcher/zipball/85eaf6a8ec915487abac52e133efc4a268204428",
+                "reference": "85eaf6a8ec915487abac52e133efc4a268204428",
                 "shasum": ""
             },
             "require": {
@@ -2254,29 +2322,29 @@
             ],
             "description": "Symfony EventDispatcher Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-14 19:48:22"
+            "time": "2018-02-14T14:11:10+00:00"
         },
         {
             "name": "symfony/finder",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/finder.git",
-                "reference": "dac8d7db537bac7ad8143eb11360a8c2231f251a"
+                "reference": "44a796d2ecc2a16a5fc8f2956a34ee617934d55f"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/finder/zipball/dac8d7db537bac7ad8143eb11360a8c2231f251a",
-                "reference": "dac8d7db537bac7ad8143eb11360a8c2231f251a",
+                "url": "https://api.github.com/repos/symfony/finder/zipball/44a796d2ecc2a16a5fc8f2956a34ee617934d55f",
+                "reference": "44a796d2ecc2a16a5fc8f2956a34ee617934d55f",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8"
+                "php": "^7.1.3"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2303,34 +2371,33 @@
             ],
             "description": "Symfony Finder Component",
             "homepage": "https://symfony.com",
-            "time": "2017-11-05 16:10:10"
+            "time": "2018-03-05T18:28:26+00:00"
         },
         {
             "name": "symfony/http-foundation",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/http-foundation.git",
-                "reference": "59bf131b5460227a2f583a7dbe6b179f98f9e0a5"
+                "reference": "6c181e81a3a9a7996c62ebd7803592536e729c5a"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/http-foundation/zipball/59bf131b5460227a2f583a7dbe6b179f98f9e0a5",
-                "reference": "59bf131b5460227a2f583a7dbe6b179f98f9e0a5",
+                "url": "https://api.github.com/repos/symfony/http-foundation/zipball/6c181e81a3a9a7996c62ebd7803592536e729c5a",
+                "reference": "6c181e81a3a9a7996c62ebd7803592536e729c5a",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8",
-                "symfony/polyfill-mbstring": "~1.1",
-                "symfony/polyfill-php70": "~1.6"
+                "php": "^7.1.3",
+                "symfony/polyfill-mbstring": "~1.1"
             },
             "require-dev": {
-                "symfony/expression-language": "~2.8|~3.0|~4.0"
+                "symfony/expression-language": "~3.4|~4.0"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2357,33 +2424,33 @@
             ],
             "description": "Symfony HttpFoundation Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-14 19:40:10"
+            "time": "2018-03-05T16:01:10+00:00"
         },
         {
             "name": "symfony/http-kernel",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/http-kernel.git",
-                "reference": "48325096bbda77b983e642d21a4dd9bdde3ab73e"
+                "reference": "2a1ebfe8c37240500befcb17bceb3893adacffa3"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/http-kernel/zipball/48325096bbda77b983e642d21a4dd9bdde3ab73e",
-                "reference": "48325096bbda77b983e642d21a4dd9bdde3ab73e",
+                "url": "https://api.github.com/repos/symfony/http-kernel/zipball/2a1ebfe8c37240500befcb17bceb3893adacffa3",
+                "reference": "2a1ebfe8c37240500befcb17bceb3893adacffa3",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8",
+                "php": "^7.1.3",
                 "psr/log": "~1.0",
-                "symfony/debug": "~2.8|~3.0|~4.0",
-                "symfony/event-dispatcher": "~2.8|~3.0|~4.0",
-                "symfony/http-foundation": "^3.3.11|~4.0"
+                "symfony/debug": "~3.4|~4.0",
+                "symfony/event-dispatcher": "~3.4|~4.0",
+                "symfony/http-foundation": "~3.4.4|~4.0.4"
             },
             "conflict": {
-                "symfony/config": "<2.8",
-                "symfony/dependency-injection": "<3.4",
-                "symfony/var-dumper": "<3.3",
+                "symfony/config": "<3.4",
+                "symfony/dependency-injection": "<3.4.5|<4.0.5,>=4",
+                "symfony/var-dumper": "<3.4",
                 "twig/twig": "<1.34|<2.4,>=2"
             },
             "provide": {
@@ -2391,34 +2458,32 @@
             },
             "require-dev": {
                 "psr/cache": "~1.0",
-                "symfony/browser-kit": "~2.8|~3.0|~4.0",
-                "symfony/class-loader": "~2.8|~3.0",
-                "symfony/config": "~2.8|~3.0|~4.0",
-                "symfony/console": "~2.8|~3.0|~4.0",
-                "symfony/css-selector": "~2.8|~3.0|~4.0",
-                "symfony/dependency-injection": "~3.4|~4.0",
-                "symfony/dom-crawler": "~2.8|~3.0|~4.0",
-                "symfony/expression-language": "~2.8|~3.0|~4.0",
-                "symfony/finder": "~2.8|~3.0|~4.0",
-                "symfony/process": "~2.8|~3.0|~4.0",
+                "symfony/browser-kit": "~3.4|~4.0",
+                "symfony/config": "~3.4|~4.0",
+                "symfony/console": "~3.4|~4.0",
+                "symfony/css-selector": "~3.4|~4.0",
+                "symfony/dependency-injection": "^3.4.5|^4.0.5",
+                "symfony/dom-crawler": "~3.4|~4.0",
+                "symfony/expression-language": "~3.4|~4.0",
+                "symfony/finder": "~3.4|~4.0",
+                "symfony/process": "~3.4|~4.0",
                 "symfony/routing": "~3.4|~4.0",
-                "symfony/stopwatch": "~2.8|~3.0|~4.0",
-                "symfony/templating": "~2.8|~3.0|~4.0",
-                "symfony/translation": "~2.8|~3.0|~4.0",
-                "symfony/var-dumper": "~3.3|~4.0"
+                "symfony/stopwatch": "~3.4|~4.0",
+                "symfony/templating": "~3.4|~4.0",
+                "symfony/translation": "~3.4|~4.0",
+                "symfony/var-dumper": "~3.4|~4.0"
             },
             "suggest": {
                 "symfony/browser-kit": "",
                 "symfony/config": "",
                 "symfony/console": "",
                 "symfony/dependency-injection": "",
-                "symfony/finder": "",
                 "symfony/var-dumper": ""
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2445,20 +2510,20 @@
             ],
             "description": "Symfony HttpKernel Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-15 02:05:18"
+            "time": "2018-03-05T22:27:01+00:00"
         },
         {
             "name": "symfony/polyfill-mbstring",
-            "version": "v1.6.0",
+            "version": "v1.7.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/polyfill-mbstring.git",
-                "reference": "2ec8b39c38cb16674bbf3fea2b6ce5bf117e1296"
+                "reference": "78be803ce01e55d3491c1397cf1c64beb9c1b63b"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/2ec8b39c38cb16674bbf3fea2b6ce5bf117e1296",
-                "reference": "2ec8b39c38cb16674bbf3fea2b6ce5bf117e1296",
+                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/78be803ce01e55d3491c1397cf1c64beb9c1b63b",
+                "reference": "78be803ce01e55d3491c1397cf1c64beb9c1b63b",
                 "shasum": ""
             },
             "require": {
@@ -2470,7 +2535,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "1.6-dev"
+                    "dev-master": "1.7-dev"
                 }
             },
             "autoload": {
@@ -2504,20 +2569,20 @@
                 "portable",
                 "shim"
             ],
-            "time": "2017-10-11 12:05:26"
+            "time": "2018-01-30T19:27:44+00:00"
         },
         {
             "name": "symfony/polyfill-php56",
-            "version": "v1.6.0",
+            "version": "v1.7.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/polyfill-php56.git",
-                "reference": "265fc96795492430762c29be291a371494ba3a5b"
+                "reference": "ebc999ce5f14204c5150b9bd15f8f04e621409d8"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/polyfill-php56/zipball/265fc96795492430762c29be291a371494ba3a5b",
-                "reference": "265fc96795492430762c29be291a371494ba3a5b",
+                "url": "https://api.github.com/repos/symfony/polyfill-php56/zipball/ebc999ce5f14204c5150b9bd15f8f04e621409d8",
+                "reference": "ebc999ce5f14204c5150b9bd15f8f04e621409d8",
                 "shasum": ""
             },
             "require": {
@@ -2527,7 +2592,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "1.6-dev"
+                    "dev-master": "1.7-dev"
                 }
             },
             "autoload": {
@@ -2560,41 +2625,37 @@
                 "portable",
                 "shim"
             ],
-            "time": "2017-10-11 12:05:26"
+            "time": "2018-01-30T19:27:44+00:00"
         },
         {
-            "name": "symfony/polyfill-php70",
-            "version": "v1.6.0",
+            "name": "symfony/polyfill-php72",
+            "version": "v1.7.0",
             "source": {
                 "type": "git",
-                "url": "https://github.com/symfony/polyfill-php70.git",
-                "reference": "0442b9c0596610bd24ae7b5f0a6cdbbc16d9fcff"
+                "url": "https://github.com/symfony/polyfill-php72.git",
+                "reference": "8eca20c8a369e069d4f4c2ac9895144112867422"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/polyfill-php70/zipball/0442b9c0596610bd24ae7b5f0a6cdbbc16d9fcff",
-                "reference": "0442b9c0596610bd24ae7b5f0a6cdbbc16d9fcff",
+                "url": "https://api.github.com/repos/symfony/polyfill-php72/zipball/8eca20c8a369e069d4f4c2ac9895144112867422",
+                "reference": "8eca20c8a369e069d4f4c2ac9895144112867422",
                 "shasum": ""
             },
             "require": {
-                "paragonie/random_compat": "~1.0|~2.0",
                 "php": ">=5.3.3"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "1.6-dev"
+                    "dev-master": "1.7-dev"
                 }
             },
             "autoload": {
                 "psr-4": {
-                    "Symfony\\Polyfill\\Php70\\": ""
+                    "Symfony\\Polyfill\\Php72\\": ""
                 },
                 "files": [
                     "bootstrap.php"
-                ],
-                "classmap": [
-                    "Resources/stubs"
                 ]
             },
             "notification-url": "https://packagist.org/downloads/",
@@ -2611,7 +2672,7 @@
                     "homepage": "https://symfony.com/contributors"
                 }
             ],
-            "description": "Symfony polyfill backporting some PHP 7.0+ features to lower PHP versions",
+            "description": "Symfony polyfill backporting some PHP 7.2+ features to lower PHP versions",
             "homepage": "https://symfony.com",
             "keywords": [
                 "compatibility",
@@ -2619,20 +2680,20 @@
                 "portable",
                 "shim"
             ],
-            "time": "2017-10-11 12:05:26"
+            "time": "2018-01-31T17:43:24+00:00"
         },
         {
             "name": "symfony/polyfill-util",
-            "version": "v1.6.0",
+            "version": "v1.7.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/polyfill-util.git",
-                "reference": "6e719200c8e540e0c0effeb31f96bdb344b94176"
+                "reference": "e17c808ec4228026d4f5a8832afa19be85979563"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/polyfill-util/zipball/6e719200c8e540e0c0effeb31f96bdb344b94176",
-                "reference": "6e719200c8e540e0c0effeb31f96bdb344b94176",
+                "url": "https://api.github.com/repos/symfony/polyfill-util/zipball/e17c808ec4228026d4f5a8832afa19be85979563",
+                "reference": "e17c808ec4228026d4f5a8832afa19be85979563",
                 "shasum": ""
             },
             "require": {
@@ -2641,7 +2702,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "1.6-dev"
+                    "dev-master": "1.7-dev"
                 }
             },
             "autoload": {
@@ -2671,29 +2732,29 @@
                 "polyfill",
                 "shim"
             ],
-            "time": "2017-10-11 12:05:26"
+            "time": "2018-01-31T18:08:44+00:00"
         },
         {
             "name": "symfony/process",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/process.git",
-                "reference": "bb3ef65d493a6d57297cad6c560ee04e2a8f5098"
+                "reference": "6ed08502a7c9559da8e60ea343bdbd19c3350b3e"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/process/zipball/bb3ef65d493a6d57297cad6c560ee04e2a8f5098",
-                "reference": "bb3ef65d493a6d57297cad6c560ee04e2a8f5098",
+                "url": "https://api.github.com/repos/symfony/process/zipball/6ed08502a7c9559da8e60ea343bdbd19c3350b3e",
+                "reference": "6ed08502a7c9559da8e60ea343bdbd19c3350b3e",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8"
+                "php": "^7.1.3"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2720,38 +2781,38 @@
             ],
             "description": "Symfony Process Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-14 19:40:10"
+            "time": "2018-02-19T12:18:43+00:00"
         },
         {
             "name": "symfony/routing",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/routing.git",
-                "reference": "5f248dfac5e4660c74982eb3dadc71cf58595570"
+                "reference": "9c6268c1970c7e507bedc8946bece32a7db23515"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/routing/zipball/5f248dfac5e4660c74982eb3dadc71cf58595570",
-                "reference": "5f248dfac5e4660c74982eb3dadc71cf58595570",
+                "url": "https://api.github.com/repos/symfony/routing/zipball/9c6268c1970c7e507bedc8946bece32a7db23515",
+                "reference": "9c6268c1970c7e507bedc8946bece32a7db23515",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8"
+                "php": "^7.1.3"
             },
             "conflict": {
-                "symfony/config": "<2.8",
-                "symfony/dependency-injection": "<3.3",
+                "symfony/config": "<3.4",
+                "symfony/dependency-injection": "<3.4",
                 "symfony/yaml": "<3.4"
             },
             "require-dev": {
                 "doctrine/annotations": "~1.0",
                 "doctrine/common": "~2.2",
                 "psr/log": "~1.0",
-                "symfony/config": "~2.8|~3.0|~4.0",
-                "symfony/dependency-injection": "~3.3|~4.0",
-                "symfony/expression-language": "~2.8|~3.0|~4.0",
-                "symfony/http-foundation": "~2.8|~3.0|~4.0",
+                "symfony/config": "~3.4|~4.0",
+                "symfony/dependency-injection": "~3.4|~4.0",
+                "symfony/expression-language": "~3.4|~4.0",
+                "symfony/http-foundation": "~3.4|~4.0",
                 "symfony/yaml": "~3.4|~4.0"
             },
             "suggest": {
@@ -2765,7 +2826,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2798,37 +2859,37 @@
                 "uri",
                 "url"
             ],
-            "time": "2017-12-14 22:37:31"
+            "time": "2018-02-28T21:50:02+00:00"
         },
         {
             "name": "symfony/translation",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/translation.git",
-                "reference": "4c5d5582baf2829751a5207659329c1f52eedeb6"
+                "reference": "e20a9b7f9f62cb33a11638b345c248e7d510c938"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/translation/zipball/4c5d5582baf2829751a5207659329c1f52eedeb6",
-                "reference": "4c5d5582baf2829751a5207659329c1f52eedeb6",
+                "url": "https://api.github.com/repos/symfony/translation/zipball/e20a9b7f9f62cb33a11638b345c248e7d510c938",
+                "reference": "e20a9b7f9f62cb33a11638b345c248e7d510c938",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8",
+                "php": "^7.1.3",
                 "symfony/polyfill-mbstring": "~1.0"
             },
             "conflict": {
-                "symfony/config": "<2.8",
+                "symfony/config": "<3.4",
                 "symfony/dependency-injection": "<3.4",
                 "symfony/yaml": "<3.4"
             },
             "require-dev": {
                 "psr/log": "~1.0",
-                "symfony/config": "~2.8|~3.0|~4.0",
+                "symfony/config": "~3.4|~4.0",
                 "symfony/dependency-injection": "~3.4|~4.0",
                 "symfony/finder": "~2.8|~3.0|~4.0",
-                "symfony/intl": "^2.8.18|^3.2.5|~4.0",
+                "symfony/intl": "~3.4|~4.0",
                 "symfony/yaml": "~3.4|~4.0"
             },
             "suggest": {
@@ -2839,7 +2900,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2866,25 +2927,26 @@
             ],
             "description": "Symfony Translation Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-12 08:27:14"
+            "time": "2018-02-22T10:50:29+00:00"
         },
         {
             "name": "symfony/var-dumper",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/var-dumper.git",
-                "reference": "757074cf71b952ce9e75b557538948811c2bf006"
+                "reference": "c7d89044ed6ed3b7d8b558d509cca0666b947e58"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/var-dumper/zipball/757074cf71b952ce9e75b557538948811c2bf006",
-                "reference": "757074cf71b952ce9e75b557538948811c2bf006",
+                "url": "https://api.github.com/repos/symfony/var-dumper/zipball/c7d89044ed6ed3b7d8b558d509cca0666b947e58",
+                "reference": "c7d89044ed6ed3b7d8b558d509cca0666b947e58",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8",
-                "symfony/polyfill-mbstring": "~1.0"
+                "php": "^7.1.3",
+                "symfony/polyfill-mbstring": "~1.0",
+                "symfony/polyfill-php72": "~1.5"
             },
             "conflict": {
                 "phpunit/phpunit": "<4.8.35|<5.4.3,>=5.0"
@@ -2895,13 +2957,12 @@
             },
             "suggest": {
                 "ext-iconv": "To convert non-UTF-8 strings to UTF-8 (or symfony/polyfill-iconv in case ext-iconv cannot be used).",
-                "ext-intl": "To show region name in time zone dump",
-                "ext-symfony_debug": ""
+                "ext-intl": "To show region name in time zone dump"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -2935,33 +2996,33 @@
                 "debug",
                 "dump"
             ],
-            "time": "2017-12-11 22:06:16"
+            "time": "2018-02-26T15:55:47+00:00"
         },
         {
             "name": "tijsverkoyen/css-to-inline-styles",
-            "version": "2.2.0",
+            "version": "2.2.1",
             "source": {
                 "type": "git",
                 "url": "https://github.com/tijsverkoyen/CssToInlineStyles.git",
-                "reference": "ab03919dfd85a74ae0372f8baf9f3c7d5c03b04b"
+                "reference": "0ed4a2ea4e0902dac0489e6436ebcd5bbcae9757"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/tijsverkoyen/CssToInlineStyles/zipball/ab03919dfd85a74ae0372f8baf9f3c7d5c03b04b",
-                "reference": "ab03919dfd85a74ae0372f8baf9f3c7d5c03b04b",
+                "url": "https://api.github.com/repos/tijsverkoyen/CssToInlineStyles/zipball/0ed4a2ea4e0902dac0489e6436ebcd5bbcae9757",
+                "reference": "0ed4a2ea4e0902dac0489e6436ebcd5bbcae9757",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5 || ^7",
-                "symfony/css-selector": "^2.7|~3.0"
+                "php": "^5.5 || ^7.0",
+                "symfony/css-selector": "^2.7 || ^3.0 || ^4.0"
             },
             "require-dev": {
-                "phpunit/phpunit": "~4.8|5.1.*"
+                "phpunit/phpunit": "^4.8.35 || ^5.7 || ^6.0"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "2.0.x-dev"
+                    "dev-master": "2.2.x-dev"
                 }
             },
             "autoload": {
@@ -2982,37 +3043,38 @@
             ],
             "description": "CssToInlineStyles is a class that enables you to convert HTML-pages/files into HTML-pages/files with inline styles. This is very useful when you're sending emails.",
             "homepage": "https://github.com/tijsverkoyen/CssToInlineStyles",
-            "time": "2016-09-20 12:50:39"
+            "time": "2017-11-27T11:13:29+00:00"
         },
         {
             "name": "tymon/jwt-auth",
-            "version": "1.0.0-rc.1",
+            "version": "1.0.0-rc.2",
             "source": {
                 "type": "git",
                 "url": "https://github.com/tymondesigns/jwt-auth.git",
-                "reference": "6adc5c9df836405c47abc2f4c836872effb71ead"
+                "reference": "d5220f6a84cbb8300f6f2f0f20aa908d072b4e4b"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/tymondesigns/jwt-auth/zipball/6adc5c9df836405c47abc2f4c836872effb71ead",
-                "reference": "6adc5c9df836405c47abc2f4c836872effb71ead",
+                "url": "https://api.github.com/repos/tymondesigns/jwt-auth/zipball/d5220f6a84cbb8300f6f2f0f20aa908d072b4e4b",
+                "reference": "d5220f6a84cbb8300f6f2f0f20aa908d072b4e4b",
                 "shasum": ""
             },
             "require": {
-                "illuminate/auth": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.*",
-                "illuminate/contracts": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.*",
-                "illuminate/http": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.*",
-                "illuminate/support": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.*",
+                "illuminate/auth": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.* || 5.6.*",
+                "illuminate/contracts": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.* || 5.6.*",
+                "illuminate/http": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.* || 5.6.*",
+                "illuminate/support": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.* || 5.6.*",
+                "lcobucci/jwt": "^3.2",
                 "namshi/jose": "^7.0",
                 "nesbot/carbon": "^1.0",
                 "php": "^5.5.9 || ^7.0"
             },
             "require-dev": {
                 "cartalyst/sentinel": "2.0.*",
-                "illuminate/console": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.*",
-                "illuminate/database": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.*",
-                "illuminate/routing": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.*",
-                "mockery/mockery": "0.9.*",
+                "illuminate/console": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.* || 5.6.*",
+                "illuminate/database": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.* || 5.6.*",
+                "illuminate/routing": "5.1.* || 5.2.* || 5.3.* || 5.4.* || 5.5.* || 5.6.*",
+                "mockery/mockery": ">=0.9.9",
                 "phpunit/phpunit": "~4.8 || ~6.0"
             },
             "type": "library",
@@ -3056,7 +3118,7 @@
                 "jwt",
                 "laravel"
             ],
-            "time": "2017-08-30 17:57:47"
+            "time": "2018-02-07T20:55:14+00:00"
         },
         {
             "name": "vlucas/phpdotenv",
@@ -3106,26 +3168,36 @@
                 "env",
                 "environment"
             ],
-            "time": "2016-09-01 10:05:43"
+            "time": "2016-09-01T10:05:43+00:00"
         },
         {
             "name": "webpatser/laravel-countries",
-            "version": "1.5.2",
+            "version": "dev-master",
             "source": {
                 "type": "git",
-                "url": "https://github.com/webpatser/laravel-countries.git",
-                "reference": "bb5d5116d796a038bfb45f083998b25506d9a595"
+                "url": "https://github.com/loshmis/laravel-countries.git",
+                "reference": "34ef71ca9b44f1257d8e7b427df7b4b5e425b7c2"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/webpatser/laravel-countries/zipball/bb5d5116d796a038bfb45f083998b25506d9a595",
-                "reference": "bb5d5116d796a038bfb45f083998b25506d9a595",
+                "url": "https://api.github.com/repos/loshmis/laravel-countries/zipball/34ef71ca9b44f1257d8e7b427df7b4b5e425b7c2",
+                "reference": "34ef71ca9b44f1257d8e7b427df7b4b5e425b7c2",
                 "shasum": ""
             },
             "require": {
                 "php": ">=5.3.0"
             },
             "type": "library",
+            "extra": {
+                "laravel": {
+                    "providers": [
+                        "Webpatser\\Countries\\CountriesServiceProvider"
+                    ],
+                    "aliases": {
+                        "Countries": "Webpatser\\Countries\\CountriesFacade"
+                    }
+                }
+            },
             "autoload": {
                 "psr-0": {
                     "Webpatser\\Countries": "src/"
@@ -3134,7 +3206,6 @@
                     "src/commands"
                 ]
             },
-            "notification-url": "https://packagist.org/downloads/",
             "license": [
                 "MIT"
             ],
@@ -3158,32 +3229,36 @@
                 "iso_3166_3",
                 "laravel"
             ],
-            "time": "2017-01-25 20:26:35"
+            "support": {
+                "source": "https://github.com/webpatser/laravel-countries",
+                "issues": "https://github.com/webpatser/laravel-countries/issues"
+            },
+            "time": "2018-03-12T20:08:04+00:00"
         }
     ],
     "packages-dev": [
         {
             "name": "barryvdh/laravel-debugbar",
-            "version": "v3.1.0",
+            "version": "v3.1.3",
             "source": {
                 "type": "git",
                 "url": "https://github.com/barryvdh/laravel-debugbar.git",
-                "reference": "01a859752094e00aa8548832312366753272f8af"
+                "reference": "664fa434e26febf04d60df0368303cf0fe14f63a"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/barryvdh/laravel-debugbar/zipball/01a859752094e00aa8548832312366753272f8af",
-                "reference": "01a859752094e00aa8548832312366753272f8af",
+                "url": "https://api.github.com/repos/barryvdh/laravel-debugbar/zipball/664fa434e26febf04d60df0368303cf0fe14f63a",
+                "reference": "664fa434e26febf04d60df0368303cf0fe14f63a",
                 "shasum": ""
             },
             "require": {
-                "illuminate/routing": "5.5.x",
-                "illuminate/session": "5.5.x",
-                "illuminate/support": "5.5.x",
-                "maximebf/debugbar": "~1.14.0",
+                "illuminate/routing": "5.5.x|5.6.x",
+                "illuminate/session": "5.5.x|5.6.x",
+                "illuminate/support": "5.5.x|5.6.x",
+                "maximebf/debugbar": "~1.15.0",
                 "php": ">=7.0",
-                "symfony/debug": "^3",
-                "symfony/finder": "^3"
+                "symfony/debug": "^3|^4",
+                "symfony/finder": "^3|^4"
             },
             "require-dev": {
                 "illuminate/framework": "5.5.x"
@@ -3191,7 +3266,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.0-dev"
+                    "dev-master": "3.2-dev"
                 },
                 "laravel": {
                     "providers": [
@@ -3228,34 +3303,34 @@
                 "profiler",
                 "webprofiler"
             ],
-            "time": "2017-09-18 13:32:46"
+            "time": "2018-02-25T13:31:58+00:00"
         },
         {
             "name": "barryvdh/laravel-ide-helper",
-            "version": "v2.4.1",
+            "version": "v2.4.3",
             "source": {
                 "type": "git",
                 "url": "https://github.com/barryvdh/laravel-ide-helper.git",
-                "reference": "2b1273c45e2f8df7a625563e2283a17c14f02ae8"
+                "reference": "5c304db44fba8e9c4aa0c09739e59f7be7736fdd"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/barryvdh/laravel-ide-helper/zipball/2b1273c45e2f8df7a625563e2283a17c14f02ae8",
-                "reference": "2b1273c45e2f8df7a625563e2283a17c14f02ae8",
+                "url": "https://api.github.com/repos/barryvdh/laravel-ide-helper/zipball/5c304db44fba8e9c4aa0c09739e59f7be7736fdd",
+                "reference": "5c304db44fba8e9c4aa0c09739e59f7be7736fdd",
                 "shasum": ""
             },
             "require": {
                 "barryvdh/reflection-docblock": "^2.0.4",
-                "illuminate/console": "^5.0,<5.6",
-                "illuminate/filesystem": "^5.0,<5.6",
-                "illuminate/support": "^5.0,<5.6",
+                "illuminate/console": "^5.0,<5.7",
+                "illuminate/filesystem": "^5.0,<5.7",
+                "illuminate/support": "^5.0,<5.7",
                 "php": ">=5.4.0",
                 "symfony/class-loader": "^2.3|^3.0"
             },
             "require-dev": {
                 "doctrine/dbal": "~2.3",
-                "illuminate/config": "^5.0,<5.6",
-                "illuminate/view": "^5.0,<5.6",
+                "illuminate/config": "^5.0,<5.7",
+                "illuminate/view": "^5.0,<5.7",
                 "phpunit/phpunit": "4.*",
                 "scrutinizer/ocular": "~1.1",
                 "squizlabs/php_codesniffer": "~2.3"
@@ -3301,7 +3376,7 @@
                 "phpstorm",
                 "sublime"
             ],
-            "time": "2017-07-16 00:24:12"
+            "time": "2018-02-08T07:56:07+00:00"
         },
         {
             "name": "barryvdh/reflection-docblock",
@@ -3350,7 +3425,7 @@
                     "email": "mike.vanriel@naenius.com"
                 }
             ],
-            "time": "2016-06-13 19:28:20"
+            "time": "2016-06-13T19:28:20+00:00"
         },
         {
             "name": "doctrine/instantiator",
@@ -3404,7 +3479,7 @@
                 "constructor",
                 "instantiate"
             ],
-            "time": "2017-07-22 11:58:36"
+            "time": "2017-07-22T11:58:36+00:00"
         },
         {
             "name": "filp/whoops",
@@ -3465,7 +3540,7 @@
                 "throwable",
                 "whoops"
             ],
-            "time": "2017-11-23 18:22:44"
+            "time": "2017-11-23T18:22:44+00:00"
         },
         {
             "name": "fzaninotto/faker",
@@ -3515,7 +3590,7 @@
                 "faker",
                 "fixtures"
             ],
-            "time": "2017-08-15 16:48:10"
+            "time": "2017-08-15T16:48:10+00:00"
         },
         {
             "name": "hamcrest/hamcrest-php",
@@ -3560,32 +3635,32 @@
             "keywords": [
                 "test"
             ],
-            "time": "2015-05-11 14:41:42"
+            "time": "2015-05-11T14:41:42+00:00"
         },
         {
             "name": "laravel/browser-kit-testing",
-            "version": "v2.0.1",
+            "version": "v4.0.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/laravel/browser-kit-testing.git",
-                "reference": "f0bb9f200ec35f9d876ded6eacfbc60868d311b9"
+                "reference": "3ea22c4da537ca8af83746d583360e8e00081a01"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/laravel/browser-kit-testing/zipball/f0bb9f200ec35f9d876ded6eacfbc60868d311b9",
-                "reference": "f0bb9f200ec35f9d876ded6eacfbc60868d311b9",
+                "url": "https://api.github.com/repos/laravel/browser-kit-testing/zipball/3ea22c4da537ca8af83746d583360e8e00081a01",
+                "reference": "3ea22c4da537ca8af83746d583360e8e00081a01",
                 "shasum": ""
             },
             "require": {
-                "php": ">=5.5.9",
-                "phpunit/phpunit": "~6.0",
-                "symfony/css-selector": "~3.1",
-                "symfony/dom-crawler": "~3.1"
+                "php": ">=7.1.3",
+                "phpunit/phpunit": "~7.0",
+                "symfony/css-selector": "~4.0",
+                "symfony/dom-crawler": "~4.0"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "2.0-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -3608,26 +3683,26 @@
                 "laravel",
                 "testing"
             ],
-            "time": "2017-06-21 11:44:53"
+            "time": "2018-02-08T16:44:18+00:00"
         },
         {
             "name": "maximebf/debugbar",
-            "version": "v1.14.1",
+            "version": "v1.15.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/maximebf/php-debugbar.git",
-                "reference": "64251a392344e3d22f3d21c3b7c531ba96eb01d2"
+                "reference": "30e7d60937ee5f1320975ca9bc7bcdd44d500f07"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/maximebf/php-debugbar/zipball/64251a392344e3d22f3d21c3b7c531ba96eb01d2",
-                "reference": "64251a392344e3d22f3d21c3b7c531ba96eb01d2",
+                "url": "https://api.github.com/repos/maximebf/php-debugbar/zipball/30e7d60937ee5f1320975ca9bc7bcdd44d500f07",
+                "reference": "30e7d60937ee5f1320975ca9bc7bcdd44d500f07",
                 "shasum": ""
             },
             "require": {
                 "php": ">=5.3.0",
                 "psr/log": "^1.0",
-                "symfony/var-dumper": "^2.6|^3.0"
+                "symfony/var-dumper": "^2.6|^3.0|^4.0"
             },
             "require-dev": {
                 "phpunit/phpunit": "^4.0|^5.0"
@@ -3669,7 +3744,7 @@
                 "debug",
                 "debugbar"
             ],
-            "time": "2017-09-13 12:19:36"
+            "time": "2017-12-15T11:13:46+00:00"
         },
         {
             "name": "mockery/mockery",
@@ -3734,7 +3809,7 @@
                 "test double",
                 "testing"
             ],
-            "time": "2017-02-28 12:52:32"
+            "time": "2017-02-28T12:52:32+00:00"
         },
         {
             "name": "myclabs/deep-copy",
@@ -3779,7 +3854,7 @@
                 "object",
                 "object graph"
             ],
-            "time": "2017-10-19 19:58:43"
+            "time": "2017-10-19T19:58:43+00:00"
         },
         {
             "name": "phar-io/manifest",
@@ -3834,7 +3909,7 @@
                 }
             ],
             "description": "Component for reading phar.io manifest information from a PHP Archive (PHAR)",
-            "time": "2017-03-05 18:14:27"
+            "time": "2017-03-05T18:14:27+00:00"
         },
         {
             "name": "phar-io/version",
@@ -3881,7 +3956,7 @@
                 }
             ],
             "description": "Library for handling version information and constraints",
-            "time": "2017-03-05 17:38:23"
+            "time": "2017-03-05T17:38:23+00:00"
         },
         {
             "name": "phpdocumentor/reflection-common",
@@ -3935,20 +4010,20 @@
                 "reflection",
                 "static analysis"
             ],
-            "time": "2017-09-11 18:02:19"
+            "time": "2017-09-11T18:02:19+00:00"
         },
         {
             "name": "phpdocumentor/reflection-docblock",
-            "version": "4.2.0",
+            "version": "4.3.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/phpDocumentor/ReflectionDocBlock.git",
-                "reference": "66465776cfc249844bde6d117abff1d22e06c2da"
+                "reference": "94fd0001232e47129dd3504189fa1c7225010d08"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/phpDocumentor/ReflectionDocBlock/zipball/66465776cfc249844bde6d117abff1d22e06c2da",
-                "reference": "66465776cfc249844bde6d117abff1d22e06c2da",
+                "url": "https://api.github.com/repos/phpDocumentor/ReflectionDocBlock/zipball/94fd0001232e47129dd3504189fa1c7225010d08",
+                "reference": "94fd0001232e47129dd3504189fa1c7225010d08",
                 "shasum": ""
             },
             "require": {
@@ -3986,7 +4061,7 @@
                 }
             ],
             "description": "With this component, a library can provide support for annotations via DocBlocks or otherwise retrieve information that is embedded in a DocBlock.",
-            "time": "2017-11-27 17:38:31"
+            "time": "2017-11-30T07:14:17+00:00"
         },
         {
             "name": "phpdocumentor/type-resolver",
@@ -4033,20 +4108,20 @@
                     "email": "me@mikevanriel.com"
                 }
             ],
-            "time": "2017-07-14 14:27:02"
+            "time": "2017-07-14T14:27:02+00:00"
         },
         {
             "name": "phpspec/prophecy",
-            "version": "1.7.3",
+            "version": "1.7.5",
             "source": {
                 "type": "git",
                 "url": "https://github.com/phpspec/prophecy.git",
-                "reference": "e4ed002c67da8eceb0eb8ddb8b3847bb53c5c2bf"
+                "reference": "dfd6be44111a7c41c2e884a336cc4f461b3b2401"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/phpspec/prophecy/zipball/e4ed002c67da8eceb0eb8ddb8b3847bb53c5c2bf",
-                "reference": "e4ed002c67da8eceb0eb8ddb8b3847bb53c5c2bf",
+                "url": "https://api.github.com/repos/phpspec/prophecy/zipball/dfd6be44111a7c41c2e884a336cc4f461b3b2401",
+                "reference": "dfd6be44111a7c41c2e884a336cc4f461b3b2401",
                 "shasum": ""
             },
             "require": {
@@ -4058,7 +4133,7 @@
             },
             "require-dev": {
                 "phpspec/phpspec": "^2.5|^3.2",
-                "phpunit/phpunit": "^4.8.35 || ^5.7"
+                "phpunit/phpunit": "^4.8.35 || ^5.7 || ^6.5"
             },
             "type": "library",
             "extra": {
@@ -4096,44 +4171,44 @@
                 "spy",
                 "stub"
             ],
-            "time": "2017-11-24 13:59:53"
+            "time": "2018-02-19T10:16:54+00:00"
         },
         {
             "name": "phpunit/php-code-coverage",
-            "version": "5.3.0",
+            "version": "6.0.1",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/php-code-coverage.git",
-                "reference": "661f34d0bd3f1a7225ef491a70a020ad23a057a1"
+                "reference": "f8ca4b604baf23dab89d87773c28cc07405189ba"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/php-code-coverage/zipball/661f34d0bd3f1a7225ef491a70a020ad23a057a1",
-                "reference": "661f34d0bd3f1a7225ef491a70a020ad23a057a1",
+                "url": "https://api.github.com/repos/sebastianbergmann/php-code-coverage/zipball/f8ca4b604baf23dab89d87773c28cc07405189ba",
+                "reference": "f8ca4b604baf23dab89d87773c28cc07405189ba",
                 "shasum": ""
             },
             "require": {
                 "ext-dom": "*",
                 "ext-xmlwriter": "*",
-                "php": "^7.0",
+                "php": "^7.1",
                 "phpunit/php-file-iterator": "^1.4.2",
                 "phpunit/php-text-template": "^1.2.1",
-                "phpunit/php-token-stream": "^2.0.1",
+                "phpunit/php-token-stream": "^3.0",
                 "sebastian/code-unit-reverse-lookup": "^1.0.1",
                 "sebastian/environment": "^3.0",
                 "sebastian/version": "^2.0.1",
                 "theseer/tokenizer": "^1.1"
             },
             "require-dev": {
-                "phpunit/phpunit": "^6.0"
+                "phpunit/phpunit": "^7.0"
             },
             "suggest": {
-                "ext-xdebug": "^2.5.5"
+                "ext-xdebug": "^2.6.0"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "5.3.x-dev"
+                    "dev-master": "6.0-dev"
                 }
             },
             "autoload": {
@@ -4159,7 +4234,7 @@
                 "testing",
                 "xunit"
             ],
-            "time": "2017-12-06 09:29:45"
+            "time": "2018-02-02T07:01:41+00:00"
         },
         {
             "name": "phpunit/php-file-iterator",
@@ -4206,7 +4281,7 @@
                 "filesystem",
                 "iterator"
             ],
-            "time": "2017-11-27 13:52:08"
+            "time": "2017-11-27T13:52:08+00:00"
         },
         {
             "name": "phpunit/php-text-template",
@@ -4247,32 +4322,32 @@
             "keywords": [
                 "template"
             ],
-            "time": "2015-06-21 13:50:34"
+            "time": "2015-06-21T13:50:34+00:00"
         },
         {
             "name": "phpunit/php-timer",
-            "version": "1.0.9",
+            "version": "2.0.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/php-timer.git",
-                "reference": "3dcf38ca72b158baf0bc245e9184d3fdffa9c46f"
+                "reference": "8b8454ea6958c3dee38453d3bd571e023108c91f"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/php-timer/zipball/3dcf38ca72b158baf0bc245e9184d3fdffa9c46f",
-                "reference": "3dcf38ca72b158baf0bc245e9184d3fdffa9c46f",
+                "url": "https://api.github.com/repos/sebastianbergmann/php-timer/zipball/8b8454ea6958c3dee38453d3bd571e023108c91f",
+                "reference": "8b8454ea6958c3dee38453d3bd571e023108c91f",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.3.3 || ^7.0"
+                "php": "^7.1"
             },
             "require-dev": {
-                "phpunit/phpunit": "^4.8.35 || ^5.7 || ^6.0"
+                "phpunit/phpunit": "^7.0"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "1.0-dev"
+                    "dev-master": "2.0-dev"
                 }
             },
             "autoload": {
@@ -4287,7 +4362,7 @@
             "authors": [
                 {
                     "name": "Sebastian Bergmann",
-                    "email": "sb@sebastian-bergmann.de",
+                    "email": "sebastian@phpunit.de",
                     "role": "lead"
                 }
             ],
@@ -4296,33 +4371,33 @@
             "keywords": [
                 "timer"
             ],
-            "time": "2017-02-26 11:10:40"
+            "time": "2018-02-01T13:07:23+00:00"
         },
         {
             "name": "phpunit/php-token-stream",
-            "version": "2.0.2",
+            "version": "3.0.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/php-token-stream.git",
-                "reference": "791198a2c6254db10131eecfe8c06670700904db"
+                "reference": "21ad88bbba7c3d93530d93994e0a33cd45f02ace"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/php-token-stream/zipball/791198a2c6254db10131eecfe8c06670700904db",
-                "reference": "791198a2c6254db10131eecfe8c06670700904db",
+                "url": "https://api.github.com/repos/sebastianbergmann/php-token-stream/zipball/21ad88bbba7c3d93530d93994e0a33cd45f02ace",
+                "reference": "21ad88bbba7c3d93530d93994e0a33cd45f02ace",
                 "shasum": ""
             },
             "require": {
                 "ext-tokenizer": "*",
-                "php": "^7.0"
+                "php": "^7.1"
             },
             "require-dev": {
-                "phpunit/phpunit": "^6.2.4"
+                "phpunit/phpunit": "^7.0"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "2.0-dev"
+                    "dev-master": "3.0-dev"
                 }
             },
             "autoload": {
@@ -4345,20 +4420,20 @@
             "keywords": [
                 "tokenizer"
             ],
-            "time": "2017-11-27 05:48:46"
+            "time": "2018-02-01T13:16:43+00:00"
         },
         {
             "name": "phpunit/phpunit",
-            "version": "6.5.5",
+            "version": "7.0.2",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/phpunit.git",
-                "reference": "83d27937a310f2984fd575686138597147bdc7df"
+                "reference": "e2f8aa21bc54b6ba218bdd4f9e0dac1e9bc3b4e9"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/phpunit/zipball/83d27937a310f2984fd575686138597147bdc7df",
-                "reference": "83d27937a310f2984fd575686138597147bdc7df",
+                "url": "https://api.github.com/repos/sebastianbergmann/phpunit/zipball/e2f8aa21bc54b6ba218bdd4f9e0dac1e9bc3b4e9",
+                "reference": "e2f8aa21bc54b6ba218bdd4f9e0dac1e9bc3b4e9",
                 "shasum": ""
             },
             "require": {
@@ -4370,15 +4445,15 @@
                 "myclabs/deep-copy": "^1.6.1",
                 "phar-io/manifest": "^1.0.1",
                 "phar-io/version": "^1.0",
-                "php": "^7.0",
+                "php": "^7.1",
                 "phpspec/prophecy": "^1.7",
-                "phpunit/php-code-coverage": "^5.3",
+                "phpunit/php-code-coverage": "^6.0",
                 "phpunit/php-file-iterator": "^1.4.3",
                 "phpunit/php-text-template": "^1.2.1",
-                "phpunit/php-timer": "^1.0.9",
-                "phpunit/phpunit-mock-objects": "^5.0.5",
+                "phpunit/php-timer": "^2.0",
+                "phpunit/phpunit-mock-objects": "^6.0",
                 "sebastian/comparator": "^2.1",
-                "sebastian/diff": "^2.0",
+                "sebastian/diff": "^3.0",
                 "sebastian/environment": "^3.1",
                 "sebastian/exporter": "^3.1",
                 "sebastian/global-state": "^2.0",
@@ -4386,16 +4461,12 @@
                 "sebastian/resource-operations": "^1.0",
                 "sebastian/version": "^2.0.1"
             },
-            "conflict": {
-                "phpdocumentor/reflection-docblock": "3.0.2",
-                "phpunit/dbunit": "<3.0"
-            },
             "require-dev": {
                 "ext-pdo": "*"
             },
             "suggest": {
                 "ext-xdebug": "*",
-                "phpunit/php-invoker": "^1.1"
+                "phpunit/php-invoker": "^2.0"
             },
             "bin": [
                 "phpunit"
@@ -4403,7 +4474,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "6.5.x-dev"
+                    "dev-master": "7.0-dev"
                 }
             },
             "autoload": {
@@ -4429,33 +4500,30 @@
                 "testing",
                 "xunit"
             ],
-            "time": "2017-12-17 06:31:19"
+            "time": "2018-02-26T07:03:12+00:00"
         },
         {
             "name": "phpunit/phpunit-mock-objects",
-            "version": "5.0.5",
+            "version": "6.0.1",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/phpunit-mock-objects.git",
-                "reference": "283b9f4f670e3a6fd6c4ff95c51a952eb5c75933"
+                "reference": "e3249dedc2d99259ccae6affbc2684eac37c2e53"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/phpunit-mock-objects/zipball/283b9f4f670e3a6fd6c4ff95c51a952eb5c75933",
-                "reference": "283b9f4f670e3a6fd6c4ff95c51a952eb5c75933",
+                "url": "https://api.github.com/repos/sebastianbergmann/phpunit-mock-objects/zipball/e3249dedc2d99259ccae6affbc2684eac37c2e53",
+                "reference": "e3249dedc2d99259ccae6affbc2684eac37c2e53",
                 "shasum": ""
             },
             "require": {
                 "doctrine/instantiator": "^1.0.5",
-                "php": "^7.0",
+                "php": "^7.1",
                 "phpunit/php-text-template": "^1.2.1",
                 "sebastian/exporter": "^3.1"
             },
-            "conflict": {
-                "phpunit/phpunit": "<6.0"
-            },
             "require-dev": {
-                "phpunit/phpunit": "^6.5"
+                "phpunit/phpunit": "^7.0"
             },
             "suggest": {
                 "ext-soap": "*"
@@ -4463,7 +4531,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "5.0.x-dev"
+                    "dev-master": "6.0.x-dev"
                 }
             },
             "autoload": {
@@ -4488,7 +4556,7 @@
                 "mock",
                 "xunit"
             ],
-            "time": "2017-12-10 08:01:53"
+            "time": "2018-02-15T05:27:38+00:00"
         },
         {
             "name": "sebastian/code-unit-reverse-lookup",
@@ -4533,25 +4601,25 @@
             ],
             "description": "Looks up which function or method a line of code belongs to",
             "homepage": "https://github.com/sebastianbergmann/code-unit-reverse-lookup/",
-            "time": "2017-03-04 06:30:41"
+            "time": "2017-03-04T06:30:41+00:00"
         },
         {
             "name": "sebastian/comparator",
-            "version": "2.1.0",
+            "version": "2.1.3",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/comparator.git",
-                "reference": "1174d9018191e93cb9d719edec01257fc05f8158"
+                "reference": "34369daee48eafb2651bea869b4b15d75ccc35f9"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/comparator/zipball/1174d9018191e93cb9d719edec01257fc05f8158",
-                "reference": "1174d9018191e93cb9d719edec01257fc05f8158",
+                "url": "https://api.github.com/repos/sebastianbergmann/comparator/zipball/34369daee48eafb2651bea869b4b15d75ccc35f9",
+                "reference": "34369daee48eafb2651bea869b4b15d75ccc35f9",
                 "shasum": ""
             },
             "require": {
                 "php": "^7.0",
-                "sebastian/diff": "^2.0",
+                "sebastian/diff": "^2.0 || ^3.0",
                 "sebastian/exporter": "^3.1"
             },
             "require-dev": {
@@ -4597,32 +4665,33 @@
                 "compare",
                 "equality"
             ],
-            "time": "2017-11-03 07:16:52"
+            "time": "2018-02-01T13:46:46+00:00"
         },
         {
             "name": "sebastian/diff",
-            "version": "2.0.1",
+            "version": "3.0.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/diff.git",
-                "reference": "347c1d8b49c5c3ee30c7040ea6fc446790e6bddd"
+                "reference": "e09160918c66281713f1c324c1f4c4c3037ba1e8"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/diff/zipball/347c1d8b49c5c3ee30c7040ea6fc446790e6bddd",
-                "reference": "347c1d8b49c5c3ee30c7040ea6fc446790e6bddd",
+                "url": "https://api.github.com/repos/sebastianbergmann/diff/zipball/e09160918c66281713f1c324c1f4c4c3037ba1e8",
+                "reference": "e09160918c66281713f1c324c1f4c4c3037ba1e8",
                 "shasum": ""
             },
             "require": {
-                "php": "^7.0"
+                "php": "^7.1"
             },
             "require-dev": {
-                "phpunit/phpunit": "^6.2"
+                "phpunit/phpunit": "^7.0",
+                "symfony/process": "^2 || ^3.3 || ^4"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "2.0-dev"
+                    "dev-master": "3.0-dev"
                 }
             },
             "autoload": {
@@ -4647,9 +4716,12 @@
             "description": "Diff implementation",
             "homepage": "https://github.com/sebastianbergmann/diff",
             "keywords": [
-                "diff"
+                "diff",
+                "udiff",
+                "unidiff",
+                "unified diff"
             ],
-            "time": "2017-08-03 08:09:46"
+            "time": "2018-02-01T13:45:15+00:00"
         },
         {
             "name": "sebastian/environment",
@@ -4699,7 +4771,7 @@
                 "environment",
                 "hhvm"
             ],
-            "time": "2017-07-01 08:51:00"
+            "time": "2017-07-01T08:51:00+00:00"
         },
         {
             "name": "sebastian/exporter",
@@ -4766,7 +4838,7 @@
                 "export",
                 "exporter"
             ],
-            "time": "2017-04-03 13:19:02"
+            "time": "2017-04-03T13:19:02+00:00"
         },
         {
             "name": "sebastian/global-state",
@@ -4817,7 +4889,7 @@
             "keywords": [
                 "global state"
             ],
-            "time": "2017-04-27 15:39:26"
+            "time": "2017-04-27T15:39:26+00:00"
         },
         {
             "name": "sebastian/object-enumerator",
@@ -4864,7 +4936,7 @@
             ],
             "description": "Traverses array structures and object graphs to enumerate all referenced objects",
             "homepage": "https://github.com/sebastianbergmann/object-enumerator/",
-            "time": "2017-08-03 12:35:26"
+            "time": "2017-08-03T12:35:26+00:00"
         },
         {
             "name": "sebastian/object-reflector",
@@ -4909,7 +4981,7 @@
             ],
             "description": "Allows reflection of object attributes, including inherited and non-public ones",
             "homepage": "https://github.com/sebastianbergmann/object-reflector/",
-            "time": "2017-03-29 09:07:27"
+            "time": "2017-03-29T09:07:27+00:00"
         },
         {
             "name": "sebastian/recursion-context",
@@ -4962,7 +5034,7 @@
             ],
             "description": "Provides functionality to recursively process PHP variables",
             "homepage": "http://www.github.com/sebastianbergmann/recursion-context",
-            "time": "2017-03-03 06:23:57"
+            "time": "2017-03-03T06:23:57+00:00"
         },
         {
             "name": "sebastian/resource-operations",
@@ -5004,7 +5076,7 @@
             ],
             "description": "Provides a list of PHP built-in functions that operate on resources",
             "homepage": "https://www.github.com/sebastianbergmann/resource-operations",
-            "time": "2015-07-28 20:34:47"
+            "time": "2015-07-28T20:34:47+00:00"
         },
         {
             "name": "sebastian/version",
@@ -5047,20 +5119,20 @@
             ],
             "description": "Library that helps with managing the version number of Git-hosted PHP projects",
             "homepage": "https://github.com/sebastianbergmann/version",
-            "time": "2016-10-03 07:35:21"
+            "time": "2016-10-03T07:35:21+00:00"
         },
         {
             "name": "symfony/class-loader",
-            "version": "v3.4.2",
+            "version": "v3.4.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/class-loader.git",
-                "reference": "e8d36a7b5568d232f5c3f8ef92665836b9f1e038"
+                "reference": "e63c12699822bb3b667e7216ba07fbcc3a3e203e"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/class-loader/zipball/e8d36a7b5568d232f5c3f8ef92665836b9f1e038",
-                "reference": "e8d36a7b5568d232f5c3f8ef92665836b9f1e038",
+                "url": "https://api.github.com/repos/symfony/class-loader/zipball/e63c12699822bb3b667e7216ba07fbcc3a3e203e",
+                "reference": "e63c12699822bb3b667e7216ba07fbcc3a3e203e",
                 "shasum": ""
             },
             "require": {
@@ -5103,28 +5175,28 @@
             ],
             "description": "Symfony ClassLoader Component",
             "homepage": "https://symfony.com",
-            "time": "2017-11-05 16:10:10"
+            "time": "2018-01-03T07:37:34+00:00"
         },
         {
             "name": "symfony/dom-crawler",
-            "version": "v3.4.2",
+            "version": "v4.0.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/dom-crawler.git",
-                "reference": "dc847845c66fa68ad4522ed27e62b9b9dd12ab3b"
+                "reference": "26726ddc01601dc9393f2afc3369ce1ca64e4537"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/dom-crawler/zipball/dc847845c66fa68ad4522ed27e62b9b9dd12ab3b",
-                "reference": "dc847845c66fa68ad4522ed27e62b9b9dd12ab3b",
+                "url": "https://api.github.com/repos/symfony/dom-crawler/zipball/26726ddc01601dc9393f2afc3369ce1ca64e4537",
+                "reference": "26726ddc01601dc9393f2afc3369ce1ca64e4537",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.5.9|>=7.0.8",
+                "php": "^7.1.3",
                 "symfony/polyfill-mbstring": "~1.0"
             },
             "require-dev": {
-                "symfony/css-selector": "~2.8|~3.0|~4.0"
+                "symfony/css-selector": "~3.4|~4.0"
             },
             "suggest": {
                 "symfony/css-selector": ""
@@ -5132,7 +5204,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.4-dev"
+                    "dev-master": "4.0-dev"
                 }
             },
             "autoload": {
@@ -5159,7 +5231,7 @@
             ],
             "description": "Symfony DomCrawler Component",
             "homepage": "https://symfony.com",
-            "time": "2017-12-14 19:40:10"
+            "time": "2018-02-22T10:50:29+00:00"
         },
         {
             "name": "theseer/tokenizer",
@@ -5199,20 +5271,20 @@
                 }
             ],
             "description": "A small library for converting tokenized PHP source code into XML and potentially other formats",
-            "time": "2017-04-07 12:08:54"
+            "time": "2017-04-07T12:08:54+00:00"
         },
         {
             "name": "webmozart/assert",
-            "version": "1.2.0",
+            "version": "1.3.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/webmozart/assert.git",
-                "reference": "2db61e59ff05fe5126d152bd0655c9ea113e550f"
+                "reference": "0df1908962e7a3071564e857d86874dad1ef204a"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/webmozart/assert/zipball/2db61e59ff05fe5126d152bd0655c9ea113e550f",
-                "reference": "2db61e59ff05fe5126d152bd0655c9ea113e550f",
+                "url": "https://api.github.com/repos/webmozart/assert/zipball/0df1908962e7a3071564e857d86874dad1ef204a",
+                "reference": "0df1908962e7a3071564e857d86874dad1ef204a",
                 "shasum": ""
             },
             "require": {
@@ -5249,18 +5321,19 @@
                 "check",
                 "validate"
             ],
-            "time": "2016-11-23 20:04:58"
+            "time": "2018-01-29T19:49:41+00:00"
         }
     ],
     "aliases": [],
     "minimum-stability": "stable",
     "stability-flags": {
+        "webpatser/laravel-countries": 20,
         "tymon/jwt-auth": 5
     },
     "prefer-stable": false,
     "prefer-lowest": false,
     "platform": {
-        "php": ">=7.0.0"
+        "php": ">=7.1.3"
     },
     "platform-dev": []
 }
diff --git a/config/app.php b/config/app.php
index f8ccbe4..d396220 100644
--- a/config/app.php
+++ b/config/app.php
@@ -23,7 +23,7 @@ return [
     | Vanguard Version
     |--------------------------------------------------------------------------
     */
-    'version' => '2.1.1',
+    'version' => '2.2.0',
 
     /*
     |--------------------------------------------------------------------------
@@ -132,21 +132,6 @@ return [
 
     'cipher' => 'AES-256-CBC',
 
-    /*
-    |--------------------------------------------------------------------------
-    | Logging Configuration
-    |--------------------------------------------------------------------------
-    |
-    | Here you may configure the log settings for your application. Out of
-    | the box, Laravel uses the Monolog PHP logging library. This gives
-    | you a variety of powerful log handlers / formatters to utilize.
-    |
-    | Available Settings: "single", "daily", "syslog", "errorlog"
-    |
-    */
-
-    'log' => 'daily',
-
     /*
     |--------------------------------------------------------------------------
     | Autoloaded Service Providers
diff --git a/config/broadcasting.php b/config/broadcasting.php
index e34e07d..43b5d08 100644
--- a/config/broadcasting.php
+++ b/config/broadcasting.php
@@ -47,6 +47,9 @@ return [
             'driver' => 'log',
         ],
 
+        'null' => [
+            'driver' => 'null',
+        ],
     ],
 
 ];
diff --git a/config/filesystems.php b/config/filesystems.php
index 0da6f97..e5f6e50 100644
--- a/config/filesystems.php
+++ b/config/filesystems.php
@@ -71,10 +71,11 @@ return [
 
         's3' => [
             'driver' => 's3',
-            'key'    => 'your-key',
-            'secret' => 'your-secret',
-            'region' => 'your-region',
-            'bucket' => 'your-bucket',
+            'key' => env('AWS_ACCESS_KEY_ID'),
+            'secret' => env('AWS_SECRET_ACCESS_KEY'),
+            'region' => env('AWS_DEFAULT_REGION'),
+            'bucket' => env('AWS_BUCKET'),
+            'url' => env('AWS_URL'),
         ],
 
         'rackspace' => [
diff --git a/config/hashing.php b/config/hashing.php
new file mode 100644
index 0000000..f929cf0
--- /dev/null
+++ b/config/hashing.php
@@ -0,0 +1,20 @@
+<?php
+
+return [
+
+    /*
+    |--------------------------------------------------------------------------
+    | Default Hash Driver
+    |--------------------------------------------------------------------------
+    |
+    | This option controls the default hash driver that will be used to hash
+    | passwords for your application. By default, the bcrypt algorithm is
+    | used; however, you remain free to modify this option if you wish.
+    |
+    | Supported: "bcrypt", "argon"
+    |
+    */
+
+    'driver' => 'bcrypt',
+
+];
diff --git a/config/logging.php b/config/logging.php
new file mode 100644
index 0000000..902efaf
--- /dev/null
+++ b/config/logging.php
@@ -0,0 +1,70 @@
+<?php
+
+return [
+
+    /*
+    |--------------------------------------------------------------------------
+    | Default Log Channel
+    |--------------------------------------------------------------------------
+    |
+    | This option defines the default log channel that gets used when writing
+    | messages to the logs. The name specified in this option should match
+    | one of the channels defined in the "channels" configuration array.
+    |
+    */
+
+    'default' => env('LOG_CHANNEL', 'stack'),
+
+    /*
+    |--------------------------------------------------------------------------
+    | Log Channels
+    |--------------------------------------------------------------------------
+    |
+    | Here you may configure the log channels for your application. Out of
+    | the box, Laravel uses the Monolog PHP logging library. This gives
+    | you a variety of powerful log handlers / formatters to utilize.
+    |
+    | Available Drivers: "single", "daily", "slack", "syslog",
+    |                    "errorlog", "custom", "stack"
+    |
+    */
+
+    'channels' => [
+        'stack' => [
+            'driver' => 'stack',
+            'channels' => ['single'],
+        ],
+
+        'single' => [
+            'driver' => 'single',
+            'path' => storage_path('logs/laravel.log'),
+            'level' => 'debug',
+        ],
+
+        'daily' => [
+            'driver' => 'daily',
+            'path' => storage_path('logs/laravel.log'),
+            'level' => 'debug',
+            'days' => 7,
+        ],
+
+        'slack' => [
+            'driver' => 'slack',
+            'url' => env('LOG_SLACK_WEBHOOK_URL'),
+            'username' => 'Laravel Log',
+            'emoji' => ':boom:',
+            'level' => 'critical',
+        ],
+
+        'syslog' => [
+            'driver' => 'syslog',
+            'level' => 'debug',
+        ],
+
+        'errorlog' => [
+            'driver' => 'errorlog',
+            'level' => 'debug',
+        ],
+    ],
+
+];
diff --git a/config/queue.php b/config/queue.php
index d304928..9119228 100644
--- a/config/queue.php
+++ b/config/queue.php
@@ -63,6 +63,7 @@ return [
             'connection' => 'default',
             'queue' => 'default',
             'retry_after' => 90,
+            'block_for' => null,
         ],
 
     ],
diff --git a/config/services.php b/config/services.php
index 3c8dc72..74d047e 100644
--- a/config/services.php
+++ b/config/services.php
@@ -54,4 +54,7 @@ return [
         'redirect' => env('GOOGLE_CALLBACK_URI'),
     ],
 
+    'authy' => [
+        'key' => env('AUTHY_KEY')
+    ]
 ];
diff --git a/database/migrations/2015_10_10_170827_create_users_table.php b/database/migrations/2015_10_10_170827_create_users_table.php
index 7904176..0a85a0f 100644
--- a/database/migrations/2015_10_10_170827_create_users_table.php
+++ b/database/migrations/2015_10_10_170827_create_users_table.php
@@ -33,6 +33,8 @@ class CreateUsersTable extends Migration
             $table->text('two_factor_options')->nullable();
             $table->rememberToken();
             $table->timestamps();
+
+            $table->index('created_at');
         });
     }
 
diff --git a/package.json b/package.json
index f3bdda4..3d7ac4e 100644
--- a/package.json
+++ b/package.json
@@ -10,11 +10,12 @@
     "production": "cross-env NODE_ENV=production node_modules/webpack/bin/webpack.js --no-progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js"
   },
   "devDependencies": {
-    "axios": "^0.17",
-    "bootstrap-sass": "^3.3.7",
+    "axios": "^0.18",
+    "bootstrap": "^4.0.0",
+    "popper.js": "^1.12",
     "cross-env": "^5.1",
     "jquery": "^3.2",
-    "laravel-mix": "^1.0",
+    "laravel-mix": "^2.0",
     "lodash": "^4.17.4",
     "vue": "^2.5.7"
   }
diff --git a/public/.htaccess b/public/.htaccess
index 232a375..25ea53a 100644
--- a/public/.htaccess
+++ b/public/.htaccess
@@ -1,6 +1,6 @@
 <IfModule mod_rewrite.c>
     #<IfModule mod_negotiation.c>
-    #    Options -MultiViews
+    #    Options -MultiViews -Indexes
     #</IfModule>
 
     RewriteEngine On
diff --git a/resources/assets/js/app.js b/resources/assets/js/app.js
index 922878b..e581d53 100644
--- a/resources/assets/js/app.js
+++ b/resources/assets/js/app.js
@@ -15,7 +15,7 @@ window.Vue = require('vue');
  * or customize the JavaScript scaffolding to fit your unique needs.
  */
 
-Vue.component('example', require('./components/Example.vue'));
+Vue.component('example-component', require('./components/ExampleComponent.vue'));
 
 const app = new Vue({
     el: '#app'
diff --git a/resources/assets/js/bootstrap.js b/resources/assets/js/bootstrap.js
index 9042114..56d664c 100644
--- a/resources/assets/js/bootstrap.js
+++ b/resources/assets/js/bootstrap.js
@@ -1,5 +1,6 @@
 
 window._ = require('lodash');
+window.Popper = require('popper.js').default;
 
 /**
  * We'll load jQuery and the Bootstrap jQuery plugin which provides support
@@ -10,7 +11,7 @@ window._ = require('lodash');
 try {
     window.$ = window.jQuery = require('jquery');
 
-    require('bootstrap-sass');
+    require('bootstrap');
 } catch (e) {}
 
 /**
@@ -49,5 +50,7 @@ if (token) {
 
 // window.Echo = new Echo({
 //     broadcaster: 'pusher',
-//     key: 'your-pusher-key'
+//     key: process.env.MIX_PUSHER_APP_KEY,
+//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,
+//     encrypted: true
 // });
\ No newline at end of file
diff --git a/resources/assets/js/components/Example.vue b/resources/assets/js/components/Example.vue
index 0439f43..8a1569f 100644
--- a/resources/assets/js/components/Example.vue
+++ b/resources/assets/js/components/Example.vue
@@ -1,12 +1,12 @@
 <template>
     <div class="container">
-        <div class="row">
-            <div class="col-md-8 col-md-offset-2">
-                <div class="panel panel-default">
-                    <div class="panel-heading">Example Component</div>
+        <div class="row justify-content-center">
+            <div class="col-md-8">
+                <div class="card card-default">
+                    <div class="card-header">Example Component</div>
 
-                    <div class="panel-body">
-                        I'm an example component!
+                    <div class="card-body">
+                        I'm an example component.
                     </div>
                 </div>
             </div>
diff --git a/storage/settings.json b/storage/settings.json
index 5951746..b906bfb 100644
--- a/storage/settings.json
+++ b/storage/settings.json
@@ -1 +1 @@
-{"remember_me":true,"notifications_signup_email":true,"forgot_password":true,"login_reset_token_lifetime":"30","throttle_enabled":true,"throttle_attempts":3,"throttle_lockout_time":2,"reg_enabled":false,"reg_email_confirmation":true,"2fa":{"enabled":true},"app_name":"Vanguard","registration":{"captcha":{"enabled":false}},"tos":false,"captcha":{"enabled":false}}
\ No newline at end of file
+{"remember_me":true,"notifications_signup_email":"0","forgot_password":"1","login_reset_token_lifetime":"30","throttle_enabled":"1","throttle_attempts":"3","throttle_lockout_time":"2","reg_enabled":false,"reg_email_confirmation":"1","2fa":{"enabled":true},"app_name":"Vanguard","registration":{"captcha":{"enabled":false}},"tos":"0","captcha":{"enabled":false}}
\ No newline at end of file
diff --git a/tests/Feature/Http/Controllers/Api/StatsControllerTest.php b/tests/Feature/Http/Controllers/Api/StatsControllerTest.php
index 6301f4b..dcbb8d6 100644
--- a/tests/Feature/Http/Controllers/Api/StatsControllerTest.php
+++ b/tests/Feature/Http/Controllers/Api/StatsControllerTest.php
@@ -30,35 +30,27 @@ class StatsControllerTest extends ApiTestCase
     {
         $adminRole = Role::whereName('Admin')->first();
 
-        $user = factory(User::class)->create([
-            'role_id' => $adminRole->id,
-        ]);
+        $user = factory(User::class)->create(['role_id' => $adminRole->id]);
 
         $this->be($user, 'api');
 
         Carbon::setTestNow(Carbon::now()->startOfYear());
 
-        $activeUsers = factory(User::class)->times(4)->create([
-            'status' => UserStatus::ACTIVE
-        ]);
+        factory(User::class)->times(4)->create(['status' => UserStatus::ACTIVE]);
 
         Carbon::setTestNow(null);
 
-        $bannedUsers = factory(User::class)->times(2)->create([
-            'status' => UserStatus::BANNED
-        ]);
+        factory(User::class)->times(2)->create(['status' => UserStatus::BANNED]);
 
-        $unconfirmedUsers = factory(User::class)->times(7)->create([
-            'status' => UserStatus::UNCONFIRMED
-        ]);
+        factory(User::class)->times(7)->create(['status' => UserStatus::UNCONFIRMED]);
 
         $users = app(UserRepository::class);
 
         $this->getJson("/api/stats");
 
         $usersPerMonth = $users->countOfNewUsersPerMonth(
-            Carbon::now()->startOfYear(),
-            Carbon::now()
+            now()->subYear()->startOfMonth(),
+            now()->endOfMonth()
         );
 
         $latestRegistrations = $users->latest(7);
diff --git a/tests/Feature/Repositories/User/EloquentUserTest.php b/tests/Feature/Repositories/User/EloquentUserTest.php
index b21d876..78a6605 100644
--- a/tests/Feature/Repositories/User/EloquentUserTest.php
+++ b/tests/Feature/Repositories/User/EloquentUserTest.php
@@ -233,11 +233,17 @@ class EloquentUserTest extends FunctionalTestCase
 
     public function test_latest()
     {
-        Carbon::setTestNow(Carbon::now()->subDay());
-        $user1 = factory(User::class)->create();
+        Carbon::setTestNow(now()->subDay());
+        $user4 = factory(User::class)->create();
 
-        Carbon::setTestNow(null);
-        $users = factory(User::class)->times(3)->create();
+        Carbon::setTestNow(now()->subMinutes(3));
+        $user3 = factory(User::class)->create();
+
+        Carbon::setTestNow(now()->subMinutes(2));
+        $user2 = factory(User::class)->create();
+
+        Carbon::setTestNow(now()->subMinutes(1));
+        $user1 = factory(User::class)->create();
 
         $latestTwo = $this->repo->latest(2);
         $latestFour = $this->repo->latest(4);
@@ -245,48 +251,52 @@ class EloquentUserTest extends FunctionalTestCase
         $this->assertEquals(2, count($latestTwo));
         $this->assertEquals(4, count($latestFour));
 
-        $this->assertArraySubset($users[0]->toArray(), $latestTwo[0]->toArray());
-        $this->assertArraySubset($users[1]->toArray(), $latestTwo[1]->toArray());
+        $this->assertArraySubset($user4->toArray(), $latestTwo[0]->toArray());
+        $this->assertArraySubset($user3->toArray(), $latestTwo[1]->toArray());
         $this->assertArraySubset($user1->toArray(), $latestFour[3]->toArray());
     }
 
     public function test_countOfNewUsersPerMonth()
     {
-        Carbon::setTestNow(Carbon::now()->startOfYear());
+        $from = now()->startOfYear();
+
+        Carbon::setTestNow($from);
         factory(User::class)->times(2)->create();
 
-        Carbon::setTestNow(Carbon::now()->startOfYear()->addMonths(2));
+        Carbon::setTestNow($from->copy()->addMonths(2));
         factory(User::class)->times(4)->create();
 
-        Carbon::setTestNow(Carbon::now()->startOfYear()->addMonths(6));
+        Carbon::setTestNow($from->copy()->addMonths(6));
         factory(User::class)->times(2)->create();
 
-        Carbon::setTestNow(Carbon::now()->startOfYear()->addMonths(7));
+        Carbon::setTestNow($from->copy()->addMonths(7));
         factory(User::class)->times(1)->create();
 
-        Carbon::setTestNow(Carbon::now()->startOfYear()->addMonths(10));
+        Carbon::setTestNow($from->copy()->addMonths(10));
         factory(User::class)->times(4)->create();
 
         Carbon::setTestNow(null);
 
+        $currentYear = now()->year;
+
         $expected = [
-            'January 2017' => 2,
-            'February 2017' => 0,
-            'March 2017' => 4,
-            'April 2017' => 0,
-            'May 2017' => 0,
-            'June 2017' => 0,
-            'July 2017' => 2,
-            'August 2017' => 1,
-            'September 2017' => 0,
-            'October 2017' => 0,
-            'November 2017' => 4,
-            'December 2017' => 0
+            "January {$currentYear}" => 2,
+            "February {$currentYear}" => 0,
+            "March {$currentYear}" => 4,
+            "April {$currentYear}" => 0,
+            "May {$currentYear}" => 0,
+            "June {$currentYear}" => 0,
+            "July {$currentYear}" => 2,
+            "August {$currentYear}" => 1,
+            "September {$currentYear}" => 0,
+            "October {$currentYear}" => 0,
+            "November {$currentYear}" => 4,
+            "December {$currentYear}" => 0
         ];
 
         $usersPerMonth = $this->repo->countOfNewUsersPerMonth(
-            Carbon::now()->startOfYear(),
-            Carbon::now()->endOfYear()
+            now()->startOfYear(),
+            now()->endOfYear()
         );
 
         $this->assertEquals($expected, $usersPerMonth);
diff --git a/tests/TestCase.php b/tests/TestCase.php
index 6e13a05..d488c27 100644
--- a/tests/TestCase.php
+++ b/tests/TestCase.php
@@ -26,6 +26,8 @@ class TestCase extends \Laravel\BrowserKitTesting\TestCase
 
         $app->make(\Illuminate\Contracts\Console\Kernel::class)->bootstrap();
 
+        \Hash::setRounds(5);
+
         return $app;
     }
 
