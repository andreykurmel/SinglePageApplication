diff --git a/_ide_helper.php b/_ide_helper.php
index b307038..7f7a796 100644
--- a/_ide_helper.php
+++ b/_ide_helper.php
@@ -1,7 +1,7 @@
 <?php
 /**
  * A helper file for Laravel 5, to provide autocomplete information to your IDE
- * Generated for Laravel 5.3.9 on 2016-09-17.
+ * Generated for Laravel 5.4.28 on 2017-07-04.
  *
  * @author Barry vd. Heuvel <barryvdh@gmail.com>
  * @see https://github.com/barryvdh/laravel-ide-helper
@@ -92,51 +92,56 @@ namespace {
         /**
          * Get the path to the application "app" directory.
          *
+         * @param string $path Optionally, a path to append to the app path
          * @return string 
          * @static 
          */
-        public static function path(){
-            return \Illuminate\Foundation\Application::path();
+        public static function path($path = ''){
+            return \Illuminate\Foundation\Application::path($path);
         }
         
         /**
          * Get the base path of the Laravel installation.
          *
+         * @param string $path Optionally, a path to append to the base path
          * @return string 
          * @static 
          */
-        public static function basePath(){
-            return \Illuminate\Foundation\Application::basePath();
+        public static function basePath($path = ''){
+            return \Illuminate\Foundation\Application::basePath($path);
         }
         
         /**
          * Get the path to the bootstrap directory.
          *
+         * @param string $path Optionally, a path to append to the bootstrap path
          * @return string 
          * @static 
          */
-        public static function bootstrapPath(){
-            return \Illuminate\Foundation\Application::bootstrapPath();
+        public static function bootstrapPath($path = ''){
+            return \Illuminate\Foundation\Application::bootstrapPath($path);
         }
         
         /**
          * Get the path to the application configuration files.
          *
+         * @param string $path Optionally, a path to append to the config path
          * @return string 
          * @static 
          */
-        public static function configPath(){
-            return \Illuminate\Foundation\Application::configPath();
+        public static function configPath($path = ''){
+            return \Illuminate\Foundation\Application::configPath($path);
         }
         
         /**
          * Get the path to the database directory.
          *
+         * @param string $path Optionally, a path to append to the database path
          * @return string 
          * @static 
          */
-        public static function databasePath(){
-            return \Illuminate\Foundation\Application::databasePath();
+        public static function databasePath($path = ''){
+            return \Illuminate\Foundation\Application::databasePath($path);
         }
         
         /**
@@ -194,11 +199,12 @@ namespace {
         /**
          * Get the path to the resources directory.
          *
+         * @param string $path
          * @return string 
          * @static 
          */
-        public static function resourcePath(){
-            return \Illuminate\Foundation\Application::resourcePath();
+        public static function resourcePath($path = ''){
+            return \Illuminate\Foundation\Application::resourcePath($path);
         }
         
         /**
@@ -345,8 +351,8 @@ namespace {
          * @return \Illuminate\Support\ServiceProvider 
          * @static 
          */
-        public static function resolveProviderClass($provider){
-            return \Illuminate\Foundation\Application::resolveProviderClass($provider);
+        public static function resolveProvider($provider){
+            return \Illuminate\Foundation\Application::resolveProvider($provider);
         }
         
         /**
@@ -385,15 +391,28 @@ namespace {
         /**
          * Resolve the given type from the container.
          * 
-         * (Overriding Container::make)
+         * (Overriding Container::makeWith)
          *
          * @param string $abstract
          * @param array $parameters
          * @return mixed 
          * @static 
          */
-        public static function make($abstract, $parameters = array()){
-            return \Illuminate\Foundation\Application::make($abstract, $parameters);
+        public static function makeWith($abstract, $parameters){
+            return \Illuminate\Foundation\Application::makeWith($abstract, $parameters);
+        }
+        
+        /**
+         * Resolve the given type from the container.
+         * 
+         * (Overriding Container::make)
+         *
+         * @param string $abstract
+         * @return mixed 
+         * @static 
+         */
+        public static function make($abstract){
+            return \Illuminate\Foundation\Application::make($abstract);
         }
         
         /**
@@ -471,6 +490,16 @@ namespace {
         }
         
         /**
+         * Get the path to the cached services.php file.
+         *
+         * @return string 
+         * @static 
+         */
+        public static function getCachedServicesPath(){
+            return \Illuminate\Foundation\Application::getCachedServicesPath();
+        }
+        
+        /**
          * Determine if the application configuration is cached.
          *
          * @return bool 
@@ -511,26 +540,6 @@ namespace {
         }
         
         /**
-         * Get the path to the cached "compiled.php" file.
-         *
-         * @return string 
-         * @static 
-         */
-        public static function getCachedCompilePath(){
-            return \Illuminate\Foundation\Application::getCachedCompilePath();
-        }
-        
-        /**
-         * Get the path to the cached services.php file.
-         *
-         * @return string 
-         * @static 
-         */
-        public static function getCachedServicesPath(){
-            return \Illuminate\Foundation\Application::getCachedServicesPath();
-        }
-        
-        /**
          * Determine if the application is currently down for maintenance.
          *
          * @return bool 
@@ -629,6 +638,17 @@ namespace {
         }
         
         /**
+         * Configure the real-time facade namespace.
+         *
+         * @param string $namespace
+         * @return void 
+         * @static 
+         */
+        public static function provideFacades($namespace){
+            \Illuminate\Foundation\Application::provideFacades($namespace);
+        }
+        
+        /**
          * Define a callback to be used to configure Monolog.
          *
          * @param callable $callback
@@ -747,6 +767,18 @@ namespace {
         }
         
         /**
+         * Determine if a given type is shared.
+         *
+         * @param string $abstract
+         * @return bool 
+         * @static 
+         */
+        public static function isShared($abstract){
+            //Method inherited from \Illuminate\Container\Container            
+            return \Illuminate\Foundation\Application::isShared($abstract);
+        }
+        
+        /**
          * Determine if a given string is an alias.
          *
          * @param string $name
@@ -773,6 +805,44 @@ namespace {
         }
         
         /**
+         * Determine if the container has a method binding.
+         *
+         * @param string $method
+         * @return bool 
+         * @static 
+         */
+        public static function hasMethodBinding($method){
+            //Method inherited from \Illuminate\Container\Container            
+            return \Illuminate\Foundation\Application::hasMethodBinding($method);
+        }
+        
+        /**
+         * Bind a callback to resolve with Container::call.
+         *
+         * @param string $method
+         * @param \Closure $callback
+         * @return void 
+         * @static 
+         */
+        public static function bindMethod($method, $callback){
+            //Method inherited from \Illuminate\Container\Container            
+            \Illuminate\Foundation\Application::bindMethod($method, $callback);
+        }
+        
+        /**
+         * Get the method binding for the given method.
+         *
+         * @param string $method
+         * @param mixed $instance
+         * @return mixed 
+         * @static 
+         */
+        public static function callMethodBinding($method, $instance){
+            //Method inherited from \Illuminate\Container\Container            
+            return \Illuminate\Foundation\Application::callMethodBinding($method, $instance);
+        }
+        
+        /**
          * Add a contextual binding to the container.
          *
          * @param string $concrete
@@ -814,18 +884,6 @@ namespace {
         }
         
         /**
-         * Wrap a Closure such that it is shared.
-         *
-         * @param \Closure $closure
-         * @return \Closure 
-         * @static 
-         */
-        public static function share($closure){
-            //Method inherited from \Illuminate\Container\Container            
-            return \Illuminate\Foundation\Application::share($closure);
-        }
-        
-        /**
          * "Extend" an abstract type in the container.
          *
          * @param string $abstract
@@ -945,17 +1003,28 @@ namespace {
         }
         
         /**
+         * Get a closure to resolve the given type from the container.
+         *
+         * @param string $abstract
+         * @return \Closure 
+         * @static 
+         */
+        public static function factory($abstract){
+            //Method inherited from \Illuminate\Container\Container            
+            return \Illuminate\Foundation\Application::factory($abstract);
+        }
+        
+        /**
          * Instantiate a concrete instance of the given type.
          *
          * @param string $concrete
-         * @param array $parameters
          * @return mixed 
          * @throws \Illuminate\Contracts\Container\BindingResolutionException
          * @static 
          */
-        public static function build($concrete, $parameters = array()){
+        public static function build($concrete){
             //Method inherited from \Illuminate\Container\Container            
-            return \Illuminate\Foundation\Application::build($concrete, $parameters);
+            return \Illuminate\Foundation\Application::build($concrete);
         }
         
         /**
@@ -985,26 +1054,39 @@ namespace {
         }
         
         /**
-         * Determine if a given type is shared.
+         * Get the container's bindings.
+         *
+         * @return array 
+         * @static 
+         */
+        public static function getBindings(){
+            //Method inherited from \Illuminate\Container\Container            
+            return \Illuminate\Foundation\Application::getBindings();
+        }
+        
+        /**
+         * Get the alias for an abstract if available.
          *
          * @param string $abstract
-         * @return bool 
+         * @return string 
+         * @throws \LogicException
          * @static 
          */
-        public static function isShared($abstract){
+        public static function getAlias($abstract){
             //Method inherited from \Illuminate\Container\Container            
-            return \Illuminate\Foundation\Application::isShared($abstract);
+            return \Illuminate\Foundation\Application::getAlias($abstract);
         }
         
         /**
-         * Get the container's bindings.
+         * Remove all of the extender callbacks for a given type.
          *
-         * @return array 
+         * @param string $abstract
+         * @return void 
          * @static 
          */
-        public static function getBindings(){
+        public static function forgetExtenders($abstract){
             //Method inherited from \Illuminate\Container\Container            
-            return \Illuminate\Foundation\Application::getBindings();
+            \Illuminate\Foundation\Application::forgetExtenders($abstract);
         }
         
         /**
@@ -1163,12 +1245,13 @@ namespace {
          *
          * @param string $command
          * @param array $parameters
+         * @param \Symfony\Component\Console\Output\OutputInterface $outputBuffer
          * @return int 
          * @static 
          */
-        public static function call($command, $parameters = array()){
+        public static function call($command, $parameters = array(), $outputBuffer = null){
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
-            return \Vanguard\Console\Kernel::call($command, $parameters);
+            return \Vanguard\Console\Kernel::call($command, $parameters, $outputBuffer);
         }
         
         /**
@@ -1176,12 +1259,12 @@ namespace {
          *
          * @param string $command
          * @param array $parameters
-         * @return void 
+         * @return \Illuminate\Foundation\Bus\PendingDispatch 
          * @static 
          */
         public static function queue($command, $parameters = array()){
             //Method inherited from \Illuminate\Foundation\Console\Kernel            
-            \Vanguard\Console\Kernel::queue($command, $parameters);
+            return \Vanguard\Console\Kernel::queue($command, $parameters);
         }
         
         /**
@@ -1217,6 +1300,18 @@ namespace {
             \Vanguard\Console\Kernel::bootstrap();
         }
         
+        /**
+         * Set the Artisan application instance.
+         *
+         * @param \Illuminate\Console\Application $artisan
+         * @return void 
+         * @static 
+         */
+        public static function setArtisan($artisan){
+            //Method inherited from \Illuminate\Foundation\Console\Kernel            
+            \Vanguard\Console\Kernel::setArtisan($artisan);
+        }
+        
     }
 
 
@@ -1390,6 +1485,17 @@ namespace {
         }
         
         /**
+         * Log the given user ID into the application without sessions or cookies.
+         *
+         * @param mixed $id
+         * @return \Vanguard\User|false 
+         * @static 
+         */
+        public static function onceUsingId($id){
+            return \Illuminate\Auth\SessionGuard::onceUsingId($id);
+        }
+        
+        /**
          * Validate a user's credentials.
          *
          * @param array $credentials
@@ -1429,23 +1535,23 @@ namespace {
          *
          * @param array $credentials
          * @param bool $remember
-         * @param bool $login
          * @return bool 
          * @static 
          */
-        public static function attempt($credentials = array(), $remember = false, $login = true){
-            return \Illuminate\Auth\SessionGuard::attempt($credentials, $remember, $login);
+        public static function attempt($credentials = array(), $remember = false){
+            return \Illuminate\Auth\SessionGuard::attempt($credentials, $remember);
         }
         
         /**
-         * Register an authentication attempt event listener.
+         * Log the given user ID into the application.
          *
-         * @param mixed $callback
-         * @return void 
+         * @param mixed $id
+         * @param bool $remember
+         * @return \Vanguard\User|false 
          * @static 
          */
-        public static function attempting($callback){
-            \Illuminate\Auth\SessionGuard::attempting($callback);
+        public static function loginUsingId($id, $remember = false){
+            return \Illuminate\Auth\SessionGuard::loginUsingId($id, $remember);
         }
         
         /**
@@ -1461,36 +1567,64 @@ namespace {
         }
         
         /**
-         * Log the given user ID into the application.
+         * Log the user out of the application.
          *
-         * @param mixed $id
-         * @param bool $remember
-         * @return \Vanguard\User|false 
+         * @return void 
          * @static 
          */
-        public static function loginUsingId($id, $remember = false){
-            return \Illuminate\Auth\SessionGuard::loginUsingId($id, $remember);
+        public static function logout(){
+            \Illuminate\Auth\SessionGuard::logout();
         }
         
         /**
-         * Log the given user ID into the application without sessions or cookies.
+         * Register an authentication attempt event listener.
          *
-         * @param mixed $id
-         * @return \Vanguard\User|false 
+         * @param mixed $callback
+         * @return void 
          * @static 
          */
-        public static function onceUsingId($id){
-            return \Illuminate\Auth\SessionGuard::onceUsingId($id);
+        public static function attempting($callback){
+            \Illuminate\Auth\SessionGuard::attempting($callback);
         }
         
         /**
-         * Log the user out of the application.
+         * Get the last user we attempted to authenticate.
          *
-         * @return void 
+         * @return \Vanguard\User 
          * @static 
          */
-        public static function logout(){
-            \Illuminate\Auth\SessionGuard::logout();
+        public static function getLastAttempted(){
+            return \Illuminate\Auth\SessionGuard::getLastAttempted();
+        }
+        
+        /**
+         * Get a unique identifier for the auth session value.
+         *
+         * @return string 
+         * @static 
+         */
+        public static function getName(){
+            return \Illuminate\Auth\SessionGuard::getName();
+        }
+        
+        /**
+         * Get the name of the cookie used to store the "recaller".
+         *
+         * @return string 
+         * @static 
+         */
+        public static function getRecallerName(){
+            return \Illuminate\Auth\SessionGuard::getRecallerName();
+        }
+        
+        /**
+         * Determine if the user was authenticated via "remember me" cookie.
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function viaRemember(){
+            return \Illuminate\Auth\SessionGuard::viaRemember();
         }
         
         /**
@@ -1610,74 +1744,57 @@ namespace {
         }
         
         /**
-         * Get the last user we attempted to authenticate.
+         * Determine if the current user is authenticated.
          *
-         * @return \Vanguard\User 
+         * @return bool 
          * @static 
          */
-        public static function getLastAttempted(){
-            return \Illuminate\Auth\SessionGuard::getLastAttempted();
+        public static function check(){
+            return \Illuminate\Auth\SessionGuard::check();
         }
         
         /**
-         * Get a unique identifier for the auth session value.
+         * Determine if the current user is a guest.
          *
-         * @return string 
+         * @return bool 
          * @static 
          */
-        public static function getName(){
-            return \Illuminate\Auth\SessionGuard::getName();
+        public static function guest(){
+            return \Illuminate\Auth\SessionGuard::guest();
         }
         
         /**
-         * Get the name of the cookie used to store the "recaller".
+         * Determine if the current user is authenticated.
          *
-         * @return string 
+         * @return \Vanguard\User 
+         * @throws \Illuminate\Auth\AuthenticationException
          * @static 
          */
-        public static function getRecallerName(){
-            return \Illuminate\Auth\SessionGuard::getRecallerName();
+        public static function authenticate(){
+            return \Illuminate\Auth\SessionGuard::authenticate();
         }
         
         /**
-         * Determine if the user was authenticated via "remember me" cookie.
+         * Register a custom macro.
          *
-         * @return bool 
+         * @param string $name
+         * @param callable $macro
+         * @return void 
          * @static 
          */
-        public static function viaRemember(){
-            return \Illuminate\Auth\SessionGuard::viaRemember();
+        public static function macro($name, $macro){
+            \Illuminate\Auth\SessionGuard::macro($name, $macro);
         }
         
         /**
-         * Determine if the current user is authenticated.
-         *
-         * @return bool 
-         * @static 
-         */
-        public static function check(){
-            return \Illuminate\Auth\SessionGuard::check();
-        }
-        
-        /**
-         * Determine if the current user is a guest.
+         * Checks if macro is registered.
          *
+         * @param string $name
          * @return bool 
          * @static 
          */
-        public static function guest(){
-            return \Illuminate\Auth\SessionGuard::guest();
-        }
-        
-        /**
-         * Determine if the current user is authenticated.
-         *
-         * @return \Vanguard\User 
-         * @throws \Illuminate\Auth\AuthenticationException
-         * @static 
-         */
-        public static function authenticate(){
-            return \Illuminate\Auth\SessionGuard::authenticate();
+        public static function hasMacro($name){
+            return \Illuminate\Auth\SessionGuard::hasMacro($name);
         }
         
     }
@@ -1729,17 +1846,6 @@ namespace {
         }
         
         /**
-         * Compile the default values for the echo statement.
-         *
-         * @param string $value
-         * @return string 
-         * @static 
-         */
-        public static function compileEchoDefaults($value){
-            return \Illuminate\View\Compilers\BladeCompiler::compileEchoDefaults($value);
-        }
-        
-        /**
          * Strip the parentheses from the given expression.
          *
          * @param string $expression
@@ -1751,24 +1857,24 @@ namespace {
         }
         
         /**
-         * Get the extensions used by the compiler.
+         * Register a custom Blade compiler.
          *
-         * @return array 
+         * @param callable $compiler
+         * @return void 
          * @static 
          */
-        public static function getExtensions(){
-            return \Illuminate\View\Compilers\BladeCompiler::getExtensions();
+        public static function extend($compiler){
+            \Illuminate\View\Compilers\BladeCompiler::extend($compiler);
         }
         
         /**
-         * Register a custom Blade compiler.
+         * Get the extensions used by the compiler.
          *
-         * @param callable $compiler
-         * @return void 
+         * @return array 
          * @static 
          */
-        public static function extend($compiler){
-            \Illuminate\View\Compilers\BladeCompiler::extend($compiler);
+        public static function getExtensions(){
+            return \Illuminate\View\Compilers\BladeCompiler::getExtensions();
         }
         
         /**
@@ -1794,73 +1900,6 @@ namespace {
         }
         
         /**
-         * Gets the raw tags used by the compiler.
-         *
-         * @return array 
-         * @static 
-         */
-        public static function getRawTags(){
-            return \Illuminate\View\Compilers\BladeCompiler::getRawTags();
-        }
-        
-        /**
-         * Sets the raw tags used for the compiler.
-         *
-         * @param string $openTag
-         * @param string $closeTag
-         * @return void 
-         * @static 
-         */
-        public static function setRawTags($openTag, $closeTag){
-            \Illuminate\View\Compilers\BladeCompiler::setRawTags($openTag, $closeTag);
-        }
-        
-        /**
-         * Sets the content tags used for the compiler.
-         *
-         * @param string $openTag
-         * @param string $closeTag
-         * @param bool $escaped
-         * @return void 
-         * @static 
-         */
-        public static function setContentTags($openTag, $closeTag, $escaped = false){
-            \Illuminate\View\Compilers\BladeCompiler::setContentTags($openTag, $closeTag, $escaped);
-        }
-        
-        /**
-         * Sets the escaped content tags used for the compiler.
-         *
-         * @param string $openTag
-         * @param string $closeTag
-         * @return void 
-         * @static 
-         */
-        public static function setEscapedContentTags($openTag, $closeTag){
-            \Illuminate\View\Compilers\BladeCompiler::setEscapedContentTags($openTag, $closeTag);
-        }
-        
-        /**
-         * Gets the content tags used for the compiler.
-         *
-         * @return string 
-         * @static 
-         */
-        public static function getContentTags(){
-            return \Illuminate\View\Compilers\BladeCompiler::getContentTags();
-        }
-        
-        /**
-         * Gets the escaped content tags used for the compiler.
-         *
-         * @return string 
-         * @static 
-         */
-        public static function getEscapedContentTags(){
-            return \Illuminate\View\Compilers\BladeCompiler::getEscapedContentTags();
-        }
-        
-        /**
          * Set the echo format to be used by the compiler.
          *
          * @param string $format
@@ -1895,6 +1934,17 @@ namespace {
             return \Illuminate\View\Compilers\BladeCompiler::isExpired($path);
         }
         
+        /**
+         * Compile the default values for the echo statement.
+         *
+         * @param string $value
+         * @return string 
+         * @static 
+         */
+        public static function compileEchoDefaults($value){
+            return \Illuminate\View\Compilers\BladeCompiler::compileEchoDefaults($value);
+        }
+        
     }
 
 
@@ -2051,17 +2101,6 @@ namespace {
         }
         
         /**
-         * Set the event dispatcher instance.
-         *
-         * @param \Illuminate\Contracts\Events\Dispatcher $events
-         * @return void 
-         * @static 
-         */
-        public static function setEventDispatcher($events){
-            \Illuminate\Cache\Repository::setEventDispatcher($events);
-        }
-        
-        /**
          * Determine if an item exists in the cache.
          *
          * @param string $key
@@ -2257,11 +2296,11 @@ namespace {
          * Set the default cache time in minutes.
          *
          * @param float|int $minutes
-         * @return void 
+         * @return $this 
          * @static 
          */
         public static function setDefaultCacheTime($minutes){
-            \Illuminate\Cache\Repository::setDefaultCacheTime($minutes);
+            return \Illuminate\Cache\Repository::setDefaultCacheTime($minutes);
         }
         
         /**
@@ -2275,6 +2314,17 @@ namespace {
         }
         
         /**
+         * Set the event dispatcher instance.
+         *
+         * @param \Illuminate\Contracts\Events\Dispatcher $events
+         * @return void 
+         * @static 
+         */
+        public static function setEventDispatcher($events){
+            \Illuminate\Cache\Repository::setEventDispatcher($events);
+        }
+        
+        /**
          * Determine if a cached value exists.
          *
          * @param string $key
@@ -2358,11 +2408,11 @@ namespace {
         /**
          * Remove all items from the cache.
          *
-         * @return void 
+         * @return bool 
          * @static 
          */
         public static function flush(){
-            \Illuminate\Cache\FileStore::flush();
+            return \Illuminate\Cache\FileStore::flush();
         }
         
         /**
@@ -2591,11 +2641,12 @@ namespace {
         /**
          * Queue a cookie to send with the next response.
          *
+         * @param array $parameters
          * @return void 
          * @static 
          */
-        public static function queue(){
-            \Illuminate\Cookie\CookieJar::queue();
+        public static function queue($parameters = null){
+            \Illuminate\Cookie\CookieJar::queue($parameters);
         }
         
         /**
@@ -2652,25 +2703,49 @@ namespace {
         /**
          * Encrypt the given value.
          *
-         * @param string $value
+         * @param mixed $value
+         * @param bool $serialize
          * @return string 
          * @throws \Illuminate\Contracts\Encryption\EncryptException
          * @static 
          */
-        public static function encrypt($value){
-            return \Illuminate\Encryption\Encrypter::encrypt($value);
+        public static function encrypt($value, $serialize = true){
+            return \Illuminate\Encryption\Encrypter::encrypt($value, $serialize);
+        }
+        
+        /**
+         * Encrypt a string without serialization.
+         *
+         * @param string $value
+         * @return string 
+         * @static 
+         */
+        public static function encryptString($value){
+            return \Illuminate\Encryption\Encrypter::encryptString($value);
         }
         
         /**
          * Decrypt the given value.
          *
-         * @param string $payload
+         * @param mixed $payload
+         * @param bool $unserialize
          * @return string 
          * @throws \Illuminate\Contracts\Encryption\DecryptException
          * @static 
          */
-        public static function decrypt($payload){
-            return \Illuminate\Encryption\Encrypter::decrypt($payload);
+        public static function decrypt($payload, $unserialize = true){
+            return \Illuminate\Encryption\Encrypter::decrypt($payload, $unserialize);
+        }
+        
+        /**
+         * Decrypt the given string without unserialization.
+         *
+         * @param string $payload
+         * @return string 
+         * @static 
+         */
+        public static function decryptString($payload){
+            return \Illuminate\Encryption\Encrypter::decryptString($payload);
         }
         
         /**
@@ -2806,6 +2881,18 @@ namespace {
         }
         
         /**
+         * Bind values to their parameters in the given statement.
+         *
+         * @param \PDOStatement $statement
+         * @param array $bindings
+         * @return void 
+         * @static 
+         */
+        public static function bindValues($statement, $bindings){
+            \Illuminate\Database\MySqlConnection::bindValues($statement, $bindings);
+        }
+        
+        /**
          * Set the query grammar to the default implementation.
          *
          * @return void 
@@ -2862,28 +2949,17 @@ namespace {
         }
         
         /**
-         * Get a new raw query expression.
-         *
-         * @param mixed $value
-         * @return \Illuminate\Database\Query\Expression 
-         * @static 
-         */
-        public static function raw($value){
-            //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::raw($value);
-        }
-        
-        /**
          * Run a select statement and return a single result.
          *
          * @param string $query
          * @param array $bindings
+         * @param bool $useReadPdo
          * @return mixed 
          * @static 
          */
-        public static function selectOne($query, $bindings = array()){
+        public static function selectOne($query, $bindings = array(), $useReadPdo = true){
             //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::selectOne($query, $bindings);
+            return \Illuminate\Database\MySqlConnection::selectOne($query, $bindings, $useReadPdo);
         }
         
         /**
@@ -2914,8 +2990,12 @@ namespace {
         }
         
         /**
-         * 
+         * Run a select statement against the database and returns a generator.
          *
+         * @param string $query
+         * @param array $bindings
+         * @param bool $useReadPdo
+         * @return \Generator 
          * @static 
          */
         public static function cursor($query, $bindings = array(), $useReadPdo = true){
@@ -2924,19 +3004,6 @@ namespace {
         }
         
         /**
-         * Bind values to their parameters in the given statement.
-         *
-         * @param \PDOStatement $statement
-         * @param array $bindings
-         * @return void 
-         * @static 
-         */
-        public static function bindValues($statement, $bindings){
-            //Method inherited from \Illuminate\Database\Connection            
-            \Illuminate\Database\MySqlConnection::bindValues($statement, $bindings);
-        }
-        
-        /**
          * Run an insert statement against the database.
          *
          * @param string $query
@@ -3014,131 +3081,84 @@ namespace {
         }
         
         /**
-         * Prepare the query bindings for execution.
+         * Execute the given callback in "dry run" mode.
          *
-         * @param array $bindings
+         * @param \Closure $callback
          * @return array 
          * @static 
          */
-        public static function prepareBindings($bindings){
+        public static function pretend($callback){
             //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::prepareBindings($bindings);
+            return \Illuminate\Database\MySqlConnection::pretend($callback);
         }
         
         /**
-         * Execute a Closure within a transaction.
+         * Prepare the query bindings for execution.
          *
-         * @param \Closure $callback
-         * @param int $attempts
-         * @return mixed 
-         * @throws \Exception|\Throwable
+         * @param array $bindings
+         * @return array 
          * @static 
          */
-        public static function transaction($callback, $attempts = 1){
+        public static function prepareBindings($bindings){
             //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::transaction($callback, $attempts);
+            return \Illuminate\Database\MySqlConnection::prepareBindings($bindings);
         }
         
         /**
-         * Start a new database transaction.
+         * Log a query in the connection's query log.
          *
+         * @param string $query
+         * @param array $bindings
+         * @param float|null $time
          * @return void 
-         * @throws Exception
          * @static 
          */
-        public static function beginTransaction(){
+        public static function logQuery($query, $bindings, $time = null){
             //Method inherited from \Illuminate\Database\Connection            
-            \Illuminate\Database\MySqlConnection::beginTransaction();
+            \Illuminate\Database\MySqlConnection::logQuery($query, $bindings, $time);
         }
         
         /**
-         * Commit the active database transaction.
+         * Register a database query listener with the connection.
          *
+         * @param \Closure $callback
          * @return void 
          * @static 
          */
-        public static function commit(){
+        public static function listen($callback){
             //Method inherited from \Illuminate\Database\Connection            
-            \Illuminate\Database\MySqlConnection::commit();
+            \Illuminate\Database\MySqlConnection::listen($callback);
         }
         
         /**
-         * Rollback the active database transaction.
+         * Get a new raw query expression.
          *
-         * @return void 
+         * @param mixed $value
+         * @return \Illuminate\Database\Query\Expression 
          * @static 
          */
-        public static function rollBack(){
+        public static function raw($value){
             //Method inherited from \Illuminate\Database\Connection            
-            \Illuminate\Database\MySqlConnection::rollBack();
+            return \Illuminate\Database\MySqlConnection::raw($value);
         }
         
         /**
-         * Get the number of active transactions.
+         * Is Doctrine available?
          *
-         * @return int 
+         * @return bool 
          * @static 
          */
-        public static function transactionLevel(){
+        public static function isDoctrineAvailable(){
             //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::transactionLevel();
+            return \Illuminate\Database\MySqlConnection::isDoctrineAvailable();
         }
         
         /**
-         * Execute the given callback in "dry run" mode.
+         * Get a Doctrine Schema Column instance.
          *
-         * @param \Closure $callback
-         * @return array 
-         * @static 
-         */
-        public static function pretend($callback){
-            //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::pretend($callback);
-        }
-        
-        /**
-         * Log a query in the connection's query log.
-         *
-         * @param string $query
-         * @param array $bindings
-         * @param float|null $time
-         * @return void 
-         * @static 
-         */
-        public static function logQuery($query, $bindings, $time = null){
-            //Method inherited from \Illuminate\Database\Connection            
-            \Illuminate\Database\MySqlConnection::logQuery($query, $bindings, $time);
-        }
-        
-        /**
-         * Register a database query listener with the connection.
-         *
-         * @param \Closure $callback
-         * @return void 
-         * @static 
-         */
-        public static function listen($callback){
-            //Method inherited from \Illuminate\Database\Connection            
-            \Illuminate\Database\MySqlConnection::listen($callback);
-        }
-        
-        /**
-         * Is Doctrine available?
-         *
-         * @return bool 
-         * @static 
-         */
-        public static function isDoctrineAvailable(){
-            //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::isDoctrineAvailable();
-        }
-        
-        /**
-         * Get a Doctrine Schema Column instance.
-         *
-         * @param string $table
-         * @param string $column
-         * @return \Doctrine\DBAL\Schema\Column 
+         * @param string $table
+         * @param string $column
+         * @return \Doctrine\DBAL\Schema\Column 
          * @static 
          */
         public static function getDoctrineColumn($table, $column){
@@ -3195,7 +3215,6 @@ namespace {
          *
          * @param \PDO|null $pdo
          * @return $this 
-         * @throws \RuntimeException
          * @static 
          */
         public static function setPdo($pdo){
@@ -3241,11 +3260,11 @@ namespace {
         /**
          * Get an option from the configuration options.
          *
-         * @param string $option
+         * @param string|null $option
          * @return mixed 
          * @static 
          */
-        public static function getConfig($option){
+        public static function getConfig($option = null){
             //Method inherited from \Illuminate\Database\Connection            
             return \Illuminate\Database\MySqlConnection::getConfig($option);
         }
@@ -3365,53 +3384,6 @@ namespace {
         }
         
         /**
-         * Get the default fetch mode for the connection.
-         *
-         * @return int 
-         * @static 
-         */
-        public static function getFetchMode(){
-            //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::getFetchMode();
-        }
-        
-        /**
-         * Get the fetch argument to be applied when selecting.
-         *
-         * @return mixed 
-         * @static 
-         */
-        public static function getFetchArgument(){
-            //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::getFetchArgument();
-        }
-        
-        /**
-         * Get custom constructor arguments for the PDO::FETCH_CLASS fetch mode.
-         *
-         * @return array 
-         * @static 
-         */
-        public static function getFetchConstructorArgument(){
-            //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::getFetchConstructorArgument();
-        }
-        
-        /**
-         * Set the default fetch mode for the connection, and optional arguments for the given fetch mode.
-         *
-         * @param int $fetchMode
-         * @param mixed $fetchArgument
-         * @param array $fetchConstructorArgument
-         * @return int 
-         * @static 
-         */
-        public static function setFetchMode($fetchMode, $fetchArgument = null, $fetchConstructorArgument = array()){
-            //Method inherited from \Illuminate\Database\Connection            
-            return \Illuminate\Database\MySqlConnection::setFetchMode($fetchMode, $fetchArgument, $fetchConstructorArgument);
-        }
-        
-        /**
          * Get the connection query log.
          *
          * @return array 
@@ -3524,12 +3496,108 @@ namespace {
             return \Illuminate\Database\MySqlConnection::withTablePrefix($grammar);
         }
         
+        /**
+         * Register a connection resolver.
+         *
+         * @param string $driver
+         * @param \Closure $callback
+         * @return void 
+         * @static 
+         */
+        public static function resolverFor($driver, $callback){
+            //Method inherited from \Illuminate\Database\Connection            
+            \Illuminate\Database\MySqlConnection::resolverFor($driver, $callback);
+        }
+        
+        /**
+         * Get the connection resolver for the given driver.
+         *
+         * @param string $driver
+         * @return mixed 
+         * @static 
+         */
+        public static function getResolver($driver){
+            //Method inherited from \Illuminate\Database\Connection            
+            return \Illuminate\Database\MySqlConnection::getResolver($driver);
+        }
+        
+        /**
+         * Execute a Closure within a transaction.
+         *
+         * @param \Closure $callback
+         * @param int $attempts
+         * @return mixed 
+         * @throws \Exception|\Throwable
+         * @static 
+         */
+        public static function transaction($callback, $attempts = 1){
+            //Method inherited from \Illuminate\Database\Connection            
+            return \Illuminate\Database\MySqlConnection::transaction($callback, $attempts);
+        }
+        
+        /**
+         * Start a new database transaction.
+         *
+         * @return void 
+         * @throws \Exception
+         * @static 
+         */
+        public static function beginTransaction(){
+            //Method inherited from \Illuminate\Database\Connection            
+            \Illuminate\Database\MySqlConnection::beginTransaction();
+        }
+        
+        /**
+         * Commit the active database transaction.
+         *
+         * @return void 
+         * @static 
+         */
+        public static function commit(){
+            //Method inherited from \Illuminate\Database\Connection            
+            \Illuminate\Database\MySqlConnection::commit();
+        }
+        
+        /**
+         * Rollback the active database transaction.
+         *
+         * @param int|null $toLevel
+         * @return void 
+         * @static 
+         */
+        public static function rollBack($toLevel = null){
+            //Method inherited from \Illuminate\Database\Connection            
+            \Illuminate\Database\MySqlConnection::rollBack($toLevel);
+        }
+        
+        /**
+         * Get the number of active transactions.
+         *
+         * @return int 
+         * @static 
+         */
+        public static function transactionLevel(){
+            //Method inherited from \Illuminate\Database\Connection            
+            return \Illuminate\Database\MySqlConnection::transactionLevel();
+        }
+        
     }
 
 
     class Eloquent extends \Illuminate\Database\Eloquent\Model{
         
         /**
+         * Create and return an un-saved model instance.
+         *
+         * @param array $attributes
+         * @return \Illuminate\Database\Eloquent\Model 
+         * @static 
+         */
+        public static function make($attributes = array()){
+            return \Illuminate\Database\Eloquent\Builder::make($attributes);
+        }
+        
+        /**
          * Register a new global scope.
          *
          * @param string $identifier
@@ -3574,6 +3642,67 @@ namespace {
         }
         
         /**
+         * Add a where clause on the primary key to the query.
+         *
+         * @param mixed $id
+         * @return $this 
+         * @static 
+         */
+        public static function whereKey($id){
+            return \Illuminate\Database\Eloquent\Builder::whereKey($id);
+        }
+        
+        /**
+         * Add a basic where clause to the query.
+         *
+         * @param string|array|\Closure $column
+         * @param string $operator
+         * @param mixed $value
+         * @param string $boolean
+         * @return $this 
+         * @static 
+         */
+        public static function where($column, $operator = null, $value = null, $boolean = 'and'){
+            return \Illuminate\Database\Eloquent\Builder::where($column, $operator, $value, $boolean);
+        }
+        
+        /**
+         * Add an "or where" clause to the query.
+         *
+         * @param string|\Closure $column
+         * @param string $operator
+         * @param mixed $value
+         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @static 
+         */
+        public static function orWhere($column, $operator = null, $value = null){
+            return \Illuminate\Database\Eloquent\Builder::orWhere($column, $operator, $value);
+        }
+        
+        /**
+         * Create a collection of models from plain arrays.
+         *
+         * @param array $items
+         * @return \Illuminate\Database\Eloquent\Collection 
+         * @static 
+         */
+        public static function hydrate($items){
+            return \Illuminate\Database\Eloquent\Builder::hydrate($items);
+        }
+        
+        /**
+         * Create a collection of models from a raw query.
+         *
+         * @param string $query
+         * @param array $bindings
+         * @return \Illuminate\Database\Eloquent\Collection 
+         * @static 
+         */
+        public static function fromQuery($query, $bindings = array()){
+            return \Illuminate\Database\Eloquent\Builder::fromQuery($query, $bindings);
+        }
+        
+        /**
          * Find a model by its primary key.
          *
          * @param mixed $id
@@ -3626,11 +3755,12 @@ namespace {
          * Get the first record matching the attributes or instantiate it.
          *
          * @param array $attributes
+         * @param array $values
          * @return \Illuminate\Database\Eloquent\Model 
          * @static 
          */
-        public static function firstOrNew($attributes){
-            return \Illuminate\Database\Eloquent\Builder::firstOrNew($attributes);
+        public static function firstOrNew($attributes, $values = array()){
+            return \Illuminate\Database\Eloquent\Builder::firstOrNew($attributes, $values);
         }
         
         /**
@@ -3658,17 +3788,6 @@ namespace {
         }
         
         /**
-         * Execute the query and get the first result.
-         *
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Model|static|null 
-         * @static 
-         */
-        public static function first($columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::first($columns);
-        }
-        
-        /**
          * Execute the query and get the first result or throw an exception.
          *
          * @param array $columns
@@ -3681,14 +3800,15 @@ namespace {
         }
         
         /**
-         * Execute the query as a "select" statement.
+         * Execute the query and get the first result or call a callback.
          *
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Collection|static[] 
+         * @param \Closure|array $columns
+         * @param \Closure|null $callback
+         * @return \Illuminate\Database\Eloquent\Model|static|mixed 
          * @static 
          */
-        public static function get($columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::get($columns);
+        public static function firstOr($columns = array(), $callback = null){
+            return \Illuminate\Database\Eloquent\Builder::firstOr($columns, $callback);
         }
         
         /**
@@ -3703,50 +3823,60 @@ namespace {
         }
         
         /**
-         * Get a generator for the given query.
+         * Execute the query as a "select" statement.
          *
-         * @return \Generator 
+         * @param array $columns
+         * @return \Illuminate\Database\Eloquent\Collection|static[] 
          * @static 
          */
-        public static function cursor(){
-            return \Illuminate\Database\Eloquent\Builder::cursor();
+        public static function get($columns = array()){
+            return \Illuminate\Database\Eloquent\Builder::get($columns);
         }
         
         /**
-         * Chunk the results of the query.
+         * Get the hydrated models without eager loading.
          *
-         * @param int $count
-         * @param callable $callback
-         * @return bool 
+         * @param array $columns
+         * @return \Illuminate\Database\Eloquent\Model[] 
          * @static 
          */
-        public static function chunk($count, $callback){
-            return \Illuminate\Database\Eloquent\Builder::chunk($count, $callback);
+        public static function getModels($columns = array()){
+            return \Illuminate\Database\Eloquent\Builder::getModels($columns);
         }
         
         /**
-         * Chunk the results of a query by comparing numeric IDs.
+         * Eager load the relationships for the models.
          *
-         * @param int $count
-         * @param callable $callback
-         * @param string $column
-         * @return bool 
+         * @param array $models
+         * @return array 
          * @static 
          */
-        public static function chunkById($count, $callback, $column = 'id'){
-            return \Illuminate\Database\Eloquent\Builder::chunkById($count, $callback, $column);
+        public static function eagerLoadRelations($models){
+            return \Illuminate\Database\Eloquent\Builder::eagerLoadRelations($models);
         }
         
         /**
-         * Execute a callback over each item while chunking.
+         * Get a generator for the given query.
+         *
+         * @return \Generator 
+         * @static 
+         */
+        public static function cursor(){
+            return \Illuminate\Database\Eloquent\Builder::cursor();
+        }
+        
+        /**
+         * Chunk the results of a query by comparing numeric IDs.
          *
-         * @param callable $callback
          * @param int $count
+         * @param callable $callback
+         * @param string $column
+         * @param string|null $alias
          * @return bool 
          * @static 
          */
-        public static function each($callback, $count = 1000){
-            return \Illuminate\Database\Eloquent\Builder::each($callback, $count);
+        public static function chunkById($count, $callback, $column = null, $alias = null){
+            return \Illuminate\Database\Eloquent\Builder::chunkById($count, $callback, $column, $alias);
         }
         
         /**
@@ -3791,167 +3921,57 @@ namespace {
         }
         
         /**
-         * Register a replacement for the default delete function.
-         *
-         * @param \Closure $callback
-         * @return void 
-         * @static 
-         */
-        public static function onDelete($callback){
-            \Illuminate\Database\Eloquent\Builder::onDelete($callback);
-        }
-        
-        /**
-         * Get the hydrated models without eager loading.
-         *
-         * @param array $columns
-         * @return \Illuminate\Database\Eloquent\Model[] 
-         * @static 
-         */
-        public static function getModels($columns = array()){
-            return \Illuminate\Database\Eloquent\Builder::getModels($columns);
-        }
-        
-        /**
-         * Eager load the relationships for the models.
-         *
-         * @param array $models
-         * @return array 
-         * @static 
-         */
-        public static function eagerLoadRelations($models){
-            return \Illuminate\Database\Eloquent\Builder::eagerLoadRelations($models);
-        }
-        
-        /**
-         * Apply the callback's query changes if the given "value" is true.
-         *
-         * @param bool $value
-         * @param \Closure $callback
-         * @return $this 
-         * @static 
-         */
-        public static function when($value, $callback){
-            return \Illuminate\Database\Eloquent\Builder::when($value, $callback);
-        }
-        
-        /**
-         * Add a basic where clause to the query.
-         *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
-         * @param string $boolean
-         * @return $this 
-         * @static 
-         */
-        public static function where($column, $operator = null, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Eloquent\Builder::where($column, $operator, $value, $boolean);
-        }
-        
-        /**
-         * Add an "or where" clause to the query.
-         *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
-         * @return \Illuminate\Database\Eloquent\Builder|static 
-         * @static 
-         */
-        public static function orWhere($column, $operator = null, $value = null){
-            return \Illuminate\Database\Eloquent\Builder::orWhere($column, $operator, $value);
-        }
-        
-        /**
-         * Add a relationship count / exists condition to the query.
+         * Save a new model and return the instance.
          *
-         * @param string $relation
-         * @param string $operator
-         * @param int $count
-         * @param string $boolean
-         * @param \Closure|null $callback
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param array $attributes
+         * @return \Illuminate\Database\Eloquent\Model|$this 
          * @static 
          */
-        public static function has($relation, $operator = '>=', $count = 1, $boolean = 'and', $callback = null){
-            return \Illuminate\Database\Eloquent\Builder::has($relation, $operator, $count, $boolean, $callback);
+        public static function create($attributes = array()){
+            return \Illuminate\Database\Eloquent\Builder::create($attributes);
         }
         
         /**
-         * Add a relationship count / exists condition to the query.
+         * Save a new model and return the instance. Allow mass-assignment.
          *
-         * @param string $relation
-         * @param string $boolean
-         * @param \Closure|null $callback
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param array $attributes
+         * @return \Illuminate\Database\Eloquent\Model|$this 
          * @static 
          */
-        public static function doesntHave($relation, $boolean = 'and', $callback = null){
-            return \Illuminate\Database\Eloquent\Builder::doesntHave($relation, $boolean, $callback);
+        public static function forceCreate($attributes){
+            return \Illuminate\Database\Eloquent\Builder::forceCreate($attributes);
         }
         
         /**
-         * Add a relationship count / exists condition to the query with where clauses.
+         * Register a replacement for the default delete function.
          *
-         * @param string $relation
          * @param \Closure $callback
-         * @param string $operator
-         * @param int $count
-         * @return \Illuminate\Database\Eloquent\Builder|static 
-         * @static 
-         */
-        public static function whereHas($relation, $callback, $operator = '>=', $count = 1){
-            return \Illuminate\Database\Eloquent\Builder::whereHas($relation, $callback, $operator, $count);
-        }
-        
-        /**
-         * Add a relationship count / exists condition to the query with where clauses.
-         *
-         * @param string $relation
-         * @param \Closure|null $callback
-         * @return \Illuminate\Database\Eloquent\Builder|static 
-         * @static 
-         */
-        public static function whereDoesntHave($relation, $callback = null){
-            return \Illuminate\Database\Eloquent\Builder::whereDoesntHave($relation, $callback);
-        }
-        
-        /**
-         * Add a relationship count / exists condition to the query with an "or".
-         *
-         * @param string $relation
-         * @param string $operator
-         * @param int $count
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @return void 
          * @static 
          */
-        public static function orHas($relation, $operator = '>=', $count = 1){
-            return \Illuminate\Database\Eloquent\Builder::orHas($relation, $operator, $count);
+        public static function onDelete($callback){
+            \Illuminate\Database\Eloquent\Builder::onDelete($callback);
         }
         
         /**
-         * Add a relationship count / exists condition to the query with where clauses and an "or".
+         * Call the given local model scopes.
          *
-         * @param string $relation
-         * @param \Closure $callback
-         * @param string $operator
-         * @param int $count
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param array $scopes
+         * @return mixed 
          * @static 
          */
-        public static function orWhereHas($relation, $callback, $operator = '>=', $count = 1){
-            return \Illuminate\Database\Eloquent\Builder::orWhereHas($relation, $callback, $operator, $count);
+        public static function scopes($scopes){
+            return \Illuminate\Database\Eloquent\Builder::scopes($scopes);
         }
         
         /**
-         * Merge the constraints from a relation query to the current query.
+         * Apply the scopes to the Eloquent builder instance and return it.
          *
-         * @param \Illuminate\Database\Eloquent\Builder $relation
          * @return \Illuminate\Database\Eloquent\Builder|static 
          * @static 
          */
-        public static function mergeModelDefinedRelationConstraints($relation){
-            return \Illuminate\Database\Eloquent\Builder::mergeModelDefinedRelationConstraints($relation);
+        public static function applyScopes(){
+            return \Illuminate\Database\Eloquent\Builder::applyScopes();
         }
         
         /**
@@ -3966,35 +3986,14 @@ namespace {
         }
         
         /**
-         * Add subselect queries to count the relations.
-         *
-         * @param mixed $relations
-         * @return $this 
-         * @static 
-         */
-        public static function withCount($relations){
-            return \Illuminate\Database\Eloquent\Builder::withCount($relations);
-        }
-        
-        /**
-         * Add the given scopes to the current builder instance.
-         *
-         * @param array $scopes
-         * @return mixed 
-         * @static 
-         */
-        public static function scopes($scopes){
-            return \Illuminate\Database\Eloquent\Builder::scopes($scopes);
-        }
-        
-        /**
-         * Apply the scopes to the Eloquent builder instance and return it.
+         * Create a new instance of the model being queried.
          *
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param array $attributes
+         * @return \Illuminate\Database\Eloquent\Model 
          * @static 
          */
-        public static function applyScopes(){
-            return \Illuminate\Database\Eloquent\Builder::applyScopes();
+        public static function newModelInstance($attributes = array()){
+            return \Illuminate\Database\Eloquent\Builder::newModelInstance($attributes);
         }
         
         /**
@@ -4008,24 +4007,24 @@ namespace {
         }
         
         /**
-         * Get a base query builder instance.
+         * Set the underlying query builder instance.
          *
-         * @return \Illuminate\Database\Query\Builder 
+         * @param \Illuminate\Database\Query\Builder $query
+         * @return $this 
          * @static 
          */
-        public static function toBase(){
-            return \Illuminate\Database\Eloquent\Builder::toBase();
+        public static function setQuery($query){
+            return \Illuminate\Database\Eloquent\Builder::setQuery($query);
         }
         
         /**
-         * Set the underlying query builder instance.
+         * Get a base query builder instance.
          *
-         * @param \Illuminate\Database\Query\Builder $query
-         * @return $this 
+         * @return \Illuminate\Database\Query\Builder 
          * @static 
          */
-        public static function setQuery($query){
-            return \Illuminate\Database\Eloquent\Builder::setQuery($query);
+        public static function toBase(){
+            return \Illuminate\Database\Eloquent\Builder::toBase();
         }
         
         /**
@@ -4071,18 +4070,6 @@ namespace {
         }
         
         /**
-         * Extend the builder with a given callback.
-         *
-         * @param string $name
-         * @param \Closure $callback
-         * @return void 
-         * @static 
-         */
-        public static function macro($name, $callback){
-            \Illuminate\Database\Eloquent\Builder::macro($name, $callback);
-        }
-        
-        /**
          * Get the given macro by name.
          *
          * @param string $name
@@ -4094,40 +4081,204 @@ namespace {
         }
         
         /**
-         * Set the columns to be selected.
+         * Chunk the results of the query.
          *
-         * @param array|mixed $columns
-         * @return $this 
+         * @param int $count
+         * @param callable $callback
+         * @return bool 
          * @static 
          */
-        public static function select($columns = array()){
-            return \Illuminate\Database\Query\Builder::select($columns);
+        public static function chunk($count, $callback){
+            return \Illuminate\Database\Eloquent\Builder::chunk($count, $callback);
         }
         
         /**
-         * Add a new "raw" select expression to the query.
+         * Execute a callback over each item while chunking.
          *
-         * @param string $expression
-         * @param array $bindings
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param callable $callback
+         * @param int $count
+         * @return bool 
          * @static 
          */
-        public static function selectRaw($expression, $bindings = array()){
-            return \Illuminate\Database\Query\Builder::selectRaw($expression, $bindings);
+        public static function each($callback, $count = 1000){
+            return \Illuminate\Database\Eloquent\Builder::each($callback, $count);
         }
         
         /**
-         * Add a subselect expression to the query.
+         * Execute the query and get the first result.
          *
-         * @param \Closure|\Illuminate\Database\Query\Builder|string $query
-         * @param string $as
-         * @return \Illuminate\Database\Query\Builder|static 
-         * @throws \InvalidArgumentException
+         * @param array $columns
+         * @return mixed 
          * @static 
          */
-        public static function selectSub($query, $as){
-            return \Illuminate\Database\Query\Builder::selectSub($query, $as);
-        }
+        public static function first($columns = array()){
+            return \Illuminate\Database\Eloquent\Builder::first($columns);
+        }
+        
+        /**
+         * Apply the callback's query changes if the given "value" is true.
+         *
+         * @param mixed $value
+         * @param callable $callback
+         * @param callable $default
+         * @return mixed 
+         * @static 
+         */
+        public static function when($value, $callback, $default = null){
+            return \Illuminate\Database\Eloquent\Builder::when($value, $callback, $default);
+        }
+        
+        /**
+         * Apply the callback's query changes if the given "value" is false.
+         *
+         * @param mixed $value
+         * @param callable $callback
+         * @param callable $default
+         * @return mixed 
+         * @static 
+         */
+        public static function unless($value, $callback, $default = null){
+            return \Illuminate\Database\Eloquent\Builder::unless($value, $callback, $default);
+        }
+        
+        /**
+         * Add a relationship count / exists condition to the query.
+         *
+         * @param string $relation
+         * @param string $operator
+         * @param int $count
+         * @param string $boolean
+         * @param \Closure|null $callback
+         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @static 
+         */
+        public static function has($relation, $operator = '>=', $count = 1, $boolean = 'and', $callback = null){
+            return \Illuminate\Database\Eloquent\Builder::has($relation, $operator, $count, $boolean, $callback);
+        }
+        
+        /**
+         * Add a relationship count / exists condition to the query with an "or".
+         *
+         * @param string $relation
+         * @param string $operator
+         * @param int $count
+         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @static 
+         */
+        public static function orHas($relation, $operator = '>=', $count = 1){
+            return \Illuminate\Database\Eloquent\Builder::orHas($relation, $operator, $count);
+        }
+        
+        /**
+         * Add a relationship count / exists condition to the query.
+         *
+         * @param string $relation
+         * @param string $boolean
+         * @param \Closure|null $callback
+         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @static 
+         */
+        public static function doesntHave($relation, $boolean = 'and', $callback = null){
+            return \Illuminate\Database\Eloquent\Builder::doesntHave($relation, $boolean, $callback);
+        }
+        
+        /**
+         * Add a relationship count / exists condition to the query with where clauses.
+         *
+         * @param string $relation
+         * @param \Closure|null $callback
+         * @param string $operator
+         * @param int $count
+         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @static 
+         */
+        public static function whereHas($relation, $callback = null, $operator = '>=', $count = 1){
+            return \Illuminate\Database\Eloquent\Builder::whereHas($relation, $callback, $operator, $count);
+        }
+        
+        /**
+         * Add a relationship count / exists condition to the query with where clauses and an "or".
+         *
+         * @param string $relation
+         * @param \Closure $callback
+         * @param string $operator
+         * @param int $count
+         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @static 
+         */
+        public static function orWhereHas($relation, $callback = null, $operator = '>=', $count = 1){
+            return \Illuminate\Database\Eloquent\Builder::orWhereHas($relation, $callback, $operator, $count);
+        }
+        
+        /**
+         * Add a relationship count / exists condition to the query with where clauses.
+         *
+         * @param string $relation
+         * @param \Closure|null $callback
+         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @static 
+         */
+        public static function whereDoesntHave($relation, $callback = null){
+            return \Illuminate\Database\Eloquent\Builder::whereDoesntHave($relation, $callback);
+        }
+        
+        /**
+         * Add subselect queries to count the relations.
+         *
+         * @param mixed $relations
+         * @return $this 
+         * @static 
+         */
+        public static function withCount($relations){
+            return \Illuminate\Database\Eloquent\Builder::withCount($relations);
+        }
+        
+        /**
+         * Merge the where constraints from another query to the current query.
+         *
+         * @param \Illuminate\Database\Eloquent\Builder $from
+         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @static 
+         */
+        public static function mergeConstraintsFrom($from){
+            return \Illuminate\Database\Eloquent\Builder::mergeConstraintsFrom($from);
+        }
+        
+        /**
+         * Set the columns to be selected.
+         *
+         * @param array|mixed $columns
+         * @return $this 
+         * @static 
+         */
+        public static function select($columns = array()){
+            return \Illuminate\Database\Query\Builder::select($columns);
+        }
+        
+        /**
+         * Add a new "raw" select expression to the query.
+         *
+         * @param string $expression
+         * @param array $bindings
+         * @return \Illuminate\Database\Query\Builder|static 
+         * @static 
+         */
+        public static function selectRaw($expression, $bindings = array()){
+            return \Illuminate\Database\Query\Builder::selectRaw($expression, $bindings);
+        }
+        
+        /**
+         * Add a subselect expression to the query.
+         *
+         * @param \Closure|\Illuminate\Database\Query\Builder|string $query
+         * @param string $as
+         * @return \Illuminate\Database\Query\Builder|static 
+         * @throws \InvalidArgumentException
+         * @static 
+         */
+        public static function selectSub($query, $as){
+            return \Illuminate\Database\Query\Builder::selectSub($query, $as);
+        }
         
         /**
          * Add a new select column to the query.
@@ -4165,31 +4316,31 @@ namespace {
          * Add a join clause to the query.
          *
          * @param string $table
-         * @param string $one
+         * @param string $first
          * @param string $operator
-         * @param string $two
+         * @param string $second
          * @param string $type
          * @param bool $where
          * @return $this 
          * @static 
          */
-        public static function join($table, $one, $operator = null, $two = null, $type = 'inner', $where = false){
-            return \Illuminate\Database\Query\Builder::join($table, $one, $operator, $two, $type, $where);
+        public static function join($table, $first, $operator = null, $second = null, $type = 'inner', $where = false){
+            return \Illuminate\Database\Query\Builder::join($table, $first, $operator, $second, $type, $where);
         }
         
         /**
          * Add a "join where" clause to the query.
          *
          * @param string $table
-         * @param string $one
+         * @param string $first
          * @param string $operator
-         * @param string $two
+         * @param string $second
          * @param string $type
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function joinWhere($table, $one, $operator, $two, $type = 'inner'){
-            return \Illuminate\Database\Query\Builder::joinWhere($table, $one, $operator, $two, $type);
+        public static function joinWhere($table, $first, $operator, $second, $type = 'inner'){
+            return \Illuminate\Database\Query\Builder::joinWhere($table, $first, $operator, $second, $type);
         }
         
         /**
@@ -4210,14 +4361,14 @@ namespace {
          * Add a "join where" clause to the query.
          *
          * @param string $table
-         * @param string $one
+         * @param string $first
          * @param string $operator
-         * @param string $two
+         * @param string $second
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function leftJoinWhere($table, $one, $operator, $two){
-            return \Illuminate\Database\Query\Builder::leftJoinWhere($table, $one, $operator, $two);
+        public static function leftJoinWhere($table, $first, $operator, $second){
+            return \Illuminate\Database\Query\Builder::leftJoinWhere($table, $first, $operator, $second);
         }
         
         /**
@@ -4238,14 +4389,14 @@ namespace {
          * Add a "right join where" clause to the query.
          *
          * @param string $table
-         * @param string $one
+         * @param string $first
          * @param string $operator
-         * @param string $two
+         * @param string $second
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function rightJoinWhere($table, $one, $operator, $two){
-            return \Illuminate\Database\Query\Builder::rightJoinWhere($table, $one, $operator, $two);
+        public static function rightJoinWhere($table, $first, $operator, $second){
+            return \Illuminate\Database\Query\Builder::rightJoinWhere($table, $first, $operator, $second);
         }
         
         /**
@@ -4263,6 +4414,29 @@ namespace {
         }
         
         /**
+         * Pass the query to a given callback.
+         *
+         * @param \Closure $callback
+         * @return \Illuminate\Database\Query\Builder 
+         * @static 
+         */
+        public static function tap($callback){
+            return \Illuminate\Database\Query\Builder::tap($callback);
+        }
+        
+        /**
+         * Merge an array of where clauses and bindings.
+         *
+         * @param array $wheres
+         * @param array $bindings
+         * @return void 
+         * @static 
+         */
+        public static function mergeWheres($wheres, $bindings){
+            \Illuminate\Database\Query\Builder::mergeWheres($wheres, $bindings);
+        }
+        
+        /**
          * Add a "where" clause comparing two columns to the query.
          *
          * @param string|array $first
@@ -4315,343 +4489,343 @@ namespace {
         }
         
         /**
-         * Add a where between statement to the query.
+         * Add a "where in" clause to the query.
          *
          * @param string $column
-         * @param array $values
+         * @param mixed $values
          * @param string $boolean
          * @param bool $not
          * @return $this 
          * @static 
          */
-        public static function whereBetween($column, $values, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::whereBetween($column, $values, $boolean, $not);
+        public static function whereIn($column, $values, $boolean = 'and', $not = false){
+            return \Illuminate\Database\Query\Builder::whereIn($column, $values, $boolean, $not);
         }
         
         /**
-         * Add an or where between statement to the query.
+         * Add an "or where in" clause to the query.
          *
          * @param string $column
-         * @param array $values
+         * @param mixed $values
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereBetween($column, $values){
-            return \Illuminate\Database\Query\Builder::orWhereBetween($column, $values);
+        public static function orWhereIn($column, $values){
+            return \Illuminate\Database\Query\Builder::orWhereIn($column, $values);
         }
         
         /**
-         * Add a where not between statement to the query.
+         * Add a "where not in" clause to the query.
          *
          * @param string $column
-         * @param array $values
+         * @param mixed $values
          * @param string $boolean
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function whereNotBetween($column, $values, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNotBetween($column, $values, $boolean);
+        public static function whereNotIn($column, $values, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereNotIn($column, $values, $boolean);
         }
         
         /**
-         * Add an or where not between statement to the query.
+         * Add an "or where not in" clause to the query.
          *
          * @param string $column
-         * @param array $values
+         * @param mixed $values
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereNotBetween($column, $values){
-            return \Illuminate\Database\Query\Builder::orWhereNotBetween($column, $values);
+        public static function orWhereNotIn($column, $values){
+            return \Illuminate\Database\Query\Builder::orWhereNotIn($column, $values);
         }
         
         /**
-         * Add a nested where statement to the query.
+         * Add a "where null" clause to the query.
          *
-         * @param \Closure $callback
+         * @param string $column
          * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param bool $not
+         * @return $this 
          * @static 
          */
-        public static function whereNested($callback, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNested($callback, $boolean);
+        public static function whereNull($column, $boolean = 'and', $not = false){
+            return \Illuminate\Database\Query\Builder::whereNull($column, $boolean, $not);
         }
         
         /**
-         * Create a new query instance for nested where condition.
+         * Add an "or where null" clause to the query.
          *
-         * @return \Illuminate\Database\Query\Builder 
+         * @param string $column
+         * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function forNestedWhere(){
-            return \Illuminate\Database\Query\Builder::forNestedWhere();
+        public static function orWhereNull($column){
+            return \Illuminate\Database\Query\Builder::orWhereNull($column);
         }
         
         /**
-         * Add another query builder as a nested where to the query builder.
+         * Add a "where not null" clause to the query.
          *
-         * @param \Illuminate\Database\Query\Builder|static $query
+         * @param string $column
          * @param string $boolean
-         * @return $this 
+         * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function addNestedWhereQuery($query, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::addNestedWhereQuery($query, $boolean);
+        public static function whereNotNull($column, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereNotNull($column, $boolean);
         }
         
         /**
-         * Add an exists clause to the query.
+         * Add a where between statement to the query.
          *
-         * @param \Closure $callback
+         * @param string $column
+         * @param array $values
          * @param string $boolean
          * @param bool $not
          * @return $this 
          * @static 
          */
-        public static function whereExists($callback, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::whereExists($callback, $boolean, $not);
+        public static function whereBetween($column, $values, $boolean = 'and', $not = false){
+            return \Illuminate\Database\Query\Builder::whereBetween($column, $values, $boolean, $not);
         }
         
         /**
-         * Add an or exists clause to the query.
+         * Add an or where between statement to the query.
          *
-         * @param \Closure $callback
-         * @param bool $not
+         * @param string $column
+         * @param array $values
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereExists($callback, $not = false){
-            return \Illuminate\Database\Query\Builder::orWhereExists($callback, $not);
+        public static function orWhereBetween($column, $values){
+            return \Illuminate\Database\Query\Builder::orWhereBetween($column, $values);
         }
         
         /**
-         * Add a where not exists clause to the query.
+         * Add a where not between statement to the query.
          *
-         * @param \Closure $callback
+         * @param string $column
+         * @param array $values
          * @param string $boolean
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function whereNotExists($callback, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNotExists($callback, $boolean);
+        public static function whereNotBetween($column, $values, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereNotBetween($column, $values, $boolean);
         }
         
         /**
-         * Add a where not exists clause to the query.
+         * Add an or where not between statement to the query.
          *
-         * @param \Closure $callback
+         * @param string $column
+         * @param array $values
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereNotExists($callback){
-            return \Illuminate\Database\Query\Builder::orWhereNotExists($callback);
+        public static function orWhereNotBetween($column, $values){
+            return \Illuminate\Database\Query\Builder::orWhereNotBetween($column, $values);
         }
         
         /**
-         * Add an exists clause to the query.
+         * Add an "or where not null" clause to the query.
          *
-         * @param \Illuminate\Database\Query\Builder $query
-         * @param string $boolean
-         * @param bool $not
-         * @return $this 
+         * @param string $column
+         * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function addWhereExistsQuery($query, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::addWhereExistsQuery($query, $boolean, $not);
+        public static function orWhereNotNull($column){
+            return \Illuminate\Database\Query\Builder::orWhereNotNull($column);
         }
         
         /**
-         * Add a "where in" clause to the query.
+         * Add a "where date" statement to the query.
          *
          * @param string $column
-         * @param mixed $values
+         * @param string $operator
+         * @param mixed $value
          * @param string $boolean
-         * @param bool $not
-         * @return $this 
+         * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function whereIn($column, $values, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::whereIn($column, $values, $boolean, $not);
+        public static function whereDate($column, $operator, $value = null, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereDate($column, $operator, $value, $boolean);
         }
         
         /**
-         * Add an "or where in" clause to the query.
+         * Add an "or where date" statement to the query.
          *
          * @param string $column
-         * @param mixed $values
+         * @param string $operator
+         * @param string $value
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereIn($column, $values){
-            return \Illuminate\Database\Query\Builder::orWhereIn($column, $values);
+        public static function orWhereDate($column, $operator, $value){
+            return \Illuminate\Database\Query\Builder::orWhereDate($column, $operator, $value);
         }
         
         /**
-         * Add a "where not in" clause to the query.
+         * Add a "where time" statement to the query.
          *
          * @param string $column
-         * @param mixed $values
+         * @param string $operator
+         * @param int $value
          * @param string $boolean
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function whereNotIn($column, $values, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNotIn($column, $values, $boolean);
+        public static function whereTime($column, $operator, $value, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereTime($column, $operator, $value, $boolean);
         }
         
         /**
-         * Add an "or where not in" clause to the query.
+         * Add an "or where time" statement to the query.
          *
          * @param string $column
-         * @param mixed $values
+         * @param string $operator
+         * @param int $value
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereNotIn($column, $values){
-            return \Illuminate\Database\Query\Builder::orWhereNotIn($column, $values);
+        public static function orWhereTime($column, $operator, $value){
+            return \Illuminate\Database\Query\Builder::orWhereTime($column, $operator, $value);
         }
         
         /**
-         * Add a "where null" clause to the query.
+         * Add a "where day" statement to the query.
          *
          * @param string $column
+         * @param string $operator
+         * @param mixed $value
          * @param string $boolean
-         * @param bool $not
-         * @return $this 
+         * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function whereNull($column, $boolean = 'and', $not = false){
-            return \Illuminate\Database\Query\Builder::whereNull($column, $boolean, $not);
+        public static function whereDay($column, $operator, $value = null, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereDay($column, $operator, $value, $boolean);
         }
         
         /**
-         * Add an "or where null" clause to the query.
+         * Add a "where month" statement to the query.
          *
          * @param string $column
+         * @param string $operator
+         * @param mixed $value
+         * @param string $boolean
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereNull($column){
-            return \Illuminate\Database\Query\Builder::orWhereNull($column);
+        public static function whereMonth($column, $operator, $value = null, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereMonth($column, $operator, $value, $boolean);
         }
         
         /**
-         * Add a "where not null" clause to the query.
+         * Add a "where year" statement to the query.
          *
          * @param string $column
+         * @param string $operator
+         * @param mixed $value
          * @param string $boolean
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function whereNotNull($column, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereNotNull($column, $boolean);
+        public static function whereYear($column, $operator, $value = null, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereYear($column, $operator, $value, $boolean);
         }
         
         /**
-         * Add an "or where not null" clause to the query.
+         * Add a nested where statement to the query.
          *
-         * @param string $column
+         * @param \Closure $callback
+         * @param string $boolean
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereNotNull($column){
-            return \Illuminate\Database\Query\Builder::orWhereNotNull($column);
+        public static function whereNested($callback, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereNested($callback, $boolean);
         }
         
         /**
-         * Add a "where date" statement to the query.
+         * Create a new query instance for nested where condition.
          *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
-         * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @return \Illuminate\Database\Query\Builder 
          * @static 
          */
-        public static function whereDate($column, $operator, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereDate($column, $operator, $value, $boolean);
+        public static function forNestedWhere(){
+            return \Illuminate\Database\Query\Builder::forNestedWhere();
         }
         
         /**
-         * Add an "or where date" statement to the query.
+         * Add another query builder as a nested where to the query builder.
          *
-         * @param string $column
-         * @param string $operator
-         * @param string $value
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param \Illuminate\Database\Query\Builder|static $query
+         * @param string $boolean
+         * @return $this 
          * @static 
          */
-        public static function orWhereDate($column, $operator, $value){
-            return \Illuminate\Database\Query\Builder::orWhereDate($column, $operator, $value);
+        public static function addNestedWhereQuery($query, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::addNestedWhereQuery($query, $boolean);
         }
         
         /**
-         * Add a "where time" statement to the query.
+         * Add an exists clause to the query.
          *
-         * @param string $column
-         * @param string $operator
-         * @param int $value
+         * @param \Closure $callback
          * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param bool $not
+         * @return $this 
          * @static 
          */
-        public static function whereTime($column, $operator, $value, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereTime($column, $operator, $value, $boolean);
+        public static function whereExists($callback, $boolean = 'and', $not = false){
+            return \Illuminate\Database\Query\Builder::whereExists($callback, $boolean, $not);
         }
         
         /**
-         * Add an "or where time" statement to the query.
+         * Add an or exists clause to the query.
          *
-         * @param string $column
-         * @param string $operator
-         * @param int $value
+         * @param \Closure $callback
+         * @param bool $not
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function orWhereTime($column, $operator, $value){
-            return \Illuminate\Database\Query\Builder::orWhereTime($column, $operator, $value);
+        public static function orWhereExists($callback, $not = false){
+            return \Illuminate\Database\Query\Builder::orWhereExists($callback, $not);
         }
         
         /**
-         * Add a "where day" statement to the query.
+         * Add a where not exists clause to the query.
          *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
+         * @param \Closure $callback
          * @param string $boolean
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function whereDay($column, $operator, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereDay($column, $operator, $value, $boolean);
+        public static function whereNotExists($callback, $boolean = 'and'){
+            return \Illuminate\Database\Query\Builder::whereNotExists($callback, $boolean);
         }
         
         /**
-         * Add a "where month" statement to the query.
+         * Add a where not exists clause to the query.
          *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
-         * @param string $boolean
+         * @param \Closure $callback
          * @return \Illuminate\Database\Query\Builder|static 
          * @static 
          */
-        public static function whereMonth($column, $operator, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereMonth($column, $operator, $value, $boolean);
+        public static function orWhereNotExists($callback){
+            return \Illuminate\Database\Query\Builder::orWhereNotExists($callback);
         }
         
         /**
-         * Add a "where year" statement to the query.
+         * Add an exists clause to the query.
          *
-         * @param string $column
-         * @param string $operator
-         * @param mixed $value
+         * @param \Illuminate\Database\Query\Builder $query
          * @param string $boolean
-         * @return \Illuminate\Database\Query\Builder|static 
+         * @param bool $not
+         * @return $this 
          * @static 
          */
-        public static function whereYear($column, $operator, $value = null, $boolean = 'and'){
-            return \Illuminate\Database\Query\Builder::whereYear($column, $operator, $value, $boolean);
+        public static function addWhereExistsQuery($query, $boolean = 'and', $not = false){
+            return \Illuminate\Database\Query\Builder::addWhereExistsQuery($query, $boolean, $not);
         }
         
         /**
@@ -4742,6 +4916,17 @@ namespace {
         }
         
         /**
+         * Add a descending "order by" clause to the query.
+         *
+         * @param string $column
+         * @return $this 
+         * @static 
+         */
+        public static function orderByDesc($column){
+            return \Illuminate\Database\Query\Builder::orderByDesc($column);
+        }
+        
+        /**
          * Add an "order by" clause for a timestamp to the query.
          *
          * @param string $column
@@ -4787,17 +4972,6 @@ namespace {
         }
         
         /**
-         * Set the "offset" value of the query.
-         *
-         * @param int $value
-         * @return $this 
-         * @static 
-         */
-        public static function offset($value){
-            return \Illuminate\Database\Query\Builder::offset($value);
-        }
-        
-        /**
          * Alias to set the "offset" value of the query.
          *
          * @param int $value
@@ -4809,14 +4983,14 @@ namespace {
         }
         
         /**
-         * Set the "limit" value of the query.
+         * Set the "offset" value of the query.
          *
          * @param int $value
          * @return $this 
          * @static 
          */
-        public static function limit($value){
-            return \Illuminate\Database\Query\Builder::limit($value);
+        public static function offset($value){
+            return \Illuminate\Database\Query\Builder::offset($value);
         }
         
         /**
@@ -4831,6 +5005,17 @@ namespace {
         }
         
         /**
+         * Set the "limit" value of the query.
+         *
+         * @param int $value
+         * @return $this 
+         * @static 
+         */
+        public static function limit($value){
+            return \Illuminate\Database\Query\Builder::limit($value);
+        }
+        
+        /**
          * Set the limit and offset for a given page.
          *
          * @param int $page
@@ -4881,7 +5066,7 @@ namespace {
         /**
          * Lock the selected rows in the table.
          *
-         * @param bool $value
+         * @param string|bool $value
          * @return $this 
          * @static 
          */
@@ -5088,18 +5273,6 @@ namespace {
         }
         
         /**
-         * Merge an array of where clauses and bindings.
-         *
-         * @param array $wheres
-         * @param array $bindings
-         * @return void 
-         * @static 
-         */
-        public static function mergeWheres($wheres, $bindings){
-            \Illuminate\Database\Query\Builder::mergeWheres($wheres, $bindings);
-        }
-        
-        /**
          * Create a raw database expression.
          *
          * @param mixed $value
@@ -5198,22 +5371,56 @@ namespace {
         }
         
         /**
-         * Checks if macro is registered.
+         * Clone the query without the given properties.
          *
-         * @param string $name
-         * @return bool 
+         * @param array $except
+         * @return static 
          * @static 
          */
-        public static function hasMacro($name){
-            return \Illuminate\Database\Query\Builder::hasMacro($name);
+        public static function cloneWithout($except){
+            return \Illuminate\Database\Query\Builder::cloneWithout($except);
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Clone the query without the given bindings.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return mixed 
+         * @param array $except
+         * @return static 
+         * @static 
+         */
+        public static function cloneWithoutBindings($except){
+            return \Illuminate\Database\Query\Builder::cloneWithoutBindings($except);
+        }
+        
+        /**
+         * Register a custom macro.
+         *
+         * @param string $name
+         * @param callable $macro
+         * @return void 
+         * @static 
+         */
+        public static function macro($name, $macro){
+            \Illuminate\Database\Query\Builder::macro($name, $macro);
+        }
+        
+        /**
+         * Checks if macro is registered.
+         *
+         * @param string $name
+         * @return bool 
+         * @static 
+         */
+        public static function hasMacro($name){
+            return \Illuminate\Database\Query\Builder::hasMacro($name);
+        }
+        
+        /**
+         * Dynamically handle calls to the class.
+         *
+         * @param string $method
+         * @param array $parameters
+         * @return mixed 
          * @throws \BadMethodCallException
          * @static 
          */
@@ -5231,12 +5438,11 @@ namespace {
          *
          * @param string|array $events
          * @param mixed $listener
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function listen($events, $listener, $priority = 0){
-            \Illuminate\Events\Dispatcher::listen($events, $listener, $priority);
+        public static function listen($events, $listener){
+            \Illuminate\Events\Dispatcher::listen($events, $listener);
         }
         
         /**
@@ -5263,6 +5469,17 @@ namespace {
         }
         
         /**
+         * Flush a set of pushed events.
+         *
+         * @param string $event
+         * @return void 
+         * @static 
+         */
+        public static function flush($event){
+            \Illuminate\Events\Dispatcher::flush($event);
+        }
+        
+        /**
          * Register an event subscriber with the dispatcher.
          *
          * @param object|string $subscriber
@@ -5277,8 +5494,8 @@ namespace {
          * Fire an event until the first non-null response is returned.
          *
          * @param string|object $event
-         * @param array $payload
-         * @return mixed 
+         * @param mixed $payload
+         * @return array|null 
          * @static 
          */
         public static function until($event, $payload = array()){
@@ -5286,24 +5503,16 @@ namespace {
         }
         
         /**
-         * Flush a set of pushed events.
-         *
-         * @param string $event
-         * @return void 
-         * @static 
-         */
-        public static function flush($event){
-            \Illuminate\Events\Dispatcher::flush($event);
-        }
-        
-        /**
-         * Get the event that is currently firing.
+         * Fire an event and call the listeners.
          *
-         * @return string 
+         * @param string|object $event
+         * @param mixed $payload
+         * @param bool $halt
+         * @return array|null 
          * @static 
          */
-        public static function firing(){
-            return \Illuminate\Events\Dispatcher::firing();
+        public static function fire($event, $payload = array(), $halt = false){
+            return \Illuminate\Events\Dispatcher::fire($event, $payload, $halt);
         }
         
         /**
@@ -5315,8 +5524,8 @@ namespace {
          * @return array|null 
          * @static 
          */
-        public static function fire($event, $payload = array(), $halt = false){
-            return \Illuminate\Events\Dispatcher::fire($event, $payload, $halt);
+        public static function dispatch($event, $payload = array(), $halt = false){
+            return \Illuminate\Events\Dispatcher::dispatch($event, $payload, $halt);
         }
         
         /**
@@ -5333,23 +5542,25 @@ namespace {
         /**
          * Register an event listener with the dispatcher.
          *
-         * @param mixed $listener
-         * @return mixed 
+         * @param string|\Closure $listener
+         * @param bool $wildcard
+         * @return \Closure 
          * @static 
          */
-        public static function makeListener($listener){
-            return \Illuminate\Events\Dispatcher::makeListener($listener);
+        public static function makeListener($listener, $wildcard = false){
+            return \Illuminate\Events\Dispatcher::makeListener($listener, $wildcard);
         }
         
         /**
          * Create a class based listener using the IoC container.
          *
-         * @param mixed $listener
+         * @param string $listener
+         * @param bool $wildcard
          * @return \Closure 
          * @static 
          */
-        public static function createClassListener($listener){
-            return \Illuminate\Events\Dispatcher::createClassListener($listener);
+        public static function createClassListener($listener, $wildcard = false){
+            return \Illuminate\Events\Dispatcher::createClassListener($listener, $wildcard);
         }
         
         /**
@@ -5448,6 +5659,17 @@ namespace {
         }
         
         /**
+         * Get the MD5 hash of the file at the given path.
+         *
+         * @param string $path
+         * @return string 
+         * @static 
+         */
+        public static function hash($path){
+            return \Illuminate\Filesystem\Filesystem::hash($path);
+        }
+        
+        /**
          * Write the contents of a file.
          *
          * @param string $path
@@ -5485,6 +5707,18 @@ namespace {
         }
         
         /**
+         * Get or set UNIX mode of a file or directory.
+         *
+         * @param string $path
+         * @param int $mode
+         * @return mixed 
+         * @static 
+         */
+        public static function chmod($path, $mode = null){
+            return \Illuminate\Filesystem\Filesystem::chmod($path, $mode);
+        }
+        
+        /**
          * Delete the file at a given path.
          *
          * @param string|array $paths
@@ -5827,6 +6061,19 @@ namespace {
         }
         
         /**
+         * Define abilities for a resource.
+         *
+         * @param string $name
+         * @param string $class
+         * @param array $abilities
+         * @return $this 
+         * @static 
+         */
+        public static function resource($name, $class, $abilities = null){
+            return \Illuminate\Auth\Access\Gate::resource($name, $class, $abilities);
+        }
+        
+        /**
          * Define a policy class for a given class type.
          *
          * @param string $class
@@ -5914,7 +6161,6 @@ namespace {
          *
          * @param object|string $class
          * @return mixed 
-         * @throws \InvalidArgumentException
          * @static 
          */
         public static function getPolicyFor($class){
@@ -5943,6 +6189,16 @@ namespace {
             return \Illuminate\Auth\Access\Gate::forUser($user);
         }
         
+        /**
+         * Get all of the defined abilities.
+         *
+         * @return array 
+         * @static 
+         */
+        public static function abilities(){
+            return \Illuminate\Auth\Access\Gate::abilities();
+        }
+        
     }
 
 
@@ -6126,6 +6382,17 @@ namespace {
         }
         
         /**
+         * Check if the route name matches the given string.
+         *
+         * @param string $name
+         * @return bool 
+         * @static 
+         */
+        public static function routeIs($name){
+            return \Illuminate\Http\Request::routeIs($name);
+        }
+        
+        /**
          * Determine if the current request URL and query string matches a pattern.
          *
          * @return bool 
@@ -6186,1447 +6453,1510 @@ namespace {
         }
         
         /**
-         * Determine if the request contains a given input item key.
+         * Merge new input into the current request's input array.
          *
-         * @param string|array $key
-         * @return bool 
+         * @param array $input
+         * @return void 
          * @static 
          */
-        public static function exists($key){
-            return \Illuminate\Http\Request::exists($key);
+        public static function merge($input){
+            \Illuminate\Http\Request::merge($input);
         }
         
         /**
-         * Determine if the request contains a non-empty value for an input item.
+         * Replace the input for the current request.
          *
-         * @param string|array $key
-         * @return bool 
+         * @param array $input
+         * @return void 
          * @static 
          */
-        public static function has($key){
-            return \Illuminate\Http\Request::has($key);
+        public static function replace($input){
+            \Illuminate\Http\Request::replace($input);
         }
         
         /**
-         * Get all of the input and files for the request.
+         * Get the JSON payload for the request.
          *
-         * @return array 
+         * @param string $key
+         * @param mixed $default
+         * @return mixed 
          * @static 
          */
-        public static function all(){
-            return \Illuminate\Http\Request::all();
+        public static function json($key = null, $default = null){
+            return \Illuminate\Http\Request::json($key, $default);
         }
         
         /**
-         * Retrieve an input item from the request.
+         * Create an Illuminate request from a Symfony instance.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @return \Illuminate\Http\Request 
          * @static 
          */
-        public static function input($key = null, $default = null){
-            return \Illuminate\Http\Request::input($key, $default);
+        public static function createFromBase($request){
+            return \Illuminate\Http\Request::createFromBase($request);
         }
         
         /**
-         * Get a subset containing the provided keys with values from the input data.
+         * Clones a request and overrides some of its parameters.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param array $query The GET parameters
+         * @param array $request The POST parameters
+         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
+         * @param array $cookies The COOKIE parameters
+         * @param array $files The FILES parameters
+         * @param array $server The SERVER parameters
+         * @return static 
          * @static 
          */
-        public static function only($keys){
-            return \Illuminate\Http\Request::only($keys);
+        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null){
+            return \Illuminate\Http\Request::duplicate($query, $request, $attributes, $cookies, $files, $server);
         }
         
         /**
-         * Get all of the input except for a specified array of items.
+         * Get the session associated with the request.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @return \Illuminate\Session\Store 
+         * @throws \RuntimeException
          * @static 
          */
-        public static function except($keys){
-            return \Illuminate\Http\Request::except($keys);
+        public static function session(){
+            return \Illuminate\Http\Request::session();
         }
         
         /**
-         * Intersect an array of items with the input data.
+         * Set the session instance on the request.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param \Illuminate\Contracts\Session\Session $session
+         * @return void 
          * @static 
          */
-        public static function intersect($keys){
-            return \Illuminate\Http\Request::intersect($keys);
+        public static function setLaravelSession($session){
+            \Illuminate\Http\Request::setLaravelSession($session);
         }
         
         /**
-         * Retrieve a query string item from the request.
+         * Get the user making the request.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param string|null $guard
+         * @return mixed 
          * @static 
          */
-        public static function query($key = null, $default = null){
-            return \Illuminate\Http\Request::query($key, $default);
+        public static function user($guard = null){
+            return \Illuminate\Http\Request::user($guard);
         }
         
         /**
-         * Determine if a cookie is set on the request.
+         * Get the route handling the request.
          *
-         * @param string $key
-         * @return bool 
+         * @param string|null $param
+         * @return \Illuminate\Routing\Route|object|string 
          * @static 
          */
-        public static function hasCookie($key){
-            return \Illuminate\Http\Request::hasCookie($key);
+        public static function route($param = null){
+            return \Illuminate\Http\Request::route($param);
         }
         
         /**
-         * Retrieve a cookie from the request.
+         * Get a unique fingerprint for the request / route / IP address.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return string 
+         * @throws \RuntimeException
          * @static 
          */
-        public static function cookie($key = null, $default = null){
-            return \Illuminate\Http\Request::cookie($key, $default);
+        public static function fingerprint(){
+            return \Illuminate\Http\Request::fingerprint();
         }
         
         /**
-         * Get an array of all of the files on the request.
+         * Set the JSON payload for the request.
          *
-         * @return array 
+         * @param array $json
+         * @return $this 
          * @static 
          */
-        public static function allFiles(){
-            return \Illuminate\Http\Request::allFiles();
+        public static function setJson($json){
+            return \Illuminate\Http\Request::setJson($json);
         }
         
         /**
-         * Retrieve a file from the request.
+         * Get the user resolver callback.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return \Illuminate\Http\UploadedFile|array|null 
+         * @return \Closure 
          * @static 
          */
-        public static function file($key = null, $default = null){
-            return \Illuminate\Http\Request::file($key, $default);
+        public static function getUserResolver(){
+            return \Illuminate\Http\Request::getUserResolver();
         }
         
         /**
-         * Determine if the uploaded data contains a file.
+         * Set the user resolver callback.
          *
-         * @param string $key
-         * @return bool 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function hasFile($key){
-            return \Illuminate\Http\Request::hasFile($key);
+        public static function setUserResolver($callback){
+            return \Illuminate\Http\Request::setUserResolver($callback);
         }
         
         /**
-         * Determine if a header is set on the request.
+         * Get the route resolver callback.
          *
-         * @param string $key
-         * @return bool 
+         * @return \Closure 
          * @static 
          */
-        public static function hasHeader($key){
-            return \Illuminate\Http\Request::hasHeader($key);
+        public static function getRouteResolver(){
+            return \Illuminate\Http\Request::getRouteResolver();
         }
         
         /**
-         * Retrieve a header from the request.
+         * Set the route resolver callback.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function header($key = null, $default = null){
-            return \Illuminate\Http\Request::header($key, $default);
+        public static function setRouteResolver($callback){
+            return \Illuminate\Http\Request::setRouteResolver($callback);
         }
         
         /**
-         * Retrieve a server variable from the request.
+         * Get all of the input and files for the request.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return array 
          * @static 
          */
-        public static function server($key = null, $default = null){
-            return \Illuminate\Http\Request::server($key, $default);
+        public static function toArray(){
+            return \Illuminate\Http\Request::toArray();
         }
         
         /**
-         * Retrieve an old input item.
+         * Determine if the given offset exists.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param string $offset
+         * @return bool 
          * @static 
          */
-        public static function old($key = null, $default = null){
-            return \Illuminate\Http\Request::old($key, $default);
+        public static function offsetExists($offset){
+            return \Illuminate\Http\Request::offsetExists($offset);
         }
         
         /**
-         * Flash the input for the current request to the session.
+         * Get the value at the given offset.
          *
-         * @param string $filter
-         * @param array $keys
-         * @return void 
+         * @param string $offset
+         * @return mixed 
          * @static 
          */
-        public static function flash($filter = null, $keys = array()){
-            \Illuminate\Http\Request::flash($filter, $keys);
+        public static function offsetGet($offset){
+            return \Illuminate\Http\Request::offsetGet($offset);
         }
         
         /**
-         * Flash only some of the input to the session.
+         * Set the value at the given offset.
          *
-         * @param array|mixed $keys
+         * @param string $offset
+         * @param mixed $value
          * @return void 
          * @static 
          */
-        public static function flashOnly($keys){
-            \Illuminate\Http\Request::flashOnly($keys);
+        public static function offsetSet($offset, $value){
+            \Illuminate\Http\Request::offsetSet($offset, $value);
         }
         
         /**
-         * Flash only some of the input to the session.
+         * Remove the value at the given offset.
          *
-         * @param array|mixed $keys
+         * @param string $offset
          * @return void 
          * @static 
          */
-        public static function flashExcept($keys){
-            \Illuminate\Http\Request::flashExcept($keys);
+        public static function offsetUnset($offset){
+            \Illuminate\Http\Request::offsetUnset($offset);
         }
         
         /**
-         * Flush all of the old input from the session.
+         * Sets the parameters for this request.
+         * 
+         * This method also re-initializes all properties.
          *
-         * @return void 
+         * @param array $query The GET parameters
+         * @param array $request The POST parameters
+         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
+         * @param array $cookies The COOKIE parameters
+         * @param array $files The FILES parameters
+         * @param array $server The SERVER parameters
+         * @param string|resource $content The raw body data
          * @static 
          */
-        public static function flush(){
-            \Illuminate\Http\Request::flush();
+        public static function initialize($query = array(), $request = array(), $attributes = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::initialize($query, $request, $attributes, $cookies, $files, $server, $content);
         }
         
         /**
-         * Merge new input into the current request's input array.
+         * Creates a new request with values from PHP's super globals.
          *
-         * @param array $input
-         * @return void 
+         * @return static 
          * @static 
          */
-        public static function merge($input){
-            \Illuminate\Http\Request::merge($input);
+        public static function createFromGlobals(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::createFromGlobals();
         }
         
         /**
-         * Replace the input for the current request.
+         * Creates a Request based on a given URI and configuration.
+         * 
+         * The information contained in the URI always take precedence
+         * over the other information (server and parameters).
          *
-         * @param array $input
-         * @return void 
+         * @param string $uri The URI
+         * @param string $method The HTTP method
+         * @param array $parameters The query (GET) or request (POST) parameters
+         * @param array $cookies The request cookies ($_COOKIE)
+         * @param array $files The request files ($_FILES)
+         * @param array $server The server parameters ($_SERVER)
+         * @param string $content The raw body data
+         * @return static 
          * @static 
          */
-        public static function replace($input){
-            \Illuminate\Http\Request::replace($input);
+        public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);
         }
         
         /**
-         * Get the JSON payload for the request.
+         * Sets a callable able to create a Request instance.
+         * 
+         * This is mainly useful when you need to override the Request class
+         * to keep BC with an existing system. It should not be used for any
+         * other purpose.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param callable|null $callable A PHP callable
          * @static 
          */
-        public static function json($key = null, $default = null){
-            return \Illuminate\Http\Request::json($key, $default);
+        public static function setFactory($callable){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setFactory($callable);
         }
         
         /**
-         * Determine if the given content types match.
+         * Overrides the PHP global variables according to this request instance.
+         * 
+         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.
+         * $_FILES is never overridden, see rfc1867
          *
-         * @param string $actual
-         * @param string $type
-         * @return bool 
          * @static 
          */
-        public static function matchesType($actual, $type){
-            return \Illuminate\Http\Request::matchesType($actual, $type);
+        public static function overrideGlobals(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::overrideGlobals();
         }
         
         /**
-         * Determine if the request is sending JSON.
+         * Sets a list of trusted proxies.
+         * 
+         * You should only list the reverse proxies that you manage directly.
          *
-         * @return bool 
+         * @param array $proxies A list of trusted proxies
+         * @param int $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies
+         * @throws \InvalidArgumentException When $trustedHeaderSet is invalid
          * @static 
          */
-        public static function isJson(){
-            return \Illuminate\Http\Request::isJson();
+        public static function setTrustedProxies($proxies){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedProxies($proxies);
         }
         
         /**
-         * Determine if the current request probably expects a JSON response.
+         * Gets the list of trusted proxies.
          *
-         * @return bool 
+         * @return array An array of trusted proxies
          * @static 
          */
-        public static function expectsJson(){
-            return \Illuminate\Http\Request::expectsJson();
+        public static function getTrustedProxies(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedProxies();
         }
         
         /**
-         * Determine if the current request is asking for JSON in return.
+         * Gets the set of trusted headers from trusted proxies.
          *
-         * @return bool 
+         * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies
          * @static 
          */
-        public static function wantsJson(){
-            return \Illuminate\Http\Request::wantsJson();
+        public static function getTrustedHeaderSet(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHeaderSet();
         }
         
         /**
-         * Determines whether the current requests accepts a given content type.
+         * Sets a list of trusted host patterns.
+         * 
+         * You should only list the hosts you manage using regexs.
          *
-         * @param string|array $contentTypes
-         * @return bool 
+         * @param array $hostPatterns A list of trusted host patterns
          * @static 
          */
-        public static function accepts($contentTypes){
-            return \Illuminate\Http\Request::accepts($contentTypes);
+        public static function setTrustedHosts($hostPatterns){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedHosts($hostPatterns);
         }
         
         /**
-         * Return the most suitable content type from the given array based on content negotiation.
+         * Gets the list of trusted host patterns.
          *
-         * @param string|array $contentTypes
-         * @return string|null 
+         * @return array An array of trusted host patterns
          * @static 
          */
-        public static function prefers($contentTypes){
-            return \Illuminate\Http\Request::prefers($contentTypes);
+        public static function getTrustedHosts(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHosts();
         }
         
         /**
-         * Determines whether a request accepts JSON.
+         * Sets the name for trusted headers.
+         * 
+         * The following header keys are supported:
+         * 
+         *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())
+         *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())
+         *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())
+         *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())
+         *  * Request::HEADER_FORWARDED:    defaults to Forwarded         (see RFC 7239)
+         * 
+         * Setting an empty value allows to disable the trusted header for the given key.
          *
-         * @return bool 
+         * @param string $key The header key
+         * @param string $value The header name
+         * @throws \InvalidArgumentException
+         * @deprecated since version 3.3, to be removed in 4.0. Use the $trustedHeaderSet argument of the Request::setTrustedProxies() method instead.
          * @static 
          */
-        public static function acceptsJson(){
-            return \Illuminate\Http\Request::acceptsJson();
+        public static function setTrustedHeaderName($key, $value){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedHeaderName($key, $value);
         }
         
         /**
-         * Determines whether a request accepts HTML.
+         * Gets the trusted proxy header name.
          *
-         * @return bool 
+         * @param string $key The header key
+         * @return string The header name
+         * @throws \InvalidArgumentException
+         * @deprecated since version 3.3, to be removed in 4.0. Use the Request::getTrustedHeaderSet() method instead.
          * @static 
          */
-        public static function acceptsHtml(){
-            return \Illuminate\Http\Request::acceptsHtml();
+        public static function getTrustedHeaderName($key){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHeaderName($key);
         }
         
         /**
-         * Get the data format expected in the response.
+         * Normalizes a query string.
+         * 
+         * It builds a normalized query string, where keys/value pairs are alphabetized,
+         * have consistent escaping and unneeded delimiters are removed.
          *
-         * @param string $default
-         * @return string 
+         * @param string $qs Query string
+         * @return string A normalized query string for the Request
          * @static 
          */
-        public static function format($default = 'html'){
-            return \Illuminate\Http\Request::format($default);
+        public static function normalizeQueryString($qs){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::normalizeQueryString($qs);
         }
         
         /**
-         * Get the bearer token from the request headers.
+         * Enables support for the _method request parameter to determine the intended HTTP method.
+         * 
+         * Be warned that enabling this feature might lead to CSRF issues in your code.
+         * Check that you are using CSRF tokens when required.
+         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered
+         * and used to send a "PUT" or "DELETE" request via the _method request parameter.
+         * If these methods are not protected against CSRF, this presents a possible vulnerability.
+         * 
+         * The HTTP method can only be overridden when the real HTTP method is POST.
          *
-         * @return string|null 
          * @static 
          */
-        public static function bearerToken(){
-            return \Illuminate\Http\Request::bearerToken();
+        public static function enableHttpMethodParameterOverride(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::enableHttpMethodParameterOverride();
         }
         
         /**
-         * Create an Illuminate request from a Symfony instance.
+         * Checks whether support for the _method request parameter is enabled.
          *
-         * @param \Symfony\Component\HttpFoundation\Request $request
-         * @return \Illuminate\Http\Request 
+         * @return bool True when the _method request parameter is enabled, false otherwise
          * @static 
          */
-        public static function createFromBase($request){
-            return \Illuminate\Http\Request::createFromBase($request);
+        public static function getHttpMethodParameterOverride(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getHttpMethodParameterOverride();
         }
         
         /**
-         * Clones a request and overrides some of its parameters.
+         * Gets a "parameter" value from any bag.
+         * 
+         * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the
+         * flexibility in controllers, it is better to explicitly get request parameters from the appropriate
+         * public property instead (attributes, query, request).
+         * 
+         * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY
          *
-         * @param array $query The GET parameters
-         * @param array $request The POST parameters
-         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
-         * @param array $cookies The COOKIE parameters
-         * @param array $files The FILES parameters
-         * @param array $server The SERVER parameters
-         * @return \Request The duplicated request
+         * @param string $key the key
+         * @param mixed $default the default value if the parameter key does not exist
+         * @return mixed 
          * @static 
          */
-        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null){
-            return \Illuminate\Http\Request::duplicate($query, $request, $attributes, $cookies, $files, $server);
+        public static function get($key, $default = null){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::get($key, $default);
         }
         
         /**
-         * Get the session associated with the request.
+         * Gets the Session.
          *
-         * @return \Illuminate\Session\Store 
-         * @throws \RuntimeException
+         * @return \Symfony\Component\HttpFoundation\SessionInterface|null The session
          * @static 
          */
-        public static function session(){
-            return \Illuminate\Http\Request::session();
+        public static function getSession(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getSession();
         }
         
         /**
-         * Get the user making the request.
+         * Whether the request contains a Session which was started in one of the
+         * previous requests.
          *
-         * @param string|null $guard
-         * @return mixed 
+         * @return bool 
          * @static 
          */
-        public static function user($guard = null){
-            return \Illuminate\Http\Request::user($guard);
+        public static function hasPreviousSession(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::hasPreviousSession();
         }
         
         /**
-         * Get the route handling the request.
+         * Whether the request contains a Session object.
+         * 
+         * This method does not give any information about the state of the session object,
+         * like whether the session is started or not. It is just a way to check if this Request
+         * is associated with a Session instance.
          *
-         * @param string|null $param
-         * @return \Illuminate\Routing\Route|object|string 
+         * @return bool true when the Request contains a Session object, false otherwise
          * @static 
          */
-        public static function route($param = null){
-            return \Illuminate\Http\Request::route($param);
+        public static function hasSession(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::hasSession();
         }
         
         /**
-         * Get a unique fingerprint for the request / route / IP address.
+         * Sets the Session.
          *
-         * @return string 
-         * @throws \RuntimeException
+         * @param \Symfony\Component\HttpFoundation\SessionInterface $session The Session
          * @static 
          */
-        public static function fingerprint(){
-            return \Illuminate\Http\Request::fingerprint();
+        public static function setSession($session){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setSession($session);
         }
         
         /**
-         * Get the user resolver callback.
+         * Returns the client IP addresses.
+         * 
+         * In the returned array the most trusted IP address is first, and the
+         * least trusted one last. The "real" client IP address is the last one,
+         * but this is also the least trusted one. Trusted proxies are stripped.
+         * 
+         * Use this method carefully; you should use getClientIp() instead.
          *
-         * @return \Closure 
+         * @return array The client IP addresses
+         * @see getClientIp()
          * @static 
          */
-        public static function getUserResolver(){
-            return \Illuminate\Http\Request::getUserResolver();
+        public static function getClientIps(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getClientIps();
         }
         
         /**
-         * Set the user resolver callback.
+         * Returns the client IP address.
+         * 
+         * This method can read the client IP address from the "X-Forwarded-For" header
+         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"
+         * header value is a comma+space separated list of IP addresses, the left-most
+         * being the original client, and each successive proxy that passed the request
+         * adding the IP address where it received the request from.
+         * 
+         * If your reverse proxy uses a different header name than "X-Forwarded-For",
+         * ("Client-Ip" for instance), configure it via the $trustedHeaderSet
+         * argument of the Request::setTrustedProxies() method instead.
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @return string|null The client IP address
+         * @see getClientIps()
+         * @see http://en.wikipedia.org/wiki/X-Forwarded-For
          * @static 
          */
-        public static function setUserResolver($callback){
-            return \Illuminate\Http\Request::setUserResolver($callback);
+        public static function getClientIp(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getClientIp();
         }
         
         /**
-         * Get the route resolver callback.
+         * Returns current script name.
          *
-         * @return \Closure 
+         * @return string 
          * @static 
          */
-        public static function getRouteResolver(){
-            return \Illuminate\Http\Request::getRouteResolver();
+        public static function getScriptName(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getScriptName();
         }
         
         /**
-         * Set the route resolver callback.
+         * Returns the path being requested relative to the executed script.
+         * 
+         * The path info always starts with a /.
+         * 
+         * Suppose this request is instantiated from /mysite on localhost:
+         * 
+         *  * http://localhost/mysite              returns an empty string
+         *  * http://localhost/mysite/about        returns '/about'
+         *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'
+         *  * http://localhost/mysite/about?var=1  returns '/about'
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @return string The raw path (i.e. not urldecoded)
          * @static 
          */
-        public static function setRouteResolver($callback){
-            return \Illuminate\Http\Request::setRouteResolver($callback);
+        public static function getPathInfo(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPathInfo();
         }
         
         /**
-         * Get all of the input and files for the request.
+         * Returns the root path from which this request is executed.
+         * 
+         * Suppose that an index.php file instantiates this request object:
+         * 
+         *  * http://localhost/index.php         returns an empty string
+         *  * http://localhost/index.php/page    returns an empty string
+         *  * http://localhost/web/index.php     returns '/web'
+         *  * http://localhost/we%20b/index.php  returns '/we%20b'
          *
-         * @return array 
+         * @return string The raw path (i.e. not urldecoded)
          * @static 
          */
-        public static function toArray(){
-            return \Illuminate\Http\Request::toArray();
+        public static function getBasePath(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getBasePath();
         }
         
         /**
-         * Determine if the given offset exists.
+         * Returns the root URL from which this request is executed.
+         * 
+         * The base URL never ends with a /.
+         * 
+         * This is similar to getBasePath(), except that it also includes the
+         * script filename (e.g. index.php) if one exists.
          *
-         * @param string $offset
-         * @return bool 
+         * @return string The raw URL (i.e. not urldecoded)
          * @static 
          */
-        public static function offsetExists($offset){
-            return \Illuminate\Http\Request::offsetExists($offset);
+        public static function getBaseUrl(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getBaseUrl();
         }
         
         /**
-         * Get the value at the given offset.
+         * Gets the request's scheme.
          *
-         * @param string $offset
-         * @return mixed 
+         * @return string 
          * @static 
          */
-        public static function offsetGet($offset){
-            return \Illuminate\Http\Request::offsetGet($offset);
+        public static function getScheme(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getScheme();
         }
         
         /**
-         * Set the value at the given offset.
+         * Returns the port on which the request is made.
+         * 
+         * This method can read the client port from the "X-Forwarded-Port" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Port" header must contain the client port.
+         * 
+         * If your reverse proxy uses a different header name than "X-Forwarded-Port",
+         * configure it via via the $trustedHeaderSet argument of the
+         * Request::setTrustedProxies() method instead.
          *
-         * @param string $offset
-         * @param mixed $value
-         * @return void 
+         * @return int|string can be a string if fetched from the server bag
          * @static 
          */
-        public static function offsetSet($offset, $value){
-            \Illuminate\Http\Request::offsetSet($offset, $value);
+        public static function getPort(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPort();
         }
         
         /**
-         * Remove the value at the given offset.
+         * Returns the user.
          *
-         * @param string $offset
-         * @return void 
+         * @return string|null 
          * @static 
          */
-        public static function offsetUnset($offset){
-            \Illuminate\Http\Request::offsetUnset($offset);
+        public static function getUser(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUser();
         }
         
         /**
-         * Sets the parameters for this request.
-         * 
-         * This method also re-initializes all properties.
+         * Returns the password.
          *
-         * @param array $query The GET parameters
-         * @param array $request The POST parameters
-         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
-         * @param array $cookies The COOKIE parameters
-         * @param array $files The FILES parameters
-         * @param array $server The SERVER parameters
-         * @param string|resource $content The raw body data
+         * @return string|null 
          * @static 
          */
-        public static function initialize($query = array(), $request = array(), $attributes = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
+        public static function getPassword(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::initialize($query, $request, $attributes, $cookies, $files, $server, $content);
+            return \Illuminate\Http\Request::getPassword();
         }
         
         /**
-         * Creates a new request with values from PHP's super globals.
+         * Gets the user info.
          *
-         * @return \Request A new request
+         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server
          * @static 
          */
-        public static function createFromGlobals(){
+        public static function getUserInfo(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::createFromGlobals();
+            return \Illuminate\Http\Request::getUserInfo();
         }
         
         /**
-         * Creates a Request based on a given URI and configuration.
+         * Returns the HTTP host being requested.
          * 
-         * The information contained in the URI always take precedence
-         * over the other information (server and parameters).
+         * The port name will be appended to the host if it's non-standard.
          *
-         * @param string $uri The URI
-         * @param string $method The HTTP method
-         * @param array $parameters The query (GET) or request (POST) parameters
-         * @param array $cookies The request cookies ($_COOKIE)
-         * @param array $files The request files ($_FILES)
-         * @param array $server The server parameters ($_SERVER)
-         * @param string $content The raw body data
-         * @return \Request A Request instance
+         * @return string 
          * @static 
          */
-        public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
+        public static function getHttpHost(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);
+            return \Illuminate\Http\Request::getHttpHost();
         }
         
         /**
-         * Sets a callable able to create a Request instance.
-         * 
-         * This is mainly useful when you need to override the Request class
-         * to keep BC with an existing system. It should not be used for any
-         * other purpose.
+         * Returns the requested URI (path and query string).
          *
-         * @param callable|null $callable A PHP callable
+         * @return string The raw URI (i.e. not URI decoded)
          * @static 
          */
-        public static function setFactory($callable){
+        public static function getRequestUri(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setFactory($callable);
+            return \Illuminate\Http\Request::getRequestUri();
         }
         
         /**
-         * Overrides the PHP global variables according to this request instance.
+         * Gets the scheme and HTTP host.
          * 
-         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.
-         * $_FILES is never overridden, see rfc1867
+         * If the URL was called with basic authentication, the user
+         * and the password are not added to the generated string.
          *
+         * @return string The scheme and HTTP host
          * @static 
          */
-        public static function overrideGlobals(){
+        public static function getSchemeAndHttpHost(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::overrideGlobals();
+            return \Illuminate\Http\Request::getSchemeAndHttpHost();
         }
         
         /**
-         * Sets a list of trusted proxies.
-         * 
-         * You should only list the reverse proxies that you manage directly.
+         * Generates a normalized URI (URL) for the Request.
          *
-         * @param array $proxies A list of trusted proxies
+         * @return string A normalized URI (URL) for the Request
+         * @see getQueryString()
          * @static 
          */
-        public static function setTrustedProxies($proxies){
+        public static function getUri(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedProxies($proxies);
+            return \Illuminate\Http\Request::getUri();
         }
         
         /**
-         * Gets the list of trusted proxies.
+         * Generates a normalized URI for the given path.
          *
-         * @return array An array of trusted proxies
+         * @param string $path A path to use instead of the current one
+         * @return string The normalized URI for the path
          * @static 
          */
-        public static function getTrustedProxies(){
+        public static function getUriForPath($path){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedProxies();
+            return \Illuminate\Http\Request::getUriForPath($path);
         }
         
         /**
-         * Sets a list of trusted host patterns.
+         * Returns the path as relative reference from the current Request path.
          * 
-         * You should only list the hosts you manage using regexs.
+         * Only the URIs path component (no schema, host etc.) is relevant and must be given.
+         * Both paths must be absolute and not contain relative parts.
+         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.
+         * Furthermore, they can be used to reduce the link size in documents.
+         * 
+         * Example target paths, given a base path of "/a/b/c/d":
+         * - "/a/b/c/d"     -> ""
+         * - "/a/b/c/"      -> "./"
+         * - "/a/b/"        -> "../"
+         * - "/a/b/c/other" -> "other"
+         * - "/a/x/y"       -> "../../x/y"
          *
-         * @param array $hostPatterns A list of trusted host patterns
+         * @param string $path The target path
+         * @return string The relative target path
          * @static 
          */
-        public static function setTrustedHosts($hostPatterns){
+        public static function getRelativeUriForPath($path){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedHosts($hostPatterns);
+            return \Illuminate\Http\Request::getRelativeUriForPath($path);
         }
         
         /**
-         * Gets the list of trusted host patterns.
+         * Generates the normalized query string for the Request.
+         * 
+         * It builds a normalized query string, where keys/value pairs are alphabetized
+         * and have consistent escaping.
          *
-         * @return array An array of trusted host patterns
+         * @return string|null A normalized query string for the Request
          * @static 
          */
-        public static function getTrustedHosts(){
+        public static function getQueryString(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHosts();
+            return \Illuminate\Http\Request::getQueryString();
         }
         
         /**
-         * Sets the name for trusted headers.
+         * Checks whether the request is secure or not.
          * 
-         * The following header keys are supported:
+         * This method can read the client protocol from the "X-Forwarded-Proto" header
+         * when trusted proxies were set via "setTrustedProxies()".
          * 
-         *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())
-         *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())
-         *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())
-         *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())
+         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".
          * 
-         * Setting an empty value allows to disable the trusted header for the given key.
+         * If your reverse proxy uses a different header name than "X-Forwarded-Proto"
+         * ("SSL_HTTPS" for instance), configure it via the $trustedHeaderSet
+         * argument of the Request::setTrustedProxies() method instead.
          *
-         * @param string $key The header key
-         * @param string $value The header name
-         * @throws \InvalidArgumentException
+         * @return bool 
          * @static 
          */
-        public static function setTrustedHeaderName($key, $value){
+        public static function isSecure(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedHeaderName($key, $value);
+            return \Illuminate\Http\Request::isSecure();
         }
         
         /**
-         * Gets the trusted proxy header name.
+         * Returns the host name.
+         * 
+         * This method can read the client host name from the "X-Forwarded-Host" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Host" header must contain the client host name.
+         * 
+         * If your reverse proxy uses a different header name than "X-Forwarded-Host",
+         * configure it via the $trustedHeaderSet argument of the
+         * Request::setTrustedProxies() method instead.
          *
-         * @param string $key The header key
-         * @return string The header name
-         * @throws \InvalidArgumentException
+         * @return string 
+         * @throws SuspiciousOperationException when the host name is invalid or not trusted
          * @static 
          */
-        public static function getTrustedHeaderName($key){
+        public static function getHost(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHeaderName($key);
+            return \Illuminate\Http\Request::getHost();
         }
         
         /**
-         * Normalizes a query string.
-         * 
-         * It builds a normalized query string, where keys/value pairs are alphabetized,
-         * have consistent escaping and unneeded delimiters are removed.
+         * Sets the request method.
          *
-         * @param string $qs Query string
-         * @return string A normalized query string for the Request
+         * @param string $method
          * @static 
          */
-        public static function normalizeQueryString($qs){
+        public static function setMethod($method){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::normalizeQueryString($qs);
+            return \Illuminate\Http\Request::setMethod($method);
         }
         
         /**
-         * Enables support for the _method request parameter to determine the intended HTTP method.
+         * Gets the request "intended" method.
          * 
-         * Be warned that enabling this feature might lead to CSRF issues in your code.
-         * Check that you are using CSRF tokens when required.
-         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered
-         * and used to send a "PUT" or "DELETE" request via the _method request parameter.
-         * If these methods are not protected against CSRF, this presents a possible vulnerability.
+         * If the X-HTTP-Method-Override header is set, and if the method is a POST,
+         * then it is used to determine the "real" intended HTTP method.
          * 
-         * The HTTP method can only be overridden when the real HTTP method is POST.
+         * The _method request parameter can also be used to determine the HTTP method,
+         * but only if enableHttpMethodParameterOverride() has been called.
+         * 
+         * The method is always an uppercased string.
          *
+         * @return string The request method
+         * @see getRealMethod()
          * @static 
          */
-        public static function enableHttpMethodParameterOverride(){
+        public static function getMethod(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::enableHttpMethodParameterOverride();
+            return \Illuminate\Http\Request::getMethod();
         }
         
         /**
-         * Checks whether support for the _method request parameter is enabled.
+         * Gets the "real" request method.
          *
-         * @return bool True when the _method request parameter is enabled, false otherwise
+         * @return string The request method
+         * @see getMethod()
          * @static 
          */
-        public static function getHttpMethodParameterOverride(){
+        public static function getRealMethod(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHttpMethodParameterOverride();
+            return \Illuminate\Http\Request::getRealMethod();
         }
         
         /**
-         * Gets a "parameter" value from any bag.
-         * 
-         * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the
-         * flexibility in controllers, it is better to explicitly get request parameters from the appropriate
-         * public property instead (attributes, query, request).
-         * 
-         * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY
+         * Gets the mime type associated with the format.
          *
-         * @param string $key the key
-         * @param mixed $default the default value if the parameter key does not exist
-         * @return mixed 
+         * @param string $format The format
+         * @return string The associated mime type (null if not found)
          * @static 
          */
-        public static function get($key, $default = null){
+        public static function getMimeType($format){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::get($key, $default);
+            return \Illuminate\Http\Request::getMimeType($format);
         }
         
         /**
-         * Gets the Session.
+         * Gets the mime types associated with the format.
          *
-         * @return \Symfony\Component\HttpFoundation\SessionInterface|null The session
+         * @param string $format The format
+         * @return array The associated mime types
          * @static 
          */
-        public static function getSession(){
+        public static function getMimeTypes($format){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getSession();
+            return \Illuminate\Http\Request::getMimeTypes($format);
         }
         
         /**
-         * Whether the request contains a Session which was started in one of the
-         * previous requests.
+         * Gets the format associated with the mime type.
          *
-         * @return bool 
+         * @param string $mimeType The associated mime type
+         * @return string|null The format (null if not found)
          * @static 
          */
-        public static function hasPreviousSession(){
+        public static function getFormat($mimeType){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::hasPreviousSession();
+            return \Illuminate\Http\Request::getFormat($mimeType);
         }
         
         /**
-         * Whether the request contains a Session object.
+         * Associates a format with mime types.
+         *
+         * @param string $format The format
+         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)
+         * @static 
+         */
+        public static function setFormat($format, $mimeTypes){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setFormat($format, $mimeTypes);
+        }
+        
+        /**
+         * Gets the request format.
          * 
-         * This method does not give any information about the state of the session object,
-         * like whether the session is started or not. It is just a way to check if this Request
-         * is associated with a Session instance.
+         * Here is the process to determine the format:
+         * 
+         *  * format defined by the user (with setRequestFormat())
+         *  * _format request attribute
+         *  * $default
          *
-         * @return bool true when the Request contains a Session object, false otherwise
+         * @param string $default The default format
+         * @return string The request format
          * @static 
          */
-        public static function hasSession(){
+        public static function getRequestFormat($default = 'html'){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::hasSession();
+            return \Illuminate\Http\Request::getRequestFormat($default);
         }
         
         /**
-         * Sets the Session.
+         * Sets the request format.
          *
-         * @param \Symfony\Component\HttpFoundation\SessionInterface $session The Session
+         * @param string $format The request format
          * @static 
          */
-        public static function setSession($session){
+        public static function setRequestFormat($format){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setSession($session);
+            return \Illuminate\Http\Request::setRequestFormat($format);
         }
         
         /**
-         * Returns the client IP addresses.
-         * 
-         * In the returned array the most trusted IP address is first, and the
-         * least trusted one last. The "real" client IP address is the last one,
-         * but this is also the least trusted one. Trusted proxies are stripped.
-         * 
-         * Use this method carefully; you should use getClientIp() instead.
+         * Gets the format associated with the request.
          *
-         * @return array The client IP addresses
-         * @see getClientIp()
+         * @return string|null The format (null if no content type is present)
          * @static 
          */
-        public static function getClientIps(){
+        public static function getContentType(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getClientIps();
+            return \Illuminate\Http\Request::getContentType();
         }
         
         /**
-         * Returns the client IP address.
-         * 
-         * This method can read the client IP address from the "X-Forwarded-For" header
-         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"
-         * header value is a comma+space separated list of IP addresses, the left-most
-         * being the original client, and each successive proxy that passed the request
-         * adding the IP address where it received the request from.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-For",
-         * ("Client-Ip" for instance), configure it via "setTrustedHeaderName()" with
-         * the "client-ip" key.
+         * Sets the default locale.
          *
-         * @return string The client IP address
-         * @see getClientIps()
-         * @see http://en.wikipedia.org/wiki/X-Forwarded-For
+         * @param string $locale
          * @static 
          */
-        public static function getClientIp(){
+        public static function setDefaultLocale($locale){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getClientIp();
+            return \Illuminate\Http\Request::setDefaultLocale($locale);
         }
         
         /**
-         * Returns current script name.
+         * Get the default locale.
          *
          * @return string 
          * @static 
          */
-        public static function getScriptName(){
+        public static function getDefaultLocale(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getScriptName();
+            return \Illuminate\Http\Request::getDefaultLocale();
         }
         
         /**
-         * Returns the path being requested relative to the executed script.
-         * 
-         * The path info always starts with a /.
-         * 
-         * Suppose this request is instantiated from /mysite on localhost:
-         * 
-         *  * http://localhost/mysite              returns an empty string
-         *  * http://localhost/mysite/about        returns '/about'
-         *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'
-         *  * http://localhost/mysite/about?var=1  returns '/about'
+         * Sets the locale.
          *
-         * @return string The raw path (i.e. not urldecoded)
+         * @param string $locale
          * @static 
          */
-        public static function getPathInfo(){
+        public static function setLocale($locale){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPathInfo();
+            return \Illuminate\Http\Request::setLocale($locale);
         }
         
         /**
-         * Returns the root path from which this request is executed.
-         * 
-         * Suppose that an index.php file instantiates this request object:
-         * 
-         *  * http://localhost/index.php         returns an empty string
-         *  * http://localhost/index.php/page    returns an empty string
-         *  * http://localhost/web/index.php     returns '/web'
-         *  * http://localhost/we%20b/index.php  returns '/we%20b'
+         * Get the locale.
          *
-         * @return string The raw path (i.e. not urldecoded)
+         * @return string 
          * @static 
          */
-        public static function getBasePath(){
+        public static function getLocale(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getBasePath();
+            return \Illuminate\Http\Request::getLocale();
         }
         
         /**
-         * Returns the root URL from which this request is executed.
-         * 
-         * The base URL never ends with a /.
-         * 
-         * This is similar to getBasePath(), except that it also includes the
-         * script filename (e.g. index.php) if one exists.
+         * Checks if the request method is of specified type.
          *
-         * @return string The raw URL (i.e. not urldecoded)
+         * @param string $method Uppercase request method (GET, POST etc)
+         * @return bool 
          * @static 
          */
-        public static function getBaseUrl(){
+        public static function isMethod($method){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getBaseUrl();
+            return \Illuminate\Http\Request::isMethod($method);
         }
         
         /**
-         * Gets the request's scheme.
+         * Checks whether or not the method is safe.
          *
-         * @return string 
+         * @see https://tools.ietf.org/html/rfc7231#section-4.2.1
+         * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.
+         * @return bool 
          * @static 
          */
-        public static function getScheme(){
+        public static function isMethodSafe(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getScheme();
+            return \Illuminate\Http\Request::isMethodSafe();
         }
         
         /**
-         * Returns the port on which the request is made.
-         * 
-         * This method can read the client port from the "X-Forwarded-Port" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Port" header must contain the client port.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Port",
-         * configure it via "setTrustedHeaderName()" with the "client-port" key.
+         * Checks whether or not the method is idempotent.
          *
-         * @return string 
+         * @return bool 
          * @static 
          */
-        public static function getPort(){
+        public static function isMethodIdempotent(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPort();
+            return \Illuminate\Http\Request::isMethodIdempotent();
         }
         
         /**
-         * Returns the user.
+         * Checks whether the method is cacheable or not.
          *
-         * @return string|null 
+         * @see https://tools.ietf.org/html/rfc7231#section-4.2.3
+         * @return bool 
          * @static 
          */
-        public static function getUser(){
+        public static function isMethodCacheable(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUser();
+            return \Illuminate\Http\Request::isMethodCacheable();
         }
         
         /**
-         * Returns the password.
+         * Returns the request body content.
          *
-         * @return string|null 
+         * @param bool $asResource If true, a resource will be returned
+         * @return string|resource The request body content or a resource to read the body stream
+         * @throws \LogicException
          * @static 
          */
-        public static function getPassword(){
+        public static function getContent($asResource = false){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPassword();
+            return \Illuminate\Http\Request::getContent($asResource);
         }
         
         /**
-         * Gets the user info.
+         * Gets the Etags.
          *
-         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server
+         * @return array The entity tags
          * @static 
          */
-        public static function getUserInfo(){
+        public static function getETags(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUserInfo();
+            return \Illuminate\Http\Request::getETags();
         }
         
         /**
-         * Returns the HTTP host being requested.
          * 
-         * The port name will be appended to the host if it's non-standard.
          *
-         * @return string 
+         * @return bool 
          * @static 
          */
-        public static function getHttpHost(){
+        public static function isNoCache(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHttpHost();
+            return \Illuminate\Http\Request::isNoCache();
         }
         
         /**
-         * Returns the requested URI (path and query string).
+         * Returns the preferred language.
          *
-         * @return string The raw URI (i.e. not URI decoded)
+         * @param array $locales An array of ordered available locales
+         * @return string|null The preferred locale
          * @static 
          */
-        public static function getRequestUri(){
+        public static function getPreferredLanguage($locales = null){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRequestUri();
+            return \Illuminate\Http\Request::getPreferredLanguage($locales);
         }
         
         /**
-         * Gets the scheme and HTTP host.
-         * 
-         * If the URL was called with basic authentication, the user
-         * and the password are not added to the generated string.
+         * Gets a list of languages acceptable by the client browser.
          *
-         * @return string The scheme and HTTP host
+         * @return array Languages ordered in the user browser preferences
          * @static 
          */
-        public static function getSchemeAndHttpHost(){
+        public static function getLanguages(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getSchemeAndHttpHost();
+            return \Illuminate\Http\Request::getLanguages();
         }
         
         /**
-         * Generates a normalized URI (URL) for the Request.
+         * Gets a list of charsets acceptable by the client browser.
          *
-         * @return string A normalized URI (URL) for the Request
-         * @see getQueryString()
+         * @return array List of charsets in preferable order
          * @static 
          */
-        public static function getUri(){
+        public static function getCharsets(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUri();
+            return \Illuminate\Http\Request::getCharsets();
         }
         
         /**
-         * Generates a normalized URI for the given path.
+         * Gets a list of encodings acceptable by the client browser.
          *
-         * @param string $path A path to use instead of the current one
-         * @return string The normalized URI for the path
+         * @return array List of encodings in preferable order
          * @static 
          */
-        public static function getUriForPath($path){
+        public static function getEncodings(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUriForPath($path);
+            return \Illuminate\Http\Request::getEncodings();
         }
         
         /**
-         * Returns the path as relative reference from the current Request path.
-         * 
-         * Only the URIs path component (no schema, host etc.) is relevant and must be given.
-         * Both paths must be absolute and not contain relative parts.
-         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.
-         * Furthermore, they can be used to reduce the link size in documents.
-         * 
-         * Example target paths, given a base path of "/a/b/c/d":
-         * - "/a/b/c/d"     -> ""
-         * - "/a/b/c/"      -> "./"
-         * - "/a/b/"        -> "../"
-         * - "/a/b/c/other" -> "other"
-         * - "/a/x/y"       -> "../../x/y"
+         * Gets a list of content types acceptable by the client browser.
          *
-         * @param string $path The target path
-         * @return string The relative target path
+         * @return array List of content types in preferable order
          * @static 
          */
-        public static function getRelativeUriForPath($path){
+        public static function getAcceptableContentTypes(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRelativeUriForPath($path);
+            return \Illuminate\Http\Request::getAcceptableContentTypes();
         }
         
         /**
-         * Generates the normalized query string for the Request.
+         * Returns true if the request is a XMLHttpRequest.
          * 
-         * It builds a normalized query string, where keys/value pairs are alphabetized
-         * and have consistent escaping.
+         * It works if your JavaScript library sets an X-Requested-With HTTP header.
+         * It is known to work with common JavaScript frameworks:
          *
-         * @return string|null A normalized query string for the Request
+         * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript
+         * @return bool true if the request is an XMLHttpRequest, false otherwise
          * @static 
          */
-        public static function getQueryString(){
+        public static function isXmlHttpRequest(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getQueryString();
+            return \Illuminate\Http\Request::isXmlHttpRequest();
         }
         
         /**
-         * Checks whether the request is secure or not.
-         * 
-         * This method can read the client protocol from the "X-Forwarded-Proto" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".
+         * Indicates whether this request originated from a trusted proxy.
          * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Proto"
-         * ("SSL_HTTPS" for instance), configure it via "setTrustedHeaderName()" with
-         * the "client-proto" key.
+         * This can be useful to determine whether or not to trust the
+         * contents of a proxy-specific header.
          *
-         * @return bool 
+         * @return bool true if the request came from a trusted proxy, false otherwise
          * @static 
          */
-        public static function isSecure(){
+        public static function isFromTrustedProxy(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isSecure();
+            return \Illuminate\Http\Request::isFromTrustedProxy();
         }
         
         /**
-         * Returns the host name.
-         * 
-         * This method can read the client host name from the "X-Forwarded-Host" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Host" header must contain the client host name.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Host",
-         * configure it via "setTrustedHeaderName()" with the "client-host" key.
+         * Determine if the given content types match.
          *
-         * @return string 
-         * @throws \UnexpectedValueException when the host name is invalid
+         * @param string $actual
+         * @param string $type
+         * @return bool 
          * @static 
          */
-        public static function getHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHost();
+        public static function matchesType($actual, $type){
+            return \Illuminate\Http\Request::matchesType($actual, $type);
         }
         
         /**
-         * Sets the request method.
+         * Determine if the request is sending JSON.
          *
-         * @param string $method
+         * @return bool 
          * @static 
          */
-        public static function setMethod($method){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setMethod($method);
+        public static function isJson(){
+            return \Illuminate\Http\Request::isJson();
         }
         
         /**
-         * Gets the request "intended" method.
-         * 
-         * If the X-HTTP-Method-Override header is set, and if the method is a POST,
-         * then it is used to determine the "real" intended HTTP method.
-         * 
-         * The _method request parameter can also be used to determine the HTTP method,
-         * but only if enableHttpMethodParameterOverride() has been called.
-         * 
-         * The method is always an uppercased string.
+         * Determine if the current request probably expects a JSON response.
          *
-         * @return string The request method
-         * @see getRealMethod()
+         * @return bool 
          * @static 
          */
-        public static function getMethod(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMethod();
+        public static function expectsJson(){
+            return \Illuminate\Http\Request::expectsJson();
         }
         
         /**
-         * Gets the "real" request method.
+         * Determine if the current request is asking for JSON in return.
          *
-         * @return string The request method
-         * @see getMethod()
+         * @return bool 
          * @static 
          */
-        public static function getRealMethod(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRealMethod();
+        public static function wantsJson(){
+            return \Illuminate\Http\Request::wantsJson();
         }
         
         /**
-         * Gets the mime type associated with the format.
+         * Determines whether the current requests accepts a given content type.
          *
-         * @param string $format The format
-         * @return string The associated mime type (null if not found)
+         * @param string|array $contentTypes
+         * @return bool 
          * @static 
          */
-        public static function getMimeType($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMimeType($format);
+        public static function accepts($contentTypes){
+            return \Illuminate\Http\Request::accepts($contentTypes);
         }
         
         /**
-         * Gets the mime types associated with the format.
+         * Return the most suitable content type from the given array based on content negotiation.
          *
-         * @param string $format The format
-         * @return array The associated mime types
+         * @param string|array $contentTypes
+         * @return string|null 
          * @static 
          */
-        public static function getMimeTypes($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMimeTypes($format);
+        public static function prefers($contentTypes){
+            return \Illuminate\Http\Request::prefers($contentTypes);
         }
         
         /**
-         * Gets the format associated with the mime type.
+         * Determines whether a request accepts JSON.
          *
-         * @param string $mimeType The associated mime type
-         * @return string|null The format (null if not found)
+         * @return bool 
          * @static 
          */
-        public static function getFormat($mimeType){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getFormat($mimeType);
+        public static function acceptsJson(){
+            return \Illuminate\Http\Request::acceptsJson();
         }
         
         /**
-         * Associates a format with mime types.
+         * Determines whether a request accepts HTML.
          *
-         * @param string $format The format
-         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)
+         * @return bool 
          * @static 
          */
-        public static function setFormat($format, $mimeTypes){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setFormat($format, $mimeTypes);
+        public static function acceptsHtml(){
+            return \Illuminate\Http\Request::acceptsHtml();
         }
         
         /**
-         * Gets the request format.
-         * 
-         * Here is the process to determine the format:
-         * 
-         *  * format defined by the user (with setRequestFormat())
-         *  * _format request attribute
-         *  * $default
+         * Get the data format expected in the response.
          *
-         * @param string $default The default format
-         * @return string The request format
+         * @param string $default
+         * @return string 
          * @static 
          */
-        public static function getRequestFormat($default = 'html'){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRequestFormat($default);
+        public static function format($default = 'html'){
+            return \Illuminate\Http\Request::format($default);
         }
         
         /**
-         * Sets the request format.
+         * Retrieve an old input item.
          *
-         * @param string $format The request format
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
          */
-        public static function setRequestFormat($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setRequestFormat($format);
+        public static function old($key = null, $default = null){
+            return \Illuminate\Http\Request::old($key, $default);
         }
         
         /**
-         * Gets the format associated with the request.
+         * Flash the input for the current request to the session.
          *
-         * @return string|null The format (null if no content type is present)
+         * @return void 
          * @static 
          */
-        public static function getContentType(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getContentType();
+        public static function flash(){
+            \Illuminate\Http\Request::flash();
         }
         
         /**
-         * Sets the default locale.
+         * Flash only some of the input to the session.
          *
-         * @param string $locale
+         * @param array|mixed $keys
+         * @return void 
          * @static 
          */
-        public static function setDefaultLocale($locale){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setDefaultLocale($locale);
+        public static function flashOnly($keys){
+            \Illuminate\Http\Request::flashOnly($keys);
         }
         
         /**
-         * Get the default locale.
+         * Flash only some of the input to the session.
          *
-         * @return string 
+         * @param array|mixed $keys
+         * @return void 
          * @static 
          */
-        public static function getDefaultLocale(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getDefaultLocale();
+        public static function flashExcept($keys){
+            \Illuminate\Http\Request::flashExcept($keys);
         }
         
         /**
-         * Sets the locale.
+         * Flush all of the old input from the session.
          *
-         * @param string $locale
+         * @return void 
          * @static 
          */
-        public static function setLocale($locale){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setLocale($locale);
+        public static function flush(){
+            \Illuminate\Http\Request::flush();
         }
         
         /**
-         * Get the locale.
+         * Retrieve a server variable from the request.
          *
-         * @return string 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
          */
-        public static function getLocale(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getLocale();
+        public static function server($key = null, $default = null){
+            return \Illuminate\Http\Request::server($key, $default);
         }
         
         /**
-         * Checks if the request method is of specified type.
+         * Determine if a header is set on the request.
          *
-         * @param string $method Uppercase request method (GET, POST etc)
+         * @param string $key
          * @return bool 
          * @static 
          */
-        public static function isMethod($method){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethod($method);
+        public static function hasHeader($key){
+            return \Illuminate\Http\Request::hasHeader($key);
         }
         
         /**
-         * Checks whether the method is safe or not.
+         * Retrieve a header from the request.
          *
-         * @return bool 
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
          */
-        public static function isMethodSafe(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethodSafe();
+        public static function header($key = null, $default = null){
+            return \Illuminate\Http\Request::header($key, $default);
         }
         
         /**
-         * Returns the request body content.
+         * Get the bearer token from the request headers.
          *
-         * @param bool $asResource If true, a resource will be returned
-         * @return string|resource The request body content or a resource to read the body stream
-         * @throws \LogicException
+         * @return string|null 
          * @static 
          */
-        public static function getContent($asResource = false){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getContent($asResource);
+        public static function bearerToken(){
+            return \Illuminate\Http\Request::bearerToken();
         }
         
         /**
-         * Gets the Etags.
+         * Determine if the request contains a given input item key.
          *
-         * @return array The entity tags
+         * @param string|array $key
+         * @return bool 
          * @static 
          */
-        public static function getETags(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getETags();
+        public static function exists($key){
+            return \Illuminate\Http\Request::exists($key);
         }
         
         /**
-         * 
+         * Determine if the request contains a non-empty value for an input item.
          *
+         * @param string|array $key
          * @return bool 
          * @static 
          */
-        public static function isNoCache(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isNoCache();
+        public static function has($key){
+            return \Illuminate\Http\Request::has($key);
         }
         
         /**
-         * Returns the preferred language.
+         * Get all of the input and files for the request.
          *
-         * @param array $locales An array of ordered available locales
-         * @return string|null The preferred locale
+         * @return array 
          * @static 
          */
-        public static function getPreferredLanguage($locales = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPreferredLanguage($locales);
+        public static function all(){
+            return \Illuminate\Http\Request::all();
         }
         
         /**
-         * Gets a list of languages acceptable by the client browser.
+         * Retrieve an input item from the request.
          *
-         * @return array Languages ordered in the user browser preferences
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
          */
-        public static function getLanguages(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getLanguages();
+        public static function input($key = null, $default = null){
+            return \Illuminate\Http\Request::input($key, $default);
         }
         
         /**
-         * Gets a list of charsets acceptable by the client browser.
+         * Get a subset containing the provided keys with values from the input data.
          *
-         * @return array List of charsets in preferable order
+         * @param array|mixed $keys
+         * @return array 
          * @static 
          */
-        public static function getCharsets(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getCharsets();
+        public static function only($keys){
+            return \Illuminate\Http\Request::only($keys);
         }
         
         /**
-         * Gets a list of encodings acceptable by the client browser.
+         * Get all of the input except for a specified array of items.
          *
-         * @return array List of encodings in preferable order
+         * @param array|mixed $keys
+         * @return array 
          * @static 
          */
-        public static function getEncodings(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getEncodings();
+        public static function except($keys){
+            return \Illuminate\Http\Request::except($keys);
         }
         
         /**
-         * Gets a list of content types acceptable by the client browser.
+         * Intersect an array of items with the input data.
          *
-         * @return array List of content types in preferable order
+         * @param array|mixed $keys
+         * @return array 
          * @static 
          */
-        public static function getAcceptableContentTypes(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getAcceptableContentTypes();
+        public static function intersect($keys){
+            return \Illuminate\Http\Request::intersect($keys);
         }
         
         /**
-         * Returns true if the request is a XMLHttpRequest.
-         * 
-         * It works if your JavaScript library sets an X-Requested-With HTTP header.
-         * It is known to work with common JavaScript frameworks:
+         * Retrieve a query string item from the request.
          *
-         * @link http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript
-         * @return bool true if the request is an XMLHttpRequest, false otherwise
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
          * @static 
          */
-        public static function isXmlHttpRequest(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isXmlHttpRequest();
+        public static function query($key = null, $default = null){
+            return \Illuminate\Http\Request::query($key, $default);
         }
         
         /**
-         * Indicates whether this request originated from a trusted proxy.
-         * 
-         * This can be useful to determine whether or not to trust the
-         * contents of a proxy-specific header.
+         * Determine if a cookie is set on the request.
          *
-         * @return bool true if the request came from a trusted proxy, false otherwise
+         * @param string $key
+         * @return bool 
          * @static 
          */
-        public static function isFromTrustedProxy(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isFromTrustedProxy();
+        public static function hasCookie($key){
+            return \Illuminate\Http\Request::hasCookie($key);
+        }
+        
+        /**
+         * Retrieve a cookie from the request.
+         *
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
+         * @static 
+         */
+        public static function cookie($key = null, $default = null){
+            return \Illuminate\Http\Request::cookie($key, $default);
+        }
+        
+        /**
+         * Get an array of all of the files on the request.
+         *
+         * @return array 
+         * @static 
+         */
+        public static function allFiles(){
+            return \Illuminate\Http\Request::allFiles();
+        }
+        
+        /**
+         * Determine if the uploaded data contains a file.
+         *
+         * @param string $key
+         * @return bool 
+         * @static 
+         */
+        public static function hasFile($key){
+            return \Illuminate\Http\Request::hasFile($key);
+        }
+        
+        /**
+         * Retrieve a file from the request.
+         *
+         * @param string $key
+         * @param mixed $default
+         * @return \Illuminate\Http\UploadedFile|array|null 
+         * @static 
+         */
+        public static function file($key = null, $default = null){
+            return \Illuminate\Http\Request::file($key, $default);
         }
         
         /**
@@ -7688,12 +8018,25 @@ namespace {
         }
         
         /**
-         * Get the translation for the given key.
+         * Get the translation for a given key.
          *
          * @param string $key
          * @param array $replace
-         * @param string|null $locale
-         * @param bool $fallback
+         * @param string $locale
+         * @return string|array|null 
+         * @static 
+         */
+        public static function trans($key, $replace = array(), $locale = null){
+            return \Illuminate\Translation\Translator::trans($key, $replace, $locale);
+        }
+        
+        /**
+         * Get the translation for the given key.
+         *
+         * @param string $key
+         * @param array $replace
+         * @param string|null $locale
+         * @param bool $fallback
          * @return string|array|null 
          * @static 
          */
@@ -7702,46 +8045,57 @@ namespace {
         }
         
         /**
-         * Get a translation according to an integer value.
+         * Get the translation for a given key from the JSON translation files.
          *
          * @param string $key
-         * @param int|array|\Countable $number
          * @param array $replace
          * @param string $locale
          * @return string 
          * @static 
          */
-        public static function choice($key, $number, $replace = array(), $locale = null){
-            return \Illuminate\Translation\Translator::choice($key, $number, $replace, $locale);
+        public static function getFromJson($key, $replace = array(), $locale = null){
+            return \Illuminate\Translation\Translator::getFromJson($key, $replace, $locale);
         }
         
         /**
-         * Get the translation for a given key.
+         * Get a translation according to an integer value.
          *
-         * @param string $id
-         * @param array $parameters
-         * @param string $domain
+         * @param string $key
+         * @param int|array|\Countable $number
+         * @param array $replace
          * @param string $locale
-         * @return string|array|null 
+         * @return string 
          * @static 
          */
-        public static function trans($id, $parameters = array(), $domain = 'messages', $locale = null){
-            return \Illuminate\Translation\Translator::trans($id, $parameters, $domain, $locale);
+        public static function transChoice($key, $number, $replace = array(), $locale = null){
+            return \Illuminate\Translation\Translator::transChoice($key, $number, $replace, $locale);
         }
         
         /**
          * Get a translation according to an integer value.
          *
-         * @param string $id
+         * @param string $key
          * @param int|array|\Countable $number
-         * @param array $parameters
-         * @param string $domain
+         * @param array $replace
          * @param string $locale
          * @return string 
          * @static 
          */
-        public static function transChoice($id, $number, $parameters = array(), $domain = 'messages', $locale = null){
-            return \Illuminate\Translation\Translator::transChoice($id, $number, $parameters, $domain, $locale);
+        public static function choice($key, $number, $replace = array(), $locale = null){
+            return \Illuminate\Translation\Translator::choice($key, $number, $replace, $locale);
+        }
+        
+        /**
+         * Add translation lines to the given locale.
+         *
+         * @param array $lines
+         * @param string $locale
+         * @param string $namespace
+         * @return void 
+         * @static 
+         */
+        public static function addLines($lines, $locale, $namespace = '*'){
+            \Illuminate\Translation\Translator::addLines($lines, $locale, $namespace);
         }
         
         /**
@@ -7783,7 +8137,7 @@ namespace {
         /**
          * Get the message selector instance.
          *
-         * @return \Symfony\Component\Translation\MessageSelector 
+         * @return \Illuminate\Translation\MessageSelector 
          * @static 
          */
         public static function getSelector(){
@@ -7793,7 +8147,7 @@ namespace {
         /**
          * Set the message selector instance.
          *
-         * @param \Symfony\Component\Translation\MessageSelector $selector
+         * @param \Illuminate\Translation\MessageSelector $selector
          * @return void 
          * @static 
          */
@@ -8056,11 +8410,12 @@ namespace {
          *
          * @param string $name
          * @param string $level
+         * @param mixed $facility
          * @return \Psr\Log\LoggerInterface 
          * @static 
          */
-        public static function useSyslog($name = 'laravel', $level = 'debug'){
-            return \Illuminate\Log\Writer::useSyslog($name, $level);
+        public static function useSyslog($name = 'laravel', $level = 'debug', $facility = 8){
+            return \Illuminate\Log\Writer::useSyslog($name, $level, $facility);
         }
         
         /**
@@ -8136,6 +8491,18 @@ namespace {
         }
         
         /**
+         * Set the global reply-to address and name.
+         *
+         * @param string $address
+         * @param string|null $name
+         * @return void 
+         * @static 
+         */
+        public static function alwaysReplyTo($address, $name = null){
+            \Illuminate\Mail\Mailer::alwaysReplyTo($address, $name);
+        }
+        
+        /**
          * Set the global to address and name.
          *
          * @param string $address
@@ -8151,7 +8518,7 @@ namespace {
          * Begin the process of mailing a mailable class instance.
          *
          * @param mixed $users
-         * @return \Illuminate\Mail\MailableMailer 
+         * @return \Illuminate\Mail\PendingMail 
          * @static 
          */
         public static function to($users){
@@ -8162,7 +8529,7 @@ namespace {
          * Begin the process of mailing a mailable class instance.
          *
          * @param mixed $users
-         * @return \Illuminate\Mail\MailableMailer 
+         * @return \Illuminate\Mail\PendingMail 
          * @static 
          */
         public static function bcc($users){
@@ -8325,7 +8692,7 @@ namespace {
         /**
          * Set the queue manager instance.
          *
-         * @param \Illuminate\Contracts\Queue\Queue $queue
+         * @param \Illuminate\Contracts\Queue\Factory $queue
          * @return $this 
          * @static 
          */
@@ -8334,14 +8701,26 @@ namespace {
         }
         
         /**
-         * Set the IoC container instance.
+         * Register a custom macro.
          *
-         * @param \Illuminate\Contracts\Container\Container $container
+         * @param string $name
+         * @param callable $macro
          * @return void 
          * @static 
          */
-        public static function setContainer($container){
-            \Illuminate\Mail\Mailer::setContainer($container);
+        public static function macro($name, $macro){
+            \Illuminate\Mail\Mailer::macro($name, $macro);
+        }
+        
+        /**
+         * Checks if macro is registered.
+         *
+         * @param string $name
+         * @return bool 
+         * @static 
+         */
+        public static function hasMacro($name){
+            return \Illuminate\Mail\Mailer::hasMacro($name);
         }
         
     }
@@ -8540,6 +8919,147 @@ namespace {
             return \Illuminate\Queue\QueueManager::isDownForMaintenance();
         }
         
+        /**
+         * Get the size of the queue.
+         *
+         * @param string $queue
+         * @return int 
+         * @static 
+         */
+        public static function size($queue = null){
+            return \Illuminate\Queue\SyncQueue::size($queue);
+        }
+        
+        /**
+         * Push a new job onto the queue.
+         *
+         * @param string $job
+         * @param mixed $data
+         * @param string $queue
+         * @return mixed 
+         * @throws \Exception|\Throwable
+         * @static 
+         */
+        public static function push($job, $data = '', $queue = null){
+            return \Illuminate\Queue\SyncQueue::push($job, $data, $queue);
+        }
+        
+        /**
+         * Push a raw payload onto the queue.
+         *
+         * @param string $payload
+         * @param string $queue
+         * @param array $options
+         * @return mixed 
+         * @static 
+         */
+        public static function pushRaw($payload, $queue = null, $options = array()){
+            return \Illuminate\Queue\SyncQueue::pushRaw($payload, $queue, $options);
+        }
+        
+        /**
+         * Push a new job onto the queue after a delay.
+         *
+         * @param \DateTime|int $delay
+         * @param string $job
+         * @param mixed $data
+         * @param string $queue
+         * @return mixed 
+         * @static 
+         */
+        public static function later($delay, $job, $data = '', $queue = null){
+            return \Illuminate\Queue\SyncQueue::later($delay, $job, $data, $queue);
+        }
+        
+        /**
+         * Pop the next job off of the queue.
+         *
+         * @param string $queue
+         * @return \Illuminate\Contracts\Queue\Job|null 
+         * @static 
+         */
+        public static function pop($queue = null){
+            return \Illuminate\Queue\SyncQueue::pop($queue);
+        }
+        
+        /**
+         * Push a new job onto the queue.
+         *
+         * @param string $queue
+         * @param string $job
+         * @param mixed $data
+         * @return mixed 
+         * @static 
+         */
+        public static function pushOn($queue, $job, $data = ''){
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::pushOn($queue, $job, $data);
+        }
+        
+        /**
+         * Push a new job onto the queue after a delay.
+         *
+         * @param string $queue
+         * @param \DateTime|int $delay
+         * @param string $job
+         * @param mixed $data
+         * @return mixed 
+         * @static 
+         */
+        public static function laterOn($queue, $delay, $job, $data = ''){
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::laterOn($queue, $delay, $job, $data);
+        }
+        
+        /**
+         * Push an array of jobs onto the queue.
+         *
+         * @param array $jobs
+         * @param mixed $data
+         * @param string $queue
+         * @return mixed 
+         * @static 
+         */
+        public static function bulk($jobs, $data = '', $queue = null){
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::bulk($jobs, $data, $queue);
+        }
+        
+        /**
+         * Get the connection name for the queue.
+         *
+         * @return string 
+         * @static 
+         */
+        public static function getConnectionName(){
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::getConnectionName();
+        }
+        
+        /**
+         * Set the connection name for the queue.
+         *
+         * @param string $name
+         * @return $this 
+         * @static 
+         */
+        public static function setConnectionName($name){
+            //Method inherited from \Illuminate\Queue\Queue            
+            return \Illuminate\Queue\SyncQueue::setConnectionName($name);
+        }
+        
+        /**
+         * Set the IoC container instance.
+         *
+         * @param \Illuminate\Container\Container $container
+         * @return void 
+         * @static 
+         */
+        public static function setContainer($container){
+            //Method inherited from \Illuminate\Queue\Queue            
+            \Illuminate\Queue\SyncQueue::setContainer($container);
+        }
+        
     }
 
 
@@ -8561,11 +9081,12 @@ namespace {
          *
          * @param int $status
          * @param array $headers
+         * @param mixed $fallback
          * @return \Illuminate\Http\RedirectResponse 
          * @static 
          */
-        public static function back($status = 302, $headers = array()){
-            return \Illuminate\Routing\Redirector::back($status, $headers);
+        public static function back($status = 302, $headers = array(), $fallback = false){
+            return \Illuminate\Routing\Redirector::back($status, $headers, $fallback);
         }
         
         /**
@@ -8826,6 +9347,17 @@ namespace {
         }
         
         /**
+         * Check if the route name matches the given string.
+         *
+         * @param string $name
+         * @return bool 
+         * @static 
+         */
+        public static function routeIs($name){
+            return \Illuminate\Http\Request::routeIs($name);
+        }
+        
+        /**
          * Determine if the current request URL and query string matches a pattern.
          *
          * @return bool 
@@ -8886,1447 +9418,2328 @@ namespace {
         }
         
         /**
-         * Determine if the request contains a given input item key.
+         * Merge new input into the current request's input array.
          *
-         * @param string|array $key
-         * @return bool 
+         * @param array $input
+         * @return void 
          * @static 
          */
-        public static function exists($key){
-            return \Illuminate\Http\Request::exists($key);
+        public static function merge($input){
+            \Illuminate\Http\Request::merge($input);
         }
         
         /**
-         * Determine if the request contains a non-empty value for an input item.
+         * Replace the input for the current request.
          *
-         * @param string|array $key
-         * @return bool 
+         * @param array $input
+         * @return void 
          * @static 
          */
-        public static function has($key){
-            return \Illuminate\Http\Request::has($key);
+        public static function replace($input){
+            \Illuminate\Http\Request::replace($input);
         }
         
         /**
-         * Get all of the input and files for the request.
+         * Get the JSON payload for the request.
          *
-         * @return array 
+         * @param string $key
+         * @param mixed $default
+         * @return mixed 
          * @static 
          */
-        public static function all(){
-            return \Illuminate\Http\Request::all();
+        public static function json($key = null, $default = null){
+            return \Illuminate\Http\Request::json($key, $default);
         }
         
         /**
-         * Retrieve an input item from the request.
+         * Create an Illuminate request from a Symfony instance.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @return \Illuminate\Http\Request 
          * @static 
          */
-        public static function input($key = null, $default = null){
-            return \Illuminate\Http\Request::input($key, $default);
+        public static function createFromBase($request){
+            return \Illuminate\Http\Request::createFromBase($request);
         }
         
         /**
-         * Get a subset containing the provided keys with values from the input data.
+         * Clones a request and overrides some of its parameters.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param array $query The GET parameters
+         * @param array $request The POST parameters
+         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
+         * @param array $cookies The COOKIE parameters
+         * @param array $files The FILES parameters
+         * @param array $server The SERVER parameters
+         * @return static 
          * @static 
          */
-        public static function only($keys){
-            return \Illuminate\Http\Request::only($keys);
+        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null){
+            return \Illuminate\Http\Request::duplicate($query, $request, $attributes, $cookies, $files, $server);
         }
         
         /**
-         * Get all of the input except for a specified array of items.
+         * Get the session associated with the request.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @return \Illuminate\Session\Store 
+         * @throws \RuntimeException
          * @static 
          */
-        public static function except($keys){
-            return \Illuminate\Http\Request::except($keys);
+        public static function session(){
+            return \Illuminate\Http\Request::session();
         }
         
         /**
-         * Intersect an array of items with the input data.
+         * Set the session instance on the request.
          *
-         * @param array|mixed $keys
-         * @return array 
+         * @param \Illuminate\Contracts\Session\Session $session
+         * @return void 
          * @static 
          */
-        public static function intersect($keys){
-            return \Illuminate\Http\Request::intersect($keys);
+        public static function setLaravelSession($session){
+            \Illuminate\Http\Request::setLaravelSession($session);
         }
         
         /**
-         * Retrieve a query string item from the request.
+         * Get the user making the request.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param string|null $guard
+         * @return mixed 
          * @static 
          */
-        public static function query($key = null, $default = null){
-            return \Illuminate\Http\Request::query($key, $default);
+        public static function user($guard = null){
+            return \Illuminate\Http\Request::user($guard);
         }
         
         /**
-         * Determine if a cookie is set on the request.
+         * Get the route handling the request.
          *
-         * @param string $key
-         * @return bool 
+         * @param string|null $param
+         * @return \Illuminate\Routing\Route|object|string 
          * @static 
          */
-        public static function hasCookie($key){
-            return \Illuminate\Http\Request::hasCookie($key);
+        public static function route($param = null){
+            return \Illuminate\Http\Request::route($param);
         }
         
         /**
-         * Retrieve a cookie from the request.
+         * Get a unique fingerprint for the request / route / IP address.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return string 
+         * @throws \RuntimeException
          * @static 
          */
-        public static function cookie($key = null, $default = null){
-            return \Illuminate\Http\Request::cookie($key, $default);
+        public static function fingerprint(){
+            return \Illuminate\Http\Request::fingerprint();
         }
         
         /**
-         * Get an array of all of the files on the request.
+         * Set the JSON payload for the request.
          *
-         * @return array 
+         * @param array $json
+         * @return $this 
          * @static 
          */
-        public static function allFiles(){
-            return \Illuminate\Http\Request::allFiles();
+        public static function setJson($json){
+            return \Illuminate\Http\Request::setJson($json);
         }
         
         /**
-         * Retrieve a file from the request.
+         * Get the user resolver callback.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return \Illuminate\Http\UploadedFile|array|null 
+         * @return \Closure 
          * @static 
          */
-        public static function file($key = null, $default = null){
-            return \Illuminate\Http\Request::file($key, $default);
+        public static function getUserResolver(){
+            return \Illuminate\Http\Request::getUserResolver();
         }
         
         /**
-         * Determine if the uploaded data contains a file.
+         * Set the user resolver callback.
          *
-         * @param string $key
-         * @return bool 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function hasFile($key){
-            return \Illuminate\Http\Request::hasFile($key);
+        public static function setUserResolver($callback){
+            return \Illuminate\Http\Request::setUserResolver($callback);
         }
         
         /**
-         * Determine if a header is set on the request.
+         * Get the route resolver callback.
          *
-         * @param string $key
-         * @return bool 
+         * @return \Closure 
          * @static 
          */
-        public static function hasHeader($key){
-            return \Illuminate\Http\Request::hasHeader($key);
+        public static function getRouteResolver(){
+            return \Illuminate\Http\Request::getRouteResolver();
         }
         
         /**
-         * Retrieve a header from the request.
+         * Set the route resolver callback.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function header($key = null, $default = null){
-            return \Illuminate\Http\Request::header($key, $default);
+        public static function setRouteResolver($callback){
+            return \Illuminate\Http\Request::setRouteResolver($callback);
         }
         
         /**
-         * Retrieve a server variable from the request.
+         * Get all of the input and files for the request.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @return array 
          * @static 
          */
-        public static function server($key = null, $default = null){
-            return \Illuminate\Http\Request::server($key, $default);
+        public static function toArray(){
+            return \Illuminate\Http\Request::toArray();
         }
         
         /**
-         * Retrieve an old input item.
+         * Determine if the given offset exists.
          *
-         * @param string $key
-         * @param string|array|null $default
-         * @return string|array 
+         * @param string $offset
+         * @return bool 
          * @static 
          */
-        public static function old($key = null, $default = null){
-            return \Illuminate\Http\Request::old($key, $default);
+        public static function offsetExists($offset){
+            return \Illuminate\Http\Request::offsetExists($offset);
         }
         
         /**
-         * Flash the input for the current request to the session.
+         * Get the value at the given offset.
          *
-         * @param string $filter
-         * @param array $keys
-         * @return void 
+         * @param string $offset
+         * @return mixed 
          * @static 
          */
-        public static function flash($filter = null, $keys = array()){
-            \Illuminate\Http\Request::flash($filter, $keys);
+        public static function offsetGet($offset){
+            return \Illuminate\Http\Request::offsetGet($offset);
         }
         
         /**
-         * Flash only some of the input to the session.
+         * Set the value at the given offset.
          *
-         * @param array|mixed $keys
+         * @param string $offset
+         * @param mixed $value
          * @return void 
          * @static 
          */
-        public static function flashOnly($keys){
-            \Illuminate\Http\Request::flashOnly($keys);
+        public static function offsetSet($offset, $value){
+            \Illuminate\Http\Request::offsetSet($offset, $value);
         }
         
         /**
-         * Flash only some of the input to the session.
+         * Remove the value at the given offset.
          *
-         * @param array|mixed $keys
+         * @param string $offset
          * @return void 
          * @static 
          */
-        public static function flashExcept($keys){
-            \Illuminate\Http\Request::flashExcept($keys);
+        public static function offsetUnset($offset){
+            \Illuminate\Http\Request::offsetUnset($offset);
         }
         
         /**
-         * Flush all of the old input from the session.
+         * Sets the parameters for this request.
+         * 
+         * This method also re-initializes all properties.
          *
-         * @return void 
+         * @param array $query The GET parameters
+         * @param array $request The POST parameters
+         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
+         * @param array $cookies The COOKIE parameters
+         * @param array $files The FILES parameters
+         * @param array $server The SERVER parameters
+         * @param string|resource $content The raw body data
          * @static 
          */
-        public static function flush(){
-            \Illuminate\Http\Request::flush();
+        public static function initialize($query = array(), $request = array(), $attributes = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::initialize($query, $request, $attributes, $cookies, $files, $server, $content);
         }
         
         /**
-         * Merge new input into the current request's input array.
+         * Creates a new request with values from PHP's super globals.
          *
-         * @param array $input
-         * @return void 
+         * @return static 
          * @static 
          */
-        public static function merge($input){
-            \Illuminate\Http\Request::merge($input);
+        public static function createFromGlobals(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::createFromGlobals();
         }
         
         /**
-         * Replace the input for the current request.
+         * Creates a Request based on a given URI and configuration.
+         * 
+         * The information contained in the URI always take precedence
+         * over the other information (server and parameters).
          *
-         * @param array $input
-         * @return void 
+         * @param string $uri The URI
+         * @param string $method The HTTP method
+         * @param array $parameters The query (GET) or request (POST) parameters
+         * @param array $cookies The request cookies ($_COOKIE)
+         * @param array $files The request files ($_FILES)
+         * @param array $server The server parameters ($_SERVER)
+         * @param string $content The raw body data
+         * @return static 
          * @static 
          */
-        public static function replace($input){
-            \Illuminate\Http\Request::replace($input);
+        public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);
         }
         
         /**
-         * Get the JSON payload for the request.
+         * Sets a callable able to create a Request instance.
+         * 
+         * This is mainly useful when you need to override the Request class
+         * to keep BC with an existing system. It should not be used for any
+         * other purpose.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param callable|null $callable A PHP callable
          * @static 
          */
-        public static function json($key = null, $default = null){
-            return \Illuminate\Http\Request::json($key, $default);
+        public static function setFactory($callable){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setFactory($callable);
         }
         
         /**
-         * Determine if the given content types match.
+         * Overrides the PHP global variables according to this request instance.
+         * 
+         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.
+         * $_FILES is never overridden, see rfc1867
          *
-         * @param string $actual
-         * @param string $type
-         * @return bool 
          * @static 
          */
-        public static function matchesType($actual, $type){
-            return \Illuminate\Http\Request::matchesType($actual, $type);
+        public static function overrideGlobals(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::overrideGlobals();
         }
         
         /**
-         * Determine if the request is sending JSON.
+         * Sets a list of trusted proxies.
+         * 
+         * You should only list the reverse proxies that you manage directly.
          *
-         * @return bool 
+         * @param array $proxies A list of trusted proxies
+         * @param int $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies
+         * @throws \InvalidArgumentException When $trustedHeaderSet is invalid
          * @static 
          */
-        public static function isJson(){
-            return \Illuminate\Http\Request::isJson();
+        public static function setTrustedProxies($proxies){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedProxies($proxies);
         }
         
         /**
-         * Determine if the current request probably expects a JSON response.
+         * Gets the list of trusted proxies.
          *
-         * @return bool 
+         * @return array An array of trusted proxies
          * @static 
          */
-        public static function expectsJson(){
-            return \Illuminate\Http\Request::expectsJson();
+        public static function getTrustedProxies(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedProxies();
         }
         
         /**
-         * Determine if the current request is asking for JSON in return.
+         * Gets the set of trusted headers from trusted proxies.
          *
-         * @return bool 
+         * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies
          * @static 
          */
-        public static function wantsJson(){
-            return \Illuminate\Http\Request::wantsJson();
+        public static function getTrustedHeaderSet(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHeaderSet();
         }
         
         /**
-         * Determines whether the current requests accepts a given content type.
+         * Sets a list of trusted host patterns.
+         * 
+         * You should only list the hosts you manage using regexs.
          *
-         * @param string|array $contentTypes
-         * @return bool 
+         * @param array $hostPatterns A list of trusted host patterns
          * @static 
          */
-        public static function accepts($contentTypes){
-            return \Illuminate\Http\Request::accepts($contentTypes);
+        public static function setTrustedHosts($hostPatterns){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedHosts($hostPatterns);
         }
         
         /**
-         * Return the most suitable content type from the given array based on content negotiation.
+         * Gets the list of trusted host patterns.
          *
-         * @param string|array $contentTypes
-         * @return string|null 
+         * @return array An array of trusted host patterns
          * @static 
          */
-        public static function prefers($contentTypes){
-            return \Illuminate\Http\Request::prefers($contentTypes);
+        public static function getTrustedHosts(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHosts();
         }
         
         /**
-         * Determines whether a request accepts JSON.
+         * Sets the name for trusted headers.
+         * 
+         * The following header keys are supported:
+         * 
+         *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())
+         *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())
+         *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())
+         *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())
+         *  * Request::HEADER_FORWARDED:    defaults to Forwarded         (see RFC 7239)
+         * 
+         * Setting an empty value allows to disable the trusted header for the given key.
          *
-         * @return bool 
+         * @param string $key The header key
+         * @param string $value The header name
+         * @throws \InvalidArgumentException
+         * @deprecated since version 3.3, to be removed in 4.0. Use the $trustedHeaderSet argument of the Request::setTrustedProxies() method instead.
          * @static 
          */
-        public static function acceptsJson(){
-            return \Illuminate\Http\Request::acceptsJson();
+        public static function setTrustedHeaderName($key, $value){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setTrustedHeaderName($key, $value);
         }
         
         /**
-         * Determines whether a request accepts HTML.
+         * Gets the trusted proxy header name.
          *
-         * @return bool 
+         * @param string $key The header key
+         * @return string The header name
+         * @throws \InvalidArgumentException
+         * @deprecated since version 3.3, to be removed in 4.0. Use the Request::getTrustedHeaderSet() method instead.
          * @static 
          */
-        public static function acceptsHtml(){
-            return \Illuminate\Http\Request::acceptsHtml();
+        public static function getTrustedHeaderName($key){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getTrustedHeaderName($key);
         }
         
         /**
-         * Get the data format expected in the response.
+         * Normalizes a query string.
+         * 
+         * It builds a normalized query string, where keys/value pairs are alphabetized,
+         * have consistent escaping and unneeded delimiters are removed.
          *
-         * @param string $default
-         * @return string 
+         * @param string $qs Query string
+         * @return string A normalized query string for the Request
          * @static 
          */
-        public static function format($default = 'html'){
-            return \Illuminate\Http\Request::format($default);
+        public static function normalizeQueryString($qs){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::normalizeQueryString($qs);
         }
         
         /**
-         * Get the bearer token from the request headers.
+         * Enables support for the _method request parameter to determine the intended HTTP method.
+         * 
+         * Be warned that enabling this feature might lead to CSRF issues in your code.
+         * Check that you are using CSRF tokens when required.
+         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered
+         * and used to send a "PUT" or "DELETE" request via the _method request parameter.
+         * If these methods are not protected against CSRF, this presents a possible vulnerability.
+         * 
+         * The HTTP method can only be overridden when the real HTTP method is POST.
          *
-         * @return string|null 
          * @static 
          */
-        public static function bearerToken(){
-            return \Illuminate\Http\Request::bearerToken();
+        public static function enableHttpMethodParameterOverride(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::enableHttpMethodParameterOverride();
         }
         
         /**
-         * Create an Illuminate request from a Symfony instance.
+         * Checks whether support for the _method request parameter is enabled.
          *
-         * @param \Symfony\Component\HttpFoundation\Request $request
-         * @return \Illuminate\Http\Request 
+         * @return bool True when the _method request parameter is enabled, false otherwise
          * @static 
          */
-        public static function createFromBase($request){
-            return \Illuminate\Http\Request::createFromBase($request);
+        public static function getHttpMethodParameterOverride(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getHttpMethodParameterOverride();
         }
         
         /**
-         * Clones a request and overrides some of its parameters.
+         * Gets a "parameter" value from any bag.
+         * 
+         * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the
+         * flexibility in controllers, it is better to explicitly get request parameters from the appropriate
+         * public property instead (attributes, query, request).
+         * 
+         * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY
          *
-         * @param array $query The GET parameters
-         * @param array $request The POST parameters
-         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
-         * @param array $cookies The COOKIE parameters
-         * @param array $files The FILES parameters
-         * @param array $server The SERVER parameters
-         * @return \Request The duplicated request
+         * @param string $key the key
+         * @param mixed $default the default value if the parameter key does not exist
+         * @return mixed 
          * @static 
          */
-        public static function duplicate($query = null, $request = null, $attributes = null, $cookies = null, $files = null, $server = null){
-            return \Illuminate\Http\Request::duplicate($query, $request, $attributes, $cookies, $files, $server);
+        public static function get($key, $default = null){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::get($key, $default);
         }
         
         /**
-         * Get the session associated with the request.
+         * Gets the Session.
          *
-         * @return \Illuminate\Session\Store 
-         * @throws \RuntimeException
+         * @return \Symfony\Component\HttpFoundation\SessionInterface|null The session
          * @static 
          */
-        public static function session(){
-            return \Illuminate\Http\Request::session();
+        public static function getSession(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getSession();
         }
         
         /**
-         * Get the user making the request.
+         * Whether the request contains a Session which was started in one of the
+         * previous requests.
          *
-         * @param string|null $guard
-         * @return mixed 
+         * @return bool 
          * @static 
          */
-        public static function user($guard = null){
-            return \Illuminate\Http\Request::user($guard);
+        public static function hasPreviousSession(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::hasPreviousSession();
         }
         
         /**
-         * Get the route handling the request.
+         * Whether the request contains a Session object.
+         * 
+         * This method does not give any information about the state of the session object,
+         * like whether the session is started or not. It is just a way to check if this Request
+         * is associated with a Session instance.
          *
-         * @param string|null $param
-         * @return \Illuminate\Routing\Route|object|string 
+         * @return bool true when the Request contains a Session object, false otherwise
          * @static 
          */
-        public static function route($param = null){
-            return \Illuminate\Http\Request::route($param);
+        public static function hasSession(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::hasSession();
         }
         
         /**
-         * Get a unique fingerprint for the request / route / IP address.
+         * Sets the Session.
          *
-         * @return string 
-         * @throws \RuntimeException
+         * @param \Symfony\Component\HttpFoundation\SessionInterface $session The Session
          * @static 
          */
-        public static function fingerprint(){
-            return \Illuminate\Http\Request::fingerprint();
+        public static function setSession($session){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setSession($session);
         }
         
         /**
-         * Get the user resolver callback.
+         * Returns the client IP addresses.
+         * 
+         * In the returned array the most trusted IP address is first, and the
+         * least trusted one last. The "real" client IP address is the last one,
+         * but this is also the least trusted one. Trusted proxies are stripped.
+         * 
+         * Use this method carefully; you should use getClientIp() instead.
          *
-         * @return \Closure 
+         * @return array The client IP addresses
+         * @see getClientIp()
          * @static 
          */
-        public static function getUserResolver(){
-            return \Illuminate\Http\Request::getUserResolver();
+        public static function getClientIps(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getClientIps();
         }
         
         /**
-         * Set the user resolver callback.
+         * Returns the client IP address.
+         * 
+         * This method can read the client IP address from the "X-Forwarded-For" header
+         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"
+         * header value is a comma+space separated list of IP addresses, the left-most
+         * being the original client, and each successive proxy that passed the request
+         * adding the IP address where it received the request from.
+         * 
+         * If your reverse proxy uses a different header name than "X-Forwarded-For",
+         * ("Client-Ip" for instance), configure it via the $trustedHeaderSet
+         * argument of the Request::setTrustedProxies() method instead.
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @return string|null The client IP address
+         * @see getClientIps()
+         * @see http://en.wikipedia.org/wiki/X-Forwarded-For
          * @static 
          */
-        public static function setUserResolver($callback){
-            return \Illuminate\Http\Request::setUserResolver($callback);
+        public static function getClientIp(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getClientIp();
         }
         
         /**
-         * Get the route resolver callback.
+         * Returns current script name.
          *
-         * @return \Closure 
+         * @return string 
          * @static 
          */
-        public static function getRouteResolver(){
-            return \Illuminate\Http\Request::getRouteResolver();
+        public static function getScriptName(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getScriptName();
         }
         
         /**
-         * Set the route resolver callback.
+         * Returns the path being requested relative to the executed script.
+         * 
+         * The path info always starts with a /.
+         * 
+         * Suppose this request is instantiated from /mysite on localhost:
+         * 
+         *  * http://localhost/mysite              returns an empty string
+         *  * http://localhost/mysite/about        returns '/about'
+         *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'
+         *  * http://localhost/mysite/about?var=1  returns '/about'
          *
-         * @param \Closure $callback
-         * @return $this 
+         * @return string The raw path (i.e. not urldecoded)
          * @static 
          */
-        public static function setRouteResolver($callback){
-            return \Illuminate\Http\Request::setRouteResolver($callback);
+        public static function getPathInfo(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPathInfo();
         }
         
         /**
-         * Get all of the input and files for the request.
+         * Returns the root path from which this request is executed.
+         * 
+         * Suppose that an index.php file instantiates this request object:
+         * 
+         *  * http://localhost/index.php         returns an empty string
+         *  * http://localhost/index.php/page    returns an empty string
+         *  * http://localhost/web/index.php     returns '/web'
+         *  * http://localhost/we%20b/index.php  returns '/we%20b'
          *
-         * @return array 
+         * @return string The raw path (i.e. not urldecoded)
          * @static 
          */
-        public static function toArray(){
-            return \Illuminate\Http\Request::toArray();
+        public static function getBasePath(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getBasePath();
         }
         
         /**
-         * Determine if the given offset exists.
+         * Returns the root URL from which this request is executed.
+         * 
+         * The base URL never ends with a /.
+         * 
+         * This is similar to getBasePath(), except that it also includes the
+         * script filename (e.g. index.php) if one exists.
          *
-         * @param string $offset
-         * @return bool 
+         * @return string The raw URL (i.e. not urldecoded)
          * @static 
          */
-        public static function offsetExists($offset){
-            return \Illuminate\Http\Request::offsetExists($offset);
+        public static function getBaseUrl(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getBaseUrl();
         }
         
         /**
-         * Get the value at the given offset.
+         * Gets the request's scheme.
          *
-         * @param string $offset
-         * @return mixed 
+         * @return string 
          * @static 
          */
-        public static function offsetGet($offset){
-            return \Illuminate\Http\Request::offsetGet($offset);
+        public static function getScheme(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getScheme();
         }
         
         /**
-         * Set the value at the given offset.
+         * Returns the port on which the request is made.
+         * 
+         * This method can read the client port from the "X-Forwarded-Port" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Port" header must contain the client port.
+         * 
+         * If your reverse proxy uses a different header name than "X-Forwarded-Port",
+         * configure it via via the $trustedHeaderSet argument of the
+         * Request::setTrustedProxies() method instead.
          *
-         * @param string $offset
-         * @param mixed $value
-         * @return void 
+         * @return int|string can be a string if fetched from the server bag
          * @static 
          */
-        public static function offsetSet($offset, $value){
-            \Illuminate\Http\Request::offsetSet($offset, $value);
+        public static function getPort(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPort();
         }
         
         /**
-         * Remove the value at the given offset.
+         * Returns the user.
          *
-         * @param string $offset
-         * @return void 
+         * @return string|null 
          * @static 
          */
-        public static function offsetUnset($offset){
-            \Illuminate\Http\Request::offsetUnset($offset);
+        public static function getUser(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUser();
         }
         
         /**
-         * Sets the parameters for this request.
-         * 
-         * This method also re-initializes all properties.
+         * Returns the password.
          *
-         * @param array $query The GET parameters
-         * @param array $request The POST parameters
-         * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)
-         * @param array $cookies The COOKIE parameters
-         * @param array $files The FILES parameters
-         * @param array $server The SERVER parameters
-         * @param string|resource $content The raw body data
+         * @return string|null 
          * @static 
          */
-        public static function initialize($query = array(), $request = array(), $attributes = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
+        public static function getPassword(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::initialize($query, $request, $attributes, $cookies, $files, $server, $content);
+            return \Illuminate\Http\Request::getPassword();
         }
         
         /**
-         * Creates a new request with values from PHP's super globals.
+         * Gets the user info.
          *
-         * @return \Request A new request
+         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server
          * @static 
          */
-        public static function createFromGlobals(){
+        public static function getUserInfo(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::createFromGlobals();
+            return \Illuminate\Http\Request::getUserInfo();
         }
         
         /**
-         * Creates a Request based on a given URI and configuration.
+         * Returns the HTTP host being requested.
          * 
-         * The information contained in the URI always take precedence
-         * over the other information (server and parameters).
+         * The port name will be appended to the host if it's non-standard.
          *
-         * @param string $uri The URI
-         * @param string $method The HTTP method
-         * @param array $parameters The query (GET) or request (POST) parameters
-         * @param array $cookies The request cookies ($_COOKIE)
-         * @param array $files The request files ($_FILES)
-         * @param array $server The server parameters ($_SERVER)
-         * @param string $content The raw body data
-         * @return \Request A Request instance
+         * @return string 
          * @static 
          */
-        public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null){
+        public static function getHttpHost(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::create($uri, $method, $parameters, $cookies, $files, $server, $content);
+            return \Illuminate\Http\Request::getHttpHost();
         }
         
         /**
-         * Sets a callable able to create a Request instance.
+         * Returns the requested URI (path and query string).
+         *
+         * @return string The raw URI (i.e. not URI decoded)
+         * @static 
+         */
+        public static function getRequestUri(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRequestUri();
+        }
+        
+        /**
+         * Gets the scheme and HTTP host.
          * 
-         * This is mainly useful when you need to override the Request class
-         * to keep BC with an existing system. It should not be used for any
-         * other purpose.
+         * If the URL was called with basic authentication, the user
+         * and the password are not added to the generated string.
          *
-         * @param callable|null $callable A PHP callable
+         * @return string The scheme and HTTP host
          * @static 
          */
-        public static function setFactory($callable){
+        public static function getSchemeAndHttpHost(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setFactory($callable);
+            return \Illuminate\Http\Request::getSchemeAndHttpHost();
         }
         
         /**
-         * Overrides the PHP global variables according to this request instance.
+         * Generates a normalized URI (URL) for the Request.
+         *
+         * @return string A normalized URI (URL) for the Request
+         * @see getQueryString()
+         * @static 
+         */
+        public static function getUri(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUri();
+        }
+        
+        /**
+         * Generates a normalized URI for the given path.
+         *
+         * @param string $path A path to use instead of the current one
+         * @return string The normalized URI for the path
+         * @static 
+         */
+        public static function getUriForPath($path){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getUriForPath($path);
+        }
+        
+        /**
+         * Returns the path as relative reference from the current Request path.
          * 
-         * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.
-         * $_FILES is never overridden, see rfc1867
+         * Only the URIs path component (no schema, host etc.) is relevant and must be given.
+         * Both paths must be absolute and not contain relative parts.
+         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.
+         * Furthermore, they can be used to reduce the link size in documents.
+         * 
+         * Example target paths, given a base path of "/a/b/c/d":
+         * - "/a/b/c/d"     -> ""
+         * - "/a/b/c/"      -> "./"
+         * - "/a/b/"        -> "../"
+         * - "/a/b/c/other" -> "other"
+         * - "/a/x/y"       -> "../../x/y"
          *
+         * @param string $path The target path
+         * @return string The relative target path
          * @static 
          */
-        public static function overrideGlobals(){
+        public static function getRelativeUriForPath($path){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::overrideGlobals();
+            return \Illuminate\Http\Request::getRelativeUriForPath($path);
         }
         
         /**
-         * Sets a list of trusted proxies.
+         * Generates the normalized query string for the Request.
          * 
-         * You should only list the reverse proxies that you manage directly.
+         * It builds a normalized query string, where keys/value pairs are alphabetized
+         * and have consistent escaping.
          *
-         * @param array $proxies A list of trusted proxies
+         * @return string|null A normalized query string for the Request
          * @static 
          */
-        public static function setTrustedProxies($proxies){
+        public static function getQueryString(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedProxies($proxies);
+            return \Illuminate\Http\Request::getQueryString();
         }
         
         /**
-         * Gets the list of trusted proxies.
+         * Checks whether the request is secure or not.
+         * 
+         * This method can read the client protocol from the "X-Forwarded-Proto" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".
+         * 
+         * If your reverse proxy uses a different header name than "X-Forwarded-Proto"
+         * ("SSL_HTTPS" for instance), configure it via the $trustedHeaderSet
+         * argument of the Request::setTrustedProxies() method instead.
          *
-         * @return array An array of trusted proxies
+         * @return bool 
          * @static 
          */
-        public static function getTrustedProxies(){
+        public static function isSecure(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedProxies();
+            return \Illuminate\Http\Request::isSecure();
         }
         
         /**
-         * Sets a list of trusted host patterns.
+         * Returns the host name.
          * 
-         * You should only list the hosts you manage using regexs.
+         * This method can read the client host name from the "X-Forwarded-Host" header
+         * when trusted proxies were set via "setTrustedProxies()".
+         * 
+         * The "X-Forwarded-Host" header must contain the client host name.
+         * 
+         * If your reverse proxy uses a different header name than "X-Forwarded-Host",
+         * configure it via the $trustedHeaderSet argument of the
+         * Request::setTrustedProxies() method instead.
          *
-         * @param array $hostPatterns A list of trusted host patterns
+         * @return string 
+         * @throws SuspiciousOperationException when the host name is invalid or not trusted
          * @static 
          */
-        public static function setTrustedHosts($hostPatterns){
+        public static function getHost(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedHosts($hostPatterns);
+            return \Illuminate\Http\Request::getHost();
         }
         
         /**
-         * Gets the list of trusted host patterns.
+         * Sets the request method.
          *
-         * @return array An array of trusted host patterns
+         * @param string $method
          * @static 
          */
-        public static function getTrustedHosts(){
+        public static function setMethod($method){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHosts();
+            return \Illuminate\Http\Request::setMethod($method);
         }
         
         /**
-         * Sets the name for trusted headers.
+         * Gets the request "intended" method.
          * 
-         * The following header keys are supported:
+         * If the X-HTTP-Method-Override header is set, and if the method is a POST,
+         * then it is used to determine the "real" intended HTTP method.
          * 
-         *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())
-         *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())
-         *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())
-         *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())
+         * The _method request parameter can also be used to determine the HTTP method,
+         * but only if enableHttpMethodParameterOverride() has been called.
          * 
-         * Setting an empty value allows to disable the trusted header for the given key.
+         * The method is always an uppercased string.
          *
-         * @param string $key The header key
-         * @param string $value The header name
-         * @throws \InvalidArgumentException
+         * @return string The request method
+         * @see getRealMethod()
          * @static 
          */
-        public static function setTrustedHeaderName($key, $value){
+        public static function getMethod(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setTrustedHeaderName($key, $value);
+            return \Illuminate\Http\Request::getMethod();
         }
         
         /**
-         * Gets the trusted proxy header name.
+         * Gets the "real" request method.
          *
-         * @param string $key The header key
-         * @return string The header name
-         * @throws \InvalidArgumentException
+         * @return string The request method
+         * @see getMethod()
          * @static 
          */
-        public static function getTrustedHeaderName($key){
+        public static function getRealMethod(){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getTrustedHeaderName($key);
+            return \Illuminate\Http\Request::getRealMethod();
         }
         
         /**
-         * Normalizes a query string.
-         * 
-         * It builds a normalized query string, where keys/value pairs are alphabetized,
-         * have consistent escaping and unneeded delimiters are removed.
+         * Gets the mime type associated with the format.
          *
-         * @param string $qs Query string
-         * @return string A normalized query string for the Request
+         * @param string $format The format
+         * @return string The associated mime type (null if not found)
          * @static 
          */
-        public static function normalizeQueryString($qs){
+        public static function getMimeType($format){
             //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::normalizeQueryString($qs);
+            return \Illuminate\Http\Request::getMimeType($format);
         }
         
         /**
-         * Enables support for the _method request parameter to determine the intended HTTP method.
+         * Gets the mime types associated with the format.
+         *
+         * @param string $format The format
+         * @return array The associated mime types
+         * @static 
+         */
+        public static function getMimeTypes($format){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getMimeTypes($format);
+        }
+        
+        /**
+         * Gets the format associated with the mime type.
+         *
+         * @param string $mimeType The associated mime type
+         * @return string|null The format (null if not found)
+         * @static 
+         */
+        public static function getFormat($mimeType){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getFormat($mimeType);
+        }
+        
+        /**
+         * Associates a format with mime types.
+         *
+         * @param string $format The format
+         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)
+         * @static 
+         */
+        public static function setFormat($format, $mimeTypes){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setFormat($format, $mimeTypes);
+        }
+        
+        /**
+         * Gets the request format.
          * 
-         * Be warned that enabling this feature might lead to CSRF issues in your code.
-         * Check that you are using CSRF tokens when required.
-         * If the HTTP method parameter override is enabled, an html-form with method "POST" can be altered
-         * and used to send a "PUT" or "DELETE" request via the _method request parameter.
-         * If these methods are not protected against CSRF, this presents a possible vulnerability.
+         * Here is the process to determine the format:
          * 
-         * The HTTP method can only be overridden when the real HTTP method is POST.
+         *  * format defined by the user (with setRequestFormat())
+         *  * _format request attribute
+         *  * $default
+         *
+         * @param string $default The default format
+         * @return string The request format
+         * @static 
+         */
+        public static function getRequestFormat($default = 'html'){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getRequestFormat($default);
+        }
+        
+        /**
+         * Sets the request format.
+         *
+         * @param string $format The request format
+         * @static 
+         */
+        public static function setRequestFormat($format){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setRequestFormat($format);
+        }
+        
+        /**
+         * Gets the format associated with the request.
+         *
+         * @return string|null The format (null if no content type is present)
+         * @static 
+         */
+        public static function getContentType(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getContentType();
+        }
+        
+        /**
+         * Sets the default locale.
+         *
+         * @param string $locale
+         * @static 
+         */
+        public static function setDefaultLocale($locale){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setDefaultLocale($locale);
+        }
+        
+        /**
+         * Get the default locale.
+         *
+         * @return string 
+         * @static 
+         */
+        public static function getDefaultLocale(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getDefaultLocale();
+        }
+        
+        /**
+         * Sets the locale.
+         *
+         * @param string $locale
+         * @static 
+         */
+        public static function setLocale($locale){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::setLocale($locale);
+        }
+        
+        /**
+         * Get the locale.
+         *
+         * @return string 
+         * @static 
+         */
+        public static function getLocale(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getLocale();
+        }
+        
+        /**
+         * Checks if the request method is of specified type.
+         *
+         * @param string $method Uppercase request method (GET, POST etc)
+         * @return bool 
+         * @static 
+         */
+        public static function isMethod($method){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethod($method);
+        }
+        
+        /**
+         * Checks whether or not the method is safe.
+         *
+         * @see https://tools.ietf.org/html/rfc7231#section-4.2.1
+         * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.
+         * @return bool 
+         * @static 
+         */
+        public static function isMethodSafe(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodSafe();
+        }
+        
+        /**
+         * Checks whether or not the method is idempotent.
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function isMethodIdempotent(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodIdempotent();
+        }
+        
+        /**
+         * Checks whether the method is cacheable or not.
+         *
+         * @see https://tools.ietf.org/html/rfc7231#section-4.2.3
+         * @return bool 
+         * @static 
+         */
+        public static function isMethodCacheable(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isMethodCacheable();
+        }
+        
+        /**
+         * Returns the request body content.
+         *
+         * @param bool $asResource If true, a resource will be returned
+         * @return string|resource The request body content or a resource to read the body stream
+         * @throws \LogicException
+         * @static 
+         */
+        public static function getContent($asResource = false){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getContent($asResource);
+        }
+        
+        /**
+         * Gets the Etags.
+         *
+         * @return array The entity tags
+         * @static 
+         */
+        public static function getETags(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getETags();
+        }
+        
+        /**
+         * 
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function isNoCache(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isNoCache();
+        }
+        
+        /**
+         * Returns the preferred language.
+         *
+         * @param array $locales An array of ordered available locales
+         * @return string|null The preferred locale
+         * @static 
+         */
+        public static function getPreferredLanguage($locales = null){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getPreferredLanguage($locales);
+        }
+        
+        /**
+         * Gets a list of languages acceptable by the client browser.
+         *
+         * @return array Languages ordered in the user browser preferences
+         * @static 
+         */
+        public static function getLanguages(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getLanguages();
+        }
+        
+        /**
+         * Gets a list of charsets acceptable by the client browser.
+         *
+         * @return array List of charsets in preferable order
+         * @static 
+         */
+        public static function getCharsets(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getCharsets();
+        }
+        
+        /**
+         * Gets a list of encodings acceptable by the client browser.
+         *
+         * @return array List of encodings in preferable order
+         * @static 
+         */
+        public static function getEncodings(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getEncodings();
+        }
+        
+        /**
+         * Gets a list of content types acceptable by the client browser.
+         *
+         * @return array List of content types in preferable order
+         * @static 
+         */
+        public static function getAcceptableContentTypes(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::getAcceptableContentTypes();
+        }
+        
+        /**
+         * Returns true if the request is a XMLHttpRequest.
+         * 
+         * It works if your JavaScript library sets an X-Requested-With HTTP header.
+         * It is known to work with common JavaScript frameworks:
+         *
+         * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript
+         * @return bool true if the request is an XMLHttpRequest, false otherwise
+         * @static 
+         */
+        public static function isXmlHttpRequest(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isXmlHttpRequest();
+        }
+        
+        /**
+         * Indicates whether this request originated from a trusted proxy.
+         * 
+         * This can be useful to determine whether or not to trust the
+         * contents of a proxy-specific header.
+         *
+         * @return bool true if the request came from a trusted proxy, false otherwise
+         * @static 
+         */
+        public static function isFromTrustedProxy(){
+            //Method inherited from \Symfony\Component\HttpFoundation\Request            
+            return \Illuminate\Http\Request::isFromTrustedProxy();
+        }
+        
+        /**
+         * Determine if the given content types match.
+         *
+         * @param string $actual
+         * @param string $type
+         * @return bool 
+         * @static 
+         */
+        public static function matchesType($actual, $type){
+            return \Illuminate\Http\Request::matchesType($actual, $type);
+        }
+        
+        /**
+         * Determine if the request is sending JSON.
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function isJson(){
+            return \Illuminate\Http\Request::isJson();
+        }
+        
+        /**
+         * Determine if the current request probably expects a JSON response.
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function expectsJson(){
+            return \Illuminate\Http\Request::expectsJson();
+        }
+        
+        /**
+         * Determine if the current request is asking for JSON in return.
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function wantsJson(){
+            return \Illuminate\Http\Request::wantsJson();
+        }
+        
+        /**
+         * Determines whether the current requests accepts a given content type.
+         *
+         * @param string|array $contentTypes
+         * @return bool 
+         * @static 
+         */
+        public static function accepts($contentTypes){
+            return \Illuminate\Http\Request::accepts($contentTypes);
+        }
+        
+        /**
+         * Return the most suitable content type from the given array based on content negotiation.
+         *
+         * @param string|array $contentTypes
+         * @return string|null 
+         * @static 
+         */
+        public static function prefers($contentTypes){
+            return \Illuminate\Http\Request::prefers($contentTypes);
+        }
+        
+        /**
+         * Determines whether a request accepts JSON.
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function acceptsJson(){
+            return \Illuminate\Http\Request::acceptsJson();
+        }
+        
+        /**
+         * Determines whether a request accepts HTML.
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function acceptsHtml(){
+            return \Illuminate\Http\Request::acceptsHtml();
+        }
+        
+        /**
+         * Get the data format expected in the response.
+         *
+         * @param string $default
+         * @return string 
+         * @static 
+         */
+        public static function format($default = 'html'){
+            return \Illuminate\Http\Request::format($default);
+        }
+        
+        /**
+         * Retrieve an old input item.
+         *
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
+         * @static 
+         */
+        public static function old($key = null, $default = null){
+            return \Illuminate\Http\Request::old($key, $default);
+        }
+        
+        /**
+         * Flash the input for the current request to the session.
+         *
+         * @return void 
+         * @static 
+         */
+        public static function flash(){
+            \Illuminate\Http\Request::flash();
+        }
+        
+        /**
+         * Flash only some of the input to the session.
+         *
+         * @param array|mixed $keys
+         * @return void 
+         * @static 
+         */
+        public static function flashOnly($keys){
+            \Illuminate\Http\Request::flashOnly($keys);
+        }
+        
+        /**
+         * Flash only some of the input to the session.
+         *
+         * @param array|mixed $keys
+         * @return void 
+         * @static 
+         */
+        public static function flashExcept($keys){
+            \Illuminate\Http\Request::flashExcept($keys);
+        }
+        
+        /**
+         * Flush all of the old input from the session.
+         *
+         * @return void 
+         * @static 
+         */
+        public static function flush(){
+            \Illuminate\Http\Request::flush();
+        }
+        
+        /**
+         * Retrieve a server variable from the request.
+         *
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
+         * @static 
+         */
+        public static function server($key = null, $default = null){
+            return \Illuminate\Http\Request::server($key, $default);
+        }
+        
+        /**
+         * Determine if a header is set on the request.
+         *
+         * @param string $key
+         * @return bool 
+         * @static 
+         */
+        public static function hasHeader($key){
+            return \Illuminate\Http\Request::hasHeader($key);
+        }
+        
+        /**
+         * Retrieve a header from the request.
+         *
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
+         * @static 
+         */
+        public static function header($key = null, $default = null){
+            return \Illuminate\Http\Request::header($key, $default);
+        }
+        
+        /**
+         * Get the bearer token from the request headers.
+         *
+         * @return string|null 
+         * @static 
+         */
+        public static function bearerToken(){
+            return \Illuminate\Http\Request::bearerToken();
+        }
+        
+        /**
+         * Determine if the request contains a given input item key.
+         *
+         * @param string|array $key
+         * @return bool 
+         * @static 
+         */
+        public static function exists($key){
+            return \Illuminate\Http\Request::exists($key);
+        }
+        
+        /**
+         * Determine if the request contains a non-empty value for an input item.
+         *
+         * @param string|array $key
+         * @return bool 
+         * @static 
+         */
+        public static function has($key){
+            return \Illuminate\Http\Request::has($key);
+        }
+        
+        /**
+         * Get all of the input and files for the request.
+         *
+         * @return array 
+         * @static 
+         */
+        public static function all(){
+            return \Illuminate\Http\Request::all();
+        }
+        
+        /**
+         * Retrieve an input item from the request.
+         *
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
+         * @static 
+         */
+        public static function input($key = null, $default = null){
+            return \Illuminate\Http\Request::input($key, $default);
+        }
+        
+        /**
+         * Get a subset containing the provided keys with values from the input data.
+         *
+         * @param array|mixed $keys
+         * @return array 
+         * @static 
+         */
+        public static function only($keys){
+            return \Illuminate\Http\Request::only($keys);
+        }
+        
+        /**
+         * Get all of the input except for a specified array of items.
+         *
+         * @param array|mixed $keys
+         * @return array 
+         * @static 
+         */
+        public static function except($keys){
+            return \Illuminate\Http\Request::except($keys);
+        }
+        
+        /**
+         * Intersect an array of items with the input data.
+         *
+         * @param array|mixed $keys
+         * @return array 
+         * @static 
+         */
+        public static function intersect($keys){
+            return \Illuminate\Http\Request::intersect($keys);
+        }
+        
+        /**
+         * Retrieve a query string item from the request.
+         *
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
+         * @static 
+         */
+        public static function query($key = null, $default = null){
+            return \Illuminate\Http\Request::query($key, $default);
+        }
+        
+        /**
+         * Determine if a cookie is set on the request.
+         *
+         * @param string $key
+         * @return bool 
+         * @static 
+         */
+        public static function hasCookie($key){
+            return \Illuminate\Http\Request::hasCookie($key);
+        }
+        
+        /**
+         * Retrieve a cookie from the request.
+         *
+         * @param string $key
+         * @param string|array|null $default
+         * @return string|array 
+         * @static 
+         */
+        public static function cookie($key = null, $default = null){
+            return \Illuminate\Http\Request::cookie($key, $default);
+        }
+        
+        /**
+         * Get an array of all of the files on the request.
+         *
+         * @return array 
+         * @static 
+         */
+        public static function allFiles(){
+            return \Illuminate\Http\Request::allFiles();
+        }
+        
+        /**
+         * Determine if the uploaded data contains a file.
+         *
+         * @param string $key
+         * @return bool 
+         * @static 
+         */
+        public static function hasFile($key){
+            return \Illuminate\Http\Request::hasFile($key);
+        }
+        
+        /**
+         * Retrieve a file from the request.
+         *
+         * @param string $key
+         * @param mixed $default
+         * @return \Illuminate\Http\UploadedFile|array|null 
+         * @static 
+         */
+        public static function file($key = null, $default = null){
+            return \Illuminate\Http\Request::file($key, $default);
+        }
+        
+        /**
+         * Register a custom macro.
+         *
+         * @param string $name
+         * @param callable $macro
+         * @return void 
+         * @static 
+         */
+        public static function macro($name, $macro){
+            \Illuminate\Http\Request::macro($name, $macro);
+        }
+        
+        /**
+         * Checks if macro is registered.
+         *
+         * @param string $name
+         * @return bool 
+         * @static 
+         */
+        public static function hasMacro($name){
+            return \Illuminate\Http\Request::hasMacro($name);
+        }
+        
+    }
+
+
+    class Response extends \Illuminate\Support\Facades\Response{
+        
+        /**
+         * Return a new response from the application.
+         *
+         * @param string $content
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\Response 
+         * @static 
+         */
+        public static function make($content = '', $status = 200, $headers = array()){
+            return \Illuminate\Routing\ResponseFactory::make($content, $status, $headers);
+        }
+        
+        /**
+         * Return a new view response from the application.
+         *
+         * @param string $view
+         * @param array $data
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\Response 
+         * @static 
+         */
+        public static function view($view, $data = array(), $status = 200, $headers = array()){
+            return \Illuminate\Routing\ResponseFactory::view($view, $data, $status, $headers);
+        }
+        
+        /**
+         * Return a new JSON response from the application.
+         *
+         * @param mixed $data
+         * @param int $status
+         * @param array $headers
+         * @param int $options
+         * @return \Illuminate\Http\JsonResponse 
+         * @static 
+         */
+        public static function json($data = array(), $status = 200, $headers = array(), $options = 0){
+            return \Illuminate\Routing\ResponseFactory::json($data, $status, $headers, $options);
+        }
+        
+        /**
+         * Return a new JSONP response from the application.
+         *
+         * @param string $callback
+         * @param mixed $data
+         * @param int $status
+         * @param array $headers
+         * @param int $options
+         * @return \Illuminate\Http\JsonResponse 
+         * @static 
+         */
+        public static function jsonp($callback, $data = array(), $status = 200, $headers = array(), $options = 0){
+            return \Illuminate\Routing\ResponseFactory::jsonp($callback, $data, $status, $headers, $options);
+        }
+        
+        /**
+         * Return a new streamed response from the application.
+         *
+         * @param \Closure $callback
+         * @param int $status
+         * @param array $headers
+         * @return \Symfony\Component\HttpFoundation\StreamedResponse 
+         * @static 
+         */
+        public static function stream($callback, $status = 200, $headers = array()){
+            return \Illuminate\Routing\ResponseFactory::stream($callback, $status, $headers);
+        }
+        
+        /**
+         * Create a new file download response.
+         *
+         * @param \SplFileInfo|string $file
+         * @param string $name
+         * @param array $headers
+         * @param string|null $disposition
+         * @return \Symfony\Component\HttpFoundation\BinaryFileResponse 
+         * @static 
+         */
+        public static function download($file, $name = null, $headers = array(), $disposition = 'attachment'){
+            return \Illuminate\Routing\ResponseFactory::download($file, $name, $headers, $disposition);
+        }
+        
+        /**
+         * Return the raw contents of a binary file.
+         *
+         * @param \SplFileInfo|string $file
+         * @param array $headers
+         * @return \Symfony\Component\HttpFoundation\BinaryFileResponse 
+         * @static 
+         */
+        public static function file($file, $headers = array()){
+            return \Illuminate\Routing\ResponseFactory::file($file, $headers);
+        }
+        
+        /**
+         * Create a new redirect response to the given path.
+         *
+         * @param string $path
+         * @param int $status
+         * @param array $headers
+         * @param bool|null $secure
+         * @return \Illuminate\Http\RedirectResponse 
+         * @static 
+         */
+        public static function redirectTo($path, $status = 302, $headers = array(), $secure = null){
+            return \Illuminate\Routing\ResponseFactory::redirectTo($path, $status, $headers, $secure);
+        }
+        
+        /**
+         * Create a new redirect response to a named route.
+         *
+         * @param string $route
+         * @param array $parameters
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
+         * @static 
+         */
+        public static function redirectToRoute($route, $parameters = array(), $status = 302, $headers = array()){
+            return \Illuminate\Routing\ResponseFactory::redirectToRoute($route, $parameters, $status, $headers);
+        }
+        
+        /**
+         * Create a new redirect response to a controller action.
+         *
+         * @param string $action
+         * @param array $parameters
+         * @param int $status
+         * @param array $headers
+         * @return \Illuminate\Http\RedirectResponse 
+         * @static 
+         */
+        public static function redirectToAction($action, $parameters = array(), $status = 302, $headers = array()){
+            return \Illuminate\Routing\ResponseFactory::redirectToAction($action, $parameters, $status, $headers);
+        }
+        
+        /**
+         * Create a new redirect response, while putting the current URL in the session.
+         *
+         * @param string $path
+         * @param int $status
+         * @param array $headers
+         * @param bool|null $secure
+         * @return \Illuminate\Http\RedirectResponse 
+         * @static 
+         */
+        public static function redirectGuest($path, $status = 302, $headers = array(), $secure = null){
+            return \Illuminate\Routing\ResponseFactory::redirectGuest($path, $status, $headers, $secure);
+        }
+        
+        /**
+         * Create a new redirect response to the previously intended location.
+         *
+         * @param string $default
+         * @param int $status
+         * @param array $headers
+         * @param bool|null $secure
+         * @return \Illuminate\Http\RedirectResponse 
+         * @static 
+         */
+        public static function redirectToIntended($default = '/', $status = 302, $headers = array(), $secure = null){
+            return \Illuminate\Routing\ResponseFactory::redirectToIntended($default, $status, $headers, $secure);
+        }
+        
+        /**
+         * Register a custom macro.
+         *
+         * @param string $name
+         * @param callable $macro
+         * @return void 
+         * @static 
+         */
+        public static function macro($name, $macro){
+            \Illuminate\Routing\ResponseFactory::macro($name, $macro);
+        }
+        
+        /**
+         * Checks if macro is registered.
+         *
+         * @param string $name
+         * @return bool 
+         * @static 
+         */
+        public static function hasMacro($name){
+            return \Illuminate\Routing\ResponseFactory::hasMacro($name);
+        }
+        
+    }
+
+
+    class Route extends \Illuminate\Support\Facades\Route{
+        
+        /**
+         * Register a new GET route with the router.
          *
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function enableHttpMethodParameterOverride(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::enableHttpMethodParameterOverride();
+        public static function get($uri, $action = null){
+            return \Illuminate\Routing\Router::get($uri, $action);
         }
         
         /**
-         * Checks whether support for the _method request parameter is enabled.
+         * Register a new POST route with the router.
          *
-         * @return bool True when the _method request parameter is enabled, false otherwise
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function getHttpMethodParameterOverride(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHttpMethodParameterOverride();
+        public static function post($uri, $action = null){
+            return \Illuminate\Routing\Router::post($uri, $action);
         }
         
         /**
-         * Gets a "parameter" value from any bag.
-         * 
-         * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the
-         * flexibility in controllers, it is better to explicitly get request parameters from the appropriate
-         * public property instead (attributes, query, request).
-         * 
-         * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY
+         * Register a new PUT route with the router.
          *
-         * @param string $key the key
-         * @param mixed $default the default value if the parameter key does not exist
-         * @return mixed 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function get($key, $default = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::get($key, $default);
+        public static function put($uri, $action = null){
+            return \Illuminate\Routing\Router::put($uri, $action);
         }
         
         /**
-         * Gets the Session.
+         * Register a new PATCH route with the router.
          *
-         * @return \Symfony\Component\HttpFoundation\SessionInterface|null The session
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function getSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getSession();
+        public static function patch($uri, $action = null){
+            return \Illuminate\Routing\Router::patch($uri, $action);
         }
         
         /**
-         * Whether the request contains a Session which was started in one of the
-         * previous requests.
+         * Register a new DELETE route with the router.
          *
-         * @return bool 
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function hasPreviousSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::hasPreviousSession();
+        public static function delete($uri, $action = null){
+            return \Illuminate\Routing\Router::delete($uri, $action);
         }
         
         /**
-         * Whether the request contains a Session object.
-         * 
-         * This method does not give any information about the state of the session object,
-         * like whether the session is started or not. It is just a way to check if this Request
-         * is associated with a Session instance.
+         * Register a new OPTIONS route with the router.
          *
-         * @return bool true when the Request contains a Session object, false otherwise
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function hasSession(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::hasSession();
+        public static function options($uri, $action = null){
+            return \Illuminate\Routing\Router::options($uri, $action);
         }
         
         /**
-         * Sets the Session.
+         * Register a new route responding to all verbs.
          *
-         * @param \Symfony\Component\HttpFoundation\SessionInterface $session The Session
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function setSession($session){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setSession($session);
+        public static function any($uri, $action = null){
+            return \Illuminate\Routing\Router::any($uri, $action);
         }
         
         /**
-         * Returns the client IP addresses.
-         * 
-         * In the returned array the most trusted IP address is first, and the
-         * least trusted one last. The "real" client IP address is the last one,
-         * but this is also the least trusted one. Trusted proxies are stripped.
-         * 
-         * Use this method carefully; you should use getClientIp() instead.
+         * Register a new route with the given verbs.
          *
-         * @return array The client IP addresses
-         * @see getClientIp()
+         * @param array|string $methods
+         * @param string $uri
+         * @param \Closure|array|string|null $action
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function getClientIps(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getClientIps();
+        public static function match($methods, $uri, $action = null){
+            return \Illuminate\Routing\Router::match($methods, $uri, $action);
         }
         
         /**
-         * Returns the client IP address.
-         * 
-         * This method can read the client IP address from the "X-Forwarded-For" header
-         * when trusted proxies were set via "setTrustedProxies()". The "X-Forwarded-For"
-         * header value is a comma+space separated list of IP addresses, the left-most
-         * being the original client, and each successive proxy that passed the request
-         * adding the IP address where it received the request from.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-For",
-         * ("Client-Ip" for instance), configure it via "setTrustedHeaderName()" with
-         * the "client-ip" key.
+         * Register an array of resource controllers.
          *
-         * @return string The client IP address
-         * @see getClientIps()
-         * @see http://en.wikipedia.org/wiki/X-Forwarded-For
+         * @param array $resources
+         * @return void 
          * @static 
          */
-        public static function getClientIp(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getClientIp();
+        public static function resources($resources){
+            \Illuminate\Routing\Router::resources($resources);
         }
         
         /**
-         * Returns current script name.
+         * Route a resource to a controller.
          *
-         * @return string 
+         * @param string $name
+         * @param string $controller
+         * @param array $options
+         * @return void 
          * @static 
          */
-        public static function getScriptName(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getScriptName();
+        public static function resource($name, $controller, $options = array()){
+            \Illuminate\Routing\Router::resource($name, $controller, $options);
         }
         
         /**
-         * Returns the path being requested relative to the executed script.
-         * 
-         * The path info always starts with a /.
-         * 
-         * Suppose this request is instantiated from /mysite on localhost:
-         * 
-         *  * http://localhost/mysite              returns an empty string
-         *  * http://localhost/mysite/about        returns '/about'
-         *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'
-         *  * http://localhost/mysite/about?var=1  returns '/about'
+         * Route an api resource to a controller.
          *
-         * @return string The raw path (i.e. not urldecoded)
+         * @param string $name
+         * @param string $controller
+         * @param array $options
+         * @return void 
          * @static 
          */
-        public static function getPathInfo(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPathInfo();
+        public static function apiResource($name, $controller, $options = array()){
+            \Illuminate\Routing\Router::apiResource($name, $controller, $options);
         }
         
         /**
-         * Returns the root path from which this request is executed.
-         * 
-         * Suppose that an index.php file instantiates this request object:
-         * 
-         *  * http://localhost/index.php         returns an empty string
-         *  * http://localhost/index.php/page    returns an empty string
-         *  * http://localhost/web/index.php     returns '/web'
-         *  * http://localhost/we%20b/index.php  returns '/we%20b'
+         * Create a route group with shared attributes.
          *
-         * @return string The raw path (i.e. not urldecoded)
+         * @param array $attributes
+         * @param \Closure|string $routes
+         * @return void 
          * @static 
          */
-        public static function getBasePath(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getBasePath();
+        public static function group($attributes, $routes){
+            \Illuminate\Routing\Router::group($attributes, $routes);
         }
         
         /**
-         * Returns the root URL from which this request is executed.
-         * 
-         * The base URL never ends with a /.
-         * 
-         * This is similar to getBasePath(), except that it also includes the
-         * script filename (e.g. index.php) if one exists.
+         * Merge the given array with the last group stack.
          *
-         * @return string The raw URL (i.e. not urldecoded)
+         * @param array $new
+         * @return array 
          * @static 
          */
-        public static function getBaseUrl(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getBaseUrl();
+        public static function mergeWithLastGroup($new){
+            return \Illuminate\Routing\Router::mergeWithLastGroup($new);
         }
         
         /**
-         * Gets the request's scheme.
+         * Get the prefix from the last group on the stack.
          *
          * @return string 
          * @static 
          */
-        public static function getScheme(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getScheme();
+        public static function getLastGroupPrefix(){
+            return \Illuminate\Routing\Router::getLastGroupPrefix();
         }
         
         /**
-         * Returns the port on which the request is made.
-         * 
-         * This method can read the client port from the "X-Forwarded-Port" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Port" header must contain the client port.
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Port",
-         * configure it via "setTrustedHeaderName()" with the "client-port" key.
+         * Dispatch the request to the application.
          *
-         * @return string 
+         * @param \Illuminate\Http\Request $request
+         * @return \Illuminate\Http\Response 
          * @static 
          */
-        public static function getPort(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPort();
+        public static function dispatch($request){
+            return \Illuminate\Routing\Router::dispatch($request);
         }
         
         /**
-         * Returns the user.
+         * Dispatch the request to a route and return the response.
          *
-         * @return string|null 
+         * @param \Illuminate\Http\Request $request
+         * @return mixed 
          * @static 
          */
-        public static function getUser(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUser();
+        public static function dispatchToRoute($request){
+            return \Illuminate\Routing\Router::dispatchToRoute($request);
         }
         
         /**
-         * Returns the password.
+         * Gather the middleware for the given route with resolved class names.
          *
-         * @return string|null 
+         * @param \Illuminate\Routing\Route $route
+         * @return array 
          * @static 
          */
-        public static function getPassword(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPassword();
+        public static function gatherRouteMiddleware($route){
+            return \Illuminate\Routing\Router::gatherRouteMiddleware($route);
         }
         
         /**
-         * Gets the user info.
+         * Create a response instance from the given value.
          *
-         * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server
+         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @param mixed $response
+         * @return \Illuminate\Http\Response 
          * @static 
          */
-        public static function getUserInfo(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUserInfo();
+        public static function prepareResponse($request, $response){
+            return \Illuminate\Routing\Router::prepareResponse($request, $response);
         }
         
         /**
-         * Returns the HTTP host being requested.
-         * 
-         * The port name will be appended to the host if it's non-standard.
+         * Substitute the route bindings onto the route.
          *
-         * @return string 
+         * @param \Illuminate\Routing\Route $route
+         * @return \Illuminate\Routing\Route 
          * @static 
-         */
-        public static function getHttpHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHttpHost();
+         */
+        public static function substituteBindings($route){
+            return \Illuminate\Routing\Router::substituteBindings($route);
         }
         
         /**
-         * Returns the requested URI (path and query string).
+         * Substitute the implicit Eloquent model bindings for the route.
          *
-         * @return string The raw URI (i.e. not URI decoded)
+         * @param \Illuminate\Routing\Route $route
+         * @return void 
          * @static 
          */
-        public static function getRequestUri(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRequestUri();
+        public static function substituteImplicitBindings($route){
+            \Illuminate\Routing\Router::substituteImplicitBindings($route);
         }
         
         /**
-         * Gets the scheme and HTTP host.
-         * 
-         * If the URL was called with basic authentication, the user
-         * and the password are not added to the generated string.
+         * Register a route matched event listener.
          *
-         * @return string The scheme and HTTP host
+         * @param string|callable $callback
+         * @return void 
          * @static 
          */
-        public static function getSchemeAndHttpHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getSchemeAndHttpHost();
+        public static function matched($callback){
+            \Illuminate\Routing\Router::matched($callback);
         }
         
         /**
-         * Generates a normalized URI (URL) for the Request.
+         * Get all of the defined middleware short-hand names.
          *
-         * @return string A normalized URI (URL) for the Request
-         * @see getQueryString()
+         * @return array 
          * @static 
          */
-        public static function getUri(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUri();
+        public static function getMiddleware(){
+            return \Illuminate\Routing\Router::getMiddleware();
         }
         
         /**
-         * Generates a normalized URI for the given path.
+         * Register a short-hand name for a middleware.
          *
-         * @param string $path A path to use instead of the current one
-         * @return string The normalized URI for the path
+         * @param string $name
+         * @param string $class
+         * @return $this 
          * @static 
          */
-        public static function getUriForPath($path){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getUriForPath($path);
+        public static function aliasMiddleware($name, $class){
+            return \Illuminate\Routing\Router::aliasMiddleware($name, $class);
         }
         
         /**
-         * Returns the path as relative reference from the current Request path.
-         * 
-         * Only the URIs path component (no schema, host etc.) is relevant and must be given.
-         * Both paths must be absolute and not contain relative parts.
-         * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.
-         * Furthermore, they can be used to reduce the link size in documents.
-         * 
-         * Example target paths, given a base path of "/a/b/c/d":
-         * - "/a/b/c/d"     -> ""
-         * - "/a/b/c/"      -> "./"
-         * - "/a/b/"        -> "../"
-         * - "/a/b/c/other" -> "other"
-         * - "/a/x/y"       -> "../../x/y"
+         * Check if a middlewareGroup with the given name exists.
          *
-         * @param string $path The target path
-         * @return string The relative target path
+         * @param string $name
+         * @return bool 
          * @static 
          */
-        public static function getRelativeUriForPath($path){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRelativeUriForPath($path);
+        public static function hasMiddlewareGroup($name){
+            return \Illuminate\Routing\Router::hasMiddlewareGroup($name);
         }
         
         /**
-         * Generates the normalized query string for the Request.
-         * 
-         * It builds a normalized query string, where keys/value pairs are alphabetized
-         * and have consistent escaping.
+         * Get all of the defined middleware groups.
          *
-         * @return string|null A normalized query string for the Request
+         * @return array 
          * @static 
          */
-        public static function getQueryString(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getQueryString();
+        public static function getMiddlewareGroups(){
+            return \Illuminate\Routing\Router::getMiddlewareGroups();
         }
         
         /**
-         * Checks whether the request is secure or not.
-         * 
-         * This method can read the client protocol from the "X-Forwarded-Proto" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Proto" header must contain the protocol: "https" or "http".
-         * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Proto"
-         * ("SSL_HTTPS" for instance), configure it via "setTrustedHeaderName()" with
-         * the "client-proto" key.
+         * Register a group of middleware.
          *
-         * @return bool 
+         * @param string $name
+         * @param array $middleware
+         * @return $this 
          * @static 
          */
-        public static function isSecure(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isSecure();
+        public static function middlewareGroup($name, $middleware){
+            return \Illuminate\Routing\Router::middlewareGroup($name, $middleware);
         }
         
         /**
-         * Returns the host name.
-         * 
-         * This method can read the client host name from the "X-Forwarded-Host" header
-         * when trusted proxies were set via "setTrustedProxies()".
-         * 
-         * The "X-Forwarded-Host" header must contain the client host name.
+         * Add a middleware to the beginning of a middleware group.
          * 
-         * If your reverse proxy uses a different header name than "X-Forwarded-Host",
-         * configure it via "setTrustedHeaderName()" with the "client-host" key.
+         * If the middleware is already in the group, it will not be added again.
          *
-         * @return string 
-         * @throws \UnexpectedValueException when the host name is invalid
+         * @param string $group
+         * @param string $middleware
+         * @return $this 
          * @static 
          */
-        public static function getHost(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getHost();
+        public static function prependMiddlewareToGroup($group, $middleware){
+            return \Illuminate\Routing\Router::prependMiddlewareToGroup($group, $middleware);
         }
         
         /**
-         * Sets the request method.
+         * Add a middleware to the end of a middleware group.
+         * 
+         * If the middleware is already in the group, it will not be added again.
          *
-         * @param string $method
+         * @param string $group
+         * @param string $middleware
+         * @return $this 
          * @static 
          */
-        public static function setMethod($method){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setMethod($method);
+        public static function pushMiddlewareToGroup($group, $middleware){
+            return \Illuminate\Routing\Router::pushMiddlewareToGroup($group, $middleware);
         }
         
         /**
-         * Gets the request "intended" method.
-         * 
-         * If the X-HTTP-Method-Override header is set, and if the method is a POST,
-         * then it is used to determine the "real" intended HTTP method.
-         * 
-         * The _method request parameter can also be used to determine the HTTP method,
-         * but only if enableHttpMethodParameterOverride() has been called.
-         * 
-         * The method is always an uppercased string.
+         * Add a new route parameter binder.
          *
-         * @return string The request method
-         * @see getRealMethod()
+         * @param string $key
+         * @param string|callable $binder
+         * @return void 
          * @static 
          */
-        public static function getMethod(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMethod();
+        public static function bind($key, $binder){
+            \Illuminate\Routing\Router::bind($key, $binder);
         }
         
         /**
-         * Gets the "real" request method.
+         * Register a model binder for a wildcard.
          *
-         * @return string The request method
-         * @see getMethod()
+         * @param string $key
+         * @param string $class
+         * @param \Closure|null $callback
+         * @return void 
+         * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
          * @static 
          */
-        public static function getRealMethod(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRealMethod();
+        public static function model($key, $class, $callback = null){
+            \Illuminate\Routing\Router::model($key, $class, $callback);
         }
         
         /**
-         * Gets the mime type associated with the format.
+         * Get the binding callback for a given binding.
          *
-         * @param string $format The format
-         * @return string The associated mime type (null if not found)
+         * @param string $key
+         * @return \Closure|null 
          * @static 
          */
-        public static function getMimeType($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMimeType($format);
+        public static function getBindingCallback($key){
+            return \Illuminate\Routing\Router::getBindingCallback($key);
         }
         
         /**
-         * Gets the mime types associated with the format.
+         * Get the global "where" patterns.
          *
-         * @param string $format The format
-         * @return array The associated mime types
+         * @return array 
          * @static 
          */
-        public static function getMimeTypes($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getMimeTypes($format);
+        public static function getPatterns(){
+            return \Illuminate\Routing\Router::getPatterns();
         }
         
         /**
-         * Gets the format associated with the mime type.
+         * Set a global where pattern on all routes.
          *
-         * @param string $mimeType The associated mime type
-         * @return string|null The format (null if not found)
+         * @param string $key
+         * @param string $pattern
+         * @return void 
          * @static 
          */
-        public static function getFormat($mimeType){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getFormat($mimeType);
+        public static function pattern($key, $pattern){
+            \Illuminate\Routing\Router::pattern($key, $pattern);
         }
         
         /**
-         * Associates a format with mime types.
+         * Set a group of global where patterns on all routes.
          *
-         * @param string $format The format
-         * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)
+         * @param array $patterns
+         * @return void 
          * @static 
          */
-        public static function setFormat($format, $mimeTypes){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setFormat($format, $mimeTypes);
+        public static function patterns($patterns){
+            \Illuminate\Routing\Router::patterns($patterns);
         }
         
         /**
-         * Gets the request format.
-         * 
-         * Here is the process to determine the format:
-         * 
-         *  * format defined by the user (with setRequestFormat())
-         *  * _format request attribute
-         *  * $default
+         * Determine if the router currently has a group stack.
          *
-         * @param string $default The default format
-         * @return string The request format
+         * @return bool 
          * @static 
          */
-        public static function getRequestFormat($default = 'html'){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getRequestFormat($default);
+        public static function hasGroupStack(){
+            return \Illuminate\Routing\Router::hasGroupStack();
         }
         
         /**
-         * Sets the request format.
+         * Get the current group stack for the router.
          *
-         * @param string $format The request format
+         * @return array 
          * @static 
          */
-        public static function setRequestFormat($format){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setRequestFormat($format);
+        public static function getGroupStack(){
+            return \Illuminate\Routing\Router::getGroupStack();
         }
         
         /**
-         * Gets the format associated with the request.
+         * Get a route parameter for the current route.
          *
-         * @return string|null The format (null if no content type is present)
+         * @param string $key
+         * @param string $default
+         * @return mixed 
          * @static 
          */
-        public static function getContentType(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getContentType();
+        public static function input($key, $default = null){
+            return \Illuminate\Routing\Router::input($key, $default);
         }
         
         /**
-         * Sets the default locale.
+         * Get the request currently being dispatched.
          *
-         * @param string $locale
+         * @return \Illuminate\Http\Request 
          * @static 
          */
-        public static function setDefaultLocale($locale){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setDefaultLocale($locale);
+        public static function getCurrentRequest(){
+            return \Illuminate\Routing\Router::getCurrentRequest();
         }
         
         /**
-         * Get the default locale.
+         * Get the currently dispatched route instance.
          *
-         * @return string 
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function getDefaultLocale(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getDefaultLocale();
+        public static function getCurrentRoute(){
+            return \Illuminate\Routing\Router::getCurrentRoute();
         }
         
         /**
-         * Sets the locale.
+         * Get the currently dispatched route instance.
          *
-         * @param string $locale
+         * @return \Illuminate\Routing\Route 
          * @static 
          */
-        public static function setLocale($locale){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::setLocale($locale);
+        public static function current(){
+            return \Illuminate\Routing\Router::current();
         }
         
         /**
-         * Get the locale.
+         * Check if a route with the given name exists.
          *
-         * @return string 
+         * @param string $name
+         * @return bool 
          * @static 
          */
-        public static function getLocale(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getLocale();
+        public static function has($name){
+            return \Illuminate\Routing\Router::has($name);
         }
         
         /**
-         * Checks if the request method is of specified type.
+         * Get the current route name.
          *
-         * @param string $method Uppercase request method (GET, POST etc)
-         * @return bool 
+         * @return string|null 
          * @static 
          */
-        public static function isMethod($method){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethod($method);
+        public static function currentRouteName(){
+            return \Illuminate\Routing\Router::currentRouteName();
         }
         
         /**
-         * Checks whether the method is safe or not.
+         * Alias for the "currentRouteNamed" method.
          *
          * @return bool 
          * @static 
          */
-        public static function isMethodSafe(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isMethodSafe();
+        public static function is(){
+            return \Illuminate\Routing\Router::is();
         }
         
         /**
-         * Returns the request body content.
+         * Determine if the current route matches a given name.
          *
-         * @param bool $asResource If true, a resource will be returned
-         * @return string|resource The request body content or a resource to read the body stream
-         * @throws \LogicException
+         * @param string $name
+         * @return bool 
          * @static 
          */
-        public static function getContent($asResource = false){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getContent($asResource);
+        public static function currentRouteNamed($name){
+            return \Illuminate\Routing\Router::currentRouteNamed($name);
         }
         
         /**
-         * Gets the Etags.
+         * Get the current route action.
          *
-         * @return array The entity tags
+         * @return string|null 
          * @static 
          */
-        public static function getETags(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getETags();
+        public static function currentRouteAction(){
+            return \Illuminate\Routing\Router::currentRouteAction();
         }
         
         /**
-         * 
+         * Alias for the "currentRouteUses" method.
          *
          * @return bool 
          * @static 
          */
-        public static function isNoCache(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isNoCache();
+        public static function uses(){
+            return \Illuminate\Routing\Router::uses();
         }
         
         /**
-         * Returns the preferred language.
+         * Determine if the current route action matches a given action.
          *
-         * @param array $locales An array of ordered available locales
-         * @return string|null The preferred locale
+         * @param string $action
+         * @return bool 
          * @static 
          */
-        public static function getPreferredLanguage($locales = null){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getPreferredLanguage($locales);
+        public static function currentRouteUses($action){
+            return \Illuminate\Routing\Router::currentRouteUses($action);
         }
         
         /**
-         * Gets a list of languages acceptable by the client browser.
+         * Register the typical authentication routes for an application.
          *
-         * @return array Languages ordered in the user browser preferences
+         * @return void 
          * @static 
          */
-        public static function getLanguages(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getLanguages();
+        public static function auth(){
+            \Illuminate\Routing\Router::auth();
         }
         
         /**
-         * Gets a list of charsets acceptable by the client browser.
+         * Set the unmapped global resource parameters to singular.
          *
-         * @return array List of charsets in preferable order
+         * @param bool $singular
+         * @return void 
          * @static 
          */
-        public static function getCharsets(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getCharsets();
+        public static function singularResourceParameters($singular = true){
+            \Illuminate\Routing\Router::singularResourceParameters($singular);
         }
         
         /**
-         * Gets a list of encodings acceptable by the client browser.
+         * Set the global resource parameter mapping.
          *
-         * @return array List of encodings in preferable order
+         * @param array $parameters
+         * @return void 
          * @static 
          */
-        public static function getEncodings(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getEncodings();
+        public static function resourceParameters($parameters = array()){
+            \Illuminate\Routing\Router::resourceParameters($parameters);
         }
         
         /**
-         * Gets a list of content types acceptable by the client browser.
+         * Get or set the verbs used in the resource URIs.
          *
-         * @return array List of content types in preferable order
+         * @param array $verbs
+         * @return array|null 
          * @static 
          */
-        public static function getAcceptableContentTypes(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::getAcceptableContentTypes();
+        public static function resourceVerbs($verbs = array()){
+            return \Illuminate\Routing\Router::resourceVerbs($verbs);
         }
         
         /**
-         * Returns true if the request is a XMLHttpRequest.
-         * 
-         * It works if your JavaScript library sets an X-Requested-With HTTP header.
-         * It is known to work with common JavaScript frameworks:
+         * Get the underlying route collection.
          *
-         * @link http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript
-         * @return bool true if the request is an XMLHttpRequest, false otherwise
+         * @return \Illuminate\Routing\RouteCollection 
          * @static 
          */
-        public static function isXmlHttpRequest(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isXmlHttpRequest();
+        public static function getRoutes(){
+            return \Illuminate\Routing\Router::getRoutes();
         }
         
         /**
-         * Indicates whether this request originated from a trusted proxy.
-         * 
-         * This can be useful to determine whether or not to trust the
-         * contents of a proxy-specific header.
+         * Set the route collection instance.
          *
-         * @return bool true if the request came from a trusted proxy, false otherwise
+         * @param \Illuminate\Routing\RouteCollection $routes
+         * @return void 
          * @static 
          */
-        public static function isFromTrustedProxy(){
-            //Method inherited from \Symfony\Component\HttpFoundation\Request            
-            return \Illuminate\Http\Request::isFromTrustedProxy();
+        public static function setRoutes($routes){
+            \Illuminate\Routing\Router::setRoutes($routes);
         }
         
         /**
@@ -10338,7 +11751,7 @@ namespace {
          * @static 
          */
         public static function macro($name, $macro){
-            \Illuminate\Http\Request::macro($name, $macro);
+            \Illuminate\Routing\Router::macro($name, $macro);
         }
         
         /**
@@ -10349,4637 +11762,4649 @@ namespace {
          * @static 
          */
         public static function hasMacro($name){
-            return \Illuminate\Http\Request::hasMacro($name);
+            return \Illuminate\Routing\Router::hasMacro($name);
+        }
+        
+        /**
+         * Dynamically handle calls to the class.
+         *
+         * @param string $method
+         * @param array $parameters
+         * @return mixed 
+         * @throws \BadMethodCallException
+         * @static 
+         */
+        public static function macroCall($method, $parameters){
+            return \Illuminate\Routing\Router::macroCall($method, $parameters);
         }
         
     }
 
 
-    class Response extends \Illuminate\Support\Facades\Response{
+    class Schema extends \Illuminate\Support\Facades\Schema{
         
         /**
-         * Return a new response from the application.
+         * Determine if the given table exists.
          *
-         * @param string $content
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\Response 
+         * @param string $table
+         * @return bool 
          * @static 
          */
-        public static function make($content = '', $status = 200, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::make($content, $status, $headers);
+        public static function hasTable($table){
+            return \Illuminate\Database\Schema\MySqlBuilder::hasTable($table);
         }
         
         /**
-         * Return a new view response from the application.
+         * Get the column listing for a given table.
          *
-         * @param string $view
-         * @param array $data
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\Response 
+         * @param string $table
+         * @return array 
          * @static 
          */
-        public static function view($view, $data = array(), $status = 200, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::view($view, $data, $status, $headers);
+        public static function getColumnListing($table){
+            return \Illuminate\Database\Schema\MySqlBuilder::getColumnListing($table);
         }
         
         /**
-         * Return a new JSON response from the application.
+         * Set the default string length for migrations.
          *
-         * @param mixed $data
-         * @param int $status
-         * @param array $headers
-         * @param int $options
-         * @return \Illuminate\Http\JsonResponse 
+         * @param int $length
+         * @return void 
          * @static 
          */
-        public static function json($data = array(), $status = 200, $headers = array(), $options = 0){
-            return \Illuminate\Routing\ResponseFactory::json($data, $status, $headers, $options);
+        public static function defaultStringLength($length){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::defaultStringLength($length);
         }
         
         /**
-         * Return a new JSONP response from the application.
+         * Determine if the given table has a given column.
          *
-         * @param string $callback
-         * @param mixed $data
-         * @param int $status
-         * @param array $headers
-         * @param int $options
-         * @return \Illuminate\Http\JsonResponse 
+         * @param string $table
+         * @param string $column
+         * @return bool 
          * @static 
          */
-        public static function jsonp($callback, $data = array(), $status = 200, $headers = array(), $options = 0){
-            return \Illuminate\Routing\ResponseFactory::jsonp($callback, $data, $status, $headers, $options);
+        public static function hasColumn($table, $column){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::hasColumn($table, $column);
         }
         
         /**
-         * Return a new streamed response from the application.
+         * Determine if the given table has given columns.
+         *
+         * @param string $table
+         * @param array $columns
+         * @return bool 
+         * @static 
+         */
+        public static function hasColumns($table, $columns){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::hasColumns($table, $columns);
+        }
+        
+        /**
+         * Get the data type for the given column name.
+         *
+         * @param string $table
+         * @param string $column
+         * @return string 
+         * @static 
+         */
+        public static function getColumnType($table, $column){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::getColumnType($table, $column);
+        }
+        
+        /**
+         * Modify a table on the schema.
          *
+         * @param string $table
          * @param \Closure $callback
-         * @param int $status
-         * @param array $headers
-         * @return \Symfony\Component\HttpFoundation\StreamedResponse 
+         * @return void 
          * @static 
          */
-        public static function stream($callback, $status = 200, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::stream($callback, $status, $headers);
+        public static function table($table, $callback){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::table($table, $callback);
         }
         
         /**
-         * Create a new file download response.
+         * Create a new table on the schema.
          *
-         * @param \SplFileInfo|string $file
-         * @param string $name
-         * @param array $headers
-         * @param string|null $disposition
-         * @return \Symfony\Component\HttpFoundation\BinaryFileResponse 
+         * @param string $table
+         * @param \Closure $callback
+         * @return void 
          * @static 
          */
-        public static function download($file, $name = null, $headers = array(), $disposition = 'attachment'){
-            return \Illuminate\Routing\ResponseFactory::download($file, $name, $headers, $disposition);
+        public static function create($table, $callback){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::create($table, $callback);
         }
         
         /**
-         * Return the raw contents of a binary file.
+         * Drop a table from the schema.
          *
-         * @param \SplFileInfo|string $file
-         * @param array $headers
-         * @return \Symfony\Component\HttpFoundation\BinaryFileResponse 
+         * @param string $table
+         * @return void 
          * @static 
          */
-        public static function file($file, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::file($file, $headers);
+        public static function drop($table){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::drop($table);
         }
         
         /**
-         * Create a new redirect response to the given path.
+         * Drop a table from the schema if it exists.
          *
-         * @param string $path
-         * @param int $status
-         * @param array $headers
-         * @param bool|null $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string $table
+         * @return void 
          * @static 
          */
-        public static function redirectTo($path, $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\ResponseFactory::redirectTo($path, $status, $headers, $secure);
+        public static function dropIfExists($table){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::dropIfExists($table);
         }
         
         /**
-         * Create a new redirect response to a named route.
+         * Rename a table on the schema.
          *
-         * @param string $route
-         * @param array $parameters
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @param string $from
+         * @param string $to
+         * @return void 
          * @static 
          */
-        public static function redirectToRoute($route, $parameters = array(), $status = 302, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::redirectToRoute($route, $parameters, $status, $headers);
+        public static function rename($from, $to){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::rename($from, $to);
         }
         
         /**
-         * Create a new redirect response to a controller action.
+         * Enable foreign key constraints.
          *
-         * @param string $action
-         * @param array $parameters
-         * @param int $status
-         * @param array $headers
-         * @return \Illuminate\Http\RedirectResponse 
+         * @return bool 
          * @static 
          */
-        public static function redirectToAction($action, $parameters = array(), $status = 302, $headers = array()){
-            return \Illuminate\Routing\ResponseFactory::redirectToAction($action, $parameters, $status, $headers);
+        public static function enableForeignKeyConstraints(){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::enableForeignKeyConstraints();
         }
         
         /**
-         * Create a new redirect response, while putting the current URL in the session.
+         * Disable foreign key constraints.
          *
-         * @param string $path
-         * @param int $status
-         * @param array $headers
-         * @param bool|null $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @return bool 
          * @static 
          */
-        public static function redirectGuest($path, $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\ResponseFactory::redirectGuest($path, $status, $headers, $secure);
+        public static function disableForeignKeyConstraints(){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::disableForeignKeyConstraints();
         }
         
         /**
-         * Create a new redirect response to the previously intended location.
+         * Get the database connection instance.
          *
-         * @param string $default
-         * @param int $status
-         * @param array $headers
-         * @param bool|null $secure
-         * @return \Illuminate\Http\RedirectResponse 
+         * @return \Illuminate\Database\Connection 
          * @static 
          */
-        public static function redirectToIntended($default = '/', $status = 302, $headers = array(), $secure = null){
-            return \Illuminate\Routing\ResponseFactory::redirectToIntended($default, $status, $headers, $secure);
+        public static function getConnection(){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::getConnection();
         }
         
         /**
-         * Register a custom macro.
+         * Set the database connection instance.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @param \Illuminate\Database\Connection $connection
+         * @return $this 
          * @static 
          */
-        public static function macro($name, $macro){
-            \Illuminate\Routing\ResponseFactory::macro($name, $macro);
+        public static function setConnection($connection){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            return \Illuminate\Database\Schema\MySqlBuilder::setConnection($connection);
         }
         
         /**
-         * Checks if macro is registered.
+         * Set the Schema Blueprint resolver callback.
          *
-         * @param string $name
-         * @return bool 
+         * @param \Closure $resolver
+         * @return void 
          * @static 
          */
-        public static function hasMacro($name){
-            return \Illuminate\Routing\ResponseFactory::hasMacro($name);
+        public static function blueprintResolver($resolver){
+            //Method inherited from \Illuminate\Database\Schema\Builder            
+            \Illuminate\Database\Schema\MySqlBuilder::blueprintResolver($resolver);
         }
         
     }
 
 
-    class Route extends \Illuminate\Support\Facades\Route{
-        
-        /**
-         * Register a new GET route with the router.
-         *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
-         * @static 
-         */
-        public static function get($uri, $action = null){
-            return \Illuminate\Routing\Router::get($uri, $action);
-        }
+    class Session extends \Illuminate\Support\Facades\Session{
         
         /**
-         * Register a new POST route with the router.
+         * Get the session configuration.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @return array 
          * @static 
          */
-        public static function post($uri, $action = null){
-            return \Illuminate\Routing\Router::post($uri, $action);
+        public static function getSessionConfig(){
+            return \Illuminate\Session\SessionManager::getSessionConfig();
         }
         
         /**
-         * Register a new PUT route with the router.
+         * Get the default session driver name.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @return string 
          * @static 
          */
-        public static function put($uri, $action = null){
-            return \Illuminate\Routing\Router::put($uri, $action);
+        public static function getDefaultDriver(){
+            return \Illuminate\Session\SessionManager::getDefaultDriver();
         }
         
         /**
-         * Register a new PATCH route with the router.
+         * Set the default session driver name.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param string $name
+         * @return void 
          * @static 
          */
-        public static function patch($uri, $action = null){
-            return \Illuminate\Routing\Router::patch($uri, $action);
+        public static function setDefaultDriver($name){
+            \Illuminate\Session\SessionManager::setDefaultDriver($name);
         }
         
         /**
-         * Register a new DELETE route with the router.
+         * Get a driver instance.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param string $driver
+         * @return mixed 
          * @static 
          */
-        public static function delete($uri, $action = null){
-            return \Illuminate\Routing\Router::delete($uri, $action);
+        public static function driver($driver = null){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Session\SessionManager::driver($driver);
         }
         
         /**
-         * Register a new OPTIONS route with the router.
+         * Register a custom driver creator Closure.
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function options($uri, $action = null){
-            return \Illuminate\Routing\Router::options($uri, $action);
+        public static function extend($driver, $callback){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Session\SessionManager::extend($driver, $callback);
         }
         
         /**
-         * Register a new route responding to all verbs.
+         * Get all of the created "drivers".
          *
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @return array 
          * @static 
          */
-        public static function any($uri, $action = null){
-            return \Illuminate\Routing\Router::any($uri, $action);
+        public static function getDrivers(){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Session\SessionManager::getDrivers();
         }
         
         /**
-         * Register a new route with the given verbs.
+         * Start the session, reading the data from a handler.
          *
-         * @param array|string $methods
-         * @param string $uri
-         * @param \Closure|array|string|null $action
-         * @return \Illuminate\Routing\Route 
+         * @return bool 
          * @static 
          */
-        public static function match($methods, $uri, $action = null){
-            return \Illuminate\Routing\Router::match($methods, $uri, $action);
+        public static function start(){
+            return \Illuminate\Session\Store::start();
         }
         
         /**
-         * Set the unmapped global resource parameters to singular.
+         * Save the session data to storage.
          *
-         * @param bool $singular
-         * @return void 
+         * @return bool 
          * @static 
          */
-        public static function singularResourceParameters($singular = true){
-            \Illuminate\Routing\Router::singularResourceParameters($singular);
+        public static function save(){
+            return \Illuminate\Session\Store::save();
         }
         
         /**
-         * Set the global resource parameter mapping.
+         * Age the flash data for the session.
          *
-         * @param array $parameters
          * @return void 
          * @static 
          */
-        public static function resourceParameters($parameters = array()){
-            \Illuminate\Routing\Router::resourceParameters($parameters);
+        public static function ageFlashData(){
+            \Illuminate\Session\Store::ageFlashData();
         }
         
         /**
-         * Register an array of resource controllers.
+         * Get all of the session data.
          *
-         * @param array $resources
-         * @return void 
+         * @return array 
          * @static 
          */
-        public static function resources($resources){
-            \Illuminate\Routing\Router::resources($resources);
+        public static function all(){
+            return \Illuminate\Session\Store::all();
         }
         
         /**
-         * Route a resource to a controller.
+         * Checks if a key exists.
          *
-         * @param string $name
-         * @param string $controller
-         * @param array $options
-         * @return void 
+         * @param string|array $key
+         * @return bool 
          * @static 
          */
-        public static function resource($name, $controller, $options = array()){
-            \Illuminate\Routing\Router::resource($name, $controller, $options);
+        public static function exists($key){
+            return \Illuminate\Session\Store::exists($key);
         }
         
         /**
-         * Register the typical authentication routes for an application.
+         * Checks if a key is present and not null.
          *
-         * @return void 
+         * @param string|array $key
+         * @return bool 
          * @static 
          */
-        public static function auth(){
-            \Illuminate\Routing\Router::auth();
+        public static function has($key){
+            return \Illuminate\Session\Store::has($key);
         }
         
         /**
-         * Create a route group with shared attributes.
+         * Get an item from the session.
          *
-         * @param array $attributes
-         * @param \Closure $callback
-         * @return void 
+         * @param string $key
+         * @param mixed $default
+         * @return mixed 
          * @static 
          */
-        public static function group($attributes, $callback){
-            \Illuminate\Routing\Router::group($attributes, $callback);
+        public static function get($key, $default = null){
+            return \Illuminate\Session\Store::get($key, $default);
         }
         
         /**
-         * Merge the given array with the last group stack.
+         * Get the value of a given key and then forget it.
          *
-         * @param array $new
-         * @return array 
+         * @param string $key
+         * @param string $default
+         * @return mixed 
          * @static 
          */
-        public static function mergeWithLastGroup($new){
-            return \Illuminate\Routing\Router::mergeWithLastGroup($new);
+        public static function pull($key, $default = null){
+            return \Illuminate\Session\Store::pull($key, $default);
         }
         
         /**
-         * Merge the given group attributes.
+         * Determine if the session contains old input.
          *
-         * @param array $new
-         * @param array $old
-         * @return array 
+         * @param string $key
+         * @return bool 
          * @static 
          */
-        public static function mergeGroup($new, $old){
-            return \Illuminate\Routing\Router::mergeGroup($new, $old);
+        public static function hasOldInput($key = null){
+            return \Illuminate\Session\Store::hasOldInput($key);
         }
         
         /**
-         * Get the prefix from the last group on the stack.
+         * Get the requested item from the flashed input array.
          *
-         * @return string 
+         * @param string $key
+         * @param mixed $default
+         * @return mixed 
          * @static 
          */
-        public static function getLastGroupPrefix(){
-            return \Illuminate\Routing\Router::getLastGroupPrefix();
+        public static function getOldInput($key = null, $default = null){
+            return \Illuminate\Session\Store::getOldInput($key, $default);
         }
         
         /**
-         * Dispatch the request to the application.
+         * Replace the given session attributes entirely.
          *
-         * @param \Illuminate\Http\Request $request
-         * @return \Illuminate\Http\Response 
+         * @param array $attributes
+         * @return void 
          * @static 
          */
-        public static function dispatch($request){
-            return \Illuminate\Routing\Router::dispatch($request);
+        public static function replace($attributes){
+            \Illuminate\Session\Store::replace($attributes);
         }
         
         /**
-         * Dispatch the request to a route and return the response.
+         * Put a key / value pair or array of key / value pairs in the session.
          *
-         * @param \Illuminate\Http\Request $request
-         * @return mixed 
+         * @param string|array $key
+         * @param mixed $value
+         * @return void 
          * @static 
          */
-        public static function dispatchToRoute($request){
-            return \Illuminate\Routing\Router::dispatchToRoute($request);
+        public static function put($key, $value = null){
+            \Illuminate\Session\Store::put($key, $value);
         }
         
         /**
-         * Gather the middleware for the given route.
+         * Get an item from the session, or store the default value.
          *
-         * @param \Illuminate\Routing\Route $route
-         * @return array 
+         * @param string $key
+         * @param \Closure $callback
+         * @return mixed 
          * @static 
          */
-        public static function gatherRouteMiddleware($route){
-            return \Illuminate\Routing\Router::gatherRouteMiddleware($route);
+        public static function remember($key, $callback){
+            return \Illuminate\Session\Store::remember($key, $callback);
         }
         
         /**
-         * Resolve the middleware name to a class name(s) preserving passed parameters.
+         * Push a value onto a session array.
          *
-         * @param string $name
-         * @return string|array 
+         * @param string $key
+         * @param mixed $value
+         * @return void 
          * @static 
          */
-        public static function resolveMiddlewareClassName($name){
-            return \Illuminate\Routing\Router::resolveMiddlewareClassName($name);
+        public static function push($key, $value){
+            \Illuminate\Session\Store::push($key, $value);
         }
         
         /**
-         * Substitute the route bindings onto the route.
+         * Increment the value of an item in the session.
          *
-         * @param \Illuminate\Routing\Route $route
-         * @return \Illuminate\Routing\Route 
+         * @param string $key
+         * @param int $amount
+         * @return mixed 
          * @static 
          */
-        public static function substituteBindings($route){
-            return \Illuminate\Routing\Router::substituteBindings($route);
+        public static function increment($key, $amount = 1){
+            return \Illuminate\Session\Store::increment($key, $amount);
         }
         
         /**
-         * Substitute the implicit Eloquent model bindings for the route.
+         * Decrement the value of an item in the session.
          *
-         * @param \Illuminate\Routing\Route $route
-         * @return void 
+         * @param string $key
+         * @param int $amount
+         * @return int 
          * @static 
          */
-        public static function substituteImplicitBindings($route){
-            \Illuminate\Routing\Router::substituteImplicitBindings($route);
+        public static function decrement($key, $amount = 1){
+            return \Illuminate\Session\Store::decrement($key, $amount);
         }
         
         /**
-         * Register a route matched event listener.
+         * Flash a key / value pair to the session.
          *
-         * @param string|callable $callback
+         * @param string $key
+         * @param mixed $value
          * @return void 
          * @static 
          */
-        public static function matched($callback){
-            \Illuminate\Routing\Router::matched($callback);
+        public static function flash($key, $value){
+            \Illuminate\Session\Store::flash($key, $value);
         }
         
         /**
-         * Get all of the defined middleware short-hand names.
+         * Flash a key / value pair to the session for immediate use.
          *
-         * @return array 
+         * @param string $key
+         * @param mixed $value
+         * @return void 
          * @static 
          */
-        public static function getMiddleware(){
-            return \Illuminate\Routing\Router::getMiddleware();
+        public static function now($key, $value){
+            \Illuminate\Session\Store::now($key, $value);
         }
         
         /**
-         * Register a short-hand name for a middleware.
+         * Reflash all of the session flash data.
          *
-         * @param string $name
-         * @param string $class
-         * @return $this 
+         * @return void 
          * @static 
          */
-        public static function middleware($name, $class){
-            return \Illuminate\Routing\Router::middleware($name, $class);
+        public static function reflash(){
+            \Illuminate\Session\Store::reflash();
         }
         
         /**
-         * Register a group of middleware.
+         * Reflash a subset of the current flash data.
          *
-         * @param string $name
-         * @param array $middleware
-         * @return $this 
+         * @param array|mixed $keys
+         * @return void 
          * @static 
          */
-        public static function middlewareGroup($name, $middleware){
-            return \Illuminate\Routing\Router::middlewareGroup($name, $middleware);
+        public static function keep($keys = null){
+            \Illuminate\Session\Store::keep($keys);
         }
         
         /**
-         * Add a middleware to the beginning of a middleware group.
-         * 
-         * If the middleware is already in the group, it will not be added again.
+         * Flash an input array to the session.
          *
-         * @param string $group
-         * @param string $middleware
-         * @return $this 
+         * @param array $value
+         * @return void 
          * @static 
          */
-        public static function prependMiddlewareToGroup($group, $middleware){
-            return \Illuminate\Routing\Router::prependMiddlewareToGroup($group, $middleware);
+        public static function flashInput($value){
+            \Illuminate\Session\Store::flashInput($value);
         }
         
         /**
-         * Add a middleware to the end of a middleware group.
-         * 
-         * If the middleware is already in the group, it will not be added again.
+         * Remove an item from the session, returning its value.
          *
-         * @param string $group
-         * @param string $middleware
-         * @return $this 
+         * @param string $key
+         * @return mixed 
          * @static 
          */
-        public static function pushMiddlewareToGroup($group, $middleware){
-            return \Illuminate\Routing\Router::pushMiddlewareToGroup($group, $middleware);
+        public static function remove($key){
+            return \Illuminate\Session\Store::remove($key);
         }
         
         /**
-         * Register a model binder for a wildcard.
+         * Remove one or many items from the session.
          *
-         * @param string $key
-         * @param string $class
-         * @param \Closure|null $callback
+         * @param string|array $keys
          * @return void 
-         * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
          * @static 
          */
-        public static function model($key, $class, $callback = null){
-            \Illuminate\Routing\Router::model($key, $class, $callback);
+        public static function forget($keys){
+            \Illuminate\Session\Store::forget($keys);
         }
         
         /**
-         * Add a new route parameter binder.
+         * Remove all of the items from the session.
          *
-         * @param string $key
-         * @param string|callable $binder
          * @return void 
          * @static 
          */
-        public static function bind($key, $binder){
-            \Illuminate\Routing\Router::bind($key, $binder);
+        public static function flush(){
+            \Illuminate\Session\Store::flush();
         }
         
         /**
-         * Create a class based binding using the IoC container.
+         * Flush the session data and regenerate the ID.
          *
-         * @param string $binding
-         * @return \Closure 
+         * @return bool 
          * @static 
          */
-        public static function createClassBinding($binding){
-            return \Illuminate\Routing\Router::createClassBinding($binding);
+        public static function invalidate(){
+            return \Illuminate\Session\Store::invalidate();
         }
         
         /**
-         * Set a global where pattern on all routes.
+         * Generate a new session identifier.
          *
-         * @param string $key
-         * @param string $pattern
-         * @return void 
+         * @param bool $destroy
+         * @return bool 
          * @static 
          */
-        public static function pattern($key, $pattern){
-            \Illuminate\Routing\Router::pattern($key, $pattern);
+        public static function regenerate($destroy = false){
+            return \Illuminate\Session\Store::regenerate($destroy);
         }
         
         /**
-         * Set a group of global where patterns on all routes.
+         * Generate a new session ID for the session.
          *
-         * @param array $patterns
-         * @return void 
+         * @param bool $destroy
+         * @return bool 
          * @static 
          */
-        public static function patterns($patterns){
-            \Illuminate\Routing\Router::patterns($patterns);
+        public static function migrate($destroy = false){
+            return \Illuminate\Session\Store::migrate($destroy);
         }
         
         /**
-         * Create a response instance from the given value.
+         * Determine if the session has been started.
          *
-         * @param \Symfony\Component\HttpFoundation\Request $request
-         * @param mixed $response
-         * @return \Illuminate\Http\Response 
+         * @return bool 
          * @static 
          */
-        public static function prepareResponse($request, $response){
-            return \Illuminate\Routing\Router::prepareResponse($request, $response);
+        public static function isStarted(){
+            return \Illuminate\Session\Store::isStarted();
         }
         
         /**
-         * Determine if the router currently has a group stack.
+         * Get the name of the session.
          *
-         * @return bool 
+         * @return string 
          * @static 
          */
-        public static function hasGroupStack(){
-            return \Illuminate\Routing\Router::hasGroupStack();
+        public static function getName(){
+            return \Illuminate\Session\Store::getName();
         }
         
         /**
-         * Get the current group stack for the router.
+         * Set the name of the session.
          *
-         * @return array 
+         * @param string $name
+         * @return void 
          * @static 
          */
-        public static function getGroupStack(){
-            return \Illuminate\Routing\Router::getGroupStack();
+        public static function setName($name){
+            \Illuminate\Session\Store::setName($name);
         }
         
         /**
-         * Get a route parameter for the current route.
+         * Get the current session ID.
          *
-         * @param string $key
-         * @param string $default
-         * @return mixed 
+         * @return string 
          * @static 
          */
-        public static function input($key, $default = null){
-            return \Illuminate\Routing\Router::input($key, $default);
+        public static function getId(){
+            return \Illuminate\Session\Store::getId();
         }
         
         /**
-         * Get the currently dispatched route instance.
+         * Set the session ID.
          *
-         * @return \Illuminate\Routing\Route 
+         * @param string $id
+         * @return void 
          * @static 
          */
-        public static function getCurrentRoute(){
-            return \Illuminate\Routing\Router::getCurrentRoute();
+        public static function setId($id){
+            \Illuminate\Session\Store::setId($id);
         }
         
         /**
-         * Get the currently dispatched route instance.
+         * Determine if this is a valid session ID.
          *
-         * @return \Illuminate\Routing\Route 
+         * @param string $id
+         * @return bool 
          * @static 
          */
-        public static function current(){
-            return \Illuminate\Routing\Router::current();
+        public static function isValidId($id){
+            return \Illuminate\Session\Store::isValidId($id);
         }
         
         /**
-         * Check if a route with the given name exists.
+         * Set the existence of the session on the handler if applicable.
          *
-         * @param string $name
-         * @return bool 
+         * @param bool $value
+         * @return void 
          * @static 
          */
-        public static function has($name){
-            return \Illuminate\Routing\Router::has($name);
+        public static function setExists($value){
+            \Illuminate\Session\Store::setExists($value);
         }
         
         /**
-         * Get the current route name.
+         * Get the CSRF token value.
          *
-         * @return string|null 
+         * @return string 
          * @static 
          */
-        public static function currentRouteName(){
-            return \Illuminate\Routing\Router::currentRouteName();
+        public static function token(){
+            return \Illuminate\Session\Store::token();
         }
         
         /**
-         * Alias for the "currentRouteNamed" method.
+         * Regenerate the CSRF token value.
          *
-         * @return bool 
+         * @return void 
          * @static 
          */
-        public static function is(){
-            return \Illuminate\Routing\Router::is();
+        public static function regenerateToken(){
+            \Illuminate\Session\Store::regenerateToken();
         }
         
         /**
-         * Determine if the current route matches a given name.
+         * Get the previous URL from the session.
          *
-         * @param string $name
-         * @return bool 
+         * @return string|null 
          * @static 
          */
-        public static function currentRouteNamed($name){
-            return \Illuminate\Routing\Router::currentRouteNamed($name);
+        public static function previousUrl(){
+            return \Illuminate\Session\Store::previousUrl();
         }
         
         /**
-         * Get the current route action.
+         * Set the "previous" URL in the session.
          *
-         * @return string|null 
+         * @param string $url
+         * @return void 
          * @static 
          */
-        public static function currentRouteAction(){
-            return \Illuminate\Routing\Router::currentRouteAction();
+        public static function setPreviousUrl($url){
+            \Illuminate\Session\Store::setPreviousUrl($url);
         }
         
         /**
-         * Alias for the "currentRouteUses" method.
+         * Get the underlying session handler implementation.
          *
-         * @return bool 
+         * @return \SessionHandlerInterface 
          * @static 
          */
-        public static function uses(){
-            return \Illuminate\Routing\Router::uses();
+        public static function getHandler(){
+            return \Illuminate\Session\Store::getHandler();
         }
         
         /**
-         * Determine if the current route action matches a given action.
+         * Determine if the session handler needs a request.
          *
-         * @param string $action
          * @return bool 
          * @static 
          */
-        public static function currentRouteUses($action){
-            return \Illuminate\Routing\Router::currentRouteUses($action);
+        public static function handlerNeedsRequest(){
+            return \Illuminate\Session\Store::handlerNeedsRequest();
         }
         
         /**
-         * Get the request currently being dispatched.
+         * Set the request on the handler instance.
          *
-         * @return \Illuminate\Http\Request 
+         * @param \Illuminate\Http\Request $request
+         * @return void 
          * @static 
          */
-        public static function getCurrentRequest(){
-            return \Illuminate\Routing\Router::getCurrentRequest();
+        public static function setRequestOnHandler($request){
+            \Illuminate\Session\Store::setRequestOnHandler($request);
         }
         
+    }
+
+
+    class Storage extends \Illuminate\Support\Facades\Storage{
+        
         /**
-         * Get the underlying route collection.
+         * Get a filesystem instance.
          *
-         * @return \Illuminate\Routing\RouteCollection 
+         * @param string $name
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
          */
-        public static function getRoutes(){
-            return \Illuminate\Routing\Router::getRoutes();
+        public static function drive($name = null){
+            return \Illuminate\Filesystem\FilesystemManager::drive($name);
         }
         
         /**
-         * Set the route collection instance.
+         * Get a filesystem instance.
          *
-         * @param \Illuminate\Routing\RouteCollection $routes
-         * @return void 
+         * @param string $name
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
          */
-        public static function setRoutes($routes){
-            \Illuminate\Routing\Router::setRoutes($routes);
+        public static function disk($name = null){
+            return \Illuminate\Filesystem\FilesystemManager::disk($name);
         }
         
         /**
-         * Get the global "where" patterns.
+         * Get a default cloud filesystem instance.
          *
-         * @return array 
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
          */
-        public static function getPatterns(){
-            return \Illuminate\Routing\Router::getPatterns();
+        public static function cloud(){
+            return \Illuminate\Filesystem\FilesystemManager::cloud();
         }
         
         /**
-         * Register a custom macro.
+         * Create an instance of the local driver.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @param array $config
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
          */
-        public static function macro($name, $macro){
-            \Illuminate\Routing\Router::macro($name, $macro);
+        public static function createLocalDriver($config){
+            return \Illuminate\Filesystem\FilesystemManager::createLocalDriver($config);
         }
         
         /**
-         * Checks if macro is registered.
+         * Create an instance of the ftp driver.
          *
-         * @param string $name
-         * @return bool 
+         * @param array $config
+         * @return \Illuminate\Filesystem\FilesystemAdapter 
          * @static 
          */
-        public static function hasMacro($name){
-            return \Illuminate\Routing\Router::hasMacro($name);
+        public static function createFtpDriver($config){
+            return \Illuminate\Filesystem\FilesystemManager::createFtpDriver($config);
         }
         
-    }
-
-
-    class Schema extends \Illuminate\Support\Facades\Schema{
-        
         /**
-         * Determine if the given table exists.
+         * Create an instance of the Amazon S3 driver.
          *
-         * @param string $table
-         * @return bool 
+         * @param array $config
+         * @return \Illuminate\Contracts\Filesystem\Cloud 
          * @static 
          */
-        public static function hasTable($table){
-            return \Illuminate\Database\Schema\MySqlBuilder::hasTable($table);
+        public static function createS3Driver($config){
+            return \Illuminate\Filesystem\FilesystemManager::createS3Driver($config);
         }
         
         /**
-         * Get the column listing for a given table.
+         * Create an instance of the Rackspace driver.
          *
-         * @param string $table
-         * @return array 
+         * @param array $config
+         * @return \Illuminate\Contracts\Filesystem\Cloud 
          * @static 
          */
-        public static function getColumnListing($table){
-            return \Illuminate\Database\Schema\MySqlBuilder::getColumnListing($table);
+        public static function createRackspaceDriver($config){
+            return \Illuminate\Filesystem\FilesystemManager::createRackspaceDriver($config);
         }
         
         /**
-         * Determine if the given table has a given column.
+         * Set the given disk instance.
          *
-         * @param string $table
-         * @param string $column
-         * @return bool 
+         * @param string $name
+         * @param mixed $disk
+         * @return void 
          * @static 
          */
-        public static function hasColumn($table, $column){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::hasColumn($table, $column);
+        public static function set($name, $disk){
+            \Illuminate\Filesystem\FilesystemManager::set($name, $disk);
         }
         
         /**
-         * Determine if the given table has given columns.
+         * Get the default driver name.
          *
-         * @param string $table
-         * @param array $columns
-         * @return bool 
+         * @return string 
          * @static 
          */
-        public static function hasColumns($table, $columns){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::hasColumns($table, $columns);
+        public static function getDefaultDriver(){
+            return \Illuminate\Filesystem\FilesystemManager::getDefaultDriver();
         }
         
         /**
-         * Get the data type for the given column name.
+         * Get the default cloud driver name.
          *
-         * @param string $table
-         * @param string $column
          * @return string 
          * @static 
          */
-        public static function getColumnType($table, $column){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::getColumnType($table, $column);
+        public static function getDefaultCloudDriver(){
+            return \Illuminate\Filesystem\FilesystemManager::getDefaultCloudDriver();
         }
         
         /**
-         * Modify a table on the schema.
+         * Register a custom driver creator Closure.
          *
-         * @param string $table
+         * @param string $driver
          * @param \Closure $callback
-         * @return \Illuminate\Database\Schema\Blueprint 
+         * @return $this 
          * @static 
          */
-        public static function table($table, $callback){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::table($table, $callback);
+        public static function extend($driver, $callback){
+            return \Illuminate\Filesystem\FilesystemManager::extend($driver, $callback);
         }
         
         /**
-         * Create a new table on the schema.
+         * Assert that the given file exists.
          *
-         * @param string $table
-         * @param \Closure $callback
-         * @return \Illuminate\Database\Schema\Blueprint 
+         * @param string $path
+         * @return void 
          * @static 
          */
-        public static function create($table, $callback){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::create($table, $callback);
+        public static function assertExists($path){
+            \Illuminate\Filesystem\FilesystemAdapter::assertExists($path);
         }
         
         /**
-         * Drop a table from the schema.
+         * Assert that the given file does not exist.
          *
-         * @param string $table
-         * @return \Illuminate\Database\Schema\Blueprint 
+         * @param string $path
+         * @return void 
          * @static 
          */
-        public static function drop($table){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::drop($table);
+        public static function assertMissing($path){
+            \Illuminate\Filesystem\FilesystemAdapter::assertMissing($path);
         }
         
         /**
-         * Drop a table from the schema if it exists.
+         * Determine if a file exists.
          *
-         * @param string $table
-         * @return \Illuminate\Database\Schema\Blueprint 
+         * @param string $path
+         * @return bool 
          * @static 
          */
-        public static function dropIfExists($table){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::dropIfExists($table);
+        public static function exists($path){
+            return \Illuminate\Filesystem\FilesystemAdapter::exists($path);
         }
         
         /**
-         * Rename a table on the schema.
+         * Get the contents of a file.
          *
-         * @param string $from
-         * @param string $to
-         * @return \Illuminate\Database\Schema\Blueprint 
+         * @param string $path
+         * @return string 
+         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
          * @static 
          */
-        public static function rename($from, $to){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::rename($from, $to);
+        public static function get($path){
+            return \Illuminate\Filesystem\FilesystemAdapter::get($path);
         }
         
         /**
-         * Enable foreign key constraints.
+         * Write the contents of a file.
          *
+         * @param string $path
+         * @param string|resource $contents
+         * @param array $options
          * @return bool 
          * @static 
          */
-        public static function enableForeignKeyConstraints(){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::enableForeignKeyConstraints();
+        public static function put($path, $contents, $options = array()){
+            return \Illuminate\Filesystem\FilesystemAdapter::put($path, $contents, $options);
         }
         
         /**
-         * Disable foreign key constraints.
+         * Store the uploaded file on the disk.
          *
-         * @return bool 
+         * @param string $path
+         * @param \Illuminate\Http\File|\Illuminate\Http\UploadedFile $file
+         * @param array $options
+         * @return string|false 
          * @static 
          */
-        public static function disableForeignKeyConstraints(){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::disableForeignKeyConstraints();
+        public static function putFile($path, $file, $options = array()){
+            return \Illuminate\Filesystem\FilesystemAdapter::putFile($path, $file, $options);
         }
         
         /**
-         * Get the database connection instance.
+         * Store the uploaded file on the disk with a given name.
          *
-         * @return \Illuminate\Database\Connection 
+         * @param string $path
+         * @param \Illuminate\Http\File|\Illuminate\Http\UploadedFile $file
+         * @param string $name
+         * @param array $options
+         * @return string|false 
          * @static 
          */
-        public static function getConnection(){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::getConnection();
+        public static function putFileAs($path, $file, $name, $options = array()){
+            return \Illuminate\Filesystem\FilesystemAdapter::putFileAs($path, $file, $name, $options);
         }
         
         /**
-         * Set the database connection instance.
+         * Get the visibility for the given path.
          *
-         * @param \Illuminate\Database\Connection $connection
-         * @return $this 
+         * @param string $path
+         * @return string 
          * @static 
          */
-        public static function setConnection($connection){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            return \Illuminate\Database\Schema\MySqlBuilder::setConnection($connection);
+        public static function getVisibility($path){
+            return \Illuminate\Filesystem\FilesystemAdapter::getVisibility($path);
         }
         
         /**
-         * Set the Schema Blueprint resolver callback.
+         * Set the visibility for the given path.
          *
-         * @param \Closure $resolver
+         * @param string $path
+         * @param string $visibility
          * @return void 
          * @static 
          */
-        public static function blueprintResolver($resolver){
-            //Method inherited from \Illuminate\Database\Schema\Builder            
-            \Illuminate\Database\Schema\MySqlBuilder::blueprintResolver($resolver);
+        public static function setVisibility($path, $visibility){
+            \Illuminate\Filesystem\FilesystemAdapter::setVisibility($path, $visibility);
         }
         
-    }
-
-
-    class Session extends \Illuminate\Support\Facades\Session{
+        /**
+         * Prepend to a file.
+         *
+         * @param string $path
+         * @param string $data
+         * @param string $separator
+         * @return int 
+         * @static 
+         */
+        public static function prepend($path, $data, $separator = ''){
+            return \Illuminate\Filesystem\FilesystemAdapter::prepend($path, $data, $separator);
+        }
         
         /**
-         * Get the session configuration.
+         * Append to a file.
          *
-         * @return array 
+         * @param string $path
+         * @param string $data
+         * @param string $separator
+         * @return int 
          * @static 
          */
-        public static function getSessionConfig(){
-            return \Illuminate\Session\SessionManager::getSessionConfig();
+        public static function append($path, $data, $separator = ''){
+            return \Illuminate\Filesystem\FilesystemAdapter::append($path, $data, $separator);
         }
         
         /**
-         * Get the default session driver name.
+         * Delete the file at a given path.
          *
-         * @return string 
+         * @param string|array $paths
+         * @return bool 
          * @static 
          */
-        public static function getDefaultDriver(){
-            return \Illuminate\Session\SessionManager::getDefaultDriver();
+        public static function delete($paths){
+            return \Illuminate\Filesystem\FilesystemAdapter::delete($paths);
         }
         
         /**
-         * Set the default session driver name.
+         * Copy a file to a new location.
          *
-         * @param string $name
-         * @return void 
+         * @param string $from
+         * @param string $to
+         * @return bool 
          * @static 
          */
-        public static function setDefaultDriver($name){
-            \Illuminate\Session\SessionManager::setDefaultDriver($name);
+        public static function copy($from, $to){
+            return \Illuminate\Filesystem\FilesystemAdapter::copy($from, $to);
         }
         
         /**
-         * Get a driver instance.
+         * Move a file to a new location.
          *
-         * @param string $driver
-         * @return mixed 
+         * @param string $from
+         * @param string $to
+         * @return bool 
          * @static 
          */
-        public static function driver($driver = null){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Session\SessionManager::driver($driver);
+        public static function move($from, $to){
+            return \Illuminate\Filesystem\FilesystemAdapter::move($from, $to);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Get the file size of a given file.
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $path
+         * @return int 
          * @static 
          */
-        public static function extend($driver, $callback){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Session\SessionManager::extend($driver, $callback);
+        public static function size($path){
+            return \Illuminate\Filesystem\FilesystemAdapter::size($path);
         }
         
         /**
-         * Get all of the created "drivers".
+         * Get the mime-type of a given file.
          *
-         * @return array 
+         * @param string $path
+         * @return string|false 
          * @static 
          */
-        public static function getDrivers(){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Session\SessionManager::getDrivers();
+        public static function mimeType($path){
+            return \Illuminate\Filesystem\FilesystemAdapter::mimeType($path);
         }
         
         /**
-         * Starts the session storage.
+         * Get the file's last modification time.
          *
-         * @return bool True if session started
-         * @throws \RuntimeException If session fails to start.
+         * @param string $path
+         * @return int 
          * @static 
          */
-        public static function start(){
-            return \Illuminate\Session\Store::start();
+        public static function lastModified($path){
+            return \Illuminate\Filesystem\FilesystemAdapter::lastModified($path);
         }
         
         /**
-         * Returns the session ID.
+         * Get the URL for the file at the given path.
          *
-         * @return string The session ID
+         * @param string $path
+         * @return string 
          * @static 
          */
-        public static function getId(){
-            return \Illuminate\Session\Store::getId();
+        public static function url($path){
+            return \Illuminate\Filesystem\FilesystemAdapter::url($path);
         }
         
         /**
-         * Sets the session ID.
+         * Get an array of all files in a directory.
          *
-         * @param string $id
+         * @param string|null $directory
+         * @param bool $recursive
+         * @return array 
          * @static 
          */
-        public static function setId($id){
-            return \Illuminate\Session\Store::setId($id);
+        public static function files($directory = null, $recursive = false){
+            return \Illuminate\Filesystem\FilesystemAdapter::files($directory, $recursive);
         }
         
         /**
-         * Determine if this is a valid session ID.
+         * Get all of the files from the given directory (recursive).
          *
-         * @param string $id
-         * @return bool 
+         * @param string|null $directory
+         * @return array 
          * @static 
          */
-        public static function isValidId($id){
-            return \Illuminate\Session\Store::isValidId($id);
+        public static function allFiles($directory = null){
+            return \Illuminate\Filesystem\FilesystemAdapter::allFiles($directory);
         }
         
         /**
-         * Returns the session name.
+         * Get all of the directories within a given directory.
          *
-         * @return mixed The session name
+         * @param string|null $directory
+         * @param bool $recursive
+         * @return array 
          * @static 
          */
-        public static function getName(){
-            return \Illuminate\Session\Store::getName();
+        public static function directories($directory = null, $recursive = false){
+            return \Illuminate\Filesystem\FilesystemAdapter::directories($directory, $recursive);
         }
         
         /**
-         * Sets the session name.
+         * Get all (recursive) of the directories within a given directory.
          *
-         * @param string $name
+         * @param string|null $directory
+         * @return array 
          * @static 
          */
-        public static function setName($name){
-            return \Illuminate\Session\Store::setName($name);
+        public static function allDirectories($directory = null){
+            return \Illuminate\Filesystem\FilesystemAdapter::allDirectories($directory);
         }
         
         /**
-         * Invalidates the current session.
-         * 
-         * Clears all session attributes and flashes and regenerates the
-         * session and deletes the old session from persistence.
+         * Create a directory.
          *
-         * @param int $lifetime Sets the cookie lifetime for the session cookie. A null value
-         *                      will leave the system settings unchanged, 0 sets the cookie
-         *                      to expire with browser session. Time is in seconds, and is
-         *                      not a Unix timestamp.
-         * @return bool True if session invalidated, false if error
+         * @param string $path
+         * @return bool 
          * @static 
          */
-        public static function invalidate($lifetime = null){
-            return \Illuminate\Session\Store::invalidate($lifetime);
+        public static function makeDirectory($path){
+            return \Illuminate\Filesystem\FilesystemAdapter::makeDirectory($path);
         }
         
         /**
-         * Migrates the current session to a new session id while maintaining all
-         * session attributes.
+         * Recursively delete a directory.
          *
-         * @param bool $destroy Whether to delete the old session or leave it to garbage collection
-         * @param int $lifetime Sets the cookie lifetime for the session cookie. A null value
-         *                       will leave the system settings unchanged, 0 sets the cookie
-         *                       to expire with browser session. Time is in seconds, and is
-         *                       not a Unix timestamp.
-         * @return bool True if session migrated, false if error
+         * @param string $directory
+         * @return bool 
          * @static 
          */
-        public static function migrate($destroy = false, $lifetime = null){
-            return \Illuminate\Session\Store::migrate($destroy, $lifetime);
+        public static function deleteDirectory($directory){
+            return \Illuminate\Filesystem\FilesystemAdapter::deleteDirectory($directory);
         }
         
         /**
-         * Generate a new session identifier.
+         * Get the Flysystem driver.
          *
-         * @param bool $destroy
-         * @return bool 
+         * @return \League\Flysystem\FilesystemInterface 
          * @static 
          */
-        public static function regenerate($destroy = false){
-            return \Illuminate\Session\Store::regenerate($destroy);
+        public static function getDriver(){
+            return \Illuminate\Filesystem\FilesystemAdapter::getDriver();
         }
         
+    }
+
+
+    class URL extends \Illuminate\Support\Facades\URL{
+        
         /**
-         * Force the session to be saved and closed.
-         * 
-         * This method is generally not required for real sessions as
-         * the session will be automatically saved at the end of
-         * code execution.
+         * Get the full URL for the current request.
          *
+         * @return string 
          * @static 
          */
-        public static function save(){
-            return \Illuminate\Session\Store::save();
+        public static function full(){
+            return \Illuminate\Routing\UrlGenerator::full();
         }
         
         /**
-         * Age the flash data for the session.
+         * Get the current URL for the request.
          *
-         * @return void 
+         * @return string 
          * @static 
          */
-        public static function ageFlashData(){
-            \Illuminate\Session\Store::ageFlashData();
+        public static function current(){
+            return \Illuminate\Routing\UrlGenerator::current();
         }
         
         /**
-         * Checks if an attribute exists.
+         * Get the URL for the previous request.
          *
-         * @param string|array $key
-         * @return bool 
+         * @param mixed $fallback
+         * @return string 
          * @static 
          */
-        public static function exists($key){
-            return \Illuminate\Session\Store::exists($key);
+        public static function previous($fallback = false){
+            return \Illuminate\Routing\UrlGenerator::previous($fallback);
         }
         
         /**
-         * Checks if an attribute is defined.
+         * Generate an absolute URL to the given path.
          *
-         * @param string $name The attribute name
-         * @return bool true if the attribute is defined, false otherwise
+         * @param string $path
+         * @param mixed $extra
+         * @param bool|null $secure
+         * @return string 
          * @static 
          */
-        public static function has($name){
-            return \Illuminate\Session\Store::has($name);
+        public static function to($path, $extra = array(), $secure = null){
+            return \Illuminate\Routing\UrlGenerator::to($path, $extra, $secure);
         }
         
         /**
-         * Returns an attribute.
+         * Generate a secure, absolute URL to the given path.
          *
-         * @param string $name The attribute name
-         * @param mixed $default The default value if not found
-         * @return mixed 
+         * @param string $path
+         * @param array $parameters
+         * @return string 
          * @static 
          */
-        public static function get($name, $default = null){
-            return \Illuminate\Session\Store::get($name, $default);
+        public static function secure($path, $parameters = array()){
+            return \Illuminate\Routing\UrlGenerator::secure($path, $parameters);
         }
         
         /**
-         * Get the value of a given key and then forget it.
+         * Generate the URL to an application asset.
          *
-         * @param string $key
-         * @param string $default
-         * @return mixed 
+         * @param string $path
+         * @param bool|null $secure
+         * @return string 
          * @static 
          */
-        public static function pull($key, $default = null){
-            return \Illuminate\Session\Store::pull($key, $default);
+        public static function asset($path, $secure = null){
+            return \Illuminate\Routing\UrlGenerator::asset($path, $secure);
         }
         
         /**
-         * Determine if the session contains old input.
+         * Generate the URL to a secure asset.
          *
-         * @param string $key
-         * @return bool 
+         * @param string $path
+         * @return string 
          * @static 
          */
-        public static function hasOldInput($key = null){
-            return \Illuminate\Session\Store::hasOldInput($key);
+        public static function secureAsset($path){
+            return \Illuminate\Routing\UrlGenerator::secureAsset($path);
         }
         
         /**
-         * Get the requested item from the flashed input array.
+         * Generate the URL to an asset from a custom root domain such as CDN, etc.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param string $root
+         * @param string $path
+         * @param bool|null $secure
+         * @return string 
          * @static 
          */
-        public static function getOldInput($key = null, $default = null){
-            return \Illuminate\Session\Store::getOldInput($key, $default);
+        public static function assetFrom($root, $path, $secure = null){
+            return \Illuminate\Routing\UrlGenerator::assetFrom($root, $path, $secure);
         }
         
         /**
-         * Sets an attribute.
+         * Get the default scheme for a raw URL.
          *
-         * @param string $name
-         * @param mixed $value
+         * @param bool|null $secure
+         * @return string 
          * @static 
          */
-        public static function set($name, $value){
-            return \Illuminate\Session\Store::set($name, $value);
+        public static function formatScheme($secure){
+            return \Illuminate\Routing\UrlGenerator::formatScheme($secure);
         }
         
         /**
-         * Put a key / value pair or array of key / value pairs in the session.
+         * Get the URL to a named route.
          *
-         * @param string|array $key
-         * @param mixed $value
-         * @return void 
+         * @param string $name
+         * @param mixed $parameters
+         * @param bool $absolute
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function put($key, $value = null){
-            \Illuminate\Session\Store::put($key, $value);
+        public static function route($name, $parameters = array(), $absolute = true){
+            return \Illuminate\Routing\UrlGenerator::route($name, $parameters, $absolute);
         }
         
         /**
-         * Push a value onto a session array.
+         * Get the URL to a controller action.
          *
-         * @param string $key
-         * @param mixed $value
-         * @return void 
+         * @param string $action
+         * @param mixed $parameters
+         * @param bool $absolute
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function push($key, $value){
-            \Illuminate\Session\Store::push($key, $value);
+        public static function action($action, $parameters = array(), $absolute = true){
+            return \Illuminate\Routing\UrlGenerator::action($action, $parameters, $absolute);
         }
         
         /**
-         * Increment the value of an item in the session.
+         * Format the array of URL parameters.
          *
-         * @param string $key
-         * @param int $amount
-         * @return mixed 
+         * @param mixed|array $parameters
+         * @return array 
          * @static 
          */
-        public static function increment($key, $amount = 1){
-            return \Illuminate\Session\Store::increment($key, $amount);
+        public static function formatParameters($parameters){
+            return \Illuminate\Routing\UrlGenerator::formatParameters($parameters);
         }
         
         /**
-         * Decrement the value of an item in the session.
+         * Get the base URL for the request.
          *
-         * @param string $key
-         * @param int $amount
-         * @return int 
+         * @param string $scheme
+         * @param string $root
+         * @return string 
          * @static 
          */
-        public static function decrement($key, $amount = 1){
-            return \Illuminate\Session\Store::decrement($key, $amount);
+        public static function formatRoot($scheme, $root = null){
+            return \Illuminate\Routing\UrlGenerator::formatRoot($scheme, $root);
         }
         
         /**
-         * Flash a key / value pair to the session.
+         * Format the given URL segments into a single URL.
          *
-         * @param string $key
-         * @param mixed $value
-         * @return void 
+         * @param string $root
+         * @param string $path
+         * @return string 
          * @static 
          */
-        public static function flash($key, $value){
-            \Illuminate\Session\Store::flash($key, $value);
+        public static function format($root, $path){
+            return \Illuminate\Routing\UrlGenerator::format($root, $path);
         }
         
         /**
-         * Flash a key / value pair to the session
-         * for immediate use.
+         * Determine if the given path is a valid URL.
          *
-         * @param string $key
-         * @param mixed $value
-         * @return void 
+         * @param string $path
+         * @return bool 
          * @static 
-         */
-        public static function now($key, $value){
-            \Illuminate\Session\Store::now($key, $value);
+         */
+        public static function isValidUrl($path){
+            return \Illuminate\Routing\UrlGenerator::isValidUrl($path);
         }
         
         /**
-         * Flash an input array to the session.
+         * Set the default named parameters used by the URL generator.
          *
-         * @param array $value
+         * @param array $defaults
          * @return void 
          * @static 
          */
-        public static function flashInput($value){
-            \Illuminate\Session\Store::flashInput($value);
+        public static function defaults($defaults){
+            \Illuminate\Routing\UrlGenerator::defaults($defaults);
         }
         
         /**
-         * Reflash all of the session flash data.
+         * Force the scheme for URLs.
          *
+         * @param string $schema
          * @return void 
          * @static 
          */
-        public static function reflash(){
-            \Illuminate\Session\Store::reflash();
+        public static function forceScheme($schema){
+            \Illuminate\Routing\UrlGenerator::forceScheme($schema);
         }
         
         /**
-         * Reflash a subset of the current flash data.
+         * Set the forced root URL.
          *
-         * @param array|mixed $keys
+         * @param string $root
          * @return void 
          * @static 
          */
-        public static function keep($keys = null){
-            \Illuminate\Session\Store::keep($keys);
+        public static function forceRootUrl($root){
+            \Illuminate\Routing\UrlGenerator::forceRootUrl($root);
         }
         
         /**
-         * Returns attributes.
+         * Set a callback to be used to format the host of generated URLs.
          *
-         * @return array Attributes
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function all(){
-            return \Illuminate\Session\Store::all();
+        public static function formatHostUsing($callback){
+            return \Illuminate\Routing\UrlGenerator::formatHostUsing($callback);
         }
         
         /**
-         * Sets attributes.
+         * Set a callback to be used to format the path of generated URLs.
          *
-         * @param array $attributes Attributes
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function replace($attributes){
-            return \Illuminate\Session\Store::replace($attributes);
+        public static function formatPathUsing($callback){
+            return \Illuminate\Routing\UrlGenerator::formatPathUsing($callback);
         }
         
         /**
-         * Removes an attribute.
+         * Get the path formatter being used by the URL generator.
          *
-         * @param string $name
-         * @return mixed The removed value or null when it does not exist
+         * @return \Closure 
          * @static 
          */
-        public static function remove($name){
-            return \Illuminate\Session\Store::remove($name);
+        public static function pathFormatter(){
+            return \Illuminate\Routing\UrlGenerator::pathFormatter();
         }
         
         /**
-         * Remove one or many items from the session.
+         * Get the request instance.
          *
-         * @param string|array $keys
-         * @return void 
+         * @return \Illuminate\Http\Request 
          * @static 
          */
-        public static function forget($keys){
-            \Illuminate\Session\Store::forget($keys);
+        public static function getRequest(){
+            return \Illuminate\Routing\UrlGenerator::getRequest();
         }
         
         /**
-         * Clears all attributes.
+         * Set the current request instance.
          *
+         * @param \Illuminate\Http\Request $request
+         * @return void 
          * @static 
          */
-        public static function clear(){
-            return \Illuminate\Session\Store::clear();
+        public static function setRequest($request){
+            \Illuminate\Routing\UrlGenerator::setRequest($request);
         }
         
         /**
-         * Remove all of the items from the session.
+         * Set the route collection.
          *
-         * @return void 
+         * @param \Illuminate\Routing\RouteCollection $routes
+         * @return $this 
          * @static 
          */
-        public static function flush(){
-            \Illuminate\Session\Store::flush();
+        public static function setRoutes($routes){
+            return \Illuminate\Routing\UrlGenerator::setRoutes($routes);
         }
         
         /**
-         * Checks if the session was started.
+         * Set the session resolver for the generator.
          *
-         * @return bool 
+         * @param callable $sessionResolver
+         * @return $this 
          * @static 
          */
-        public static function isStarted(){
-            return \Illuminate\Session\Store::isStarted();
+        public static function setSessionResolver($sessionResolver){
+            return \Illuminate\Routing\UrlGenerator::setSessionResolver($sessionResolver);
         }
         
         /**
-         * Registers a SessionBagInterface with the session.
+         * Set the root controller namespace.
          *
-         * @param \Symfony\Component\HttpFoundation\Session\SessionBagInterface $bag
+         * @param string $rootNamespace
+         * @return $this 
          * @static 
          */
-        public static function registerBag($bag){
-            return \Illuminate\Session\Store::registerBag($bag);
+        public static function setRootControllerNamespace($rootNamespace){
+            return \Illuminate\Routing\UrlGenerator::setRootControllerNamespace($rootNamespace);
         }
         
         /**
-         * Gets a bag instance by name.
+         * Register a custom macro.
          *
          * @param string $name
-         * @return \Symfony\Component\HttpFoundation\Session\SessionBagInterface 
+         * @param callable $macro
+         * @return void 
          * @static 
          */
-        public static function getBag($name){
-            return \Illuminate\Session\Store::getBag($name);
+        public static function macro($name, $macro){
+            \Illuminate\Routing\UrlGenerator::macro($name, $macro);
         }
         
         /**
-         * Gets session meta.
+         * Checks if macro is registered.
          *
-         * @return \Symfony\Component\HttpFoundation\Session\MetadataBag 
+         * @param string $name
+         * @return bool 
          * @static 
          */
-        public static function getMetadataBag(){
-            return \Illuminate\Session\Store::getMetadataBag();
+        public static function hasMacro($name){
+            return \Illuminate\Routing\UrlGenerator::hasMacro($name);
         }
         
+    }
+
+
+    class Validator extends \Illuminate\Support\Facades\Validator{
+        
         /**
-         * Get the raw bag data array for a given bag.
+         * Create a new Validator instance.
          *
-         * @param string $name
-         * @return array 
+         * @param array $data
+         * @param array $rules
+         * @param array $messages
+         * @param array $customAttributes
+         * @return \Illuminate\Validation\Validator 
          * @static 
          */
-        public static function getBagData($name){
-            return \Illuminate\Session\Store::getBagData($name);
+        public static function make($data, $rules, $messages = array(), $customAttributes = array()){
+            return \Illuminate\Validation\Factory::make($data, $rules, $messages, $customAttributes);
         }
         
         /**
-         * Get the CSRF token value.
+         * Validate the given data against the provided rules.
          *
-         * @return string 
+         * @param array $data
+         * @param array $rules
+         * @param array $messages
+         * @param array $customAttributes
+         * @return void 
+         * @throws \Illuminate\Validation\ValidationException
          * @static 
          */
-        public static function token(){
-            return \Illuminate\Session\Store::token();
+        public static function validate($data, $rules, $messages = array(), $customAttributes = array()){
+            \Illuminate\Validation\Factory::validate($data, $rules, $messages, $customAttributes);
         }
         
         /**
-         * Get the CSRF token value.
+         * Register a custom validator extension.
          *
-         * @return string 
+         * @param string $rule
+         * @param \Closure|string $extension
+         * @param string $message
+         * @return void 
          * @static 
          */
-        public static function getToken(){
-            return \Illuminate\Session\Store::getToken();
+        public static function extend($rule, $extension, $message = null){
+            \Illuminate\Validation\Factory::extend($rule, $extension, $message);
         }
         
         /**
-         * Regenerate the CSRF token value.
+         * Register a custom implicit validator extension.
          *
+         * @param string $rule
+         * @param \Closure|string $extension
+         * @param string $message
          * @return void 
          * @static 
          */
-        public static function regenerateToken(){
-            \Illuminate\Session\Store::regenerateToken();
+        public static function extendImplicit($rule, $extension, $message = null){
+            \Illuminate\Validation\Factory::extendImplicit($rule, $extension, $message);
         }
         
         /**
-         * Get the previous URL from the session.
+         * Register a custom dependent validator extension.
          *
-         * @return string|null 
+         * @param string $rule
+         * @param \Closure|string $extension
+         * @param string $message
+         * @return void 
          * @static 
          */
-        public static function previousUrl(){
-            return \Illuminate\Session\Store::previousUrl();
+        public static function extendDependent($rule, $extension, $message = null){
+            \Illuminate\Validation\Factory::extendDependent($rule, $extension, $message);
         }
         
         /**
-         * Set the "previous" URL in the session.
+         * Register a custom validator message replacer.
          *
-         * @param string $url
+         * @param string $rule
+         * @param \Closure|string $replacer
          * @return void 
          * @static 
          */
-        public static function setPreviousUrl($url){
-            \Illuminate\Session\Store::setPreviousUrl($url);
+        public static function replacer($rule, $replacer){
+            \Illuminate\Validation\Factory::replacer($rule, $replacer);
         }
         
         /**
-         * Set the existence of the session on the handler if applicable.
+         * Set the Validator instance resolver.
          *
-         * @param bool $value
+         * @param \Closure $resolver
          * @return void 
          * @static 
          */
-        public static function setExists($value){
-            \Illuminate\Session\Store::setExists($value);
+        public static function resolver($resolver){
+            \Illuminate\Validation\Factory::resolver($resolver);
         }
         
         /**
-         * Get the underlying session handler implementation.
+         * Get the Translator implementation.
          *
-         * @return \SessionHandlerInterface 
+         * @return \Illuminate\Contracts\Translation\Translator 
          * @static 
          */
-        public static function getHandler(){
-            return \Illuminate\Session\Store::getHandler();
+        public static function getTranslator(){
+            return \Illuminate\Validation\Factory::getTranslator();
         }
         
         /**
-         * Determine if the session handler needs a request.
+         * Get the Presence Verifier implementation.
          *
-         * @return bool 
+         * @return \Illuminate\Validation\PresenceVerifierInterface 
          * @static 
          */
-        public static function handlerNeedsRequest(){
-            return \Illuminate\Session\Store::handlerNeedsRequest();
+        public static function getPresenceVerifier(){
+            return \Illuminate\Validation\Factory::getPresenceVerifier();
         }
         
         /**
-         * Set the request on the handler instance.
+         * Set the Presence Verifier implementation.
          *
-         * @param \Symfony\Component\HttpFoundation\Request $request
+         * @param \Illuminate\Validation\PresenceVerifierInterface $presenceVerifier
          * @return void 
          * @static 
          */
-        public static function setRequestOnHandler($request){
-            \Illuminate\Session\Store::setRequestOnHandler($request);
+        public static function setPresenceVerifier($presenceVerifier){
+            \Illuminate\Validation\Factory::setPresenceVerifier($presenceVerifier);
         }
         
     }
 
 
-    class Storage extends \Illuminate\Support\Facades\Storage{
+    class View extends \Illuminate\Support\Facades\View{
         
         /**
-         * Get a filesystem instance.
+         * Get the evaluated view contents for the given view.
          *
-         * @param string $name
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param string $path
+         * @param array $data
+         * @param array $mergeData
+         * @return \Illuminate\Contracts\View\View 
          * @static 
          */
-        public static function drive($name = null){
-            return \Illuminate\Filesystem\FilesystemManager::drive($name);
+        public static function file($path, $data = array(), $mergeData = array()){
+            return \Illuminate\View\Factory::file($path, $data, $mergeData);
         }
         
         /**
-         * Get a filesystem instance.
+         * Get the evaluated view contents for the given view.
          *
-         * @param string $name
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param string $view
+         * @param array $data
+         * @param array $mergeData
+         * @return \Illuminate\Contracts\View\View 
          * @static 
          */
-        public static function disk($name = null){
-            return \Illuminate\Filesystem\FilesystemManager::disk($name);
+        public static function make($view, $data = array(), $mergeData = array()){
+            return \Illuminate\View\Factory::make($view, $data, $mergeData);
         }
         
         /**
-         * Get a default cloud filesystem instance.
+         * Get the rendered content of the view based on a given condition.
          *
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param bool $condition
+         * @param string $view
+         * @param array $data
+         * @param array $mergeData
+         * @return string 
          * @static 
          */
-        public static function cloud(){
-            return \Illuminate\Filesystem\FilesystemManager::cloud();
+        public static function renderWhen($condition, $view, $data = array(), $mergeData = array()){
+            return \Illuminate\View\Factory::renderWhen($condition, $view, $data, $mergeData);
         }
         
         /**
-         * Create an instance of the local driver.
+         * Get the rendered contents of a partial from a loop.
          *
-         * @param array $config
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param string $view
+         * @param array $data
+         * @param string $iterator
+         * @param string $empty
+         * @return string 
          * @static 
          */
-        public static function createLocalDriver($config){
-            return \Illuminate\Filesystem\FilesystemManager::createLocalDriver($config);
+        public static function renderEach($view, $data, $iterator, $empty = 'raw|'){
+            return \Illuminate\View\Factory::renderEach($view, $data, $iterator, $empty);
         }
         
         /**
-         * Create an instance of the ftp driver.
+         * Determine if a given view exists.
          *
-         * @param array $config
-         * @return \Illuminate\Filesystem\FilesystemAdapter 
+         * @param string $view
+         * @return bool 
          * @static 
          */
-        public static function createFtpDriver($config){
-            return \Illuminate\Filesystem\FilesystemManager::createFtpDriver($config);
+        public static function exists($view){
+            return \Illuminate\View\Factory::exists($view);
         }
         
         /**
-         * Create an instance of the Amazon S3 driver.
+         * Get the appropriate view engine for the given path.
          *
-         * @param array $config
-         * @return \Illuminate\Contracts\Filesystem\Cloud 
+         * @param string $path
+         * @return \Illuminate\View\Engines\EngineInterface 
+         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function createS3Driver($config){
-            return \Illuminate\Filesystem\FilesystemManager::createS3Driver($config);
+        public static function getEngineFromPath($path){
+            return \Illuminate\View\Factory::getEngineFromPath($path);
+        }
+        
+        /**
+         * Add a piece of shared data to the environment.
+         *
+         * @param array|string $key
+         * @param mixed $value
+         * @return mixed 
+         * @static 
+         */
+        public static function share($key, $value = null){
+            return \Illuminate\View\Factory::share($key, $value);
+        }
+        
+        /**
+         * Increment the rendering counter.
+         *
+         * @return void 
+         * @static 
+         */
+        public static function incrementRender(){
+            \Illuminate\View\Factory::incrementRender();
         }
         
         /**
-         * Create an instance of the Rackspace driver.
+         * Decrement the rendering counter.
          *
-         * @param array $config
-         * @return \Illuminate\Contracts\Filesystem\Cloud 
+         * @return void 
          * @static 
          */
-        public static function createRackspaceDriver($config){
-            return \Illuminate\Filesystem\FilesystemManager::createRackspaceDriver($config);
+        public static function decrementRender(){
+            \Illuminate\View\Factory::decrementRender();
         }
         
         /**
-         * Get the default driver name.
+         * Check if there are no active render operations.
          *
-         * @return string 
+         * @return bool 
          * @static 
          */
-        public static function getDefaultDriver(){
-            return \Illuminate\Filesystem\FilesystemManager::getDefaultDriver();
+        public static function doneRendering(){
+            return \Illuminate\View\Factory::doneRendering();
         }
         
         /**
-         * Get the default cloud driver name.
+         * Add a location to the array of view locations.
          *
-         * @return string 
+         * @param string $location
+         * @return void 
          * @static 
          */
-        public static function getDefaultCloudDriver(){
-            return \Illuminate\Filesystem\FilesystemManager::getDefaultCloudDriver();
+        public static function addLocation($location){
+            \Illuminate\View\Factory::addLocation($location);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Add a new namespace to the loader.
          *
-         * @param string $driver
-         * @param \Closure $callback
+         * @param string $namespace
+         * @param string|array $hints
          * @return $this 
          * @static 
          */
-        public static function extend($driver, $callback){
-            return \Illuminate\Filesystem\FilesystemManager::extend($driver, $callback);
+        public static function addNamespace($namespace, $hints){
+            return \Illuminate\View\Factory::addNamespace($namespace, $hints);
         }
         
         /**
-         * Determine if a file exists.
+         * Prepend a new namespace to the loader.
          *
-         * @param string $path
-         * @return bool 
+         * @param string $namespace
+         * @param string|array $hints
+         * @return $this 
          * @static 
          */
-        public static function exists($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::exists($path);
+        public static function prependNamespace($namespace, $hints){
+            return \Illuminate\View\Factory::prependNamespace($namespace, $hints);
         }
         
         /**
-         * Get the contents of a file.
+         * Replace the namespace hints for the given namespace.
          *
-         * @param string $path
-         * @return string 
-         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
+         * @param string $namespace
+         * @param string|array $hints
+         * @return $this 
          * @static 
          */
-        public static function get($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::get($path);
+        public static function replaceNamespace($namespace, $hints){
+            return \Illuminate\View\Factory::replaceNamespace($namespace, $hints);
         }
         
         /**
-         * Write the contents of a file.
+         * Register a valid view extension and its engine.
          *
-         * @param string $path
-         * @param string|resource $contents
-         * @param string $visibility
-         * @return bool 
+         * @param string $extension
+         * @param string $engine
+         * @param \Closure $resolver
+         * @return void 
          * @static 
          */
-        public static function put($path, $contents, $visibility = null){
-            return \Illuminate\Filesystem\FilesystemAdapter::put($path, $contents, $visibility);
+        public static function addExtension($extension, $engine, $resolver = null){
+            \Illuminate\View\Factory::addExtension($extension, $engine, $resolver);
         }
         
         /**
-         * Store the uploaded file on the disk.
+         * Flush all of the factory state like sections and stacks.
          *
-         * @param string $path
-         * @param \Illuminate\Http\UploadedFile $file
-         * @param string $visibility
-         * @return string|false 
+         * @return void 
          * @static 
          */
-        public static function putFile($path, $file, $visibility = null){
-            return \Illuminate\Filesystem\FilesystemAdapter::putFile($path, $file, $visibility);
+        public static function flushState(){
+            \Illuminate\View\Factory::flushState();
         }
         
         /**
-         * Store the uploaded file on the disk with a given name.
+         * Flush all of the section contents if done rendering.
          *
-         * @param string $path
-         * @param \Illuminate\Http\File|\Illuminate\Http\UploadedFile $file
-         * @param string $name
-         * @param string $visibility
-         * @return string|false 
+         * @return void 
          * @static 
          */
-        public static function putFileAs($path, $file, $name, $visibility = null){
-            return \Illuminate\Filesystem\FilesystemAdapter::putFileAs($path, $file, $name, $visibility);
+        public static function flushStateIfDoneRendering(){
+            \Illuminate\View\Factory::flushStateIfDoneRendering();
         }
         
         /**
-         * Get the visibility for the given path.
+         * Get the extension to engine bindings.
          *
-         * @param string $path
-         * @return string 
+         * @return array 
          * @static 
          */
-        public static function getVisibility($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::getVisibility($path);
+        public static function getExtensions(){
+            return \Illuminate\View\Factory::getExtensions();
         }
         
         /**
-         * Set the visibility for the given path.
+         * Get the engine resolver instance.
          *
-         * @param string $path
-         * @param string $visibility
-         * @return void 
+         * @return \Illuminate\View\Engines\EngineResolver 
          * @static 
          */
-        public static function setVisibility($path, $visibility){
-            \Illuminate\Filesystem\FilesystemAdapter::setVisibility($path, $visibility);
+        public static function getEngineResolver(){
+            return \Illuminate\View\Factory::getEngineResolver();
         }
         
         /**
-         * Prepend to a file.
+         * Get the view finder instance.
          *
-         * @param string $path
-         * @param string $data
-         * @param string $separator
-         * @return int 
+         * @return \Illuminate\View\ViewFinderInterface 
          * @static 
          */
-        public static function prepend($path, $data, $separator = ''){
-            return \Illuminate\Filesystem\FilesystemAdapter::prepend($path, $data, $separator);
+        public static function getFinder(){
+            return \Illuminate\View\Factory::getFinder();
         }
         
         /**
-         * Append to a file.
+         * Set the view finder instance.
          *
-         * @param string $path
-         * @param string $data
-         * @param string $separator
-         * @return int 
+         * @param \Illuminate\View\ViewFinderInterface $finder
+         * @return void 
          * @static 
          */
-        public static function append($path, $data, $separator = ''){
-            return \Illuminate\Filesystem\FilesystemAdapter::append($path, $data, $separator);
+        public static function setFinder($finder){
+            \Illuminate\View\Factory::setFinder($finder);
         }
         
         /**
-         * Delete the file at a given path.
+         * Flush the cache of views located by the finder.
          *
-         * @param string|array $paths
-         * @return bool 
+         * @return void 
          * @static 
          */
-        public static function delete($paths){
-            return \Illuminate\Filesystem\FilesystemAdapter::delete($paths);
+        public static function flushFinderCache(){
+            \Illuminate\View\Factory::flushFinderCache();
         }
         
         /**
-         * Copy a file to a new location.
+         * Get the event dispatcher instance.
          *
-         * @param string $from
-         * @param string $to
-         * @return bool 
+         * @return \Illuminate\Contracts\Events\Dispatcher 
          * @static 
          */
-        public static function copy($from, $to){
-            return \Illuminate\Filesystem\FilesystemAdapter::copy($from, $to);
+        public static function getDispatcher(){
+            return \Illuminate\View\Factory::getDispatcher();
         }
         
         /**
-         * Move a file to a new location.
+         * Set the event dispatcher instance.
          *
-         * @param string $from
-         * @param string $to
-         * @return bool 
+         * @param \Illuminate\Contracts\Events\Dispatcher $events
+         * @return void 
          * @static 
          */
-        public static function move($from, $to){
-            return \Illuminate\Filesystem\FilesystemAdapter::move($from, $to);
+        public static function setDispatcher($events){
+            \Illuminate\View\Factory::setDispatcher($events);
         }
         
         /**
-         * Get the file size of a given file.
+         * Get the IoC container instance.
          *
-         * @param string $path
-         * @return int 
+         * @return \Illuminate\Contracts\Container\Container 
          * @static 
          */
-        public static function size($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::size($path);
+        public static function getContainer(){
+            return \Illuminate\View\Factory::getContainer();
         }
         
         /**
-         * Get the mime-type of a given file.
+         * Set the IoC container instance.
          *
-         * @param string $path
-         * @return string|false 
+         * @param \Illuminate\Contracts\Container\Container $container
+         * @return void 
          * @static 
          */
-        public static function mimeType($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::mimeType($path);
+        public static function setContainer($container){
+            \Illuminate\View\Factory::setContainer($container);
         }
         
         /**
-         * Get the file's last modification time.
+         * Get an item from the shared data.
          *
-         * @param string $path
-         * @return int 
+         * @param string $key
+         * @param mixed $default
+         * @return mixed 
          * @static 
          */
-        public static function lastModified($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::lastModified($path);
+        public static function shared($key, $default = null){
+            return \Illuminate\View\Factory::shared($key, $default);
         }
         
         /**
-         * Get the URL for the file at the given path.
+         * Get all of the shared data for the environment.
          *
-         * @param string $path
-         * @return string 
+         * @return array 
          * @static 
          */
-        public static function url($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::url($path);
+        public static function getShared(){
+            return \Illuminate\View\Factory::getShared();
         }
         
         /**
-         * Get an array of all files in a directory.
+         * Register a view composer event.
          *
-         * @param string|null $directory
-         * @param bool $recursive
+         * @param array|string $views
+         * @param \Closure|string $callback
          * @return array 
          * @static 
          */
-        public static function files($directory = null, $recursive = false){
-            return \Illuminate\Filesystem\FilesystemAdapter::files($directory, $recursive);
+        public static function composer($views, $callback){
+            return \Illuminate\View\Factory::composer($views, $callback);
         }
         
         /**
-         * Get all of the files from the given directory (recursive).
+         * Register a view creator event.
          *
-         * @param string|null $directory
+         * @param array|string $views
+         * @param \Closure|string $callback
          * @return array 
          * @static 
          */
-        public static function allFiles($directory = null){
-            return \Illuminate\Filesystem\FilesystemAdapter::allFiles($directory);
+        public static function creator($views, $callback){
+            return \Illuminate\View\Factory::creator($views, $callback);
         }
         
         /**
-         * Get all of the directories within a given directory.
+         * Start a component rendering process.
          *
-         * @param string|null $directory
-         * @param bool $recursive
-         * @return array 
+         * @param string $name
+         * @param array $data
+         * @return void 
          * @static 
          */
-        public static function directories($directory = null, $recursive = false){
-            return \Illuminate\Filesystem\FilesystemAdapter::directories($directory, $recursive);
+        public static function startComponent($name, $data = array()){
+            \Illuminate\View\Factory::startComponent($name, $data);
         }
         
         /**
-         * Get all (recursive) of the directories within a given directory.
+         * Render the current component.
          *
-         * @param string|null $directory
-         * @return array 
+         * @return string 
          * @static 
          */
-        public static function allDirectories($directory = null){
-            return \Illuminate\Filesystem\FilesystemAdapter::allDirectories($directory);
+        public static function renderComponent(){
+            return \Illuminate\View\Factory::renderComponent();
         }
         
         /**
-         * Create a directory.
+         * Start the slot rendering process.
          *
-         * @param string $path
-         * @return bool 
+         * @param string $name
+         * @param string|null $content
+         * @return void 
          * @static 
          */
-        public static function makeDirectory($path){
-            return \Illuminate\Filesystem\FilesystemAdapter::makeDirectory($path);
+        public static function slot($name, $content = null){
+            \Illuminate\View\Factory::slot($name, $content);
         }
         
         /**
-         * Recursively delete a directory.
+         * Save the slot content for rendering.
          *
-         * @param string $directory
-         * @return bool 
+         * @return void 
          * @static 
          */
-        public static function deleteDirectory($directory){
-            return \Illuminate\Filesystem\FilesystemAdapter::deleteDirectory($directory);
+        public static function endSlot(){
+            \Illuminate\View\Factory::endSlot();
         }
         
         /**
-         * Get the Flysystem driver.
+         * Register multiple view composers via an array.
          *
-         * @return \League\Flysystem\FilesystemInterface 
+         * @param array $composers
+         * @return array 
          * @static 
          */
-        public static function getDriver(){
-            return \Illuminate\Filesystem\FilesystemAdapter::getDriver();
+        public static function composers($composers){
+            return \Illuminate\View\Factory::composers($composers);
         }
         
-    }
-
-
-    class URL extends \Illuminate\Support\Facades\URL{
+        /**
+         * Call the composer for a given view.
+         *
+         * @param \Illuminate\Contracts\View\View $view
+         * @return void 
+         * @static 
+         */
+        public static function callComposer($view){
+            \Illuminate\View\Factory::callComposer($view);
+        }
         
         /**
-         * Get the full URL for the current request.
+         * Call the creator for a given view.
          *
-         * @return string 
+         * @param \Illuminate\Contracts\View\View $view
+         * @return void 
          * @static 
          */
-        public static function full(){
-            return \Illuminate\Routing\UrlGenerator::full();
+        public static function callCreator($view){
+            \Illuminate\View\Factory::callCreator($view);
         }
         
         /**
-         * Get the current URL for the request.
+         * Start injecting content into a section.
          *
-         * @return string 
+         * @param string $section
+         * @param string|null $content
+         * @return void 
          * @static 
          */
-        public static function current(){
-            return \Illuminate\Routing\UrlGenerator::current();
+        public static function startSection($section, $content = null){
+            \Illuminate\View\Factory::startSection($section, $content);
         }
         
         /**
-         * Get the URL for the previous request.
+         * Inject inline content into a section.
          *
-         * @param mixed $fallback
-         * @return string 
+         * @param string $section
+         * @param string $content
+         * @return void 
          * @static 
          */
-        public static function previous($fallback = false){
-            return \Illuminate\Routing\UrlGenerator::previous($fallback);
+        public static function inject($section, $content){
+            \Illuminate\View\Factory::inject($section, $content);
         }
         
         /**
-         * Generate an absolute URL to the given path.
+         * Stop injecting content into a section and return its contents.
          *
-         * @param string $path
-         * @param mixed $extra
-         * @param bool|null $secure
          * @return string 
          * @static 
          */
-        public static function to($path, $extra = array(), $secure = null){
-            return \Illuminate\Routing\UrlGenerator::to($path, $extra, $secure);
+        public static function yieldSection(){
+            return \Illuminate\View\Factory::yieldSection();
         }
         
         /**
-         * Generate a secure, absolute URL to the given path.
+         * Stop injecting content into a section.
          *
-         * @param string $path
-         * @param array $parameters
+         * @param bool $overwrite
          * @return string 
+         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function secure($path, $parameters = array()){
-            return \Illuminate\Routing\UrlGenerator::secure($path, $parameters);
+        public static function stopSection($overwrite = false){
+            return \Illuminate\View\Factory::stopSection($overwrite);
         }
         
         /**
-         * Generate the URL to an application asset.
+         * Stop injecting content into a section and append it.
          *
-         * @param string $path
-         * @param bool|null $secure
          * @return string 
+         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function asset($path, $secure = null){
-            return \Illuminate\Routing\UrlGenerator::asset($path, $secure);
+        public static function appendSection(){
+            return \Illuminate\View\Factory::appendSection();
         }
         
         /**
-         * Generate the URL to an asset from a custom root domain such as CDN, etc.
+         * Get the string contents of a section.
          *
-         * @param string $root
-         * @param string $path
-         * @param bool|null $secure
+         * @param string $section
+         * @param string $default
          * @return string 
          * @static 
          */
-        public static function assetFrom($root, $path, $secure = null){
-            return \Illuminate\Routing\UrlGenerator::assetFrom($root, $path, $secure);
+        public static function yieldContent($section, $default = ''){
+            return \Illuminate\View\Factory::yieldContent($section, $default);
         }
         
         /**
-         * Generate the URL to a secure asset.
+         * Get the parent placeholder for the current request.
          *
-         * @param string $path
+         * @param string $section
          * @return string 
          * @static 
          */
-        public static function secureAsset($path){
-            return \Illuminate\Routing\UrlGenerator::secureAsset($path);
+        public static function parentPlaceholder($section = ''){
+            return \Illuminate\View\Factory::parentPlaceholder($section);
         }
         
         /**
-         * Force the schema for URLs.
+         * Check if section exists.
          *
-         * @param string $schema
-         * @return void 
+         * @param string $name
+         * @return bool 
          * @static 
          */
-        public static function forceSchema($schema){
-            \Illuminate\Routing\UrlGenerator::forceSchema($schema);
+        public static function hasSection($name){
+            return \Illuminate\View\Factory::hasSection($name);
         }
         
         /**
-         * Get the URL to a named route.
+         * Get the contents of a section.
          *
          * @param string $name
-         * @param mixed $parameters
-         * @param bool $absolute
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @param string $default
+         * @return mixed 
          * @static 
          */
-        public static function route($name, $parameters = array(), $absolute = true){
-            return \Illuminate\Routing\UrlGenerator::route($name, $parameters, $absolute);
+        public static function getSection($name, $default = null){
+            return \Illuminate\View\Factory::getSection($name, $default);
         }
         
         /**
-         * Get the URL to a controller action.
+         * Get the entire array of sections.
          *
-         * @param string $action
-         * @param mixed $parameters
-         * @param bool $absolute
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @return array 
          * @static 
          */
-        public static function action($action, $parameters = array(), $absolute = true){
-            return \Illuminate\Routing\UrlGenerator::action($action, $parameters, $absolute);
+        public static function getSections(){
+            return \Illuminate\View\Factory::getSections();
         }
         
         /**
-         * Set the forced root URL.
+         * Flush all of the sections.
          *
-         * @param string $root
          * @return void 
          * @static 
          */
-        public static function forceRootUrl($root){
-            \Illuminate\Routing\UrlGenerator::forceRootUrl($root);
+        public static function flushSections(){
+            \Illuminate\View\Factory::flushSections();
         }
         
         /**
-         * Determine if the given path is a valid URL.
+         * Add new loop to the stack.
          *
-         * @param string $path
-         * @return bool 
+         * @param \Countable|array $data
+         * @return void 
          * @static 
          */
-        public static function isValidUrl($path){
-            return \Illuminate\Routing\UrlGenerator::isValidUrl($path);
+        public static function addLoop($data){
+            \Illuminate\View\Factory::addLoop($data);
         }
         
         /**
-         * Get the request instance.
+         * Increment the top loop's indices.
          *
-         * @return \Illuminate\Http\Request 
+         * @return void 
          * @static 
          */
-        public static function getRequest(){
-            return \Illuminate\Routing\UrlGenerator::getRequest();
+        public static function incrementLoopIndices(){
+            \Illuminate\View\Factory::incrementLoopIndices();
         }
         
         /**
-         * Set the current request instance.
+         * Pop a loop from the top of the loop stack.
          *
-         * @param \Illuminate\Http\Request $request
          * @return void 
          * @static 
          */
-        public static function setRequest($request){
-            \Illuminate\Routing\UrlGenerator::setRequest($request);
+        public static function popLoop(){
+            \Illuminate\View\Factory::popLoop();
         }
         
         /**
-         * Set the route collection.
+         * Get an instance of the last loop in the stack.
          *
-         * @param \Illuminate\Routing\RouteCollection $routes
-         * @return $this 
+         * @return \stdClass|null 
          * @static 
          */
-        public static function setRoutes($routes){
-            return \Illuminate\Routing\UrlGenerator::setRoutes($routes);
+        public static function getLastLoop(){
+            return \Illuminate\View\Factory::getLastLoop();
         }
         
         /**
-         * Set the session resolver for the generator.
+         * Get the entire loop stack.
          *
-         * @param callable $sessionResolver
-         * @return $this 
+         * @return array 
          * @static 
          */
-        public static function setSessionResolver($sessionResolver){
-            return \Illuminate\Routing\UrlGenerator::setSessionResolver($sessionResolver);
+        public static function getLoopStack(){
+            return \Illuminate\View\Factory::getLoopStack();
         }
         
         /**
-         * Set the root controller namespace.
+         * Start injecting content into a push section.
          *
-         * @param string $rootNamespace
-         * @return $this 
+         * @param string $section
+         * @param string $content
+         * @return void 
          * @static 
          */
-        public static function setRootControllerNamespace($rootNamespace){
-            return \Illuminate\Routing\UrlGenerator::setRootControllerNamespace($rootNamespace);
+        public static function startPush($section, $content = ''){
+            \Illuminate\View\Factory::startPush($section, $content);
         }
         
         /**
-         * Register a custom macro.
+         * Stop injecting content into a push section.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @return string 
+         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function macro($name, $macro){
-            \Illuminate\Routing\UrlGenerator::macro($name, $macro);
+        public static function stopPush(){
+            return \Illuminate\View\Factory::stopPush();
         }
         
         /**
-         * Checks if macro is registered.
+         * Start prepending content into a push section.
          *
-         * @param string $name
-         * @return bool 
+         * @param string $section
+         * @param string $content
+         * @return void 
          * @static 
          */
-        public static function hasMacro($name){
-            return \Illuminate\Routing\UrlGenerator::hasMacro($name);
+        public static function startPrepend($section, $content = ''){
+            \Illuminate\View\Factory::startPrepend($section, $content);
         }
         
-    }
-
-
-    class Validator extends \Illuminate\Support\Facades\Validator{
+        /**
+         * Stop prepending content into a push section.
+         *
+         * @return string 
+         * @throws \InvalidArgumentException
+         * @static 
+         */
+        public static function stopPrepend(){
+            return \Illuminate\View\Factory::stopPrepend();
+        }
         
         /**
-         * Create a new Validator instance.
+         * Get the string contents of a push section.
          *
-         * @param array $data
-         * @param array $rules
-         * @param array $messages
-         * @param array $customAttributes
-         * @return \Illuminate\Validation\Validator 
+         * @param string $section
+         * @param string $default
+         * @return string 
          * @static 
          */
-        public static function make($data, $rules, $messages = array(), $customAttributes = array()){
-            return \Illuminate\Validation\Factory::make($data, $rules, $messages, $customAttributes);
+        public static function yieldPushContent($section, $default = ''){
+            return \Illuminate\View\Factory::yieldPushContent($section, $default);
         }
         
         /**
-         * Validate the given data against the provided rules.
+         * Flush all of the stacks.
          *
-         * @param array $data
-         * @param array $rules
-         * @param array $messages
-         * @param array $customAttributes
          * @return void 
-         * @throws \Illuminate\Validation\ValidationException
          * @static 
          */
-        public static function validate($data, $rules, $messages = array(), $customAttributes = array()){
-            \Illuminate\Validation\Factory::validate($data, $rules, $messages, $customAttributes);
+        public static function flushStacks(){
+            \Illuminate\View\Factory::flushStacks();
         }
         
         /**
-         * Register a custom validator extension.
+         * Start a translation block.
          *
-         * @param string $rule
-         * @param \Closure|string $extension
-         * @param string $message
+         * @param array $replacements
          * @return void 
          * @static 
          */
-        public static function extend($rule, $extension, $message = null){
-            \Illuminate\Validation\Factory::extend($rule, $extension, $message);
+        public static function startTranslation($replacements = array()){
+            \Illuminate\View\Factory::startTranslation($replacements);
         }
         
         /**
-         * Register a custom implicit validator extension.
+         * Render the current translation.
          *
-         * @param string $rule
-         * @param \Closure|string $extension
-         * @param string $message
-         * @return void 
+         * @return string 
          * @static 
          */
-        public static function extendImplicit($rule, $extension, $message = null){
-            \Illuminate\Validation\Factory::extendImplicit($rule, $extension, $message);
+        public static function renderTranslation(){
+            return \Illuminate\View\Factory::renderTranslation();
         }
         
+    }
+
+
+    class Notification extends \Illuminate\Support\Facades\Notification{
+        
         /**
-         * Register a custom implicit validator message replacer.
+         * Send the given notification to the given notifiable entities.
          *
-         * @param string $rule
-         * @param \Closure|string $replacer
+         * @param \Illuminate\Support\Collection|array|mixed $notifiables
+         * @param mixed $notification
          * @return void 
          * @static 
          */
-        public static function replacer($rule, $replacer){
-            \Illuminate\Validation\Factory::replacer($rule, $replacer);
+        public static function send($notifiables, $notification){
+            \Illuminate\Notifications\ChannelManager::send($notifiables, $notification);
         }
         
         /**
-         * Set the Validator instance resolver.
+         * Send the given notification immediately.
          *
-         * @param \Closure $resolver
+         * @param \Illuminate\Support\Collection|array|mixed $notifiables
+         * @param mixed $notification
+         * @param array|null $channels
          * @return void 
          * @static 
          */
-        public static function resolver($resolver){
-            \Illuminate\Validation\Factory::resolver($resolver);
+        public static function sendNow($notifiables, $notification, $channels = null){
+            \Illuminate\Notifications\ChannelManager::sendNow($notifiables, $notification, $channels);
         }
         
         /**
-         * Get the Translator implementation.
+         * Get a channel instance.
          *
-         * @return \Symfony\Component\Translation\TranslatorInterface 
+         * @param string|null $name
+         * @return mixed 
          * @static 
          */
-        public static function getTranslator(){
-            return \Illuminate\Validation\Factory::getTranslator();
+        public static function channel($name = null){
+            return \Illuminate\Notifications\ChannelManager::channel($name);
         }
         
         /**
-         * Get the Presence Verifier implementation.
+         * Get the default channel driver name.
          *
-         * @return \Illuminate\Validation\PresenceVerifierInterface 
+         * @return string 
          * @static 
          */
-        public static function getPresenceVerifier(){
-            return \Illuminate\Validation\Factory::getPresenceVerifier();
+        public static function getDefaultDriver(){
+            return \Illuminate\Notifications\ChannelManager::getDefaultDriver();
         }
         
         /**
-         * Set the Presence Verifier implementation.
+         * Get the default channel driver name.
          *
-         * @param \Illuminate\Validation\PresenceVerifierInterface $presenceVerifier
-         * @return void 
+         * @return string 
          * @static 
          */
-        public static function setPresenceVerifier($presenceVerifier){
-            \Illuminate\Validation\Factory::setPresenceVerifier($presenceVerifier);
+        public static function deliversVia(){
+            return \Illuminate\Notifications\ChannelManager::deliversVia();
         }
         
-    }
-
-
-    class View extends \Illuminate\Support\Facades\View{
-        
         /**
-         * Get the evaluated view contents for the given view.
+         * Set the default channel driver name.
          *
-         * @param string $path
-         * @param array $data
-         * @param array $mergeData
-         * @return \Illuminate\Contracts\View\View 
+         * @param string $channel
+         * @return void 
          * @static 
          */
-        public static function file($path, $data = array(), $mergeData = array()){
-            return \Illuminate\View\Factory::file($path, $data, $mergeData);
+        public static function deliverVia($channel){
+            \Illuminate\Notifications\ChannelManager::deliverVia($channel);
         }
         
         /**
-         * Get the evaluated view contents for the given view.
+         * Get a driver instance.
          *
-         * @param string $view
-         * @param array $data
-         * @param array $mergeData
-         * @return \Illuminate\Contracts\View\View 
+         * @param string $driver
+         * @return mixed 
          * @static 
          */
-        public static function make($view, $data = array(), $mergeData = array()){
-            return \Illuminate\View\Factory::make($view, $data, $mergeData);
+        public static function driver($driver = null){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Notifications\ChannelManager::driver($driver);
         }
         
         /**
-         * Get the evaluated view contents for a named view.
+         * Register a custom driver creator Closure.
          *
-         * @param string $view
-         * @param mixed $data
-         * @return \Illuminate\Contracts\View\View 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function of($view, $data = array()){
-            return \Illuminate\View\Factory::of($view, $data);
+        public static function extend($driver, $callback){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Notifications\ChannelManager::extend($driver, $callback);
         }
         
         /**
-         * Register a named view.
+         * Get all of the created "drivers".
          *
-         * @param string $view
-         * @param string $name
-         * @return void 
+         * @return array 
          * @static 
          */
-        public static function name($view, $name){
-            \Illuminate\View\Factory::name($view, $name);
+        public static function getDrivers(){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Illuminate\Notifications\ChannelManager::getDrivers();
         }
         
+    }
+
+
+    class JsValidator extends \Proengsoft\JsValidation\Facades\JsValidatorFacade{
+        
         /**
-         * Add an alias for a view.
+         * Creates JsValidator instance based on rules and message arrays.
          *
-         * @param string $view
-         * @param string $alias
-         * @return void 
+         * @param array $rules
+         * @param array $messages
+         * @param array $customAttributes
+         * @param null|string $selector
+         * @return \Proengsoft\JsValidation\JavascriptValidator 
          * @static 
          */
-        public static function alias($view, $alias){
-            \Illuminate\View\Factory::alias($view, $alias);
+        public static function make($rules, $messages = array(), $customAttributes = array(), $selector = null){
+            return \Proengsoft\JsValidation\JsValidatorFactory::make($rules, $messages, $customAttributes, $selector);
         }
         
         /**
-         * Determine if a given view exists.
+         * Creates JsValidator instance based on FormRequest.
          *
-         * @param string $view
-         * @return bool 
+         * @param $formRequest
+         * @param null $selector
+         * @return \Proengsoft\JsValidation\JavascriptValidator 
+         * @throws FormRequestArgumentException
          * @static 
          */
-        public static function exists($view){
-            return \Illuminate\View\Factory::exists($view);
+        public static function formRequest($formRequest, $selector = null){
+            return \Proengsoft\JsValidation\JsValidatorFactory::formRequest($formRequest, $selector);
         }
         
         /**
-         * Get the rendered contents of a partial from a loop.
+         * Creates JsValidator instance based on Validator.
          *
-         * @param string $view
-         * @param array $data
-         * @param string $iterator
-         * @param string $empty
-         * @return string 
+         * @param \Illuminate\Validation\Validator $validator
+         * @param string|null $selector
+         * @return \Proengsoft\JsValidation\JavascriptValidator 
          * @static 
          */
-        public static function renderEach($view, $data, $iterator, $empty = 'raw|'){
-            return \Illuminate\View\Factory::renderEach($view, $data, $iterator, $empty);
+        public static function validator($validator, $selector = null){
+            return \Proengsoft\JsValidation\JsValidatorFactory::validator($validator, $selector);
         }
         
+    }
+
+
+    class Socialite extends \Laravel\Socialite\Facades\Socialite{
+        
         /**
-         * Get the appropriate view engine for the given path.
+         * Get a driver instance.
          *
-         * @param string $path
-         * @return \Illuminate\View\Engines\EngineInterface 
-         * @throws \InvalidArgumentException
+         * @param string $driver
+         * @return mixed 
          * @static 
          */
-        public static function getEngineFromPath($path){
-            return \Illuminate\View\Factory::getEngineFromPath($path);
+        public static function with($driver){
+            return \Laravel\Socialite\SocialiteManager::with($driver);
         }
         
         /**
-         * Add a piece of shared data to the environment.
+         * Build an OAuth 2 provider instance.
          *
-         * @param array|string $key
-         * @param mixed $value
-         * @return mixed 
+         * @param string $provider
+         * @param array $config
+         * @return \Laravel\Socialite\Two\AbstractProvider 
          * @static 
          */
-        public static function share($key, $value = null){
-            return \Illuminate\View\Factory::share($key, $value);
+        public static function buildProvider($provider, $config){
+            return \Laravel\Socialite\SocialiteManager::buildProvider($provider, $config);
         }
         
         /**
-         * Register a view creator event.
+         * Format the server configuration.
          *
-         * @param array|string $views
-         * @param \Closure|string $callback
+         * @param array $config
          * @return array 
          * @static 
          */
-        public static function creator($views, $callback){
-            return \Illuminate\View\Factory::creator($views, $callback);
+        public static function formatConfig($config){
+            return \Laravel\Socialite\SocialiteManager::formatConfig($config);
         }
         
         /**
-         * Register multiple view composers via an array.
+         * Get the default driver name.
          *
-         * @param array $composers
-         * @return array 
+         * @throws \InvalidArgumentException
+         * @return string 
          * @static 
          */
-        public static function composers($composers){
-            return \Illuminate\View\Factory::composers($composers);
+        public static function getDefaultDriver(){
+            return \Laravel\Socialite\SocialiteManager::getDefaultDriver();
         }
         
         /**
-         * Register a view composer event.
+         * Get a driver instance.
          *
-         * @param array|string $views
-         * @param \Closure|string $callback
-         * @param int|null $priority
-         * @return array 
+         * @param string $driver
+         * @return mixed 
          * @static 
          */
-        public static function composer($views, $callback, $priority = null){
-            return \Illuminate\View\Factory::composer($views, $callback, $priority);
+        public static function driver($driver = null){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Laravel\Socialite\SocialiteManager::driver($driver);
         }
         
         /**
-         * Call the composer for a given view.
+         * Register a custom driver creator Closure.
          *
-         * @param \Illuminate\Contracts\View\View $view
-         * @return void 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function callComposer($view){
-            \Illuminate\View\Factory::callComposer($view);
+        public static function extend($driver, $callback){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Laravel\Socialite\SocialiteManager::extend($driver, $callback);
         }
         
         /**
-         * Call the creator for a given view.
+         * Get all of the created "drivers".
          *
-         * @param \Illuminate\Contracts\View\View $view
-         * @return void 
+         * @return array 
          * @static 
          */
-        public static function callCreator($view){
-            \Illuminate\View\Factory::callCreator($view);
+        public static function getDrivers(){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \Laravel\Socialite\SocialiteManager::getDrivers();
         }
         
+    }
+
+
+    class Form extends \Collective\Html\FormFacade{
+        
         /**
-         * Start injecting content into a section.
+         * Open up a new HTML form.
          *
-         * @param string $section
-         * @param string $content
-         * @return void 
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function startSection($section, $content = ''){
-            \Illuminate\View\Factory::startSection($section, $content);
+        public static function open($options = array()){
+            return \Collective\Html\FormBuilder::open($options);
         }
         
         /**
-         * Inject inline content into a section.
+         * Create a new model based form builder.
          *
-         * @param string $section
-         * @param string $content
-         * @return void 
+         * @param mixed $model
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function inject($section, $content){
-            \Illuminate\View\Factory::inject($section, $content);
+        public static function model($model, $options = array()){
+            return \Collective\Html\FormBuilder::model($model, $options);
         }
         
         /**
-         * Stop injecting content into a section and return its contents.
+         * Set the model instance on the form builder.
          *
-         * @return string 
+         * @param mixed $model
+         * @return void 
          * @static 
          */
-        public static function yieldSection(){
-            return \Illuminate\View\Factory::yieldSection();
+        public static function setModel($model){
+            \Collective\Html\FormBuilder::setModel($model);
         }
         
         /**
-         * Stop injecting content into a section.
+         * Close the current form.
          *
-         * @param bool $overwrite
          * @return string 
-         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function stopSection($overwrite = false){
-            return \Illuminate\View\Factory::stopSection($overwrite);
+        public static function close(){
+            return \Collective\Html\FormBuilder::close();
         }
         
         /**
-         * Stop injecting content into a section and append it.
+         * Generate a hidden field with the current CSRF token.
          *
          * @return string 
-         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function appendSection(){
-            return \Illuminate\View\Factory::appendSection();
+        public static function token(){
+            return \Collective\Html\FormBuilder::token();
         }
         
         /**
-         * Get the string contents of a section.
+         * Create a form label element.
          *
-         * @param string $section
-         * @param string $default
-         * @return string 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @param bool $escape_html
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function yieldContent($section, $default = ''){
-            return \Illuminate\View\Factory::yieldContent($section, $default);
+        public static function label($name, $value = null, $options = array(), $escape_html = true){
+            return \Collective\Html\FormBuilder::label($name, $value, $options, $escape_html);
         }
         
         /**
-         * Start injecting content into a push section.
+         * Create a form input field.
          *
-         * @param string $section
-         * @param string $content
-         * @return void 
+         * @param string $type
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function startPush($section, $content = ''){
-            \Illuminate\View\Factory::startPush($section, $content);
+        public static function input($type, $name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::input($type, $name, $value, $options);
         }
         
         /**
-         * Stop injecting content into a push section.
+         * Create a text input field.
          *
-         * @return string 
-         * @throws \InvalidArgumentException
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function stopPush(){
-            return \Illuminate\View\Factory::stopPush();
+        public static function text($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::text($name, $value, $options);
         }
         
         /**
-         * Get the string contents of a push section.
+         * Create a password input field.
          *
-         * @param string $section
-         * @param string $default
-         * @return string 
+         * @param string $name
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function yieldPushContent($section, $default = ''){
-            return \Illuminate\View\Factory::yieldPushContent($section, $default);
+        public static function password($name, $options = array()){
+            return \Collective\Html\FormBuilder::password($name, $options);
         }
         
         /**
-         * Flush all of the section contents.
+         * Create a hidden input field.
          *
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function flushSections(){
-            \Illuminate\View\Factory::flushSections();
+        public static function hidden($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::hidden($name, $value, $options);
         }
         
         /**
-         * Flush all of the section contents if done rendering.
+         * Create a search input field.
          *
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function flushSectionsIfDoneRendering(){
-            \Illuminate\View\Factory::flushSectionsIfDoneRendering();
+        public static function search($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::search($name, $value, $options);
         }
         
         /**
-         * Increment the rendering counter.
+         * Create an e-mail input field.
          *
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function incrementRender(){
-            \Illuminate\View\Factory::incrementRender();
+        public static function email($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::email($name, $value, $options);
         }
         
         /**
-         * Decrement the rendering counter.
+         * Create a tel input field.
          *
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function decrementRender(){
-            \Illuminate\View\Factory::decrementRender();
+        public static function tel($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::tel($name, $value, $options);
         }
         
         /**
-         * Check if there are no active render operations.
+         * Create a number input field.
          *
-         * @return bool 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function doneRendering(){
-            return \Illuminate\View\Factory::doneRendering();
+        public static function number($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::number($name, $value, $options);
         }
         
         /**
-         * Add new loop to the stack.
+         * Create a date input field.
          *
-         * @param \Countable|array $data
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function addLoop($data){
-            \Illuminate\View\Factory::addLoop($data);
+        public static function date($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::date($name, $value, $options);
         }
         
         /**
-         * Increment the top loop's indices.
+         * Create a datetime input field.
          *
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function incrementLoopIndices(){
-            \Illuminate\View\Factory::incrementLoopIndices();
+        public static function datetime($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::datetime($name, $value, $options);
         }
         
         /**
-         * Pop a loop from the top of the loop stack.
+         * Create a datetime-local input field.
          *
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function popLoop(){
-            \Illuminate\View\Factory::popLoop();
+        public static function datetimeLocal($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::datetimeLocal($name, $value, $options);
         }
         
         /**
-         * Get an instance of the first loop in the stack.
+         * Create a time input field.
          *
-         * @return array 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getFirstLoop(){
-            return \Illuminate\View\Factory::getFirstLoop();
+        public static function time($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::time($name, $value, $options);
         }
         
         /**
-         * Get the entire loop stack.
+         * Create a url input field.
          *
-         * @return array 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getLoopStack(){
-            return \Illuminate\View\Factory::getLoopStack();
+        public static function url($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::url($name, $value, $options);
         }
         
         /**
-         * Add a location to the array of view locations.
+         * Create a file input field.
          *
-         * @param string $location
-         * @return void 
+         * @param string $name
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function addLocation($location){
-            \Illuminate\View\Factory::addLocation($location);
+        public static function file($name, $options = array()){
+            return \Collective\Html\FormBuilder::file($name, $options);
         }
         
         /**
-         * Add a new namespace to the loader.
+         * Create a textarea input field.
          *
-         * @param string $namespace
-         * @param string|array $hints
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function addNamespace($namespace, $hints){
-            \Illuminate\View\Factory::addNamespace($namespace, $hints);
+        public static function textarea($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::textarea($name, $value, $options);
         }
         
         /**
-         * Prepend a new namespace to the loader.
+         * Create a select box field.
          *
-         * @param string $namespace
-         * @param string|array $hints
-         * @return void 
+         * @param string $name
+         * @param array $list
+         * @param string $selected
+         * @param array $selectAttributes
+         * @param array $optionsAttributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function prependNamespace($namespace, $hints){
-            \Illuminate\View\Factory::prependNamespace($namespace, $hints);
+        public static function select($name, $list = array(), $selected = null, $selectAttributes = array(), $optionsAttributes = array()){
+            return \Collective\Html\FormBuilder::select($name, $list, $selected, $selectAttributes, $optionsAttributes);
         }
         
         /**
-         * Register a valid view extension and its engine.
+         * Create a select range field.
          *
-         * @param string $extension
-         * @param string $engine
-         * @param \Closure $resolver
-         * @return void 
+         * @param string $name
+         * @param string $begin
+         * @param string $end
+         * @param string $selected
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function addExtension($extension, $engine, $resolver = null){
-            \Illuminate\View\Factory::addExtension($extension, $engine, $resolver);
+        public static function selectRange($name, $begin, $end, $selected = null, $options = array()){
+            return \Collective\Html\FormBuilder::selectRange($name, $begin, $end, $selected, $options);
         }
         
         /**
-         * Get the extension to engine bindings.
+         * Create a select year field.
          *
-         * @return array 
+         * @param string $name
+         * @param string $begin
+         * @param string $end
+         * @param string $selected
+         * @param array $options
+         * @return mixed 
          * @static 
          */
-        public static function getExtensions(){
-            return \Illuminate\View\Factory::getExtensions();
+        public static function selectYear(){
+            return \Collective\Html\FormBuilder::selectYear();
         }
         
         /**
-         * Get the engine resolver instance.
+         * Create a select month field.
          *
-         * @return \Illuminate\View\Engines\EngineResolver 
+         * @param string $name
+         * @param string $selected
+         * @param array $options
+         * @param string $format
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getEngineResolver(){
-            return \Illuminate\View\Factory::getEngineResolver();
+        public static function selectMonth($name, $selected = null, $options = array(), $format = '%B'){
+            return \Collective\Html\FormBuilder::selectMonth($name, $selected, $options, $format);
         }
         
         /**
-         * Get the view finder instance.
+         * Get the select option for the given value.
          *
-         * @return \Illuminate\View\ViewFinderInterface 
+         * @param string $display
+         * @param string $value
+         * @param string $selected
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getFinder(){
-            return \Illuminate\View\Factory::getFinder();
+        public static function getSelectOption($display, $value, $selected, $attributes = array()){
+            return \Collective\Html\FormBuilder::getSelectOption($display, $value, $selected, $attributes);
         }
         
         /**
-         * Set the view finder instance.
+         * Create a checkbox input field.
          *
-         * @param \Illuminate\View\ViewFinderInterface $finder
-         * @return void 
+         * @param string $name
+         * @param mixed $value
+         * @param bool $checked
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function setFinder($finder){
-            \Illuminate\View\Factory::setFinder($finder);
+        public static function checkbox($name, $value = 1, $checked = null, $options = array()){
+            return \Collective\Html\FormBuilder::checkbox($name, $value, $checked, $options);
         }
         
         /**
-         * Get the event dispatcher instance.
+         * Create a radio button input field.
          *
-         * @return \Illuminate\Contracts\Events\Dispatcher 
+         * @param string $name
+         * @param mixed $value
+         * @param bool $checked
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getDispatcher(){
-            return \Illuminate\View\Factory::getDispatcher();
+        public static function radio($name, $value = null, $checked = null, $options = array()){
+            return \Collective\Html\FormBuilder::radio($name, $value, $checked, $options);
         }
         
         /**
-         * Set the event dispatcher instance.
+         * Create a HTML reset input element.
          *
-         * @param \Illuminate\Contracts\Events\Dispatcher $events
-         * @return void 
+         * @param string $value
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function setDispatcher($events){
-            \Illuminate\View\Factory::setDispatcher($events);
+        public static function reset($value, $attributes = array()){
+            return \Collective\Html\FormBuilder::reset($value, $attributes);
         }
         
         /**
-         * Get the IoC container instance.
+         * Create a HTML image input element.
          *
-         * @return \Illuminate\Contracts\Container\Container 
+         * @param string $url
+         * @param string $name
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getContainer(){
-            return \Illuminate\View\Factory::getContainer();
+        public static function image($url, $name = null, $attributes = array()){
+            return \Collective\Html\FormBuilder::image($url, $name, $attributes);
         }
         
         /**
-         * Set the IoC container instance.
+         * Create a color input field.
          *
-         * @param \Illuminate\Contracts\Container\Container $container
-         * @return void 
+         * @param string $name
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function setContainer($container){
-            \Illuminate\View\Factory::setContainer($container);
+        public static function color($name, $value = null, $options = array()){
+            return \Collective\Html\FormBuilder::color($name, $value, $options);
         }
         
         /**
-         * Get an item from the shared data.
+         * Create a submit button element.
          *
-         * @param string $key
-         * @param mixed $default
-         * @return mixed 
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function shared($key, $default = null){
-            return \Illuminate\View\Factory::shared($key, $default);
+        public static function submit($value = null, $options = array()){
+            return \Collective\Html\FormBuilder::submit($value, $options);
         }
         
         /**
-         * Get all of the shared data for the environment.
+         * Create a button element.
          *
-         * @return array 
+         * @param string $value
+         * @param array $options
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getShared(){
-            return \Illuminate\View\Factory::getShared();
+        public static function button($value = null, $options = array()){
+            return \Collective\Html\FormBuilder::button($value, $options);
         }
         
         /**
-         * Check if section exists.
+         * Get the ID attribute for a field name.
          *
          * @param string $name
-         * @return bool 
+         * @param array $attributes
+         * @return string 
          * @static 
          */
-        public static function hasSection($name){
-            return \Illuminate\View\Factory::hasSection($name);
+        public static function getIdAttribute($name, $attributes){
+            return \Collective\Html\FormBuilder::getIdAttribute($name, $attributes);
         }
         
         /**
-         * Get the entire array of sections.
+         * Get the value that should be assigned to the field.
          *
-         * @return array 
+         * @param string $name
+         * @param string $value
+         * @return mixed 
          * @static 
          */
-        public static function getSections(){
-            return \Illuminate\View\Factory::getSections();
+        public static function getValueAttribute($name, $value = null){
+            return \Collective\Html\FormBuilder::getValueAttribute($name, $value);
         }
         
         /**
-         * Get all of the registered named views in environment.
+         * Get a value from the session's old input.
          *
-         * @return array 
+         * @param string $name
+         * @return mixed 
          * @static 
          */
-        public static function getNames(){
-            return \Illuminate\View\Factory::getNames();
+        public static function old($name){
+            return \Collective\Html\FormBuilder::old($name);
         }
         
-    }
-
-
-    class Notification extends \Illuminate\Support\Facades\Notification{
-        
         /**
-         * Send the given notification to the given notifiable entities.
+         * Determine if the old input is empty.
          *
-         * @param \Illuminate\Support\Collection|array|mixed $notifiables
-         * @param mixed $notification
-         * @return void 
+         * @return bool 
          * @static 
          */
-        public static function send($notifiables, $notification){
-            \Illuminate\Notifications\ChannelManager::send($notifiables, $notification);
+        public static function oldInputIsEmpty(){
+            return \Collective\Html\FormBuilder::oldInputIsEmpty();
         }
         
         /**
-         * Send the given notification immediately.
+         * Get the session store implementation.
          *
-         * @param \Illuminate\Support\Collection|array|mixed $notifiables
-         * @param mixed $notification
-         * @return void 
+         * @return \Illuminate\Contracts\Session\Session $session
          * @static 
          */
-        public static function sendNow($notifiables, $notification){
-            \Illuminate\Notifications\ChannelManager::sendNow($notifiables, $notification);
+        public static function getSessionStore(){
+            return \Collective\Html\FormBuilder::getSessionStore();
         }
         
         /**
-         * Get a channel instance.
+         * Set the session store implementation.
          *
-         * @param string|null $name
-         * @return mixed 
+         * @param \Illuminate\Contracts\Session\Session $session
+         * @return $this 
          * @static 
          */
-        public static function channel($name = null){
-            return \Illuminate\Notifications\ChannelManager::channel($name);
+        public static function setSessionStore($session){
+            return \Collective\Html\FormBuilder::setSessionStore($session);
         }
         
         /**
-         * Get the default channel driver name.
+         * Register a custom macro.
          *
-         * @return string 
+         * @param string $name
+         * @param callable $macro
+         * @return void 
          * @static 
          */
-        public static function getDefaultDriver(){
-            return \Illuminate\Notifications\ChannelManager::getDefaultDriver();
+        public static function macro($name, $macro){
+            \Collective\Html\FormBuilder::macro($name, $macro);
         }
         
         /**
-         * Get the default channel driver name.
+         * Checks if macro is registered.
          *
-         * @return string 
+         * @param string $name
+         * @return bool 
          * @static 
          */
-        public static function deliversVia(){
-            return \Illuminate\Notifications\ChannelManager::deliversVia();
+        public static function hasMacro($name){
+            return \Collective\Html\FormBuilder::hasMacro($name);
         }
         
         /**
-         * Set the default channel driver name.
+         * Dynamically handle calls to the class.
          *
-         * @param string $channel
-         * @return void 
+         * @param string $method
+         * @param array $parameters
+         * @return mixed 
+         * @throws \BadMethodCallException
          * @static 
          */
-        public static function deliverVia($channel){
-            \Illuminate\Notifications\ChannelManager::deliverVia($channel);
+        public static function macroCall($method, $parameters){
+            return \Collective\Html\FormBuilder::macroCall($method, $parameters);
         }
         
         /**
-         * Get a driver instance.
+         * Register a custom component.
          *
-         * @param string $driver
-         * @return mixed 
+         * @param $name
+         * @param $view
+         * @param array $signature
+         * @return void 
          * @static 
          */
-        public static function driver($driver = null){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Notifications\ChannelManager::driver($driver);
+        public static function component($name, $view, $signature){
+            \Collective\Html\FormBuilder::component($name, $view, $signature);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Check if a component is registered.
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @param $name
+         * @return bool 
          * @static 
          */
-        public static function extend($driver, $callback){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Notifications\ChannelManager::extend($driver, $callback);
+        public static function hasComponent($name){
+            return \Collective\Html\FormBuilder::hasComponent($name);
         }
         
         /**
-         * Get all of the created "drivers".
+         * Dynamically handle calls to the class.
          *
-         * @return array 
+         * @param string $method
+         * @param array $parameters
+         * @return \Illuminate\Contracts\View\View|mixed 
+         * @throws \BadMethodCallException
          * @static 
          */
-        public static function getDrivers(){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Illuminate\Notifications\ChannelManager::getDrivers();
+        public static function componentCall($method, $parameters){
+            return \Collective\Html\FormBuilder::componentCall($method, $parameters);
         }
         
     }
 
 
-    class JsValidator extends \Proengsoft\JsValidation\Facades\JsValidatorFacade{
+    class HTML extends \Collective\Html\HtmlFacade{
         
         /**
-         * Creates JsValidator instance based on rules and message arrays.
+         * Convert an HTML string to entities.
          *
-         * @param array $rules
-         * @param array $messages
-         * @param array $customAttributes
-         * @param null|string $selector
-         * @return \Proengsoft\JsValidation\JavascriptValidator 
+         * @param string $value
+         * @return string 
          * @static 
          */
-        public static function make($rules, $messages = array(), $customAttributes = array(), $selector = null){
-            return \Proengsoft\JsValidation\JsValidatorFactory::make($rules, $messages, $customAttributes, $selector);
+        public static function entities($value){
+            return \Collective\Html\HtmlBuilder::entities($value);
         }
         
         /**
-         * Creates JsValidator instance based on FormRequest.
+         * Convert entities to HTML characters.
          *
-         * @param $formRequest
-         * @param null $selector
-         * @return \Proengsoft\JsValidation\JavascriptValidator 
-         * @throws FormRequestArgumentException
+         * @param string $value
+         * @return string 
          * @static 
          */
-        public static function formRequest($formRequest, $selector = null){
-            return \Proengsoft\JsValidation\JsValidatorFactory::formRequest($formRequest, $selector);
+        public static function decode($value){
+            return \Collective\Html\HtmlBuilder::decode($value);
         }
         
         /**
-         * Creates JsValidator instance based on Validator.
+         * Generate a link to a JavaScript file.
          *
-         * @param \Illuminate\Validation\Validator $validator
-         * @param string|null $selector
-         * @return \Proengsoft\JsValidation\JavascriptValidator 
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function validator($validator, $selector = null){
-            return \Proengsoft\JsValidation\JsValidatorFactory::validator($validator, $selector);
+        public static function script($url, $attributes = array(), $secure = null){
+            return \Collective\Html\HtmlBuilder::script($url, $attributes, $secure);
         }
         
-    }
-
-
-    class Socialite extends \Laravel\Socialite\Facades\Socialite{
-        
         /**
-         * Get a driver instance.
+         * Generate a link to a CSS file.
          *
-         * @param string $driver
-         * @return mixed 
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function with($driver){
-            return \Laravel\Socialite\SocialiteManager::with($driver);
+        public static function style($url, $attributes = array(), $secure = null){
+            return \Collective\Html\HtmlBuilder::style($url, $attributes, $secure);
         }
         
         /**
-         * Build an OAuth 2 provider instance.
+         * Generate an HTML image element.
          *
-         * @param string $provider
-         * @param array $config
-         * @return \Laravel\Socialite\Two\AbstractProvider 
+         * @param string $url
+         * @param string $alt
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function buildProvider($provider, $config){
-            return \Laravel\Socialite\SocialiteManager::buildProvider($provider, $config);
+        public static function image($url, $alt = null, $attributes = array(), $secure = null){
+            return \Collective\Html\HtmlBuilder::image($url, $alt, $attributes, $secure);
         }
         
         /**
-         * Format the server configuration.
+         * Generate a link to a Favicon file.
          *
-         * @param array $config
-         * @return array 
+         * @param string $url
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function formatConfig($config){
-            return \Laravel\Socialite\SocialiteManager::formatConfig($config);
+        public static function favicon($url, $attributes = array(), $secure = null){
+            return \Collective\Html\HtmlBuilder::favicon($url, $attributes, $secure);
         }
         
         /**
-         * Get the default driver name.
+         * Generate a HTML link.
          *
-         * @throws \InvalidArgumentException
-         * @return string 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @param bool $secure
+         * @param bool $escape
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getDefaultDriver(){
-            return \Laravel\Socialite\SocialiteManager::getDefaultDriver();
+        public static function link($url, $title = null, $attributes = array(), $secure = null, $escape = true){
+            return \Collective\Html\HtmlBuilder::link($url, $title, $attributes, $secure, $escape);
         }
         
         /**
-         * Get a driver instance.
+         * Generate a HTTPS HTML link.
          *
-         * @param string $driver
-         * @return mixed 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function driver($driver = null){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Laravel\Socialite\SocialiteManager::driver($driver);
+        public static function secureLink($url, $title = null, $attributes = array()){
+            return \Collective\Html\HtmlBuilder::secureLink($url, $title, $attributes);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Generate a HTML link to an asset.
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @param bool $secure
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function extend($driver, $callback){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Laravel\Socialite\SocialiteManager::extend($driver, $callback);
+        public static function linkAsset($url, $title = null, $attributes = array(), $secure = null){
+            return \Collective\Html\HtmlBuilder::linkAsset($url, $title, $attributes, $secure);
         }
         
         /**
-         * Get all of the created "drivers".
+         * Generate a HTTPS HTML link to an asset.
          *
-         * @return array 
+         * @param string $url
+         * @param string $title
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function getDrivers(){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \Laravel\Socialite\SocialiteManager::getDrivers();
+        public static function linkSecureAsset($url, $title = null, $attributes = array()){
+            return \Collective\Html\HtmlBuilder::linkSecureAsset($url, $title, $attributes);
         }
         
-    }
-
-
-    class Form extends \Collective\Html\FormFacade{
-        
         /**
-         * Open up a new HTML form.
+         * Generate a HTML link to a named route.
          *
-         * @param array $options
+         * @param string $name
+         * @param string $title
+         * @param array $parameters
+         * @param array $attributes
          * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function open($options = array()){
-            return \Collective\Html\FormBuilder::open($options);
+        public static function linkRoute($name, $title = null, $parameters = array(), $attributes = array()){
+            return \Collective\Html\HtmlBuilder::linkRoute($name, $title, $parameters, $attributes);
         }
         
         /**
-         * Create a new model based form builder.
+         * Generate a HTML link to a controller action.
          *
-         * @param mixed $model
-         * @param array $options
+         * @param string $action
+         * @param string $title
+         * @param array $parameters
+         * @param array $attributes
          * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function model($model, $options = array()){
-            return \Collective\Html\FormBuilder::model($model, $options);
+        public static function linkAction($action, $title = null, $parameters = array(), $attributes = array()){
+            return \Collective\Html\HtmlBuilder::linkAction($action, $title, $parameters, $attributes);
         }
         
         /**
-         * Set the model instance on the form builder.
+         * Generate a HTML link to an email address.
          *
-         * @param mixed $model
-         * @return void 
+         * @param string $email
+         * @param string $title
+         * @param array $attributes
+         * @param bool $escape
+         * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function setModel($model){
-            \Collective\Html\FormBuilder::setModel($model);
+        public static function mailto($email, $title = null, $attributes = array(), $escape = true){
+            return \Collective\Html\HtmlBuilder::mailto($email, $title, $attributes, $escape);
         }
         
         /**
-         * Close the current form.
+         * Obfuscate an e-mail address to prevent spam-bots from sniffing it.
          *
+         * @param string $email
          * @return string 
          * @static 
          */
-        public static function close(){
-            return \Collective\Html\FormBuilder::close();
+        public static function email($email){
+            return \Collective\Html\HtmlBuilder::email($email);
         }
         
         /**
-         * Generate a hidden field with the current CSRF token.
+         * Generates non-breaking space entities based on number supplied.
          *
+         * @param int $num
          * @return string 
          * @static 
          */
-        public static function token(){
-            return \Collective\Html\FormBuilder::token();
+        public static function nbsp($num = 1){
+            return \Collective\Html\HtmlBuilder::nbsp($num);
         }
         
         /**
-         * Create a form label element.
+         * Generate an ordered list of items.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @param bool $escape_html
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $list
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString|string 
          * @static 
          */
-        public static function label($name, $value = null, $options = array(), $escape_html = true){
-            return \Collective\Html\FormBuilder::label($name, $value, $options, $escape_html);
+        public static function ol($list, $attributes = array()){
+            return \Collective\Html\HtmlBuilder::ol($list, $attributes);
         }
         
         /**
-         * Create a form input field.
+         * Generate an un-ordered list of items.
          *
-         * @param string $type
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $list
+         * @param array $attributes
+         * @return \Illuminate\Support\HtmlString|string 
          * @static 
          */
-        public static function input($type, $name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::input($type, $name, $value, $options);
+        public static function ul($list, $attributes = array()){
+            return \Collective\Html\HtmlBuilder::ul($list, $attributes);
         }
         
         /**
-         * Create a text input field.
+         * Generate a description list of items.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
+         * @param array $list
+         * @param array $attributes
          * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function text($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::text($name, $value, $options);
+        public static function dl($list, $attributes = array()){
+            return \Collective\Html\HtmlBuilder::dl($list, $attributes);
         }
         
         /**
-         * Create a password input field.
+         * Build an HTML attribute string from an array.
          *
-         * @param string $name
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $attributes
+         * @return string 
          * @static 
          */
-        public static function password($name, $options = array()){
-            return \Collective\Html\FormBuilder::password($name, $options);
+        public static function attributes($attributes){
+            return \Collective\Html\HtmlBuilder::attributes($attributes);
         }
         
         /**
-         * Create a hidden input field.
+         * Obfuscate a string to prevent spam-bots from sniffing it.
          *
-         * @param string $name
          * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return string 
          * @static 
          */
-        public static function hidden($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::hidden($name, $value, $options);
+        public static function obfuscate($value){
+            return \Collective\Html\HtmlBuilder::obfuscate($value);
         }
         
         /**
-         * Create an e-mail input field.
+         * Generate a meta tag.
          *
          * @param string $name
-         * @param string $value
-         * @param array $options
+         * @param string $content
+         * @param array $attributes
          * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function email($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::email($name, $value, $options);
+        public static function meta($name, $content, $attributes = array()){
+            return \Collective\Html\HtmlBuilder::meta($name, $content, $attributes);
         }
         
         /**
-         * Create a tel input field.
+         * Generate an html tag.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
+         * @param string $tag
+         * @param mixed $content
+         * @param array $attributes
          * @return \Illuminate\Support\HtmlString 
          * @static 
          */
-        public static function tel($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::tel($name, $value, $options);
+        public static function tag($tag, $content, $attributes = array()){
+            return \Collective\Html\HtmlBuilder::tag($tag, $content, $attributes);
         }
         
         /**
-         * Create a number input field.
+         * Register a custom macro.
          *
          * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param callable $macro
+         * @return void 
          * @static 
          */
-        public static function number($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::number($name, $value, $options);
+        public static function macro($name, $macro){
+            \Collective\Html\HtmlBuilder::macro($name, $macro);
         }
         
         /**
-         * Create a date input field.
+         * Checks if macro is registered.
          *
          * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool 
          * @static 
          */
-        public static function date($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::date($name, $value, $options);
+        public static function hasMacro($name){
+            return \Collective\Html\HtmlBuilder::hasMacro($name);
         }
         
         /**
-         * Create a datetime input field.
+         * Dynamically handle calls to the class.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param string $method
+         * @param array $parameters
+         * @return mixed 
+         * @throws \BadMethodCallException
          * @static 
          */
-        public static function datetime($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::datetime($name, $value, $options);
+        public static function macroCall($method, $parameters){
+            return \Collective\Html\HtmlBuilder::macroCall($method, $parameters);
         }
         
         /**
-         * Create a datetime-local input field.
+         * Register a custom component.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param $name
+         * @param $view
+         * @param array $signature
+         * @return void 
          * @static 
          */
-        public static function datetimeLocal($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::datetimeLocal($name, $value, $options);
+        public static function component($name, $view, $signature){
+            \Collective\Html\HtmlBuilder::component($name, $view, $signature);
         }
         
         /**
-         * Create a time input field.
+         * Check if a component is registered.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param $name
+         * @return bool 
          * @static 
          */
-        public static function time($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::time($name, $value, $options);
+        public static function hasComponent($name){
+            return \Collective\Html\HtmlBuilder::hasComponent($name);
         }
         
         /**
-         * Create a url input field.
+         * Dynamically handle calls to the class.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param string $method
+         * @param array $parameters
+         * @return \Illuminate\Contracts\View\View|mixed 
+         * @throws \BadMethodCallException
          * @static 
          */
-        public static function url($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::url($name, $value, $options);
+        public static function componentCall($method, $parameters){
+            return \Collective\Html\HtmlBuilder::componentCall($method, $parameters);
         }
         
+    }
+
+
+    class Countries extends \Webpatser\Countries\CountriesFacade{
+        
         /**
-         * Create a file input field.
+         * Returns one country
          *
-         * @param string $name
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param string $id The country id
+         * @return array 
          * @static 
          */
-        public static function file($name, $options = array()){
-            return \Collective\Html\FormBuilder::file($name, $options);
+        public static function getOne($id){
+            return \Webpatser\Countries\Countries::getOne($id);
         }
         
         /**
-         * Create a textarea input field.
+         * Returns a list of countries
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param string  sort
+         * @return array 
          * @static 
          */
-        public static function textarea($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::textarea($name, $value, $options);
+        public static function getList($sort = null){
+            return \Webpatser\Countries\Countries::getList($sort);
         }
         
         /**
-         * Create a select box field.
+         * Returns a list of countries suitable to use with a select element in Laravelcollective\html
+         * Will show the value and sort by the column specified in the display attribute
          *
-         * @param string $name
-         * @param array $list
-         * @param string $selected
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param string  display
+         * @return array 
          * @static 
          */
-        public static function select($name, $list = array(), $selected = null, $options = array()){
-            return \Collective\Html\FormBuilder::select($name, $list, $selected, $options);
+        public static function getListForSelect($display = 'name'){
+            return \Webpatser\Countries\Countries::getListForSelect($display);
         }
         
         /**
-         * Create a select range field.
+         * Clear the list of booted models so they will be re-booted.
          *
-         * @param string $name
-         * @param string $begin
-         * @param string $end
-         * @param string $selected
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return void 
          * @static 
          */
-        public static function selectRange($name, $begin, $end, $selected = null, $options = array()){
-            return \Collective\Html\FormBuilder::selectRange($name, $begin, $end, $selected, $options);
+        public static function clearBootedModels(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::clearBootedModels();
         }
         
         /**
-         * Create a select year field.
+         * Fill the model with an array of attributes.
          *
-         * @param string $name
-         * @param string $begin
-         * @param string $end
-         * @param string $selected
-         * @param array $options
-         * @return mixed 
+         * @param array $attributes
+         * @return $this 
+         * @throws \Illuminate\Database\Eloquent\MassAssignmentException
          * @static 
          */
-        public static function selectYear(){
-            return \Collective\Html\FormBuilder::selectYear();
+        public static function fill($attributes){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::fill($attributes);
         }
         
         /**
-         * Create a select month field.
+         * Fill the model with an array of attributes. Force mass assignment.
          *
-         * @param string $name
-         * @param string $selected
-         * @param array $options
-         * @param string $format
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $attributes
+         * @return $this 
          * @static 
          */
-        public static function selectMonth($name, $selected = null, $options = array(), $format = '%B'){
-            return \Collective\Html\FormBuilder::selectMonth($name, $selected, $options, $format);
+        public static function forceFill($attributes){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::forceFill($attributes);
         }
         
         /**
-         * Get the select option for the given value.
+         * Create a new instance of the given model.
          *
-         * @param string $display
-         * @param string $value
-         * @param string $selected
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $attributes
+         * @param bool $exists
+         * @return static 
          * @static 
          */
-        public static function getSelectOption($display, $value, $selected){
-            return \Collective\Html\FormBuilder::getSelectOption($display, $value, $selected);
+        public static function newInstance($attributes = array(), $exists = false){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newInstance($attributes, $exists);
         }
         
         /**
-         * Create a checkbox input field.
+         * Create a new model instance that is existing.
          *
-         * @param string $name
-         * @param mixed $value
-         * @param bool $checked
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array $attributes
+         * @param string|null $connection
+         * @return static 
          * @static 
          */
-        public static function checkbox($name, $value = 1, $checked = null, $options = array()){
-            return \Collective\Html\FormBuilder::checkbox($name, $value, $checked, $options);
+        public static function newFromBuilder($attributes = array(), $connection = null){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newFromBuilder($attributes, $connection);
         }
         
         /**
-         * Create a radio button input field.
+         * Begin querying the model on a given connection.
          *
-         * @param string $name
-         * @param mixed $value
-         * @param bool $checked
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param string|null $connection
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
          */
-        public static function radio($name, $value = null, $checked = null, $options = array()){
-            return \Collective\Html\FormBuilder::radio($name, $value, $checked, $options);
+        public static function on($connection = null){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::on($connection);
         }
         
         /**
-         * Create a HTML reset input element.
+         * Begin querying the model on the write connection.
          *
-         * @param string $value
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return \Illuminate\Database\Query\Builder 
          * @static 
          */
-        public static function reset($value, $attributes = array()){
-            return \Collective\Html\FormBuilder::reset($value, $attributes);
+        public static function onWriteConnection(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::onWriteConnection();
         }
         
         /**
-         * Create a HTML image input element.
+         * Get all of the models from the database.
          *
-         * @param string $url
-         * @param string $name
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|mixed $columns
+         * @return \Illuminate\Database\Eloquent\Collection|static[] 
          * @static 
          */
-        public static function image($url, $name = null, $attributes = array()){
-            return \Collective\Html\FormBuilder::image($url, $name, $attributes);
+        public static function all($columns = array()){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::all($columns);
         }
         
         /**
-         * Create a color input field.
+         * Begin querying a model with eager loading.
          *
-         * @param string $name
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|string $relations
+         * @return \Illuminate\Database\Eloquent\Builder|static 
          * @static 
          */
-        public static function color($name, $value = null, $options = array()){
-            return \Collective\Html\FormBuilder::color($name, $value, $options);
+        public static function with($relations){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::with($relations);
         }
         
         /**
-         * Create a submit button element.
+         * Eager load relations on the model.
          *
-         * @param string $value
-         * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|string $relations
+         * @return $this 
          * @static 
          */
-        public static function submit($value = null, $options = array()){
-            return \Collective\Html\FormBuilder::submit($value, $options);
+        public static function load($relations){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::load($relations);
         }
         
         /**
-         * Create a button element.
+         * Update the model in the database.
          *
-         * @param string $value
+         * @param array $attributes
          * @param array $options
-         * @return \Illuminate\Support\HtmlString 
+         * @return bool 
          * @static 
          */
-        public static function button($value = null, $options = array()){
-            return \Collective\Html\FormBuilder::button($value, $options);
+        public static function update($attributes = array(), $options = array()){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::update($attributes, $options);
         }
         
         /**
-         * Get the ID attribute for a field name.
+         * Save the model and all of its relationships.
          *
-         * @param string $name
-         * @param array $attributes
-         * @return string 
+         * @return bool 
          * @static 
          */
-        public static function getIdAttribute($name, $attributes){
-            return \Collective\Html\FormBuilder::getIdAttribute($name, $attributes);
+        public static function push(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::push();
         }
         
         /**
-         * Get the value that should be assigned to the field.
+         * Save the model to the database.
          *
-         * @param string $name
-         * @param string $value
-         * @return mixed 
+         * @param array $options
+         * @return bool 
          * @static 
          */
-        public static function getValueAttribute($name, $value = null){
-            return \Collective\Html\FormBuilder::getValueAttribute($name, $value);
+        public static function save($options = array()){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::save($options);
         }
         
         /**
-         * Get a value from the session's old input.
+         * Save the model to the database using transaction.
          *
-         * @param string $name
-         * @return mixed 
+         * @param array $options
+         * @return bool 
+         * @throws \Throwable
          * @static 
          */
-        public static function old($name){
-            return \Collective\Html\FormBuilder::old($name);
+        public static function saveOrFail($options = array()){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::saveOrFail($options);
         }
         
         /**
-         * Determine if the old input is empty.
+         * Destroy the models for the given IDs.
          *
-         * @return bool 
+         * @param array|int $ids
+         * @return int 
          * @static 
          */
-        public static function oldInputIsEmpty(){
-            return \Collective\Html\FormBuilder::oldInputIsEmpty();
+        public static function destroy($ids){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::destroy($ids);
         }
         
         /**
-         * Get the session store implementation.
+         * Delete the model from the database.
          *
-         * @return \Illuminate\Session\SessionInterface $session
+         * @return bool|null 
+         * @throws \Exception
          * @static 
          */
-        public static function getSessionStore(){
-            return \Collective\Html\FormBuilder::getSessionStore();
+        public static function delete(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::delete();
         }
         
         /**
-         * Set the session store implementation.
+         * Force a hard delete on a soft deleted model.
+         * 
+         * This method protects developers from running forceDelete when trait is missing.
          *
-         * @param \Illuminate\Session\SessionInterface $session
-         * @return $this 
+         * @return bool|null 
          * @static 
          */
-        public static function setSessionStore($session){
-            return \Collective\Html\FormBuilder::setSessionStore($session);
+        public static function forceDelete(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::forceDelete();
         }
         
         /**
-         * Register a custom macro.
+         * Begin querying the model.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
          */
-        public static function macro($name, $macro){
-            \Collective\Html\FormBuilder::macro($name, $macro);
+        public static function query(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::query();
         }
         
         /**
-         * Checks if macro is registered.
+         * Get a new query builder for the model's table.
          *
-         * @param string $name
-         * @return bool 
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
          */
-        public static function hasMacro($name){
-            return \Collective\Html\FormBuilder::hasMacro($name);
+        public static function newQuery(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newQuery();
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Get a new query builder that doesn't have any global scopes.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return mixed 
-         * @throws \BadMethodCallException
+         * @return \Illuminate\Database\Eloquent\Builder|static 
          * @static 
          */
-        public static function macroCall($method, $parameters){
-            return \Collective\Html\FormBuilder::macroCall($method, $parameters);
+        public static function newQueryWithoutScopes(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newQueryWithoutScopes();
         }
         
         /**
-         * Register a custom component.
+         * Get a new query instance without a given scope.
          *
-         * @param $name
-         * @param $view
-         * @param array $signature
-         * @return void 
+         * @param \Illuminate\Database\Eloquent\Scope|string $scope
+         * @return \Illuminate\Database\Eloquent\Builder 
          * @static 
          */
-        public static function component($name, $view, $signature){
-            \Collective\Html\FormBuilder::component($name, $view, $signature);
+        public static function newQueryWithoutScope($scope){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newQueryWithoutScope($scope);
         }
         
         /**
-         * Check if a component is registered.
+         * Create a new Eloquent query builder for the model.
          *
-         * @param $name
-         * @return bool 
+         * @param \Illuminate\Database\Query\Builder $query
+         * @return \Illuminate\Database\Eloquent\Builder|static 
          * @static 
          */
-        public static function hasComponent($name){
-            return \Collective\Html\FormBuilder::hasComponent($name);
+        public static function newEloquentBuilder($query){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newEloquentBuilder($query);
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Create a new Eloquent Collection instance.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return \Illuminate\Contracts\View\View|mixed 
-         * @throws \BadMethodCallException
+         * @param array $models
+         * @return \Illuminate\Database\Eloquent\Collection 
          * @static 
          */
-        public static function componentCall($method, $parameters){
-            return \Collective\Html\FormBuilder::componentCall($method, $parameters);
+        public static function newCollection($models = array()){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newCollection($models);
         }
         
-    }
-
-
-    class HTML extends \Collective\Html\HtmlFacade{
-        
         /**
-         * Convert an HTML string to entities.
+         * Create a new pivot model instance.
          *
-         * @param string $value
-         * @return string 
+         * @param \Illuminate\Database\Eloquent\Model $parent
+         * @param array $attributes
+         * @param string $table
+         * @param bool $exists
+         * @param string|null $using
+         * @return \Illuminate\Database\Eloquent\Relations\Pivot 
          * @static 
          */
-        public static function entities($value){
-            return \Collective\Html\HtmlBuilder::entities($value);
+        public static function newPivot($parent, $attributes, $table, $exists, $using = null){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::newPivot($parent, $attributes, $table, $exists, $using);
         }
         
         /**
-         * Convert entities to HTML characters.
+         * Convert the model instance to an array.
          *
-         * @param string $value
-         * @return string 
+         * @return array 
          * @static 
          */
-        public static function decode($value){
-            return \Collective\Html\HtmlBuilder::decode($value);
+        public static function toArray(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::toArray();
         }
         
         /**
-         * Generate a link to a JavaScript file.
+         * Convert the model instance to JSON.
          *
-         * @param string $url
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @param int $options
+         * @return string 
+         * @throws \Illuminate\Database\Eloquent\JsonEncodingException
          * @static 
          */
-        public static function script($url, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::script($url, $attributes, $secure);
+        public static function toJson($options = 0){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::toJson($options);
         }
         
         /**
-         * Generate a link to a CSS file.
+         * Convert the object into something JSON serializable.
          *
-         * @param string $url
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @return array 
          * @static 
          */
-        public static function style($url, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::style($url, $attributes, $secure);
+        public static function jsonSerialize(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::jsonSerialize();
         }
         
         /**
-         * Generate an HTML image element.
+         * Reload a fresh model instance from the database.
          *
-         * @param string $url
-         * @param string $alt
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|string $with
+         * @return static|null 
          * @static 
          */
-        public static function image($url, $alt = null, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::image($url, $alt, $attributes, $secure);
+        public static function fresh($with = array()){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::fresh($with);
         }
         
         /**
-         * Generate a link to a Favicon file.
+         * Reload the current model instance with fresh attributes from the database.
          *
-         * @param string $url
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @return void 
          * @static 
          */
-        public static function favicon($url, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::favicon($url, $attributes, $secure);
+        public static function refresh(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::refresh();
         }
         
         /**
-         * Generate a HTML link.
+         * Clone the model into a new, non-existing instance.
          *
-         * @param string $url
-         * @param string $title
-         * @param array $attributes
-         * @param bool $secure
-         * @param bool $escape
-         * @return \Illuminate\Support\HtmlString 
+         * @param array|null $except
+         * @return \Illuminate\Database\Eloquent\Model 
          * @static 
          */
-        public static function link($url, $title = null, $attributes = array(), $secure = null, $escape = true){
-            return \Collective\Html\HtmlBuilder::link($url, $title, $attributes, $secure, $escape);
+        public static function replicate($except = null){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::replicate($except);
         }
         
         /**
-         * Generate a HTTPS HTML link.
+         * Determine if two models have the same ID and belong to the same table.
          *
-         * @param string $url
-         * @param string $title
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @param \Illuminate\Database\Eloquent\Model $model
+         * @return bool 
          * @static 
          */
-        public static function secureLink($url, $title = null, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::secureLink($url, $title, $attributes);
+        public static function is($model){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::is($model);
         }
         
         /**
-         * Generate a HTML link to an asset.
+         * Get the database connection for the model.
          *
-         * @param string $url
-         * @param string $title
-         * @param array $attributes
-         * @param bool $secure
-         * @return \Illuminate\Support\HtmlString 
+         * @return \Illuminate\Database\Connection 
          * @static 
          */
-        public static function linkAsset($url, $title = null, $attributes = array(), $secure = null){
-            return \Collective\Html\HtmlBuilder::linkAsset($url, $title, $attributes, $secure);
+        public static function getConnection(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getConnection();
         }
         
         /**
-         * Generate a HTTPS HTML link to an asset.
+         * Get the current connection name for the model.
          *
-         * @param string $url
-         * @param string $title
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return string 
          * @static 
          */
-        public static function linkSecureAsset($url, $title = null, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::linkSecureAsset($url, $title, $attributes);
+        public static function getConnectionName(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getConnectionName();
         }
         
         /**
-         * Generate a HTML link to a named route.
+         * Set the connection associated with the model.
          *
          * @param string $name
-         * @param string $title
-         * @param array $parameters
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return $this 
          * @static 
          */
-        public static function linkRoute($name, $title = null, $parameters = array(), $attributes = array()){
-            return \Collective\Html\HtmlBuilder::linkRoute($name, $title, $parameters, $attributes);
+        public static function setConnection($name){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setConnection($name);
         }
         
         /**
-         * Generate a HTML link to a controller action.
+         * Resolve a connection instance.
          *
-         * @param string $action
-         * @param string $title
-         * @param array $parameters
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @param string|null $connection
+         * @return \Illuminate\Database\Connection 
          * @static 
          */
-        public static function linkAction($action, $title = null, $parameters = array(), $attributes = array()){
-            return \Collective\Html\HtmlBuilder::linkAction($action, $title, $parameters, $attributes);
+        public static function resolveConnection($connection = null){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::resolveConnection($connection);
         }
         
         /**
-         * Generate a HTML link to an email address.
+         * Get the connection resolver instance.
          *
-         * @param string $email
-         * @param string $title
-         * @param array $attributes
-         * @param bool $escape
-         * @return \Illuminate\Support\HtmlString 
+         * @return \Illuminate\Database\ConnectionResolverInterface 
          * @static 
          */
-        public static function mailto($email, $title = null, $attributes = array(), $escape = true){
-            return \Collective\Html\HtmlBuilder::mailto($email, $title, $attributes, $escape);
+        public static function getConnectionResolver(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getConnectionResolver();
         }
         
         /**
-         * Obfuscate an e-mail address to prevent spam-bots from sniffing it.
+         * Set the connection resolver instance.
          *
-         * @param string $email
-         * @return string 
+         * @param \Illuminate\Database\ConnectionResolverInterface $resolver
+         * @return void 
          * @static 
          */
-        public static function email($email){
-            return \Collective\Html\HtmlBuilder::email($email);
+        public static function setConnectionResolver($resolver){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::setConnectionResolver($resolver);
         }
         
         /**
-         * Generates non-breaking space entities based on number supplied.
+         * Unset the connection resolver for models.
          *
-         * @param int $num
-         * @return string 
+         * @return void 
          * @static 
          */
-        public static function nbsp($num = 1){
-            return \Collective\Html\HtmlBuilder::nbsp($num);
+        public static function unsetConnectionResolver(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            \Webpatser\Countries\Countries::unsetConnectionResolver();
         }
         
         /**
-         * Generate an ordered list of items.
+         * Get the table associated with the model.
          *
-         * @param array $list
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString|string 
+         * @return string 
          * @static 
-         */
-        public static function ol($list, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::ol($list, $attributes);
+         */
+        public static function getTable(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getTable();
         }
         
         /**
-         * Generate an un-ordered list of items.
+         * Set the table associated with the model.
          *
-         * @param array $list
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString|string 
+         * @param string $table
+         * @return $this 
          * @static 
          */
-        public static function ul($list, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::ul($list, $attributes);
+        public static function setTable($table){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setTable($table);
         }
         
         /**
-         * Generate a description list of items.
+         * Get the primary key for the model.
          *
-         * @param array $list
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return string 
          * @static 
          */
-        public static function dl($list, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::dl($list, $attributes);
+        public static function getKeyName(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getKeyName();
         }
         
         /**
-         * Build an HTML attribute string from an array.
+         * Set the primary key for the model.
          *
-         * @param array $attributes
-         * @return string 
+         * @param string $key
+         * @return $this 
          * @static 
          */
-        public static function attributes($attributes){
-            return \Collective\Html\HtmlBuilder::attributes($attributes);
+        public static function setKeyName($key){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setKeyName($key);
         }
         
         /**
-         * Obfuscate a string to prevent spam-bots from sniffing it.
+         * Get the table qualified key name.
          *
-         * @param string $value
          * @return string 
          * @static 
          */
-        public static function obfuscate($value){
-            return \Collective\Html\HtmlBuilder::obfuscate($value);
+        public static function getQualifiedKeyName(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getQualifiedKeyName();
         }
         
         /**
-         * Generate a meta tag.
+         * Get the auto-incrementing key type.
          *
-         * @param string $name
-         * @param string $content
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @return string 
          * @static 
          */
-        public static function meta($name, $content, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::meta($name, $content, $attributes);
+        public static function getKeyType(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getKeyType();
         }
         
         /**
-         * Generate an html tag.
+         * Set the data type for the primary key.
          *
-         * @param string $tag
-         * @param mixed $content
-         * @param array $attributes
-         * @return \Illuminate\Support\HtmlString 
+         * @param string $type
+         * @return $this 
          * @static 
          */
-        public static function tag($tag, $content, $attributes = array()){
-            return \Collective\Html\HtmlBuilder::tag($tag, $content, $attributes);
+        public static function setKeyType($type){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setKeyType($type);
         }
         
         /**
-         * Register a custom macro.
+         * Get the value indicating whether the IDs are incrementing.
          *
-         * @param string $name
-         * @param callable $macro
-         * @return void 
+         * @return bool 
          * @static 
          */
-        public static function macro($name, $macro){
-            \Collective\Html\HtmlBuilder::macro($name, $macro);
+        public static function getIncrementing(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getIncrementing();
         }
         
         /**
-         * Checks if macro is registered.
+         * Set whether IDs are incrementing.
          *
-         * @param string $name
-         * @return bool 
+         * @param bool $value
+         * @return $this 
          * @static 
          */
-        public static function hasMacro($name){
-            return \Collective\Html\HtmlBuilder::hasMacro($name);
+        public static function setIncrementing($value){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::setIncrementing($value);
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Get the value of the model's primary key.
          *
-         * @param string $method
-         * @param array $parameters
          * @return mixed 
-         * @throws \BadMethodCallException
          * @static 
          */
-        public static function macroCall($method, $parameters){
-            return \Collective\Html\HtmlBuilder::macroCall($method, $parameters);
+        public static function getKey(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getKey();
         }
         
         /**
-         * Register a custom component.
+         * Get the queueable identity for the entity.
          *
-         * @param $name
-         * @param $view
-         * @param array $signature
-         * @return void 
+         * @return mixed 
          * @static 
          */
-        public static function component($name, $view, $signature){
-            \Collective\Html\HtmlBuilder::component($name, $view, $signature);
+        public static function getQueueableId(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getQueueableId();
         }
         
         /**
-         * Check if a component is registered.
+         * Get the value of the model's route key.
          *
-         * @param $name
-         * @return bool 
+         * @return mixed 
          * @static 
          */
-        public static function hasComponent($name){
-            return \Collective\Html\HtmlBuilder::hasComponent($name);
+        public static function getRouteKey(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getRouteKey();
         }
         
         /**
-         * Dynamically handle calls to the class.
+         * Get the route key for the model.
          *
-         * @param string $method
-         * @param array $parameters
-         * @return \Illuminate\Contracts\View\View|mixed 
-         * @throws \BadMethodCallException
+         * @return string 
          * @static 
          */
-        public static function componentCall($method, $parameters){
-            return \Collective\Html\HtmlBuilder::componentCall($method, $parameters);
+        public static function getRouteKeyName(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getRouteKeyName();
         }
         
-    }
-
-
-    class Countries extends \Webpatser\Countries\CountriesFacade{
-        
         /**
-         * Returns one country
+         * Get the default foreign key name for the model.
          *
-         * @param string $id The country id
-         * @return array 
+         * @return string 
          * @static 
          */
-        public static function getOne($id){
-            return \Webpatser\Countries\Countries::getOne($id);
+        public static function getForeignKey(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getForeignKey();
         }
         
         /**
-         * Returns a list of countries
+         * Get the number of models to return per page.
          *
-         * @param string  sort
-         * @return array 
+         * @return int 
          * @static 
          */
-        public static function getList($sort = null){
-            return \Webpatser\Countries\Countries::getList($sort);
+        public static function getPerPage(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::getPerPage();
         }
         
         /**
-         * Clear the list of booted models so they will be re-booted.
+         * Set the number of models to return per page.
          *
-         * @return void 
+         * @param int $perPage
+         * @return $this 
          * @static 
          */
-        public static function clearBootedModels(){
+        public static function setPerPage($perPage){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::clearBootedModels();
+            return \Webpatser\Countries\Countries::setPerPage($perPage);
         }
         
         /**
-         * Register a new global scope on the model.
+         * Determine if the given attribute exists.
          *
-         * @param \Illuminate\Database\Eloquent\Scope|\Closure|string $scope
-         * @param \Closure|null $implementation
-         * @return mixed 
-         * @throws \InvalidArgumentException
+         * @param mixed $offset
+         * @return bool 
          * @static 
          */
-        public static function addGlobalScope($scope, $implementation = null){
+        public static function offsetExists($offset){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::addGlobalScope($scope, $implementation);
+            return \Webpatser\Countries\Countries::offsetExists($offset);
         }
         
         /**
-         * Determine if a model has a global scope.
+         * Get the value for a given offset.
          *
-         * @param \Illuminate\Database\Eloquent\Scope|string $scope
-         * @return bool 
+         * @param mixed $offset
+         * @return mixed 
          * @static 
          */
-        public static function hasGlobalScope($scope){
+        public static function offsetGet($offset){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasGlobalScope($scope);
+            return \Webpatser\Countries\Countries::offsetGet($offset);
         }
         
         /**
-         * Get a global scope registered with the model.
+         * Set the value for a given offset.
          *
-         * @param \Illuminate\Database\Eloquent\Scope|string $scope
-         * @return \Illuminate\Database\Eloquent\Scope|\Closure|null 
+         * @param mixed $offset
+         * @param mixed $value
+         * @return void 
          * @static 
          */
-        public static function getGlobalScope($scope){
+        public static function offsetSet($offset, $value){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getGlobalScope($scope);
+            \Webpatser\Countries\Countries::offsetSet($offset, $value);
         }
         
         /**
-         * Get the global scopes for this class instance.
+         * Unset the value for a given offset.
          *
-         * @return array 
+         * @param mixed $offset
+         * @return void 
          * @static 
          */
-        public static function getGlobalScopes(){
+        public static function offsetUnset($offset){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getGlobalScopes();
+            \Webpatser\Countries\Countries::offsetUnset($offset);
         }
         
         /**
-         * Register an observer with the Model.
+         * Convert the model's attributes to an array.
          *
-         * @param object|string $class
-         * @param int $priority
-         * @return void 
+         * @return array 
          * @static 
          */
-        public static function observe($class, $priority = 0){
+        public static function attributesToArray(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::observe($class, $priority);
+            return \Webpatser\Countries\Countries::attributesToArray();
         }
         
         /**
-         * Fill the model with an array of attributes.
+         * Get the model's relationships in array form.
          *
-         * @param array $attributes
-         * @return $this 
-         * @throws \Illuminate\Database\Eloquent\MassAssignmentException
+         * @return array 
          * @static 
          */
-        public static function fill($attributes){
+        public static function relationsToArray(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fill($attributes);
+            return \Webpatser\Countries\Countries::relationsToArray();
         }
         
         /**
-         * Fill the model with an array of attributes. Force mass assignment.
+         * Get an attribute from the model.
          *
-         * @param array $attributes
-         * @return $this 
+         * @param string $key
+         * @return mixed 
          * @static 
          */
-        public static function forceFill($attributes){
+        public static function getAttribute($key){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::forceFill($attributes);
+            return \Webpatser\Countries\Countries::getAttribute($key);
         }
         
         /**
-         * Create a new instance of the given model.
+         * Get a plain attribute (not a relationship).
          *
-         * @param array $attributes
-         * @param bool $exists
-         * @return static 
+         * @param string $key
+         * @return mixed 
          * @static 
          */
-        public static function newInstance($attributes = array(), $exists = false){
+        public static function getAttributeValue($key){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newInstance($attributes, $exists);
+            return \Webpatser\Countries\Countries::getAttributeValue($key);
         }
         
         /**
-         * Create a new model instance that is existing.
+         * Get a relationship.
          *
-         * @param array $attributes
-         * @param string|null $connection
-         * @return static 
+         * @param string $key
+         * @return mixed 
          * @static 
          */
-        public static function newFromBuilder($attributes = array(), $connection = null){
+        public static function getRelationValue($key){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newFromBuilder($attributes, $connection);
+            return \Webpatser\Countries\Countries::getRelationValue($key);
         }
         
         /**
-         * Create a collection of models from plain arrays.
+         * Determine if a get mutator exists for an attribute.
          *
-         * @param array $items
-         * @param string|null $connection
-         * @return \Illuminate\Database\Eloquent\Collection 
+         * @param string $key
+         * @return bool 
          * @static 
          */
-        public static function hydrate($items, $connection = null){
+        public static function hasGetMutator($key){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hydrate($items, $connection);
+            return \Webpatser\Countries\Countries::hasGetMutator($key);
         }
         
         /**
-         * Create a collection of models from a raw query.
+         * Set a given attribute on the model.
          *
-         * @param string $query
-         * @param array $bindings
-         * @param string|null $connection
-         * @return \Illuminate\Database\Eloquent\Collection 
+         * @param string $key
+         * @param mixed $value
+         * @return $this 
          * @static 
          */
-        public static function hydrateRaw($query, $bindings = array(), $connection = null){
+        public static function setAttribute($key, $value){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hydrateRaw($query, $bindings, $connection);
+            return \Webpatser\Countries\Countries::setAttribute($key, $value);
         }
         
         /**
-         * Save a new model and return the instance.
+         * Determine if a set mutator exists for an attribute.
          *
-         * @param array $attributes
-         * @return static 
+         * @param string $key
+         * @return bool 
          * @static 
          */
-        public static function create($attributes = array()){
+        public static function hasSetMutator($key){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::create($attributes);
+            return \Webpatser\Countries\Countries::hasSetMutator($key);
         }
         
         /**
-         * Save a new model and return the instance. Allow mass-assignment.
+         * Set a given JSON attribute on the model.
          *
-         * @param array $attributes
-         * @return static 
+         * @param string $key
+         * @param mixed $value
+         * @return $this 
          * @static 
          */
-        public static function forceCreate($attributes){
+        public static function fillJsonAttribute($key, $value){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::forceCreate($attributes);
+            return \Webpatser\Countries\Countries::fillJsonAttribute($key, $value);
         }
         
         /**
-         * Begin querying the model.
+         * Decode the given JSON back into an array or object.
          *
-         * @return \Illuminate\Database\Eloquent\Builder 
+         * @param string $value
+         * @param bool $asObject
+         * @return mixed 
          * @static 
          */
-        public static function query(){
+        public static function fromJson($value, $asObject = false){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::query();
+            return \Webpatser\Countries\Countries::fromJson($value, $asObject);
         }
         
         /**
-         * Begin querying the model on a given connection.
+         * Convert a DateTime to a storable string.
          *
-         * @param string|null $connection
-         * @return \Illuminate\Database\Eloquent\Builder 
+         * @param \DateTime|int $value
+         * @return string 
          * @static 
          */
-        public static function on($connection = null){
+        public static function fromDateTime($value){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::on($connection);
+            return \Webpatser\Countries\Countries::fromDateTime($value);
         }
         
         /**
-         * Begin querying the model on the write connection.
+         * Get the attributes that should be converted to dates.
          *
-         * @return \Illuminate\Database\Query\Builder 
+         * @return array 
          * @static 
          */
-        public static function onWriteConnection(){
+        public static function getDates(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::onWriteConnection();
+            return \Webpatser\Countries\Countries::getDates();
         }
         
         /**
-         * Get all of the models from the database.
+         * Set the date format used by the model.
          *
-         * @param array|mixed $columns
-         * @return \Illuminate\Database\Eloquent\Collection|static[] 
+         * @param string $format
+         * @return $this 
          * @static 
          */
-        public static function all($columns = array()){
+        public static function setDateFormat($format){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::all($columns);
+            return \Webpatser\Countries\Countries::setDateFormat($format);
         }
         
         /**
-         * Reload a fresh model instance from the database.
+         * Determine whether an attribute should be cast to a native type.
          *
-         * @param array|string $with
-         * @return $this|null 
+         * @param string $key
+         * @param array|string|null $types
+         * @return bool 
          * @static 
          */
-        public static function fresh($with = array()){
+        public static function hasCast($key, $types = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fresh($with);
+            return \Webpatser\Countries\Countries::hasCast($key, $types);
         }
         
         /**
-         * Eager load relations on the model.
+         * Get the casts array.
          *
-         * @param array|string $relations
-         * @return $this 
+         * @return array 
          * @static 
          */
-        public static function load($relations){
+        public static function getCasts(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::load($relations);
+            return \Webpatser\Countries\Countries::getCasts();
         }
         
         /**
-         * Begin querying a model with eager loading.
+         * Get all of the current attributes on the model.
          *
-         * @param array|string $relations
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @return array 
          * @static 
          */
-        public static function with($relations){
+        public static function getAttributes(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::with($relations);
+            return \Webpatser\Countries\Countries::getAttributes();
         }
         
         /**
-         * Append attributes to query when building a query.
+         * Set the array of model attributes. No checking is done.
          *
-         * @param array|string $attributes
+         * @param array $attributes
+         * @param bool $sync
          * @return $this 
          * @static 
          */
-        public static function append($attributes){
+        public static function setRawAttributes($attributes, $sync = false){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::append($attributes);
+            return \Webpatser\Countries\Countries::setRawAttributes($attributes, $sync);
         }
         
         /**
-         * Define a one-to-one relationship.
+         * Get the model's original attribute values.
          *
-         * @param string $related
-         * @param string $foreignKey
-         * @param string $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\HasOne 
+         * @param string|null $key
+         * @param mixed $default
+         * @return mixed|array 
          * @static 
          */
-        public static function hasOne($related, $foreignKey = null, $localKey = null){
+        public static function getOriginal($key = null, $default = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasOne($related, $foreignKey, $localKey);
+            return \Webpatser\Countries\Countries::getOriginal($key, $default);
         }
         
         /**
-         * Define a polymorphic one-to-one relationship.
+         * Sync the original attributes with the current.
          *
-         * @param string $related
-         * @param string $name
-         * @param string $type
-         * @param string $id
-         * @param string $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\MorphOne 
+         * @return $this 
          * @static 
          */
-        public static function morphOne($related, $name, $type = null, $id = null, $localKey = null){
+        public static function syncOriginal(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphOne($related, $name, $type, $id, $localKey);
+            return \Webpatser\Countries\Countries::syncOriginal();
         }
         
         /**
-         * Define an inverse one-to-one or many relationship.
+         * Sync a single original attribute with its current value.
          *
-         * @param string $related
-         * @param string $foreignKey
-         * @param string $otherKey
-         * @param string $relation
-         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo 
+         * @param string $attribute
+         * @return $this 
          * @static 
          */
-        public static function belongsTo($related, $foreignKey = null, $otherKey = null, $relation = null){
+        public static function syncOriginalAttribute($attribute){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::belongsTo($related, $foreignKey, $otherKey, $relation);
+            return \Webpatser\Countries\Countries::syncOriginalAttribute($attribute);
         }
         
         /**
-         * Define a polymorphic, inverse one-to-one or many relationship.
+         * Determine if the model or given attribute(s) have been modified.
          *
-         * @param string $name
-         * @param string $type
-         * @param string $id
-         * @return \Illuminate\Database\Eloquent\Relations\MorphTo 
+         * @param array|string|null $attributes
+         * @return bool 
          * @static 
          */
-        public static function morphTo($name = null, $type = null, $id = null){
+        public static function isDirty($attributes = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphTo($name, $type, $id);
+            return \Webpatser\Countries\Countries::isDirty($attributes);
         }
         
         /**
-         * Retrieve the fully qualified class name from a slug.
+         * Determine if the model or given attribute(s) have remained the same.
          *
-         * @param string $class
-         * @return string 
+         * @param array|string|null $attributes
+         * @return bool 
          * @static 
          */
-        public static function getActualClassNameForMorph($class){
+        public static function isClean($attributes = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getActualClassNameForMorph($class);
+            return \Webpatser\Countries\Countries::isClean($attributes);
         }
         
         /**
-         * Define a one-to-many relationship.
+         * Get the attributes that have been changed since last sync.
          *
-         * @param string $related
-         * @param string $foreignKey
-         * @param string $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\HasMany 
+         * @return array 
          * @static 
          */
-        public static function hasMany($related, $foreignKey = null, $localKey = null){
+        public static function getDirty(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasMany($related, $foreignKey, $localKey);
+            return \Webpatser\Countries\Countries::getDirty();
         }
         
         /**
-         * Define a has-many-through relationship.
+         * Append attributes to query when building a query.
          *
-         * @param string $related
-         * @param string $through
-         * @param string|null $firstKey
-         * @param string|null $secondKey
-         * @param string|null $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\HasManyThrough 
+         * @param array|string $attributes
+         * @return $this 
          * @static 
          */
-        public static function hasManyThrough($related, $through, $firstKey = null, $secondKey = null, $localKey = null){
+        public static function append($attributes){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasManyThrough($related, $through, $firstKey, $secondKey, $localKey);
+            return \Webpatser\Countries\Countries::append($attributes);
         }
         
         /**
-         * Define a polymorphic one-to-many relationship.
+         * Set the accessors to append to model arrays.
          *
-         * @param string $related
-         * @param string $name
-         * @param string $type
-         * @param string $id
-         * @param string $localKey
-         * @return \Illuminate\Database\Eloquent\Relations\MorphMany 
+         * @param array $appends
+         * @return $this 
          * @static 
          */
-        public static function morphMany($related, $name, $type = null, $id = null, $localKey = null){
+        public static function setAppends($appends){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphMany($related, $name, $type, $id, $localKey);
+            return \Webpatser\Countries\Countries::setAppends($appends);
         }
         
         /**
-         * Define a many-to-many relationship.
+         * Get the mutated attributes for a given instance.
          *
-         * @param string $related
-         * @param string $table
-         * @param string $foreignKey
-         * @param string $otherKey
-         * @param string $relation
-         * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany 
+         * @return array 
          * @static 
          */
-        public static function belongsToMany($related, $table = null, $foreignKey = null, $otherKey = null, $relation = null){
+        public static function getMutatedAttributes(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::belongsToMany($related, $table, $foreignKey, $otherKey, $relation);
+            return \Webpatser\Countries\Countries::getMutatedAttributes();
         }
         
         /**
-         * Define a polymorphic many-to-many relationship.
+         * Extract and cache all the mutated attributes of a class.
          *
-         * @param string $related
-         * @param string $name
-         * @param string $table
-         * @param string $foreignKey
-         * @param string $otherKey
-         * @param bool $inverse
-         * @return \Illuminate\Database\Eloquent\Relations\MorphToMany 
+         * @param string $class
+         * @return void 
          * @static 
          */
-        public static function morphToMany($related, $name, $table = null, $foreignKey = null, $otherKey = null, $inverse = false){
+        public static function cacheMutatedAttributes($class){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphToMany($related, $name, $table, $foreignKey, $otherKey, $inverse);
+            \Webpatser\Countries\Countries::cacheMutatedAttributes($class);
         }
         
         /**
-         * Define a polymorphic, inverse many-to-many relationship.
+         * Register an observer with the Model.
          *
-         * @param string $related
-         * @param string $name
-         * @param string $table
-         * @param string $foreignKey
-         * @param string $otherKey
-         * @return \Illuminate\Database\Eloquent\Relations\MorphToMany 
+         * @param object|string $class
+         * @return void 
          * @static 
          */
-        public static function morphedByMany($related, $name, $table = null, $foreignKey = null, $otherKey = null){
+        public static function observe($class){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::morphedByMany($related, $name, $table, $foreignKey, $otherKey);
+            \Webpatser\Countries\Countries::observe($class);
         }
         
         /**
-         * Get the joining table name for a many-to-many relation.
+         * Get the observable event names.
          *
-         * @param string $related
-         * @return string 
+         * @return array 
          * @static 
          */
-        public static function joiningTable($related){
+        public static function getObservableEvents(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::joiningTable($related);
+            return \Webpatser\Countries\Countries::getObservableEvents();
         }
         
         /**
-         * Destroy the models for the given IDs.
+         * Set the observable event names.
          *
-         * @param array|int $ids
-         * @return int 
+         * @param array $observables
+         * @return $this 
          * @static 
          */
-        public static function destroy($ids){
+        public static function setObservableEvents($observables){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::destroy($ids);
+            return \Webpatser\Countries\Countries::setObservableEvents($observables);
         }
         
         /**
-         * Delete the model from the database.
+         * Add an observable event name.
          *
-         * @return bool|null 
-         * @throws \Exception
+         * @param array|mixed $observables
+         * @return void 
          * @static 
          */
-        public static function delete(){
+        public static function addObservableEvents($observables){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::delete();
+            \Webpatser\Countries\Countries::addObservableEvents($observables);
         }
         
         /**
-         * Force a hard delete on a soft deleted model.
-         * 
-         * This method protects developers from running forceDelete when trait is missing.
+         * Remove an observable event name.
          *
-         * @return bool|null 
+         * @param array|mixed $observables
+         * @return void 
          * @static 
          */
-        public static function forceDelete(){
+        public static function removeObservableEvents($observables){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::forceDelete();
+            \Webpatser\Countries\Countries::removeObservableEvents($observables);
         }
         
         /**
          * Register a saving model event with the dispatcher.
          *
          * @param \Closure|string $callback
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function saving($callback, $priority = 0){
+        public static function saving($callback){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::saving($callback, $priority);
+            \Webpatser\Countries\Countries::saving($callback);
         }
         
         /**
          * Register a saved model event with the dispatcher.
          *
          * @param \Closure|string $callback
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function saved($callback, $priority = 0){
+        public static function saved($callback){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::saved($callback, $priority);
+            \Webpatser\Countries\Countries::saved($callback);
         }
         
         /**
          * Register an updating model event with the dispatcher.
          *
          * @param \Closure|string $callback
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function updating($callback, $priority = 0){
+        public static function updating($callback){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::updating($callback, $priority);
+            \Webpatser\Countries\Countries::updating($callback);
         }
         
         /**
          * Register an updated model event with the dispatcher.
          *
          * @param \Closure|string $callback
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function updated($callback, $priority = 0){
+        public static function updated($callback){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::updated($callback, $priority);
+            \Webpatser\Countries\Countries::updated($callback);
         }
         
         /**
          * Register a creating model event with the dispatcher.
          *
          * @param \Closure|string $callback
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function creating($callback, $priority = 0){
+        public static function creating($callback){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::creating($callback, $priority);
+            \Webpatser\Countries\Countries::creating($callback);
         }
         
         /**
          * Register a created model event with the dispatcher.
          *
          * @param \Closure|string $callback
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function created($callback, $priority = 0){
+        public static function created($callback){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::created($callback, $priority);
+            \Webpatser\Countries\Countries::created($callback);
         }
         
         /**
          * Register a deleting model event with the dispatcher.
          *
          * @param \Closure|string $callback
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function deleting($callback, $priority = 0){
+        public static function deleting($callback){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::deleting($callback, $priority);
+            \Webpatser\Countries\Countries::deleting($callback);
         }
         
         /**
          * Register a deleted model event with the dispatcher.
          *
          * @param \Closure|string $callback
-         * @param int $priority
          * @return void 
          * @static 
          */
-        public static function deleted($callback, $priority = 0){
+        public static function deleted($callback){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::deleted($callback, $priority);
+            \Webpatser\Countries\Countries::deleted($callback);
         }
         
         /**
@@ -14994,431 +16419,471 @@ namespace {
         }
         
         /**
-         * Get the observable event names.
+         * Get the event dispatcher instance.
          *
-         * @return array 
+         * @return \Illuminate\Contracts\Events\Dispatcher 
          * @static 
          */
-        public static function getObservableEvents(){
+        public static function getEventDispatcher(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getObservableEvents();
+            return \Webpatser\Countries\Countries::getEventDispatcher();
         }
         
         /**
-         * Set the observable event names.
+         * Set the event dispatcher instance.
          *
-         * @param array $observables
-         * @return $this 
+         * @param \Illuminate\Contracts\Events\Dispatcher $dispatcher
+         * @return void 
          * @static 
          */
-        public static function setObservableEvents($observables){
+        public static function setEventDispatcher($dispatcher){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setObservableEvents($observables);
+            \Webpatser\Countries\Countries::setEventDispatcher($dispatcher);
         }
         
         /**
-         * Add an observable event name.
+         * Unset the event dispatcher for models.
          *
-         * @param array|mixed $observables
          * @return void 
          * @static 
          */
-        public static function addObservableEvents($observables){
+        public static function unsetEventDispatcher(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::addObservableEvents($observables);
+            \Webpatser\Countries\Countries::unsetEventDispatcher();
         }
         
         /**
-         * Remove an observable event name.
+         * Register a new global scope on the model.
          *
-         * @param array|mixed $observables
-         * @return void 
+         * @param \Illuminate\Database\Eloquent\Scope|\Closure|string $scope
+         * @param \Closure|null $implementation
+         * @return mixed 
+         * @throws \InvalidArgumentException
          * @static 
          */
-        public static function removeObservableEvents($observables){
+        public static function addGlobalScope($scope, $implementation = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::removeObservableEvents($observables);
+            return \Webpatser\Countries\Countries::addGlobalScope($scope, $implementation);
         }
         
         /**
-         * Update the model in the database.
+         * Determine if a model has a global scope.
          *
-         * @param array $attributes
-         * @param array $options
+         * @param \Illuminate\Database\Eloquent\Scope|string $scope
          * @return bool 
          * @static 
          */
-        public static function update($attributes = array(), $options = array()){
+        public static function hasGlobalScope($scope){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::update($attributes, $options);
+            return \Webpatser\Countries\Countries::hasGlobalScope($scope);
         }
         
         /**
-         * Save the model and all of its relationships.
+         * Get a global scope registered with the model.
          *
-         * @return bool 
+         * @param \Illuminate\Database\Eloquent\Scope|string $scope
+         * @return \Illuminate\Database\Eloquent\Scope|\Closure|null 
          * @static 
          */
-        public static function push(){
+        public static function getGlobalScope($scope){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::push();
+            return \Webpatser\Countries\Countries::getGlobalScope($scope);
         }
         
         /**
-         * Save the model to the database.
+         * Get the global scopes for this class instance.
          *
-         * @param array $options
-         * @return bool 
+         * @return array 
          * @static 
          */
-        public static function save($options = array()){
+        public static function getGlobalScopes(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::save($options);
+            return \Webpatser\Countries\Countries::getGlobalScopes();
         }
         
         /**
-         * Save the model to the database using transaction.
+         * Define a one-to-one relationship.
          *
-         * @param array $options
-         * @return bool 
-         * @throws \Throwable
+         * @param string $related
+         * @param string $foreignKey
+         * @param string $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\HasOne 
          * @static 
          */
-        public static function saveOrFail($options = array()){
+        public static function hasOne($related, $foreignKey = null, $localKey = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::saveOrFail($options);
+            return \Webpatser\Countries\Countries::hasOne($related, $foreignKey, $localKey);
         }
         
         /**
-         * Touch the owning relations of the model.
+         * Define a polymorphic one-to-one relationship.
          *
-         * @return void 
+         * @param string $related
+         * @param string $name
+         * @param string $type
+         * @param string $id
+         * @param string $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\MorphOne 
          * @static 
          */
-        public static function touchOwners(){
+        public static function morphOne($related, $name, $type = null, $id = null, $localKey = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::touchOwners();
+            return \Webpatser\Countries\Countries::morphOne($related, $name, $type, $id, $localKey);
         }
         
         /**
-         * Determine if the model touches a given relation.
+         * Define an inverse one-to-one or many relationship.
          *
+         * @param string $related
+         * @param string $foreignKey
+         * @param string $ownerKey
          * @param string $relation
-         * @return bool 
+         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo 
          * @static 
          */
-        public static function touches($relation){
+        public static function belongsTo($related, $foreignKey = null, $ownerKey = null, $relation = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::touches($relation);
+            return \Webpatser\Countries\Countries::belongsTo($related, $foreignKey, $ownerKey, $relation);
         }
         
         /**
-         * Update the model's update timestamp.
+         * Define a polymorphic, inverse one-to-one or many relationship.
          *
-         * @return bool 
+         * @param string $name
+         * @param string $type
+         * @param string $id
+         * @return \Illuminate\Database\Eloquent\Relations\MorphTo 
          * @static 
          */
-        public static function touch(){
+        public static function morphTo($name = null, $type = null, $id = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::touch();
+            return \Webpatser\Countries\Countries::morphTo($name, $type, $id);
         }
         
         /**
-         * Set the value of the "created at" attribute.
+         * Retrieve the actual class name for a given morph class.
          *
-         * @param mixed $value
-         * @return $this 
+         * @param string $class
+         * @return string 
          * @static 
          */
-        public static function setCreatedAt($value){
+        public static function getActualClassNameForMorph($class){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setCreatedAt($value);
+            return \Webpatser\Countries\Countries::getActualClassNameForMorph($class);
         }
         
         /**
-         * Set the value of the "updated at" attribute.
+         * Define a one-to-many relationship.
          *
-         * @param mixed $value
-         * @return $this 
+         * @param string $related
+         * @param string $foreignKey
+         * @param string $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\HasMany 
          * @static 
          */
-        public static function setUpdatedAt($value){
+        public static function hasMany($related, $foreignKey = null, $localKey = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setUpdatedAt($value);
+            return \Webpatser\Countries\Countries::hasMany($related, $foreignKey, $localKey);
         }
         
         /**
-         * Get the name of the "created at" column.
+         * Define a has-many-through relationship.
          *
-         * @return string 
+         * @param string $related
+         * @param string $through
+         * @param string|null $firstKey
+         * @param string|null $secondKey
+         * @param string|null $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\HasManyThrough 
          * @static 
          */
-        public static function getCreatedAtColumn(){
+        public static function hasManyThrough($related, $through, $firstKey = null, $secondKey = null, $localKey = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getCreatedAtColumn();
+            return \Webpatser\Countries\Countries::hasManyThrough($related, $through, $firstKey, $secondKey, $localKey);
         }
         
         /**
-         * Get the name of the "updated at" column.
+         * Define a polymorphic one-to-many relationship.
          *
-         * @return string 
+         * @param string $related
+         * @param string $name
+         * @param string $type
+         * @param string $id
+         * @param string $localKey
+         * @return \Illuminate\Database\Eloquent\Relations\MorphMany 
          * @static 
          */
-        public static function getUpdatedAtColumn(){
+        public static function morphMany($related, $name, $type = null, $id = null, $localKey = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getUpdatedAtColumn();
+            return \Webpatser\Countries\Countries::morphMany($related, $name, $type, $id, $localKey);
         }
         
         /**
-         * Get a fresh timestamp for the model.
+         * Define a many-to-many relationship.
          *
-         * @return \Carbon\Carbon 
+         * @param string $related
+         * @param string $table
+         * @param string $foreignKey
+         * @param string $relatedKey
+         * @param string $relation
+         * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany 
          * @static 
          */
-        public static function freshTimestamp(){
+        public static function belongsToMany($related, $table = null, $foreignKey = null, $relatedKey = null, $relation = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::freshTimestamp();
+            return \Webpatser\Countries\Countries::belongsToMany($related, $table, $foreignKey, $relatedKey, $relation);
         }
         
         /**
-         * Get a fresh timestamp for the model.
+         * Define a polymorphic many-to-many relationship.
          *
-         * @return string 
+         * @param string $related
+         * @param string $name
+         * @param string $table
+         * @param string $foreignKey
+         * @param string $relatedKey
+         * @param bool $inverse
+         * @return \Illuminate\Database\Eloquent\Relations\MorphToMany 
          * @static 
          */
-        public static function freshTimestampString(){
+        public static function morphToMany($related, $name, $table = null, $foreignKey = null, $relatedKey = null, $inverse = false){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::freshTimestampString();
+            return \Webpatser\Countries\Countries::morphToMany($related, $name, $table, $foreignKey, $relatedKey, $inverse);
         }
         
         /**
-         * Get a new query builder for the model's table.
+         * Define a polymorphic, inverse many-to-many relationship.
          *
-         * @return \Illuminate\Database\Eloquent\Builder 
+         * @param string $related
+         * @param string $name
+         * @param string $table
+         * @param string $foreignKey
+         * @param string $relatedKey
+         * @return \Illuminate\Database\Eloquent\Relations\MorphToMany 
          * @static 
          */
-        public static function newQuery(){
+        public static function morphedByMany($related, $name, $table = null, $foreignKey = null, $relatedKey = null){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newQuery();
+            return \Webpatser\Countries\Countries::morphedByMany($related, $name, $table, $foreignKey, $relatedKey);
         }
         
         /**
-         * Get a new query instance without a given scope.
+         * Get the joining table name for a many-to-many relation.
          *
-         * @param \Illuminate\Database\Eloquent\Scope|string $scope
-         * @return \Illuminate\Database\Eloquent\Builder 
+         * @param string $related
+         * @return string 
          * @static 
          */
-        public static function newQueryWithoutScope($scope){
+        public static function joiningTable($related){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newQueryWithoutScope($scope);
+            return \Webpatser\Countries\Countries::joiningTable($related);
         }
         
         /**
-         * Get a new query builder that doesn't have any global scopes.
+         * Determine if the model touches a given relation.
          *
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @param string $relation
+         * @return bool 
          * @static 
          */
-        public static function newQueryWithoutScopes(){
+        public static function touches($relation){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newQueryWithoutScopes();
+            return \Webpatser\Countries\Countries::touches($relation);
         }
         
         /**
-         * Create a new Eloquent query builder for the model.
+         * Touch the owning relations of the model.
          *
-         * @param \Illuminate\Database\Query\Builder $query
-         * @return \Illuminate\Database\Eloquent\Builder|static 
+         * @return void 
          * @static 
          */
-        public static function newEloquentBuilder($query){
+        public static function touchOwners(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newEloquentBuilder($query);
+            \Webpatser\Countries\Countries::touchOwners();
         }
         
         /**
-         * Create a new Eloquent Collection instance.
+         * Get the class name for polymorphic relations.
          *
-         * @param array $models
-         * @return \Illuminate\Database\Eloquent\Collection 
+         * @return string 
          * @static 
          */
-        public static function newCollection($models = array()){
+        public static function getMorphClass(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newCollection($models);
+            return \Webpatser\Countries\Countries::getMorphClass();
         }
         
         /**
-         * Create a new pivot model instance.
+         * Get all the loaded relations for the instance.
          *
-         * @param \Illuminate\Database\Eloquent\Model $parent
-         * @param array $attributes
-         * @param string $table
-         * @param bool $exists
-         * @return \Illuminate\Database\Eloquent\Relations\Pivot 
+         * @return array 
          * @static 
          */
-        public static function newPivot($parent, $attributes, $table, $exists){
+        public static function getRelations(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::newPivot($parent, $attributes, $table, $exists);
+            return \Webpatser\Countries\Countries::getRelations();
         }
         
         /**
-         * Get the table associated with the model.
+         * Get a specified relationship.
          *
-         * @return string 
+         * @param string $relation
+         * @return mixed 
          * @static 
          */
-        public static function getTable(){
+        public static function getRelation($relation){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getTable();
+            return \Webpatser\Countries\Countries::getRelation($relation);
         }
         
         /**
-         * Set the table associated with the model.
+         * Determine if the given relation is loaded.
          *
-         * @param string $table
-         * @return $this 
+         * @param string $key
+         * @return bool 
          * @static 
          */
-        public static function setTable($table){
+        public static function relationLoaded($key){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setTable($table);
+            return \Webpatser\Countries\Countries::relationLoaded($key);
         }
         
         /**
-         * Get the value of the model's primary key.
+         * Set the specific relationship in the model.
          *
-         * @return mixed 
+         * @param string $relation
+         * @param mixed $value
+         * @return $this 
          * @static 
          */
-        public static function getKey(){
+        public static function setRelation($relation, $value){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getKey();
+            return \Webpatser\Countries\Countries::setRelation($relation, $value);
         }
         
         /**
-         * Get the queueable identity for the entity.
+         * Set the entire relations array on the model.
          *
-         * @return mixed 
+         * @param array $relations
+         * @return $this 
          * @static 
          */
-        public static function getQueueableId(){
+        public static function setRelations($relations){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getQueueableId();
+            return \Webpatser\Countries\Countries::setRelations($relations);
         }
         
         /**
-         * Get the primary key for the model.
+         * Get the relationships that are touched on save.
          *
-         * @return string 
+         * @return array 
          * @static 
          */
-        public static function getKeyName(){
+        public static function getTouchedRelations(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getKeyName();
+            return \Webpatser\Countries\Countries::getTouchedRelations();
         }
         
         /**
-         * Set the primary key for the model.
+         * Set the relationships that are touched on save.
          *
-         * @param string $key
+         * @param array $touches
          * @return $this 
          * @static 
          */
-        public static function setKeyName($key){
+        public static function setTouchedRelations($touches){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setKeyName($key);
+            return \Webpatser\Countries\Countries::setTouchedRelations($touches);
         }
         
         /**
-         * Get the table qualified key name.
+         * Update the model's update timestamp.
          *
-         * @return string 
+         * @return bool 
          * @static 
          */
-        public static function getQualifiedKeyName(){
+        public static function touch(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getQualifiedKeyName();
+            return \Webpatser\Countries\Countries::touch();
         }
         
         /**
-         * Get the value of the model's route key.
+         * Set the value of the "created at" attribute.
          *
-         * @return mixed 
+         * @param mixed $value
+         * @return $this 
          * @static 
          */
-        public static function getRouteKey(){
+        public static function setCreatedAt($value){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRouteKey();
+            return \Webpatser\Countries\Countries::setCreatedAt($value);
         }
         
         /**
-         * Get the route key for the model.
+         * Set the value of the "updated at" attribute.
          *
-         * @return string 
+         * @param mixed $value
+         * @return $this 
          * @static 
          */
-        public static function getRouteKeyName(){
+        public static function setUpdatedAt($value){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRouteKeyName();
+            return \Webpatser\Countries\Countries::setUpdatedAt($value);
         }
         
         /**
-         * Determine if the model uses timestamps.
+         * Get a fresh timestamp for the model.
          *
-         * @return bool 
+         * @return \Carbon\Carbon 
          * @static 
          */
-        public static function usesTimestamps(){
+        public static function freshTimestamp(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::usesTimestamps();
+            return \Webpatser\Countries\Countries::freshTimestamp();
         }
         
         /**
-         * Get the class name for polymorphic relations.
+         * Get a fresh timestamp for the model.
          *
          * @return string 
          * @static 
          */
-        public static function getMorphClass(){
+        public static function freshTimestampString(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getMorphClass();
+            return \Webpatser\Countries\Countries::freshTimestampString();
         }
         
         /**
-         * Get the number of models to return per page.
+         * Determine if the model uses timestamps.
          *
-         * @return int 
+         * @return bool 
          * @static 
          */
-        public static function getPerPage(){
+        public static function usesTimestamps(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getPerPage();
+            return \Webpatser\Countries\Countries::usesTimestamps();
         }
         
         /**
-         * Set the number of models to return per page.
+         * Get the name of the "created at" column.
          *
-         * @param int $perPage
-         * @return $this 
+         * @return string 
          * @static 
          */
-        public static function setPerPage($perPage){
+        public static function getCreatedAtColumn(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setPerPage($perPage);
+            return \Webpatser\Countries\Countries::getCreatedAtColumn();
         }
         
         /**
-         * Get the default foreign key name for the model.
+         * Get the name of the "updated at" column.
          *
          * @return string 
          * @static 
          */
-        public static function getForeignKey(){
+        public static function getUpdatedAtColumn(){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getForeignKey();
+            return \Webpatser\Countries\Countries::getUpdatedAtColumn();
         }
         
         /**
@@ -15457,30 +16922,6 @@ namespace {
         }
         
         /**
-         * Make the given, typically hidden, attributes visible.
-         *
-         * @param array|string $attributes
-         * @return $this 
-         * @static 
-         */
-        public static function makeVisible($attributes){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::makeVisible($attributes);
-        }
-        
-        /**
-         * Make the given, typically visible, attributes hidden.
-         *
-         * @param array|string $attributes
-         * @return $this 
-         * @static 
-         */
-        public static function makeHidden($attributes){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::makeHidden($attributes);
-        }
-        
-        /**
          * Get the visible attributes for the model.
          *
          * @return array 
@@ -15516,15 +16957,27 @@ namespace {
         }
         
         /**
-         * Set the accessors to append to model arrays.
+         * Make the given, typically hidden, attributes visible.
          *
-         * @param array $appends
+         * @param array|string $attributes
          * @return $this 
          * @static 
          */
-        public static function setAppends($appends){
+        public static function makeVisible($attributes){
             //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setAppends($appends);
+            return \Webpatser\Countries\Countries::makeVisible($attributes);
+        }
+        
+        /**
+         * Make the given, typically visible, attributes hidden.
+         *
+         * @param array|string $attributes
+         * @return $this 
+         * @static 
+         */
+        public static function makeHidden($attributes){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::makeHidden($attributes);
         }
         
         /**
@@ -15644,916 +17097,1009 @@ namespace {
         }
         
         /**
-         * Determine if the model is totally guarded.
+         * Determine if the model is totally guarded.
+         *
+         * @return bool 
+         * @static 
+         */
+        public static function totallyGuarded(){
+            //Method inherited from \Illuminate\Database\Eloquent\Model            
+            return \Webpatser\Countries\Countries::totallyGuarded();
+        }
+        
+    }
+
+
+    class Image extends \Intervention\Image\Facades\Image{
+        
+        /**
+         * Overrides configuration settings
+         *
+         * @param array $config
+         * @static 
+         */
+        public static function configure($config = array()){
+            return \Intervention\Image\ImageManager::configure($config);
+        }
+        
+        /**
+         * Initiates an Image instance from different input types
+         *
+         * @param mixed $data
+         * @return \Intervention\Image\Image 
+         * @static 
+         */
+        public static function make($data){
+            return \Intervention\Image\ImageManager::make($data);
+        }
+        
+        /**
+         * Creates an empty image canvas
+         *
+         * @param integer $width
+         * @param integer $height
+         * @param mixed $background
+         * @return \Intervention\Image\Image 
+         * @static 
+         */
+        public static function canvas($width, $height, $background = null){
+            return \Intervention\Image\ImageManager::canvas($width, $height, $background);
+        }
+        
+        /**
+         * Create new cached image and run callback
+         * (requires additional package intervention/imagecache)
+         *
+         * @param \Closure $callback
+         * @param integer $lifetime
+         * @param boolean $returnObj
+         * @return \Image 
+         * @static 
+         */
+        public static function cache($callback, $lifetime = null, $returnObj = false){
+            return \Intervention\Image\ImageManager::cache($callback, $lifetime, $returnObj);
+        }
+        
+    }
+
+
+    class Settings extends \anlutro\LaravelSettings\Facade{
+        
+        /**
+         * 
+         *
+         * @static 
+         */
+        public static function getDefaultDriver(){
+            return \anlutro\LaravelSettings\SettingsManager::getDefaultDriver();
+        }
+        
+        /**
+         * 
+         *
+         * @static 
+         */
+        public static function createJsonDriver(){
+            return \anlutro\LaravelSettings\SettingsManager::createJsonDriver();
+        }
+        
+        /**
+         * 
+         *
+         * @static 
+         */
+        public static function createDatabaseDriver(){
+            return \anlutro\LaravelSettings\SettingsManager::createDatabaseDriver();
+        }
+        
+        /**
+         * 
          *
-         * @return bool 
          * @static 
          */
-        public static function totallyGuarded(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::totallyGuarded();
+        public static function createMemoryDriver(){
+            return \anlutro\LaravelSettings\SettingsManager::createMemoryDriver();
         }
         
         /**
-         * Get the relationships that are touched on save.
+         * 
          *
-         * @return array 
          * @static 
          */
-        public static function getTouchedRelations(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getTouchedRelations();
+        public static function createArrayDriver(){
+            return \anlutro\LaravelSettings\SettingsManager::createArrayDriver();
         }
         
         /**
-         * Set the relationships that are touched on save.
+         * Get a driver instance.
          *
-         * @param array $touches
-         * @return $this 
+         * @param string $driver
+         * @return mixed 
          * @static 
          */
-        public static function setTouchedRelations($touches){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setTouchedRelations($touches);
+        public static function driver($driver = null){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \anlutro\LaravelSettings\SettingsManager::driver($driver);
         }
         
         /**
-         * Get the value indicating whether the IDs are incrementing.
+         * Register a custom driver creator Closure.
          *
-         * @return bool 
+         * @param string $driver
+         * @param \Closure $callback
+         * @return $this 
          * @static 
          */
-        public static function getIncrementing(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getIncrementing();
+        public static function extend($driver, $callback){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \anlutro\LaravelSettings\SettingsManager::extend($driver, $callback);
         }
         
         /**
-         * Set whether IDs are incrementing.
+         * Get all of the created "drivers".
          *
-         * @param bool $value
-         * @return $this 
+         * @return array 
          * @static 
          */
-        public static function setIncrementing($value){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setIncrementing($value);
+        public static function getDrivers(){
+            //Method inherited from \Illuminate\Support\Manager            
+            return \anlutro\LaravelSettings\SettingsManager::getDrivers();
         }
         
+    }
+
+
+    class Authy extends \Vanguard\Services\Auth\TwoFactor\Facade{
+        
         /**
-         * Convert the model instance to JSON.
+         * Determine if the given user has two-factor authentication enabled.
          *
-         * @param int $options
-         * @return string 
+         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
+         * @return bool 
          * @static 
          */
-        public static function toJson($options = 0){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::toJson($options);
+        public static function isEnabled($user){
+            return \Vanguard\Services\Auth\TwoFactor\Authy::isEnabled($user);
         }
         
         /**
-         * Convert the object into something JSON serializable.
+         * Register the given user with the provider.
          *
-         * @return array 
+         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
          * @static 
          */
-        public static function jsonSerialize(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::jsonSerialize();
+        public static function register($user){
+            return \Vanguard\Services\Auth\TwoFactor\Authy::register($user);
         }
         
         /**
-         * Convert the model instance to an array.
+         * Determine if the given token is valid for the given user.
          *
-         * @return array 
+         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
+         * @param string $token
+         * @return bool 
          * @static 
          */
-        public static function toArray(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::toArray();
+        public static function tokenIsValid($user, $token){
+            return \Vanguard\Services\Auth\TwoFactor\Authy::tokenIsValid($user, $token);
         }
         
         /**
-         * Convert the model's attributes to an array.
+         * Delete the given user from the provider.
          *
-         * @return array 
+         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
+         * @return bool 
          * @static 
          */
-        public static function attributesToArray(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::attributesToArray();
+        public static function delete($user){
+            return \Vanguard\Services\Auth\TwoFactor\Authy::delete($user);
         }
         
+    }
+
+
+    class JWTAuth extends \Tymon\JWTAuth\Facades\JWTAuth{
+        
         /**
-         * Get the model's relationships in array form.
+         * Authenticate a user via a token.
          *
-         * @return array 
+         * @return \Tymon\JWTAuth\Contracts\JWTSubject|false 
          * @static 
          */
-        public static function relationsToArray(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::relationsToArray();
+        public static function authenticate(){
+            return \Vanguard\Services\Auth\Api\JWTAuth::authenticate();
         }
         
         /**
-         * Get an attribute from the model.
+         * Attempt to authenticate the user and return the token.
          *
-         * @param string $key
-         * @return mixed 
+         * @param array $credentials
+         * @return false|string 
          * @static 
          */
-        public static function getAttribute($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getAttribute($key);
+        public static function attempt($credentials){
+            //Method inherited from \Tymon\JWTAuth\JWTAuth            
+            return \Vanguard\Services\Auth\Api\JWTAuth::attempt($credentials);
         }
         
         /**
-         * Get a plain attribute (not a relationship).
+         * Alias for authenticate().
          *
-         * @param string $key
-         * @return mixed 
+         * @return \Tymon\JWTAuth\Contracts\JWTSubject|false 
          * @static 
          */
-        public static function getAttributeValue($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getAttributeValue($key);
+        public static function toUser(){
+            //Method inherited from \Tymon\JWTAuth\JWTAuth            
+            return \Vanguard\Services\Auth\Api\JWTAuth::toUser();
         }
         
         /**
-         * Get a relationship.
+         * Get the authenticated user.
          *
-         * @param string $key
-         * @return mixed 
+         * @return \Tymon\JWTAuth\Contracts\JWTSubject 
          * @static 
          */
-        public static function getRelationValue($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRelationValue($key);
+        public static function user(){
+            //Method inherited from \Tymon\JWTAuth\JWTAuth            
+            return \Vanguard\Services\Auth\Api\JWTAuth::user();
         }
         
         /**
-         * Determine if a get mutator exists for an attribute.
+         * Generate a token for a given subject.
          *
-         * @param string $key
-         * @return bool 
+         * @param \Tymon\JWTAuth\Contracts\JWTSubject $subject
+         * @return string 
          * @static 
          */
-        public static function hasGetMutator($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasGetMutator($key);
+        public static function fromSubject($subject){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::fromSubject($subject);
         }
         
         /**
-         * Determine whether an attribute should be cast to a native type.
+         * Alias to generate a token for a given user.
          *
-         * @param string $key
-         * @param array|string|null $types
-         * @return bool 
+         * @param \Tymon\JWTAuth\Contracts\JWTSubject $user
+         * @return string 
          * @static 
          */
-        public static function hasCast($key, $types = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasCast($key, $types);
+        public static function fromUser($user){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::fromUser($user);
         }
         
         /**
-         * Get the casts array.
+         * Refresh an expired token.
          *
-         * @return array 
+         * @param bool $forceForever
+         * @param bool $resetClaims
+         * @return string 
          * @static 
          */
-        public static function getCasts(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getCasts();
+        public static function refresh($forceForever = false, $resetClaims = false){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::refresh($forceForever, $resetClaims);
         }
         
         /**
-         * Set a given attribute on the model.
+         * Invalidate a token (add it to the blacklist).
          *
-         * @param string $key
-         * @param mixed $value
+         * @param bool $forceForever
          * @return $this 
          * @static 
          */
-        public static function setAttribute($key, $value){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setAttribute($key, $value);
+        public static function invalidate($forceForever = false){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::invalidate($forceForever);
         }
         
         /**
-         * Determine if a set mutator exists for an attribute.
+         * Alias to get the payload, and as a result checks that
+         * the token is valid i.e. not expired or blacklisted.
          *
-         * @param string $key
-         * @return bool 
+         * @throws \Tymon\JWTAuth\Exceptions\JWTException
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
          */
-        public static function hasSetMutator($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::hasSetMutator($key);
+        public static function checkOrFail(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::checkOrFail();
         }
         
         /**
-         * Get the attributes that should be converted to dates.
+         * Check that the token is valid.
          *
-         * @return array 
+         * @return bool 
          * @static 
          */
-        public static function getDates(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getDates();
+        public static function check(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::check();
         }
         
         /**
-         * Convert a DateTime to a storable string.
+         * Get the token.
          *
-         * @param \DateTime|int $value
-         * @return string 
+         * @return \Tymon\JWTAuth\Token|false 
          * @static 
          */
-        public static function fromDateTime($value){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fromDateTime($value);
+        public static function getToken(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::getToken();
         }
         
         /**
-         * Set the date format used by the model.
+         * Parse the token from the request.
          *
-         * @param string $format
+         * @throws \Tymon\JWTAuth\Exceptions\JWTException
          * @return $this 
          * @static 
          */
-        public static function setDateFormat($format){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setDateFormat($format);
+        public static function parseToken(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::parseToken();
         }
         
         /**
-         * Decode the given JSON back into an array or object.
+         * Get the raw Payload instance.
          *
-         * @param string $value
-         * @param bool $asObject
-         * @return mixed 
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
          */
-        public static function fromJson($value, $asObject = false){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::fromJson($value, $asObject);
+        public static function getPayload(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::getPayload();
         }
         
         /**
-         * Clone the model into a new, non-existing instance.
+         * Alias for getPayload().
          *
-         * @param array|null $except
-         * @return \Illuminate\Database\Eloquent\Model 
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
          */
-        public static function replicate($except = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::replicate($except);
+        public static function payload(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::payload();
         }
         
         /**
-         * Determine if two models have the same ID and belong to the same table.
+         * Convenience method to get a claim value.
          *
-         * @param \Illuminate\Database\Eloquent\Model $model
-         * @return bool 
+         * @param string $claim
+         * @return mixed 
          * @static 
          */
-        public static function is($model){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::is($model);
+        public static function getClaim($claim){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::getClaim($claim);
         }
         
         /**
-         * Get all of the current attributes on the model.
+         * Create a Payload instance.
          *
-         * @return array 
+         * @param \Tymon\JWTAuth\Contracts\JWTSubject $subject
+         * @return \Tymon\JWTAuth\Payload 
          * @static 
          */
-        public static function getAttributes(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getAttributes();
+        public static function makePayload($subject){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::makePayload($subject);
         }
         
         /**
-         * Set the array of model attributes. No checking is done.
+         * Set the token.
          *
-         * @param array $attributes
-         * @param bool $sync
+         * @param \Tymon\JWTAuth\Token|string $token
          * @return $this 
          * @static 
          */
-        public static function setRawAttributes($attributes, $sync = false){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setRawAttributes($attributes, $sync);
+        public static function setToken($token){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::setToken($token);
         }
         
         /**
-         * Get the model's original attribute values.
+         * Unset the current token.
          *
-         * @param string|null $key
-         * @param mixed $default
-         * @return mixed|array 
+         * @return $this 
          * @static 
          */
-        public static function getOriginal($key = null, $default = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getOriginal($key, $default);
+        public static function unsetToken(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::unsetToken();
         }
         
         /**
-         * Sync the original attributes with the current.
+         * Set the request instance.
          *
+         * @param \Illuminate\Http\Request $request
          * @return $this 
          * @static 
          */
-        public static function syncOriginal(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::syncOriginal();
+        public static function setRequest($request){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::setRequest($request);
         }
         
         /**
-         * Sync a single original attribute with its current value.
+         * Get the Manager instance.
          *
-         * @param string $attribute
-         * @return $this 
+         * @return \Tymon\JWTAuth\Manager 
          * @static 
          */
-        public static function syncOriginalAttribute($attribute){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::syncOriginalAttribute($attribute);
+        public static function manager(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::manager();
         }
         
         /**
-         * Determine if the model or given attribute(s) have been modified.
+         * Get the Parser instance.
          *
-         * @param array|string|null $attributes
-         * @return bool 
+         * @return \Tymon\JWTAuth\Http\Parser\Parser 
          * @static 
          */
-        public static function isDirty($attributes = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::isDirty($attributes);
+        public static function parser(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::parser();
         }
         
         /**
-         * Determine if the model or given attribute(s) have remained the same.
+         * Get the Payload Factory.
          *
-         * @param array|string|null $attributes
-         * @return bool 
+         * @return \Tymon\JWTAuth\Factory 
          * @static 
          */
-        public static function isClean($attributes = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::isClean($attributes);
+        public static function factory(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::factory();
         }
         
         /**
-         * Get the attributes that have been changed since last sync.
+         * Get the Blacklist.
          *
-         * @return array 
+         * @return \Tymon\JWTAuth\Blacklist 
          * @static 
          */
-        public static function getDirty(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getDirty();
+        public static function blacklist(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::blacklist();
         }
         
         /**
-         * Get all the loaded relations for the instance.
+         * Set the custom claims.
          *
-         * @return array 
-         * @static 
-         */
-        public static function getRelations(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRelations();
+         * @param array $customClaims
+         * @return $this 
+         * @static 
+         */
+        public static function customClaims($customClaims){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::customClaims($customClaims);
         }
         
         /**
-         * Get a specified relationship.
+         * Alias to set the custom claims.
          *
-         * @param string $relation
-         * @return mixed 
+         * @param array $customClaims
+         * @return $this 
          * @static 
          */
-        public static function getRelation($relation){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getRelation($relation);
+        public static function claims($customClaims){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::claims($customClaims);
         }
         
         /**
-         * Determine if the given relation is loaded.
+         * Get the custom claims.
          *
-         * @param string $key
-         * @return bool 
+         * @return array 
          * @static 
          */
-        public static function relationLoaded($key){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::relationLoaded($key);
+        public static function getCustomClaims(){
+            //Method inherited from \Tymon\JWTAuth\JWT            
+            return \Vanguard\Services\Auth\Api\JWTAuth::getCustomClaims();
         }
         
+    }
+
+
+    class Agent extends \Jenssegers\Agent\Facades\Agent{
+        
         /**
-         * Set the specific relationship in the model.
+         * Get all detection rules. These rules include the additional
+         * platforms and browsers.
          *
-         * @param string $relation
-         * @param mixed $value
-         * @return $this 
+         * @return array 
          * @static 
          */
-        public static function setRelation($relation, $value){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setRelation($relation, $value);
+        public static function getDetectionRulesExtended(){
+            return \Jenssegers\Agent\Agent::getDetectionRulesExtended();
         }
         
         /**
-         * Set the entire relations array on the model.
+         * 
          *
-         * @param array $relations
-         * @return $this 
+         * @inheritdoc 
          * @static 
          */
-        public static function setRelations($relations){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setRelations($relations);
+        public static function getRules(){
+            return \Jenssegers\Agent\Agent::getRules();
         }
         
         /**
-         * Get the database connection for the model.
+         * 
          *
-         * @return \Illuminate\Database\Connection 
+         * @return \Jenssegers\Agent\CrawlerDetect 
          * @static 
          */
-        public static function getConnection(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getConnection();
+        public static function getCrawlerDetect(){
+            return \Jenssegers\Agent\Agent::getCrawlerDetect();
         }
         
         /**
-         * Get the current connection name for the model.
+         * Get accept languages.
          *
-         * @return string 
+         * @param string $acceptLanguage
+         * @return array 
          * @static 
          */
-        public static function getConnectionName(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getConnectionName();
+        public static function languages($acceptLanguage = null){
+            return \Jenssegers\Agent\Agent::languages($acceptLanguage);
         }
         
         /**
-         * Set the connection associated with the model.
+         * Get the browser name.
          *
-         * @param string $name
-         * @return $this 
+         * @param null $userAgent
+         * @return string 
          * @static 
          */
-        public static function setConnection($name){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::setConnection($name);
+        public static function browser($userAgent = null){
+            return \Jenssegers\Agent\Agent::browser($userAgent);
         }
         
         /**
-         * Resolve a connection instance.
+         * Get the platform name.
          *
-         * @param string|null $connection
-         * @return \Illuminate\Database\Connection 
+         * @param string $userAgent
+         * @return string 
          * @static 
          */
-        public static function resolveConnection($connection = null){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::resolveConnection($connection);
+        public static function platform($userAgent = null){
+            return \Jenssegers\Agent\Agent::platform($userAgent);
         }
         
         /**
-         * Get the connection resolver instance.
+         * Get the device name.
          *
-         * @return \Illuminate\Database\ConnectionResolverInterface 
+         * @param string $userAgent
+         * @return string 
          * @static 
          */
-        public static function getConnectionResolver(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getConnectionResolver();
+        public static function device($userAgent = null){
+            return \Jenssegers\Agent\Agent::device($userAgent);
         }
         
         /**
-         * Set the connection resolver instance.
+         * Check if the device is a desktop computer.
          *
-         * @param \Illuminate\Database\ConnectionResolverInterface $resolver
-         * @return void 
+         * @param string $userAgent deprecated
+         * @param array $httpHeaders deprecated
+         * @return bool 
          * @static 
          */
-        public static function setConnectionResolver($resolver){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::setConnectionResolver($resolver);
+        public static function isDesktop($userAgent = null, $httpHeaders = null){
+            return \Jenssegers\Agent\Agent::isDesktop($userAgent, $httpHeaders);
         }
         
         /**
-         * Unset the connection resolver for models.
+         * Check if the device is a mobile phone.
          *
-         * @return void 
+         * @param string $userAgent deprecated
+         * @param array $httpHeaders deprecated
+         * @return bool 
          * @static 
          */
-        public static function unsetConnectionResolver(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::unsetConnectionResolver();
+        public static function isPhone($userAgent = null, $httpHeaders = null){
+            return \Jenssegers\Agent\Agent::isPhone($userAgent, $httpHeaders);
         }
         
         /**
-         * Get the event dispatcher instance.
+         * Get the robot name.
          *
-         * @return \Illuminate\Contracts\Events\Dispatcher 
+         * @param string $userAgent
+         * @return string|bool 
          * @static 
          */
-        public static function getEventDispatcher(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getEventDispatcher();
+        public static function robot($userAgent = null){
+            return \Jenssegers\Agent\Agent::robot($userAgent);
         }
         
         /**
-         * Set the event dispatcher instance.
+         * Check if device is a robot.
          *
-         * @param \Illuminate\Contracts\Events\Dispatcher $dispatcher
-         * @return void 
+         * @param string $userAgent
+         * @return bool 
          * @static 
          */
-        public static function setEventDispatcher($dispatcher){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::setEventDispatcher($dispatcher);
+        public static function isRobot($userAgent = null){
+            return \Jenssegers\Agent\Agent::isRobot($userAgent);
         }
         
         /**
-         * Unset the event dispatcher for models.
+         * 
          *
-         * @return void 
+         * @inheritdoc 
          * @static 
          */
-        public static function unsetEventDispatcher(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::unsetEventDispatcher();
+        public static function version($propertyName, $type = 'text'){
+            return \Jenssegers\Agent\Agent::version($propertyName, $type);
         }
         
         /**
-         * Get the mutated attributes for a given instance.
+         * Get the current script version.
+         * 
+         * This is useful for the demo.php file,
+         * so people can check on what version they are testing
+         * for mobile devices.
          *
-         * @return array 
+         * @return string The version number in semantic version format.
          * @static 
          */
-        public static function getMutatedAttributes(){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::getMutatedAttributes();
+        public static function getScriptVersion(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getScriptVersion();
         }
         
         /**
-         * Extract and cache all the mutated attributes of a class.
+         * Set the HTTP Headers. Must be PHP-flavored. This method will reset existing headers.
          *
-         * @param string $class
-         * @return void 
+         * @param array $httpHeaders The headers to set. If null, then using PHP's _SERVER to extract
+         *                           the headers. The default null is left for backwards compatibility.
          * @static 
          */
-        public static function cacheMutatedAttributes($class){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::cacheMutatedAttributes($class);
+        public static function setHttpHeaders($httpHeaders = null){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::setHttpHeaders($httpHeaders);
         }
         
         /**
-         * Determine if the given attribute exists.
+         * Retrieves the HTTP headers.
          *
-         * @param mixed $offset
-         * @return bool 
+         * @return array 
          * @static 
          */
-        public static function offsetExists($offset){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::offsetExists($offset);
+        public static function getHttpHeaders(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getHttpHeaders();
         }
         
         /**
-         * Get the value for a given offset.
+         * Retrieves a particular header. If it doesn't exist, no exception/error is caused.
+         * 
+         * Simply null is returned.
          *
-         * @param mixed $offset
-         * @return mixed 
+         * @param string $header The name of the header to retrieve. Can be HTTP compliant such as
+         *                       "User-Agent" or "X-Device-User-Agent" or can be php-esque with the
+         *                       all-caps, HTTP_ prefixed, underscore seperated awesomeness.
+         * @return string|null The value of the header.
          * @static 
          */
-        public static function offsetGet($offset){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            return \Webpatser\Countries\Countries::offsetGet($offset);
+        public static function getHttpHeader($header){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getHttpHeader($header);
         }
         
         /**
-         * Set the value for a given offset.
+         * 
          *
-         * @param mixed $offset
-         * @param mixed $value
-         * @return void 
          * @static 
          */
-        public static function offsetSet($offset, $value){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::offsetSet($offset, $value);
+        public static function getMobileHeaders(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMobileHeaders();
         }
         
         /**
-         * Unset the value for a given offset.
+         * Get all possible HTTP headers that
+         * can contain the User-Agent string.
          *
-         * @param mixed $offset
-         * @return void 
+         * @return array List of HTTP headers.
          * @static 
          */
-        public static function offsetUnset($offset){
-            //Method inherited from \Illuminate\Database\Eloquent\Model            
-            \Webpatser\Countries\Countries::offsetUnset($offset);
+        public static function getUaHttpHeaders(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getUaHttpHeaders();
         }
         
-    }
-
-
-    class Image extends \Intervention\Image\Facades\Image{
-        
         /**
-         * Overrides configuration settings
+         * Set CloudFront headers
+         * http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-device
          *
-         * @param array $config
+         * @param array $cfHeaders List of HTTP headers
+         * @return boolean If there were CloudFront headers to be set
          * @static 
          */
-        public static function configure($config = array()){
-            return \Intervention\Image\ImageManager::configure($config);
+        public static function setCfHeaders($cfHeaders = null){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::setCfHeaders($cfHeaders);
         }
         
         /**
-         * Initiates an Image instance from different input types
+         * Retrieves the cloudfront headers.
          *
-         * @param mixed $data
-         * @return \Intervention\Image\Image 
+         * @return array 
          * @static 
          */
-        public static function make($data){
-            return \Intervention\Image\ImageManager::make($data);
+        public static function getCfHeaders(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getCfHeaders();
         }
         
         /**
-         * Creates an empty image canvas
+         * Set the User-Agent to be used.
          *
-         * @param integer $width
-         * @param integer $height
-         * @param mixed $background
-         * @return \Intervention\Image\Image 
+         * @param string $userAgent The user agent string to set.
+         * @return string|null 
          * @static 
          */
-        public static function canvas($width, $height, $background = null){
-            return \Intervention\Image\ImageManager::canvas($width, $height, $background);
+        public static function setUserAgent($userAgent = null){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::setUserAgent($userAgent);
         }
         
         /**
-         * Create new cached image and run callback
-         * (requires additional package intervention/imagecache)
+         * Retrieve the User-Agent.
          *
-         * @param \Closure $callback
-         * @param integer $lifetime
-         * @param boolean $returnObj
-         * @return \Image 
+         * @return string|null The user agent if it's set.
          * @static 
          */
-        public static function cache($callback, $lifetime = null, $returnObj = false){
-            return \Intervention\Image\ImageManager::cache($callback, $lifetime, $returnObj);
+        public static function getUserAgent(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getUserAgent();
         }
         
-    }
-
-
-    class Entrust extends \Zizaco\Entrust\EntrustFacade{
-        
         /**
-         * Checks if the current user has a role by its name
+         * Set the detection type. Must be one of self::DETECTION_TYPE_MOBILE or
+         * self::DETECTION_TYPE_EXTENDED. Otherwise, nothing is set.
          *
-         * @param string $name Role name.
-         * @return bool 
+         * @deprecated since version 2.6.9
+         * @param string $type The type. Must be a self::DETECTION_TYPE_* constant. The default
+         *                     parameter is null which will default to self::DETECTION_TYPE_MOBILE.
          * @static 
          */
-        public static function hasRole($role, $requireAll = false){
-            return \Zizaco\Entrust\Entrust::hasRole($role, $requireAll);
+        public static function setDetectionType($type = null){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::setDetectionType($type);
         }
         
         /**
-         * Check if the current user has a permission by its name
+         * 
          *
-         * @param string $permission Permission string.
-         * @return bool 
          * @static 
          */
-        public static function can($permission, $requireAll = false){
-            return \Zizaco\Entrust\Entrust::can($permission, $requireAll);
+        public static function getMatchingRegex(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMatchingRegex();
         }
         
         /**
-         * Check if the current user has a role or permission by its name
+         * 
          *
-         * @param array|string $roles The role(s) needed.
-         * @param array|string $permissions The permission(s) needed.
-         * @param array $options The Options.
-         * @return bool 
          * @static 
          */
-        public static function ability($roles, $permissions, $options = array()){
-            return \Zizaco\Entrust\Entrust::ability($roles, $permissions, $options);
+        public static function getMatchesArray(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMatchesArray();
         }
         
         /**
-         * Get the currently authenticated user or null.
+         * Retrieve the list of known phone devices.
          *
-         * @return \Zizaco\Entrust\Illuminate\Auth\UserInterface|null 
+         * @return array List of phone devices.
          * @static 
          */
-        public static function user(){
-            return \Zizaco\Entrust\Entrust::user();
+        public static function getPhoneDevices(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getPhoneDevices();
         }
         
         /**
-         * Filters a route for a role or set of roles.
-         * 
-         * If the third parameter is null then abort with status code 403.
-         * Otherwise the $result is returned.
+         * Retrieve the list of known tablet devices.
          *
-         * @param string $route Route pattern. i.e: "admin/*"
-         * @param array|string $roles The role(s) needed
-         * @param mixed $result i.e: Redirect::to('/')
-         * @param bool $requireAll User must have all roles
-         * @return mixed 
+         * @return array List of tablet devices.
          * @static 
          */
-        public static function routeNeedsRole($route, $roles, $result = null, $requireAll = true){
-            return \Zizaco\Entrust\Entrust::routeNeedsRole($route, $roles, $result, $requireAll);
+        public static function getTabletDevices(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getTabletDevices();
         }
         
         /**
-         * Filters a route for a permission or set of permissions.
-         * 
-         * If the third parameter is null then abort with status code 403.
-         * Otherwise the $result is returned.
+         * Alias for getBrowsers() method.
          *
-         * @param string $route Route pattern. i.e: "admin/*"
-         * @param array|string $permissions The permission(s) needed
-         * @param mixed $result i.e: Redirect::to('/')
-         * @param bool $requireAll User must have all permissions
-         * @return mixed 
+         * @return array List of user agents.
          * @static 
          */
-        public static function routeNeedsPermission($route, $permissions, $result = null, $requireAll = true){
-            return \Zizaco\Entrust\Entrust::routeNeedsPermission($route, $permissions, $result, $requireAll);
+        public static function getUserAgents(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getUserAgents();
         }
         
         /**
-         * Filters a route for role(s) and/or permission(s).
-         * 
-         * If the third parameter is null then abort with status code 403.
-         * Otherwise the $result is returned.
+         * Retrieve the list of known browsers. Specifically, the user agents.
          *
-         * @param string $route Route pattern. i.e: "admin/*"
-         * @param array|string $roles The role(s) needed
-         * @param array|string $permissions The permission(s) needed
-         * @param mixed $result i.e: Redirect::to('/')
-         * @param bool $requireAll User must have all roles and permissions
-         * @return void 
+         * @return array List of browsers / user agents.
          * @static 
          */
-        public static function routeNeedsRoleOrPermission($route, $roles, $permissions, $result = null, $requireAll = false){
-            \Zizaco\Entrust\Entrust::routeNeedsRoleOrPermission($route, $roles, $permissions, $result, $requireAll);
+        public static function getBrowsers(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getBrowsers();
         }
         
-    }
-
-
-    class Settings extends \anlutro\LaravelSettings\Facade{
-        
         /**
-         * 
+         * Retrieve the list of known utilities.
          *
+         * @return array List of utilities.
          * @static 
          */
-        public static function getDefaultDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::getDefaultDriver();
+        public static function getUtilities(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getUtilities();
         }
         
         /**
-         * 
+         * Method gets the mobile detection rules. This method is used for the magic methods $detect->is*().
          *
+         * @deprecated since version 2.6.9
+         * @return array All the rules (but not extended).
          * @static 
          */
-        public static function createJsonDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::createJsonDriver();
+        public static function getMobileDetectionRules(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMobileDetectionRules();
         }
         
         /**
+         * Method gets the mobile detection rules + utilities.
          * 
+         * The reason this is separate is because utilities rules
+         * don't necessary imply mobile. This method is used inside
+         * the new $detect->is('stuff') method.
          *
+         * @deprecated since version 2.6.9
+         * @return array All the rules + extended.
          * @static 
          */
-        public static function createDatabaseDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::createDatabaseDriver();
+        public static function getMobileDetectionRulesExtended(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getMobileDetectionRulesExtended();
         }
         
         /**
-         * 
+         * Retrieve the list of mobile operating systems.
          *
+         * @return array The list of mobile operating systems.
          * @static 
          */
-        public static function createMemoryDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::createMemoryDriver();
+        public static function getOperatingSystems(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getOperatingSystems();
         }
         
         /**
+         * Check the HTTP headers for signs of mobile.
          * 
+         * This is the fastest mobile check possible; it's used
+         * inside isMobile() method.
          *
+         * @return bool 
          * @static 
          */
-        public static function createArrayDriver(){
-            return \anlutro\LaravelSettings\SettingsManager::createArrayDriver();
+        public static function checkHttpHeadersForMobile(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::checkHttpHeadersForMobile();
         }
         
         /**
-         * Get a driver instance.
+         * Check if the device is mobile.
+         * 
+         * Returns true if any type of mobile device detected, including special ones
          *
-         * @param string $driver
-         * @return mixed 
+         * @param null $userAgent deprecated
+         * @param null $httpHeaders deprecated
+         * @return bool 
          * @static 
          */
-        public static function driver($driver = null){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \anlutro\LaravelSettings\SettingsManager::driver($driver);
+        public static function isMobile($userAgent = null, $httpHeaders = null){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::isMobile($userAgent, $httpHeaders);
         }
         
         /**
-         * Register a custom driver creator Closure.
+         * Check if the device is a tablet.
+         * 
+         * Return true if any type of tablet device is detected.
          *
-         * @param string $driver
-         * @param \Closure $callback
-         * @return $this 
+         * @param string $userAgent deprecated
+         * @param array $httpHeaders deprecated
+         * @return bool 
          * @static 
          */
-        public static function extend($driver, $callback){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \anlutro\LaravelSettings\SettingsManager::extend($driver, $callback);
+        public static function isTablet($userAgent = null, $httpHeaders = null){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::isTablet($userAgent, $httpHeaders);
         }
         
         /**
-         * Get all of the created "drivers".
+         * This method checks for a certain property in the
+         * userAgent.
          *
-         * @return array 
+         * @todo : The httpHeaders part is not yet used.
+         * @param string $key
+         * @param string $userAgent deprecated
+         * @param string $httpHeaders deprecated
+         * @return bool|int|null 
          * @static 
          */
-        public static function getDrivers(){
-            //Method inherited from \Illuminate\Support\Manager            
-            return \anlutro\LaravelSettings\SettingsManager::getDrivers();
+        public static function is($key, $userAgent = null, $httpHeaders = null){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::is($key, $userAgent, $httpHeaders);
         }
         
-    }
-
-
-    class Authy extends \Vanguard\Services\Auth\TwoFactor\Facade{
-        
         /**
-         * Determine if the given user has two-factor authentication enabled.
+         * Some detection rules are relative (not standard),
+         * because of the diversity of devices, vendors and
+         * their conventions in representing the User-Agent or
+         * the HTTP headers.
+         * 
+         * This method will be used to check custom regexes against
+         * the User-Agent string.
          *
-         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
+         * @param $regex
+         * @param string $userAgent
          * @return bool 
+         * @todo : search in the HTTP headers too.
          * @static 
          */
-        public static function isEnabled($user){
-            return \Vanguard\Services\Auth\TwoFactor\Authy::isEnabled($user);
+        public static function match($regex, $userAgent = null){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::match($regex, $userAgent);
         }
         
         /**
-         * Register the given user with the provider.
+         * Get the properties array.
          *
-         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
+         * @return array 
          * @static 
          */
-        public static function register($user){
-            return \Vanguard\Services\Auth\TwoFactor\Authy::register($user);
+        public static function getProperties(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::getProperties();
         }
         
         /**
-         * Determine if the given token is valid for the given user.
+         * Prepare the version number.
          *
-         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
-         * @param string $token
-         * @return bool 
+         * @todo Remove the error supression from str_replace() call.
+         * @param string $ver The string version, like "2.6.21.2152";
+         * @return float 
          * @static 
          */
-        public static function tokenIsValid($user, $token){
-            return \Vanguard\Services\Auth\TwoFactor\Authy::tokenIsValid($user, $token);
+        public static function prepareVersionNo($ver){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::prepareVersionNo($ver);
         }
         
         /**
-         * Delete the given user from the provider.
+         * Retrieve the mobile grading, using self::MOBILE_GRADE_* constants.
          *
-         * @param \Vanguard\Services\Auth\TwoFactor\TwoFactorAuthenticatable $user
-         * @return bool 
+         * @return string One of the self::MOBILE_GRADE_* constants.
          * @static 
          */
-        public static function delete($user){
-            return \Vanguard\Services\Auth\TwoFactor\Authy::delete($user);
+        public static function mobileGrade(){
+            //Method inherited from \Mobile_Detect            
+            return \Jenssegers\Agent\Agent::mobileGrade();
         }
         
     }
@@ -16561,3 +18107,5 @@ namespace {
 
 }
 
+
+
diff --git a/app/Country.php b/app/Country.php
index 5f45a06..c4ff580 100644
--- a/app/Country.php
+++ b/app/Country.php
@@ -9,4 +9,4 @@ class Country extends Model
     protected $table = 'countries';
 
     public $timestamps = false;
-}
\ No newline at end of file
+}
diff --git a/app/Events/User/Registered.php b/app/Events/User/Registered.php
index 7fb41aa..9fa64b8 100644
--- a/app/Events/User/Registered.php
+++ b/app/Events/User/Registered.php
@@ -4,7 +4,7 @@ namespace Vanguard\Events\User;
 
 use Vanguard\User;
 
-class Registered 
+class Registered
 {
     /**
      * @var User
diff --git a/app/Exceptions/Handler.php b/app/Exceptions/Handler.php
index becf49e..d76d6eb 100644
--- a/app/Exceptions/Handler.php
+++ b/app/Exceptions/Handler.php
@@ -9,6 +9,7 @@ use Illuminate\Database\Eloquent\ModelNotFoundException;
 use Illuminate\Http\Exceptions\HttpResponseException;
 use Illuminate\Session\TokenMismatchException;
 use Illuminate\Validation\ValidationException;
+use Symfony\Component\HttpFoundation\Response;
 use Symfony\Component\HttpKernel\Exception\HttpException;
 use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
 use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
@@ -52,7 +53,7 @@ class Handler extends ExceptionHandler
         if ($e instanceof HttpResponseException) {
             return $e->getResponse();
         } elseif ($e instanceof ModelNotFoundException) {
-            $e = new NotFoundHttpException($e->getMessage(), $e);
+            $e = new NotFoundHttpException("Resource not found.", $e);
         } elseif ($e instanceof AuthorizationException) {
             $e = new HttpException(403, $e->getMessage());
         } elseif ($e instanceof ValidationException && $e->getResponse()) {
@@ -62,6 +63,13 @@ class Handler extends ExceptionHandler
         }
 
         if ($this->isHttpException($e)) {
+            if ($request->expectsJson()) {
+                return response()->json(
+                    ['error' => $e->getMessage() ?: $this->getMessageFromStatusCode($e->getStatusCode())],
+                    $e->getStatusCode()
+                );
+            }
+
             return $this->toIlluminateResponse($this->renderHttpException($e), $e);
         }
 
@@ -85,4 +93,9 @@ class Handler extends ExceptionHandler
 
         return redirect()->guest('login');
     }
+
+    private function getMessageFromStatusCode($code)
+    {
+        return array_get(Response::$statusTexts, $code);
+    }
 }
diff --git a/app/Http/Controllers/Api/ActivityController.php b/app/Http/Controllers/Api/ActivityController.php
new file mode 100644
index 0000000..65a050e
--- /dev/null
+++ b/app/Http/Controllers/Api/ActivityController.php
@@ -0,0 +1,39 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api;
+
+use Vanguard\Http\Requests\Activity\GetActivitiesRequest;
+use Vanguard\Repositories\Activity\ActivityRepository;
+use Vanguard\Transformers\ActivityTransformer;
+
+/**
+ * Class ActivityController
+ * @package Vanguard\Http\Controllers\Api
+ */
+class ActivityController extends ApiController
+{
+    public function __construct()
+    {
+        $this->middleware('auth');
+        $this->middleware('permission:users.activity');
+    }
+
+    /**
+     * Paginate user activities.
+     * @param GetActivitiesRequest $request
+     * @param ActivityRepository $activities
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index(GetActivitiesRequest $request, ActivityRepository $activities)
+    {
+        $result = $activities->paginateActivities(
+            $request->per_page ?: 20,
+            $request->search
+        );
+
+        return $this->respondWithPagination(
+            $result,
+            new ActivityTransformer
+        );
+    }
+}
diff --git a/app/Http/Controllers/Api/ApiController.php b/app/Http/Controllers/Api/ApiController.php
new file mode 100644
index 0000000..e7b7333
--- /dev/null
+++ b/app/Http/Controllers/Api/ApiController.php
@@ -0,0 +1,208 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api;
+
+use Illuminate\Contracts\Pagination\Paginator;
+use Illuminate\Http\Response;
+use League\Fractal\Manager;
+use League\Fractal\Pagination\IlluminatePaginatorAdapter;
+use League\Fractal\Resource\Collection;
+use League\Fractal\Resource\Item;
+use Vanguard\Http\Controllers\Controller;
+use Vanguard\Support\DataArraySerializer;
+
+abstract class ApiController extends Controller
+{
+    protected $statusCode = 200;
+
+    protected $fractal;
+
+    /**
+     * @return Manager
+     */
+    protected function fractal()
+    {
+        if ($this->fractal) {
+            return $this->fractal;
+        }
+
+        $fractal = app(Manager::class);
+        $fractal->setRecursionLimit(2);
+        $fractal->setSerializer(new DataArraySerializer);
+
+        if ($includes = request('include')) {
+            $fractal->parseIncludes($includes);
+        }
+
+        return $this->fractal = $fractal;
+    }
+
+    /**
+     * Getter for statusCode
+     *
+     * @return int
+     */
+    public function getStatusCode()
+    {
+        return $this->statusCode;
+    }
+
+    /**
+     * Setter for statusCode
+     *
+     * @param int $statusCode Value to set
+     *
+     * @return self
+     */
+    public function setStatusCode($statusCode)
+    {
+        $this->statusCode = $statusCode;
+        return $this;
+    }
+
+    protected function respondWithItem($item, $callback)
+    {
+        if ($includes = $this->getValidIncludes($callback)) {
+            $item->load($includes);
+        }
+
+        $resource = new Item($item, $callback);
+
+        $rootScope = $this->fractal()->createData($resource);
+
+        return $this->respondWithArray($rootScope->toArray());
+    }
+
+    protected function respondWithCollection($collection, $callback)
+    {
+        if ($includes = $this->getValidIncludes($callback)) {
+            $collection->load($includes);
+        }
+
+        $resource = new Collection($collection, $callback);
+
+        $rootScope = $this->fractal()->createData($resource);
+
+        return $this->respondWithArray($rootScope->toArray());
+    }
+
+    protected function respondWithPagination(Paginator $paginator, $callback)
+    {
+        if ($includes = $this->getValidIncludes($callback)) {
+            $paginator->load($includes);
+        }
+
+        $queryParams = array_diff_key($_GET, array_flip(['page']));
+        $paginator->appends($queryParams);
+
+        $resource = new Collection($paginator, $callback, 'data');
+        $resource->setPaginator(new IlluminatePaginatorAdapter($paginator));
+
+        $rootScope = $this->fractal()->createData($resource);
+
+        return $this->respondWithArray($rootScope->toArray());
+    }
+
+    private function getValidIncludes($callback)
+    {
+        $includes = $this->fractal()->getRequestedIncludes();
+
+        if (! $includes) {
+            return null;
+        }
+
+        return array_intersect(
+            $includes,
+            $callback->getAvailableIncludes()
+        );
+    }
+
+    protected function respondWithSuccess($statusCode = 200)
+    {
+        return $this->setStatusCode($statusCode)
+            ->respondWithArray(['success' => true]);
+    }
+
+    protected function respondWithArray(array $array, array $headers = [])
+    {
+        $response = \Response::json($array, $this->statusCode, $headers);
+
+        $response->header('Content-Type', 'application/json');
+
+        return $response;
+    }
+
+    protected function respondWithError($message)
+    {
+        if ($this->statusCode === 200) {
+            trigger_error(
+                "You better have a really good reason for erroring on a 200...",
+                E_USER_WARNING
+            );
+        }
+
+        return $this->respondWithArray([
+            'error' => $message
+        ]);
+    }
+
+    /**
+     * Generates a Response with a 403 HTTP header and a given message.
+     *
+     * @param string $message
+     * @return Response
+     */
+    public function errorForbidden($message = 'Forbidden')
+    {
+        return $this->setStatusCode(403)
+            ->respondWithError($message);
+    }
+
+    /**
+     * Generates a Response with a 500 HTTP header and a given message.
+     *
+     * @param string $message
+     * @return Response
+     */
+    public function errorInternalError($message = 'Internal Error')
+    {
+        return $this->setStatusCode(500)
+            ->respondWithError($message);
+    }
+
+    /**
+     * Generates a Response with a 404 HTTP header and a given message.
+     *
+     * @param string $message
+     * @return Response
+     */
+    public function errorNotFound($message = 'Resource Not Found')
+    {
+        return $this->setStatusCode(404)
+            ->respondWithError($message);
+    }
+
+    /**
+     * Generates a Response with a 401 HTTP header and a given message.
+     *
+     * @param string $message
+     * @return Response
+     */
+    public function errorUnauthorized($message = 'Unauthorized')
+    {
+        return $this->setStatusCode(401)
+            ->respondWithError($message);
+    }
+
+    /**
+     * Generates a Response with a 400 HTTP header and a given message.
+     *
+     * @param string $message
+     * @return Response
+     */
+    public function errorWrongArgs($message = 'Wrong Arguments')
+    {
+        return $this->setStatusCode(400)
+            ->respondWithError($message);
+    }
+}
diff --git a/app/Http/Controllers/Api/Auth/AuthController.php b/app/Http/Controllers/Api/Auth/AuthController.php
new file mode 100644
index 0000000..1f463aa
--- /dev/null
+++ b/app/Http/Controllers/Api/Auth/AuthController.php
@@ -0,0 +1,59 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Auth;
+
+use JWTAuth;
+use Tymon\JWTAuth\Exceptions\JWTException;
+use Vanguard\Events\User\LoggedIn;
+use Vanguard\Events\User\LoggedOut;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Auth\LoginRequest;
+
+/**
+ * Class LoginController
+ * @package Vanguard\Http\Controllers\Api\Auth
+ */
+class AuthController extends ApiController
+{
+    public function __construct()
+    {
+        $this->middleware('guest')->only('login');
+        $this->middleware('auth')->only('logout');
+    }
+
+    /**
+     * Attempt to log the user in and generate unique
+     * JWT token on successful authentication.
+     * @param LoginRequest $request
+     * @return \Illuminate\Http\Response
+     */
+    public function login(LoginRequest $request)
+    {
+        $credentials = $request->only('username', 'password');
+
+        try {
+            if (! $token = JWTAuth::attempt($credentials)) {
+                return $this->errorUnauthorized('Invalid credentials.');
+            }
+        } catch (JWTException $e) {
+            return $this->errorInternalError('Could not create token.');
+        }
+
+        event(new LoggedIn);
+
+        return $this->respondWithArray(compact('token'));
+    }
+
+    /**
+     * Logout user and invalidate token.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function logout()
+    {
+        event(new LoggedOut);
+
+        auth()->logout();
+
+        return $this->respondWithSuccess();
+    }
+}
diff --git a/app/Http/Controllers/Api/Auth/Password/RemindController.php b/app/Http/Controllers/Api/Auth/Password/RemindController.php
new file mode 100644
index 0000000..859a846
--- /dev/null
+++ b/app/Http/Controllers/Api/Auth/Password/RemindController.php
@@ -0,0 +1,41 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Auth\Password;
+
+use Vanguard\Events\User\RequestedPasswordResetEmail;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Auth\PasswordRemindRequest;
+use Vanguard\Notifications\ResetPassword;
+use Vanguard\Repositories\User\UserRepository;
+use Password;
+
+class RemindController extends ApiController
+{
+    /**
+     * Create a new password controller instance.
+     */
+    public function __construct()
+    {
+        $this->middleware('guest');
+    }
+
+    /**
+     * Send a reset link to the given user.
+     *
+     * @param PasswordRemindRequest $request
+     * @param UserRepository $users
+     * @return \Illuminate\Http\Response
+     */
+    public function index(PasswordRemindRequest $request, UserRepository $users)
+    {
+        $user = $users->findByEmail($request->email);
+
+        $token = Password::getRepository()->create($user);
+
+        $user->notify(new ResetPassword($token));
+
+        event(new RequestedPasswordResetEmail($user));
+
+        return $this->respondWithSuccess();
+    }
+}
diff --git a/app/Http/Controllers/Api/Auth/Password/ResetController.php b/app/Http/Controllers/Api/Auth/Password/ResetController.php
new file mode 100644
index 0000000..3799953
--- /dev/null
+++ b/app/Http/Controllers/Api/Auth/Password/ResetController.php
@@ -0,0 +1,58 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Auth\Password;
+
+use Vanguard\Events\User\ResetedPasswordViaEmail;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Auth\PasswordResetRequest;
+use Password;
+
+class ResetController extends ApiController
+{
+    /**
+     * Create a new password controller instance.
+     */
+    public function __construct()
+    {
+        $this->middleware('guest');
+    }
+
+    /**
+     * Reset the given user's password.
+     *
+     * @param PasswordResetRequest $request
+     * @return \Illuminate\Http\Response
+     */
+    public function index(PasswordResetRequest $request)
+    {
+        $credentials = $request->only('email', 'password', 'password_confirmation', 'token');
+
+        $response = Password::reset($credentials, function ($user, $password) {
+            $this->resetPassword($user, $password);
+        });
+
+        switch ($response) {
+            case Password::PASSWORD_RESET:
+                return $this->respondWithSuccess();
+
+            default:
+                return $this->setStatusCode(400)
+                    ->respondWithError(trans($response));
+        }
+    }
+
+    /**
+     * Reset the given user's password.
+     *
+     * @param  \Illuminate\Contracts\Auth\CanResetPassword  $user
+     * @param  string  $password
+     * @return void
+     */
+    protected function resetPassword($user, $password)
+    {
+        $user->password = $password;
+        $user->save();
+
+        event(new ResetedPasswordViaEmail($user));
+    }
+}
diff --git a/app/Http/Controllers/Api/Auth/RegistrationController.php b/app/Http/Controllers/Api/Auth/RegistrationController.php
new file mode 100644
index 0000000..fb76e74
--- /dev/null
+++ b/app/Http/Controllers/Api/Auth/RegistrationController.php
@@ -0,0 +1,87 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Auth;
+
+use Vanguard\Events\User\Registered;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Auth\RegisterRequest;
+use Vanguard\Repositories\Role\RoleRepository;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Support\Enum\UserStatus;
+
+class RegistrationController extends ApiController
+{
+    /**
+     * @var UserRepository
+     */
+    private $users;
+
+    /**
+     * @var RoleRepository
+     */
+    private $roles;
+
+    /**
+     * Create a new authentication controller instance.
+     * @param UserRepository $users
+     * @param RoleRepository $roles
+     */
+    public function __construct(UserRepository $users, RoleRepository $roles)
+    {
+        $this->middleware('registration');
+
+        $this->users = $users;
+        $this->roles = $roles;
+    }
+
+    /**
+     * @param RegisterRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index(RegisterRequest $request)
+    {
+        // Determine user status. User's status will be set to UNCONFIRMED
+        // if he has to confirm his email or to ACTIVE if email confirmation is not required
+        $status = settings('reg_email_confirmation')
+            ? UserStatus::UNCONFIRMED
+            : UserStatus::ACTIVE;
+
+        $role = $this->roles->findByName('User');
+
+        $user = $this->users->create(array_merge(
+            $request->only('email', 'username', 'password'),
+            ['status' => $status, 'role_id' => $role->id]
+        ));
+
+        event(new Registered($user));
+
+        return $this->setStatusCode(201)
+            ->respondWithArray([
+                'requires_email_confirmation' => !! settings('reg_email_confirmation')
+            ]);
+    }
+
+    /**
+     * Verify email via email confirmation token.
+     * @param $token
+     * @return \Illuminate\Http\Response
+     */
+    public function verifyEmail($token)
+    {
+        if (! settings('reg_email_confirmation')) {
+            return $this->errorNotFound();
+        }
+
+        if ($user = $this->users->findByConfirmationToken($token)) {
+            $this->users->update($user->id, [
+                'status' => UserStatus::ACTIVE,
+                'confirmation_token' => null
+            ]);
+
+            return $this->respondWithSuccess();
+        }
+
+        return $this->setStatusCode(400)
+            ->respondWithError("Invalid confirmation token.");
+    }
+}
diff --git a/app/Http/Controllers/Api/Auth/SocialLoginController.php b/app/Http/Controllers/Api/Auth/SocialLoginController.php
new file mode 100644
index 0000000..ef4c436
--- /dev/null
+++ b/app/Http/Controllers/Api/Auth/SocialLoginController.php
@@ -0,0 +1,64 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Auth;
+
+use Exception;
+use JWTAuth;
+use Socialite;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Auth\Social\ApiAuthenticateRequest;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Services\Auth\Social\SocialManager;
+
+class SocialLoginController extends ApiController
+{
+    /**
+     * @var UserRepository
+     */
+    private $users;
+
+    /**
+     * @var SocialManager
+     */
+    private $socialManager;
+
+    /**
+     * @param UserRepository $users
+     * @param SocialManager $socialManager
+     */
+    public function __construct(UserRepository $users, SocialManager $socialManager)
+    {
+        $this->users = $users;
+        $this->socialManager = $socialManager;
+    }
+
+    public function index(ApiAuthenticateRequest $request)
+    {
+        try {
+            $socialUser = Socialite::driver($request->network)->userFromToken($request->social_token);
+        } catch (Exception $e) {
+            return $this->errorInternalError("Could not connect to specified social network.");
+        }
+
+        $user = $this->users->findBySocialId(
+            $request->network,
+            $socialUser->getId()
+        );
+
+        if (! $user) {
+            if (! settings('reg_enabled')) {
+                return $this->errorForbidden("Only users who already created an account can log in.");
+            }
+
+            $user = $this->socialManager->associate($socialUser, $request->network);
+        }
+
+        if ($user->isBanned()) {
+            return $this->errorForbidden("Your account is banned by administrators.");
+        }
+
+        return $this->respondWithArray([
+            'token' => JWTAuth::fromUser($user)
+        ]);
+    }
+}
diff --git a/app/Http/Controllers/Api/Authorization/PermissionsController.php b/app/Http/Controllers/Api/Authorization/PermissionsController.php
new file mode 100644
index 0000000..8439892
--- /dev/null
+++ b/app/Http/Controllers/Api/Authorization/PermissionsController.php
@@ -0,0 +1,97 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Authorization;
+
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Permission\CreatePermissionRequest;
+use Vanguard\Http\Requests\Permission\RemovePermissionRequest;
+use Vanguard\Http\Requests\Permission\UpdatePermissionRequest;
+use Vanguard\Permission;
+use Vanguard\Repositories\Permission\PermissionRepository;
+use Vanguard\Transformers\PermissionTransformer;
+
+/**
+ * Class PermissionsController
+ * @package Vanguard\Http\Controllers\Api\Users
+ */
+class PermissionsController extends ApiController
+{
+    /**
+     * @var PermissionRepository
+     */
+    private $permissions;
+
+    public function __construct(PermissionRepository $permissions)
+    {
+        $this->permissions = $permissions;
+        $this->middleware('auth');
+        $this->middleware('permission:permissions.manage');
+    }
+
+    /**
+     * Get all system permissions.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index()
+    {
+        return $this->respondWithCollection(
+            $this->permissions->all(),
+            new PermissionTransformer
+        );
+    }
+
+    /**
+     * Create new permission from request.
+     * @param CreatePermissionRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function store(CreatePermissionRequest $request)
+    {
+        $permission = $this->permissions->create(
+            $request->only(['name', 'display_name', 'description'])
+        );
+
+        return $this->respondWithItem($permission, new PermissionTransformer);
+    }
+
+    /**
+     * Get info about specified permission.
+     * @param Permission $permission
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function show(Permission $permission)
+    {
+        return $this->respondWithItem($permission, new PermissionTransformer);
+    }
+
+    /**
+     * Update specified permission.
+     * @param Permission $permission
+     * @param UpdatePermissionRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function update(Permission $permission, UpdatePermissionRequest $request)
+    {
+        $input = collect($request->all());
+
+        $permission = $this->permissions->update(
+            $permission->id,
+            $input->only(['name', 'display_name', 'description'])->toArray()
+        );
+
+        return $this->respondWithItem($permission, new PermissionTransformer);
+    }
+
+    /**
+     * Remove specified permission from storage.
+     * @param Permission $permission
+     * @param RemovePermissionRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function destroy(Permission $permission, RemovePermissionRequest $request)
+    {
+        $this->permissions->delete($permission->id);
+
+        return $this->respondWithSuccess();
+    }
+}
diff --git a/app/Http/Controllers/Api/Authorization/RolePermissionsController.php b/app/Http/Controllers/Api/Authorization/RolePermissionsController.php
new file mode 100644
index 0000000..a28672c
--- /dev/null
+++ b/app/Http/Controllers/Api/Authorization/RolePermissionsController.php
@@ -0,0 +1,65 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Authorization;
+
+use Cache;
+use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
+use Vanguard\Events\Role\PermissionsUpdated;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Role\CreateRoleRequest;
+use Vanguard\Http\Requests\Role\RemoveRoleRequest;
+use Vanguard\Http\Requests\Role\UpdateRolePermissionsRequest;
+use Vanguard\Http\Requests\Role\UpdateRoleRequest;
+use Vanguard\Repositories\Role\RoleRepository;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Role;
+use Vanguard\Transformers\PermissionTransformer;
+use Vanguard\Transformers\RoleTransformer;
+
+/**
+ * Class RolePermissionsController
+ * @package Vanguard\Http\Controllers\Api
+ */
+class RolePermissionsController extends ApiController
+{
+    /**
+     * @var RoleRepository
+     */
+    private $roles;
+
+    public function __construct(RoleRepository $roles)
+    {
+        $this->roles = $roles;
+        $this->middleware('auth');
+        $this->middleware('permission:permissions.manage');
+    }
+
+    public function show(Role $role)
+    {
+        return $this->respondWithCollection(
+            $role->cachedPermissions(),
+            new PermissionTransformer
+        );
+    }
+
+    /**
+     * Update specified role.
+     * @param Role $role
+     * @param UpdateRolePermissionsRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function update(Role $role, UpdateRolePermissionsRequest $request)
+    {
+        $this->roles->updatePermissions(
+            $role->id,
+            $request->permissions
+        );
+
+        event(new PermissionsUpdated);
+
+        return $this->respondWithCollection(
+            $role->cachedPermissions(),
+            new PermissionTransformer
+        );
+    }
+}
diff --git a/app/Http/Controllers/Api/Authorization/RolesController.php b/app/Http/Controllers/Api/Authorization/RolesController.php
new file mode 100644
index 0000000..0f7c606
--- /dev/null
+++ b/app/Http/Controllers/Api/Authorization/RolesController.php
@@ -0,0 +1,107 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Authorization;
+
+use Cache;
+use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Role\CreateRoleRequest;
+use Vanguard\Http\Requests\Role\RemoveRoleRequest;
+use Vanguard\Http\Requests\Role\UpdateRoleRequest;
+use Vanguard\Repositories\Role\RoleRepository;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Role;
+use Vanguard\Transformers\RoleTransformer;
+
+/**
+ * Class RolesController
+ * @package Vanguard\Http\Controllers\Api\Users
+ */
+class RolesController extends ApiController
+{
+    /**
+     * @var RoleRepository
+     */
+    private $roles;
+
+    public function __construct(RoleRepository $roles)
+    {
+        $this->roles = $roles;
+        $this->middleware('auth');
+        $this->middleware('permission:roles.manage');
+    }
+
+    /**
+     * Get all system roles with users count for each role.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index()
+    {
+        return $this->respondWithCollection(
+            $this->roles->getAllWithUsersCount(),
+            new RoleTransformer
+        );
+    }
+
+    /**
+     * Create new role from the request.
+     * @param CreateRoleRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function store(CreateRoleRequest $request)
+    {
+        $role = $this->roles->create(
+            $request->only(['name', 'display_name', 'description'])
+        );
+
+        return $this->respondWithItem($role, new RoleTransformer);
+    }
+
+    /**
+     * Return info about specified role.
+     * @param Role $role
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function show(Role $role)
+    {
+        return $this->respondWithItem($role, new RoleTransformer);
+    }
+
+    /**
+     * Update specified role.
+     * @param Role $role
+     * @param UpdateRoleRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function update(Role $role, UpdateRoleRequest $request)
+    {
+        $input = collect($request->all());
+
+        $role = $this->roles->update(
+            $role->id,
+            $input->only(['name', 'display_name', 'description'])->toArray()
+        );
+
+        return $this->respondWithItem($role, new RoleTransformer);
+    }
+
+    /**
+     * Remove specified role (if role is removable).
+     * @param Role $role
+     * @param UserRepository $users
+     * @param RemoveRoleRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function destroy(Role $role, UserRepository $users, RemoveRoleRequest $request)
+    {
+        $userRole = $this->roles->findByName('User');
+
+        $users->switchRolesForUsers($role->id, $userRole->id);
+
+        $this->roles->delete($role->id);
+
+        Cache::flush();
+
+        return $this->respondWithSuccess();
+    }
+}
diff --git a/app/Http/Controllers/Api/CountriesController.php b/app/Http/Controllers/Api/CountriesController.php
new file mode 100644
index 0000000..e264760
--- /dev/null
+++ b/app/Http/Controllers/Api/CountriesController.php
@@ -0,0 +1,36 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api;
+
+use Vanguard\Repositories\Country\CountryRepository;
+use Vanguard\Transformers\CountryTransformer;
+
+/**
+ * Class CountriesController
+ * @package Vanguard\Http\Controllers\Api
+ */
+class CountriesController extends ApiController
+{
+    /**
+     * @var CountryRepository
+     */
+    private $countries;
+
+    public function __construct(CountryRepository $countries)
+    {
+        $this->middleware('auth');
+        $this->countries = $countries;
+    }
+
+    /**
+     * Get list of all available countries.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index()
+    {
+        return $this->respondWithCollection(
+            $this->countries->all(),
+            new CountryTransformer
+        );
+    }
+}
diff --git a/app/Http/Controllers/Api/Profile/AvatarController.php b/app/Http/Controllers/Api/Profile/AvatarController.php
new file mode 100644
index 0000000..0da9942
--- /dev/null
+++ b/app/Http/Controllers/Api/Profile/AvatarController.php
@@ -0,0 +1,92 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Profile;
+
+use Illuminate\Http\Request;
+use Vanguard\Events\User\ChangedAvatar;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\User\UploadAvatarRawRequest;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Services\Upload\UserAvatarManager;
+use Vanguard\Transformers\UserTransformer;
+
+/**
+ * Class DetailsController
+ * @package Vanguard\Http\Controllers\Api\Profile
+ */
+class AvatarController extends ApiController
+{
+    /**
+     * @var UserRepository
+     */
+    private $users;
+    /**
+     * @var UserAvatarManager
+     */
+    private $avatarManager;
+
+    public function __construct(UserRepository $users, UserAvatarManager $avatarManager)
+    {
+        $this->middleware('auth');
+
+        $this->users = $users;
+        $this->avatarManager = $avatarManager;
+    }
+
+    public function update(UploadAvatarRawRequest $request)
+    {
+        $name = $this->avatarManager->uploadAndCropAvatar(
+            auth()->user(),
+            $request->file('file')
+        );
+
+        $user = $this->users->update(
+            auth()->id(),
+            ['avatar' => $name]
+        );
+
+        event(new ChangedAvatar);
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+
+    public function updateExternal(Request $request)
+    {
+        $this->validate($request, [
+            'url' => 'required|url'
+        ]);
+
+        $this->avatarManager->deleteAvatarIfUploaded(
+            auth()->user()
+        );
+
+        $user = $this->users->update(
+            auth()->id(),
+            ['avatar' => $request->url]
+        );
+
+        event(new ChangedAvatar);
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+
+    /**
+     * Remove avatar for currently authenticated user and set it to null.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function destroy()
+    {
+        $user = auth()->user();
+
+        $this->avatarManager->deleteAvatarIfUploaded($user);
+
+        $user = $this->users->update(
+            $user->id,
+            ['avatar' => null]
+        );
+
+        event(new ChangedAvatar);
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+}
diff --git a/app/Http/Controllers/Api/Profile/DetailsController.php b/app/Http/Controllers/Api/Profile/DetailsController.php
new file mode 100644
index 0000000..1940bef
--- /dev/null
+++ b/app/Http/Controllers/Api/Profile/DetailsController.php
@@ -0,0 +1,61 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Profile;
+
+use Vanguard\Events\User\UpdatedProfileDetails;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\User\UpdateProfileDetailsRequest;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Transformers\UserTransformer;
+
+/**
+ * Class DetailsController
+ * @package Vanguard\Http\Controllers\Api\Profile
+ */
+class DetailsController extends ApiController
+{
+    public function __construct()
+    {
+        $this->middleware('auth');
+    }
+
+    /**
+     * Handle user details request.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index()
+    {
+        return $this->respondWithItem(
+            auth()->user(),
+            new UserTransformer
+        );
+    }
+
+    /**
+     * Updates user profile details.
+     * @param UpdateProfileDetailsRequest $request
+     * @param UserRepository $users
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function update(UpdateProfileDetailsRequest $request, UserRepository $users)
+    {
+        $user = $request->user();
+
+        $data = collect($request->all());
+
+        $data = $data->only([
+            'first_name', 'last_name', 'birthday',
+            'phone', 'address', 'country_id'
+        ])->toArray();
+
+        if (! isset($data['country_id'])) {
+            $data['country_id'] = $user->country_id;
+        }
+
+        $user = $users->update($user->id, $data);
+
+        event(new UpdatedProfileDetails);
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+}
diff --git a/app/Http/Controllers/Api/Profile/SessionsController.php b/app/Http/Controllers/Api/Profile/SessionsController.php
new file mode 100644
index 0000000..a8fb269
--- /dev/null
+++ b/app/Http/Controllers/Api/Profile/SessionsController.php
@@ -0,0 +1,35 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Profile;
+
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Repositories\Session\SessionRepository;
+use Vanguard\Transformers\SessionTransformer;
+
+/**
+ * Class DetailsController
+ * @package Vanguard\Http\Controllers\Api\Profile
+ */
+class SessionsController extends ApiController
+{
+    public function __construct()
+    {
+        $this->middleware('auth');
+        $this->middleware('session.database');
+    }
+
+    /**
+     * Handle user details request.
+     * @param SessionRepository $sessions
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index(SessionRepository $sessions)
+    {
+        $sessions = $sessions->getUserSessions(auth()->id());
+
+        return $this->respondWithCollection(
+            $sessions,
+            new SessionTransformer
+        );
+    }
+}
diff --git a/app/Http/Controllers/Api/Profile/TwoFactorController.php b/app/Http/Controllers/Api/Profile/TwoFactorController.php
new file mode 100644
index 0000000..b272a1a
--- /dev/null
+++ b/app/Http/Controllers/Api/Profile/TwoFactorController.php
@@ -0,0 +1,72 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Profile;
+
+use Authy;
+use Vanguard\Events\User\TwoFactorDisabled;
+use Vanguard\Events\User\TwoFactorEnabled;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\User\EnableTwoFactorRequest;
+use Vanguard\Transformers\UserTransformer;
+
+/**
+ * Class TwoFactorController
+ * @package Vanguard\Http\Controllers\Api\Profile
+ */
+class TwoFactorController extends ApiController
+{
+    public function __construct()
+    {
+        $this->middleware('auth');
+    }
+
+    /**
+     * Enable 2FA for specified user.
+     * @param EnableTwoFactorRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function update(EnableTwoFactorRequest $request)
+    {
+        $user = auth()->user();
+
+        if (Authy::isEnabled($user)) {
+            return $this->setStatusCode(422)
+                ->respondWithError("2FA is already enabled for this user.");
+        }
+
+        $user->setAuthPhoneInformation(
+            $request->country_code,
+            $request->phone_number
+        );
+
+        Authy::register($user);
+
+        $user->save();
+
+        event(new TwoFactorEnabled);
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+
+    /**
+     * Disable 2FA for currently authenticated user.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function destroy()
+    {
+        $user = auth()->user();
+
+        if (! Authy::isEnabled($user)) {
+            return $this->setStatusCode(422)
+                ->respondWithError("2FA is not enabled for this user.");
+        }
+
+        Authy::delete($user);
+
+        $user->save();
+
+        event(new TwoFactorDisabled);
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+}
diff --git a/app/Http/Controllers/Api/SessionsController.php b/app/Http/Controllers/Api/SessionsController.php
new file mode 100644
index 0000000..7ea8a43
--- /dev/null
+++ b/app/Http/Controllers/Api/SessionsController.php
@@ -0,0 +1,54 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api;
+
+use Vanguard\Repositories\Session\SessionRepository;
+use Vanguard\Transformers\SessionTransformer;
+
+/**
+ * Class SessionsController
+ * @package Vanguard\Http\Controllers\Api\Users
+ */
+class SessionsController extends ApiController
+{
+    /**
+     * @var SessionRepository
+     */
+    private $sessions;
+
+    public function __construct(SessionRepository $sessions)
+    {
+        $this->middleware('auth');
+        $this->middleware('session.database');
+        $this->sessions = $sessions;
+    }
+
+    /**
+     * Get info about specified session.
+     * @param $session
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function show($session)
+    {
+        $this->authorize('manage-session', $session);
+
+        return $this->respondWithItem(
+            $session,
+            new SessionTransformer
+        );
+    }
+
+    /**
+     * Destroy specified session.
+     * @param $session
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function destroy($session)
+    {
+        $this->authorize('manage-session', $session);
+
+        $this->sessions->invalidateSession($session->id);
+
+        return $this->respondWithSuccess();
+    }
+}
diff --git a/app/Http/Controllers/Api/SettingsController.php b/app/Http/Controllers/Api/SettingsController.php
new file mode 100644
index 0000000..f2d536b
--- /dev/null
+++ b/app/Http/Controllers/Api/SettingsController.php
@@ -0,0 +1,26 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api;
+
+use Settings;
+
+/**
+ * Class SettingsController
+ * @package Vanguard\Http\Controllers\Api\Settings
+ */
+class SettingsController extends ApiController
+{
+    public function __construct()
+    {
+        $this->middleware('auth');
+        $this->middleware('permission:settings.general');
+    }
+    /**
+     * System settings.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index()
+    {
+        return Settings::all();
+    }
+}
diff --git a/app/Http/Controllers/Api/StatsController.php b/app/Http/Controllers/Api/StatsController.php
new file mode 100644
index 0000000..289c7c6
--- /dev/null
+++ b/app/Http/Controllers/Api/StatsController.php
@@ -0,0 +1,92 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api;
+
+use Auth;
+use Carbon\Carbon;
+use League\Fractal\Resource\Collection;
+use Vanguard\Repositories\Activity\ActivityRepository;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\Transformers\UserTransformer;
+
+/**
+ * Class StatsController
+ * @package Vanguard\Http\Controllers\Api
+ */
+class StatsController extends ApiController
+{
+    /**
+     * @var UserRepository
+     */
+    private $users;
+    /**
+     * @var ActivityRepository
+     */
+    private $activities;
+
+    public function __construct(UserRepository $users, ActivityRepository $activities)
+    {
+        $this->middleware('auth');
+        $this->users = $users;
+        $this->activities = $activities;
+    }
+
+    /**
+     * @return \Illuminate\Http\JsonResponse|mixed
+     */
+    public function index()
+    {
+        if (Auth::user()->hasRole('Admin')) {
+            return $this->adminStats();
+        }
+
+        return $this->defaultStats();
+    }
+
+    /**
+     * Get admin stats with details about users per
+     * status and users per month for current year.
+     * @return \Illuminate\Http\JsonResponse
+     */
+    private function adminStats()
+    {
+        $usersPerMonth = $this->users->countOfNewUsersPerMonth(
+            Carbon::now()->startOfYear(),
+            Carbon::now()
+        );
+
+        $usersPerStatus = [
+            'total' => $this->users->count(),
+            'new' => $this->users->newUsersCount(),
+            'banned' => $this->users->countByStatus(UserStatus::BANNED),
+            'unconfirmed' => $this->users->countByStatus(UserStatus::UNCONFIRMED)
+        ];
+
+        $latestRegistrations = $this->users->latest(7);
+
+        $resource = new Collection(
+            $latestRegistrations,
+            new UserTransformer
+        );
+
+        return $this->respondWithArray([
+            'users_per_month' => $usersPerMonth,
+            'users_per_status' => $usersPerStatus,
+            'latest_registrations' => $this->fractal()->createData($resource)->toArray()
+        ]);
+    }
+
+    /**
+     * Get user activity for each day in specified period.
+     * @return mixed
+     */
+    private function defaultStats()
+    {
+        return $this->activities->userActivityForPeriod(
+            Auth::user()->id,
+            Carbon::now()->subWeeks(2),
+            Carbon::now()
+        );
+    }
+}
diff --git a/app/Http/Controllers/Api/Users/ActivityController.php b/app/Http/Controllers/Api/Users/ActivityController.php
new file mode 100644
index 0000000..3a1d0e5
--- /dev/null
+++ b/app/Http/Controllers/Api/Users/ActivityController.php
@@ -0,0 +1,49 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Users;
+
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\Activity\GetActivitiesRequest;
+use Vanguard\Repositories\Activity\ActivityRepository;
+use Vanguard\Transformers\ActivityTransformer;
+use Vanguard\User;
+
+/**
+ * Class ActivityController
+ * @package Vanguard\Http\Controllers\Api\Users
+ */
+class ActivityController extends ApiController
+{
+    /**
+     * @var ActivityRepository
+     */
+    private $activities;
+
+    public function __construct(ActivityRepository $activities)
+    {
+        $this->middleware('auth');
+        $this->middleware('permission:users.activity');
+
+        $this->activities = $activities;
+    }
+
+    /**
+     * Get activities for specified user.
+     * @param User $user
+     * @param GetActivitiesRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index(User $user, GetActivitiesRequest $request)
+    {
+        $activities = $this->activities->paginateActivitiesForUser(
+            $user->id,
+            $request->per_page ?: 20,
+            $request->search
+        );
+
+        return $this->respondWithPagination(
+            $activities,
+            new ActivityTransformer
+        );
+    }
+}
diff --git a/app/Http/Controllers/Api/Users/AvatarController.php b/app/Http/Controllers/Api/Users/AvatarController.php
new file mode 100644
index 0000000..4b9a849
--- /dev/null
+++ b/app/Http/Controllers/Api/Users/AvatarController.php
@@ -0,0 +1,106 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Users;
+
+use Illuminate\Http\Request;
+use Vanguard\Events\User\UpdatedByAdmin;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\User\CreateUserRequest;
+use Vanguard\Http\Requests\User\UpdateUserRequest;
+use Vanguard\Http\Requests\User\UploadAvatarRawRequest;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Services\Upload\UserAvatarManager;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\Transformers\UserTransformer;
+use Vanguard\User;
+
+/**
+ * Class AvatarController
+ * @package Vanguard\Http\Controllers\Api\Users
+ */
+class AvatarController extends ApiController
+{
+    /**
+     * @var UserRepository
+     */
+    private $users;
+
+    /**
+     * @var UserAvatarManager
+     */
+    private $avatarManager;
+
+    public function __construct(UserRepository $users, UserAvatarManager $avatarManager)
+    {
+        $this->middleware('auth');
+        $this->middleware('permission:users.manage');
+
+        $this->users = $users;
+        $this->avatarManager = $avatarManager;
+    }
+
+    /**
+     * @param User $user
+     * @param UploadAvatarRawRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function update(User $user, UploadAvatarRawRequest $request)
+    {
+        $name = $this->avatarManager->uploadAndCropAvatar(
+            $user,
+            $request->file('file')
+        );
+
+        $user = $this->users->update(
+            $user->id,
+            ['avatar' => $name]
+        );
+
+        event(new UpdatedByAdmin($user));
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+
+    /**
+     * Update user's avatar to external resource.
+     * @param User $user
+     * @param Request $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function updateExternal(User $user, Request $request)
+    {
+        $this->validate($request, [
+            'url' => 'required|url'
+        ]);
+
+        $this->avatarManager->deleteAvatarIfUploaded($user);
+
+        $user = $this->users->update(
+            $user->id,
+            ['avatar' => $request->url]
+        );
+
+        event(new UpdatedByAdmin($user));
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+
+    /**
+     * Remove user's avatar and set it to null.
+     * @param User $user
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function destroy(User $user)
+    {
+        $this->avatarManager->deleteAvatarIfUploaded($user);
+
+        $user = $this->users->update(
+            $user->id,
+            ['avatar' => null]
+        );
+
+        event(new UpdatedByAdmin($user));
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+}
diff --git a/app/Http/Controllers/Api/Users/SessionsController.php b/app/Http/Controllers/Api/Users/SessionsController.php
new file mode 100644
index 0000000..eeb2077
--- /dev/null
+++ b/app/Http/Controllers/Api/Users/SessionsController.php
@@ -0,0 +1,36 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Users;
+
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Repositories\Session\SessionRepository;
+use Vanguard\Transformers\SessionTransformer;
+use Vanguard\User;
+
+/**
+ * Class SessionsController
+ * @package Vanguard\Http\Controllers\Api\Users
+ */
+class SessionsController extends ApiController
+{
+    public function __construct()
+    {
+        $this->middleware('auth');
+        $this->middleware('permission:users.manage');
+        $this->middleware('session.database');
+    }
+
+    /**
+     * Get sessions for specified user.
+     * @param User $user
+     * @param SessionRepository $sessions
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index(User $user, SessionRepository $sessions)
+    {
+        return $this->respondWithCollection(
+            $sessions->getUserSessions($user->id),
+            new SessionTransformer
+        );
+    }
+}
diff --git a/app/Http/Controllers/Api/Users/TwoFactorController.php b/app/Http/Controllers/Api/Users/TwoFactorController.php
new file mode 100644
index 0000000..c066eb1
--- /dev/null
+++ b/app/Http/Controllers/Api/Users/TwoFactorController.php
@@ -0,0 +1,72 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Users;
+
+use Authy;
+use Vanguard\Events\User\TwoFactorDisabledByAdmin;
+use Vanguard\Events\User\TwoFactorEnabledByAdmin;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\User\EnableTwoFactorRequest;
+use Vanguard\Transformers\UserTransformer;
+use Vanguard\User;
+
+/**
+ * Class TwoFactorController
+ * @package Vanguard\Http\Controllers\Api\Users
+ */
+class TwoFactorController extends ApiController
+{
+    public function __construct()
+    {
+        $this->middleware('auth');
+        $this->middleware('permission:users.manage');
+    }
+
+    /**
+     * Enable 2FA for specified user.
+     * @param User $user
+     * @param EnableTwoFactorRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function update(User $user, EnableTwoFactorRequest $request)
+    {
+        if (Authy::isEnabled($user)) {
+            return $this->setStatusCode(422)
+                ->respondWithError("2FA is already enabled for this user.");
+        }
+
+        $user->setAuthPhoneInformation(
+            $request->country_code,
+            $request->phone_number
+        );
+
+        Authy::register($user);
+
+        $user->save();
+
+        event(new TwoFactorEnabledByAdmin($user));
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+
+    /**
+     * Disable 2FA for specified user.
+     * @param User $user
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function destroy(User $user)
+    {
+        if (! Authy::isEnabled($user)) {
+            return $this->setStatusCode(422)
+                ->respondWithError("2FA is not enabled for this user.");
+        }
+
+        Authy::delete($user);
+
+        $user->save();
+
+        event(new TwoFactorDisabledByAdmin($user));
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+}
diff --git a/app/Http/Controllers/Api/Users/UsersController.php b/app/Http/Controllers/Api/Users/UsersController.php
new file mode 100644
index 0000000..2147aa4
--- /dev/null
+++ b/app/Http/Controllers/Api/Users/UsersController.php
@@ -0,0 +1,141 @@
+<?php
+
+namespace Vanguard\Http\Controllers\Api\Users;
+
+use Illuminate\Http\Request;
+use Vanguard\Events\User\Banned;
+use Vanguard\Events\User\Deleted;
+use Vanguard\Events\User\UpdatedByAdmin;
+use Vanguard\Http\Controllers\Api\ApiController;
+use Vanguard\Http\Requests\User\CreateUserRequest;
+use Vanguard\Http\Requests\User\UpdateUserRequest;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\Transformers\UserTransformer;
+use Vanguard\User;
+
+/**
+ * Class UsersController
+ * @package Vanguard\Http\Controllers\Api\Users
+ */
+class UsersController extends ApiController
+{
+    /**
+     * @var UserRepository
+     */
+    private $users;
+
+    public function __construct(UserRepository $users)
+    {
+        $this->middleware('auth');
+        $this->middleware('permission:users.manage');
+
+        $this->users = $users;
+    }
+
+    /**
+     * Paginate all users.
+     * @param Request $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function index(Request $request)
+    {
+        $users = $this->users->paginate(
+            $request->per_page ?: 20,
+            $request->search,
+            $request->status
+        );
+
+        return $this->respondWithPagination(
+            $users,
+            new UserTransformer
+        );
+    }
+
+    /**
+     * Create new user record.
+     * @param CreateUserRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function store(CreateUserRequest $request)
+    {
+        $data = $request->only([
+            'email', 'password', 'username', 'first_name', 'last_name',
+            'phone', 'address', 'country_id', 'birthday', 'role_id'
+        ]);
+
+        $data += ['status' => UserStatus::ACTIVE];
+
+        $user = $this->users->create($data);
+
+        return $this->setStatusCode(201)
+            ->respondWithItem($user, new UserTransformer);
+    }
+
+    /**
+     * Show the info about requested user.
+     * @param User $user
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function show(User $user)
+    {
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+
+    /**
+     * @param User $user
+     * @param UpdateUserRequest $request
+     * @return \Illuminate\Http\JsonResponse
+     */
+    public function update(User $user, UpdateUserRequest $request)
+    {
+        $data = collect($request->all());
+
+        $data = $data->only([
+            'email', 'password', 'username', 'first_name', 'last_name',
+            'phone', 'address', 'country_id', 'birthday', 'status', 'role_id'
+        ])->toArray();
+
+        $user = $this->users->update($user->id, $data);
+
+        event(new UpdatedByAdmin($user));
+
+        // If user status was updated to "Banned",
+        // fire the appropriate event.
+        if ($this->userIsBanned($user, $request)) {
+            event(new Banned($user));
+        }
+
+        return $this->respondWithItem($user, new UserTransformer);
+    }
+
+    /**
+     * Check if user is banned during last update.
+     *
+     * @param User $user
+     * @param Request $request
+     * @return bool
+     */
+    private function userIsBanned(User $user, Request $request)
+    {
+        return $user->status != $request->status && $request->status == UserStatus::BANNED;
+    }
+
+    /**
+     * Remove specified user from storage.
+     * @param User $user
+     * @return \Illuminate\Http\Response
+     */
+    public function destroy(User $user)
+    {
+        if ($user->id == auth()->id()) {
+            return $this->errorForbidden("You cannot delete yourself.");
+        }
+
+        event(new Deleted($user));
+
+        $this->users->delete($user->id);
+
+        return $this->respondWithSuccess();
+    }
+}
diff --git a/app/Http/Controllers/ActivityController.php b/app/Http/Controllers/Web/ActivityController.php
similarity index 94%
rename from app/Http/Controllers/ActivityController.php
rename to app/Http/Controllers/Web/ActivityController.php
index 291935b..75c0295 100644
--- a/app/Http/Controllers/ActivityController.php
+++ b/app/Http/Controllers/Web/ActivityController.php
@@ -1,7 +1,8 @@
 <?php
 
-namespace Vanguard\Http\Controllers;
+namespace Vanguard\Http\Controllers\Web;
 
+use Vanguard\Http\Controllers\Controller;
 use Vanguard\Repositories\Activity\ActivityRepository;
 use Vanguard\Repositories\Activity\EloquentActivity;
 use Vanguard\User;
@@ -55,6 +56,7 @@ class ActivityController extends Controller
     public function userActivity(User $user, Request $request)
     {
         $perPage = 20;
+        $perPage = 20;
         $adminView = true;
 
         $activities = $this->activities->paginateActivitiesForUser(
diff --git a/app/Http/Controllers/Auth/AuthController.php b/app/Http/Controllers/Web/Auth/AuthController.php
similarity index 91%
rename from app/Http/Controllers/Auth/AuthController.php
rename to app/Http/Controllers/Web/Auth/AuthController.php
index 84d2288..c1678b2 100644
--- a/app/Http/Controllers/Auth/AuthController.php
+++ b/app/Http/Controllers/Web/Auth/AuthController.php
@@ -1,13 +1,12 @@
 <?php
 
-namespace Vanguard\Http\Controllers\Auth;
+namespace Vanguard\Http\Controllers\Web\Auth;
 
 use Vanguard\Events\User\LoggedIn;
 use Vanguard\Events\User\LoggedOut;
 use Vanguard\Events\User\Registered;
 use Vanguard\Http\Requests\Auth\LoginRequest;
 use Vanguard\Http\Requests\Auth\RegisterRequest;
-use Vanguard\Mailers\UserMailer;
 use Vanguard\Repositories\Role\RoleRepository;
 use Vanguard\Repositories\User\UserRepository;
 use Vanguard\Services\Auth\TwoFactor\Contracts\Authenticatable;
@@ -18,7 +17,6 @@ use Carbon\Carbon;
 use Illuminate\Cache\RateLimiter;
 use Illuminate\Http\Request;
 use Vanguard\Http\Controllers\Controller;
-use Lang;
 use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
 use Validator;
 
@@ -75,7 +73,6 @@ class AuthController extends Controller
         $credentials = $this->getCredentials($request);
 
         if (! Auth::validate($credentials)) {
-
             // If the login attempt was unsuccessful we will increment the number of attempts
             // to login and redirect the user back to the login form. Of course, when this
             // user surpasses their maximum number of attempts they will get locked out.
@@ -159,7 +156,7 @@ class AuthController extends Controller
             $request->session()->pull('auth.2fa.id')
         );
 
-        if ( ! $user) {
+        if (! $user) {
             throw new NotFoundHttpException;
         }
 
@@ -349,10 +346,10 @@ class AuthController extends Controller
      * Handle a registration request for the application.
      *
      * @param RegisterRequest $request
-     * @param UserMailer $mailer
+     * @param RoleRepository $roles
      * @return \Illuminate\Http\Response
      */
-    public function postRegister(RegisterRequest $request, UserMailer $mailer, RoleRepository $roles)
+    public function postRegister(RegisterRequest $request, RoleRepository $roles)
     {
         // Determine user status. User's status will be set to UNCONFIRMED
         // if he has to confirm his email or to ACTIVE if email confirmation is not required
@@ -368,19 +365,12 @@ class AuthController extends Controller
             ['status' => $status, 'role_id' => $role->id]
         ));
 
-        $this->users->updateSocialNetworks($user->id, []);
-
-        // Check if email confirmation is required,
-        // and if it does, send confirmation email to the user.
-        if (settings('reg_email_confirmation')) {
-            $this->sendConfirmationEmail($mailer, $user);
-            $message = trans('app.account_create_confirm_email');
-        } else {
-            $message = trans('app.account_created_login');
-        }
-
         event(new Registered($user));
 
+        $message = settings('reg_email_confirmation')
+            ? trans('app.account_create_confirm_email')
+            : trans('app.account_created_login');
+
         return redirect('login')->with('success', $message);
     }
 
@@ -388,7 +378,7 @@ class AuthController extends Controller
      * Confirm user's email.
      *
      * @param $token
-     * @return $this
+     * @return \Illuminate\Http\RedirectResponse
      */
     public function confirmEmail($token)
     {
@@ -419,15 +409,4 @@ class AuthController extends Controller
             ['username' => 'email']
         )->fails();
     }
-
-    /**
-     * @param UserMailer $mailer
-     * @param $user
-     */
-    private function sendConfirmationEmail(UserMailer $mailer, $user)
-    {
-        $token = str_random(60);
-        $this->users->update($user->id, ['confirmation_token' => $token]);
-        $mailer->sendConfirmationEmail($user, $token);
-    }
 }
diff --git a/app/Http/Controllers/Auth/PasswordController.php b/app/Http/Controllers/Web/Auth/PasswordController.php
similarity index 98%
rename from app/Http/Controllers/Auth/PasswordController.php
rename to app/Http/Controllers/Web/Auth/PasswordController.php
index 53bfbf9..49aae93 100644
--- a/app/Http/Controllers/Auth/PasswordController.php
+++ b/app/Http/Controllers/Web/Auth/PasswordController.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Vanguard\Http\Controllers\Auth;
+namespace Vanguard\Http\Controllers\Web\Auth;
 
 use Illuminate\Http\RedirectResponse;
 use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
diff --git a/app/Http/Controllers/Auth/SocialAuthController.php b/app/Http/Controllers/Web/Auth/SocialAuthController.php
similarity index 64%
rename from app/Http/Controllers/Auth/SocialAuthController.php
rename to app/Http/Controllers/Web/Auth/SocialAuthController.php
index 598e88c..cb0d477 100644
--- a/app/Http/Controllers/Auth/SocialAuthController.php
+++ b/app/Http/Controllers/Web/Auth/SocialAuthController.php
@@ -1,20 +1,17 @@
 <?php
 
-namespace Vanguard\Http\Controllers\Auth;
+namespace Vanguard\Http\Controllers\Web\Auth;
 
 use Authy;
 use Vanguard\Http\Controllers\Controller;
-use Vanguard\Http\Controllers\RolesController;
-use Vanguard\Http\Requests\Auth\Social\LoginRequest;
 use Vanguard\Http\Requests\Auth\Social\SaveEmailRequest;
-use Vanguard\Repositories\Role\RoleRepository;
 use Vanguard\Repositories\User\UserRepository;
-use Vanguard\Support\Enum\UserStatus;
 use Auth;
 use Session;
 use Socialite;
 use Laravel\Socialite\Contracts\User as SocialUser;
 use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
+use Vanguard\Services\Auth\Social\SocialManager;
 
 class SocialAuthController extends Controller
 {
@@ -24,16 +21,16 @@ class SocialAuthController extends Controller
     private $users;
 
     /**
-     * @var RoleRepository
+     * @var SocialManager
      */
-    private $roles;
+    private $socialManager;
 
-    public function __construct(UserRepository $users, RoleRepository $roles)
+    public function __construct(UserRepository $users, SocialManager $socialManager)
     {
         $this->middleware('guest');
 
         $this->users = $users;
-        $this->roles = $roles;
+        $this->socialManager = $socialManager;
     }
 
     /**
@@ -75,7 +72,7 @@ class SocialAuthController extends Controller
                     : redirect('login')->withErrors(trans('app.you_have_to_provide_email'));
             }
 
-            $user = $this->createOrAssociateAccountForUser($socialUser, $provider);
+            $user = $this->socialManager->associate($socialUser, $provider);
         }
 
         return $this->loginAndRedirect($user);
@@ -106,7 +103,7 @@ class SocialAuthController extends Controller
 
         $account->email = $request->get('email');
 
-        $user = $this->createOrAssociateAccountForUser($account, 'twitter');
+        $user = $this->socialManager->associate($account, 'twitter');
 
         return $this->loginAndRedirect($user);
     }
@@ -123,62 +120,6 @@ class SocialAuthController extends Controller
     }
 
     /**
-     * Create account for user authenticated via social network.
-     * If user with the same email address retrieved from social network
-     * exists in our database, just associate it with provided social account.
-     *
-     * @param SocialUser $socialUser
-     * @param $provider
-     * @return \Vanguard\User
-     */
-    private function createOrAssociateAccountForUser(SocialUser $socialUser, $provider)
-    {
-        $user = $this->users->findByEmail($socialUser->getEmail());
-
-        if (! $user) {
-            // User with email retrieved from social auth provider does not
-            // exist in our database. That means that we have to create new user here
-            list($firstName, $lastName) = $this->parseUserFullName($socialUser);
-
-            $role = $this->roles->findByName('User');
-
-            $user = $this->users->create([
-                'email' => $socialUser->getEmail(),
-                'password' => str_random(10),
-                'first_name' => $firstName,
-                'last_name' => $lastName,
-                'status' => UserStatus::ACTIVE,
-                'avatar' => $socialUser->getAvatar(),
-                'role_id' => $role->id
-            ]);
-
-            $this->users->updateSocialNetworks($user->id, []);
-        }
-
-        // Associate social account with user account inside our application
-        $this->users->associateSocialAccountForUser($user->id, $provider, $socialUser);
-
-        return $user;
-    }
-
-    /**
-     * Parse User's name from his social network account.
-     *
-     * @param SocialUser $user
-     * @return array
-     */
-    private function parseUserFullName(SocialUser $user)
-    {
-        $name = $user->getName();
-
-        if (strpos($name, " ") !== false) {
-            return explode(" ", $name, 2);
-        }
-
-        return [$name, ''];
-    }
-
-    /**
      * Redirect user to page where he can provide an email,
      * since email is not provided inside oAuth response.
      *
diff --git a/app/Http/Controllers/DashboardController.php b/app/Http/Controllers/Web/DashboardController.php
similarity index 96%
rename from app/Http/Controllers/DashboardController.php
rename to app/Http/Controllers/Web/DashboardController.php
index 6939e98..7f06f51 100644
--- a/app/Http/Controllers/DashboardController.php
+++ b/app/Http/Controllers/Web/DashboardController.php
@@ -1,7 +1,8 @@
 <?php
 
-namespace Vanguard\Http\Controllers;
+namespace Vanguard\Http\Controllers\Web;
 
+use Vanguard\Http\Controllers\Controller;
 use Vanguard\Repositories\Activity\ActivityRepository;
 use Vanguard\Repositories\User\UserRepository;
 use Vanguard\Support\Enum\UserStatus;
@@ -84,6 +85,4 @@ class DashboardController extends Controller
 
         return view('dashboard.default', compact('activities'));
     }
-
-
-}
\ No newline at end of file
+}
diff --git a/app/Http/Controllers/InstallController.php b/app/Http/Controllers/Web/InstallController.php
similarity index 98%
rename from app/Http/Controllers/InstallController.php
rename to app/Http/Controllers/Web/InstallController.php
index bcb66e0..f6c295a 100644
--- a/app/Http/Controllers/InstallController.php
+++ b/app/Http/Controllers/Web/InstallController.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Vanguard\Http\Controllers;
+namespace Vanguard\Http\Controllers\Web;
 
 use Artisan;
 use DB;
@@ -10,6 +10,7 @@ use Illuminate\Http\Request;
 use Input;
 use Session;
 use Settings;
+use Vanguard\Http\Controllers\Controller;
 use Vanguard\Http\Requests;
 
 class InstallController extends Controller
diff --git a/app/Http/Controllers/PermissionsController.php b/app/Http/Controllers/Web/PermissionsController.php
similarity index 97%
rename from app/Http/Controllers/PermissionsController.php
rename to app/Http/Controllers/Web/PermissionsController.php
index f4c12de..50bc37c 100644
--- a/app/Http/Controllers/PermissionsController.php
+++ b/app/Http/Controllers/Web/PermissionsController.php
@@ -1,9 +1,10 @@
 <?php
 
-namespace Vanguard\Http\Controllers;
+namespace Vanguard\Http\Controllers\Web;
 
 use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
 use Vanguard\Events\Role\PermissionsUpdated;
+use Vanguard\Http\Controllers\Controller;
 use Vanguard\Http\Requests\Permission\CreatePermissionRequest;
 use Vanguard\Http\Requests\Permission\UpdatePermissionRequest;
 use Vanguard\Permission;
diff --git a/app/Http/Controllers/ProfileController.php b/app/Http/Controllers/Web/ProfileController.php
similarity index 88%
rename from app/Http/Controllers/ProfileController.php
rename to app/Http/Controllers/Web/ProfileController.php
index ed391eb..6fd6a37 100644
--- a/app/Http/Controllers/ProfileController.php
+++ b/app/Http/Controllers/Web/ProfileController.php
@@ -1,15 +1,15 @@
 <?php
 
-namespace Vanguard\Http\Controllers;
+namespace Vanguard\Http\Controllers\Web;
 
 use Vanguard\Events\User\ChangedAvatar;
 use Vanguard\Events\User\TwoFactorDisabled;
 use Vanguard\Events\User\TwoFactorEnabled;
 use Vanguard\Events\User\UpdatedProfileDetails;
+use Vanguard\Http\Controllers\Controller;
 use Vanguard\Http\Requests\User\EnableTwoFactorRequest;
 use Vanguard\Http\Requests\User\UpdateProfileDetailsRequest;
 use Vanguard\Http\Requests\User\UpdateProfileLoginDetailsRequest;
-use Vanguard\Http\Requests\User\UpdateUserRequest;
 use Vanguard\Repositories\Activity\ActivityRepository;
 use Vanguard\Repositories\Country\CountryRepository;
 use Vanguard\Repositories\Role\RoleRepository;
@@ -66,14 +66,13 @@ class ProfileController extends Controller
         $user = $this->theUser;
         $edit = true;
         $roles = $rolesRepo->lists();
-        $socials = $user->socialNetworks;
         $countries = [0 => 'Select a Country'] + $countryRepository->lists()->toArray();
         $socialLogins = $this->users->getUserSocialLogins($this->theUser->id);
         $statuses = UserStatus::lists();
 
         return view(
             'user/profile',
-            compact('user', 'edit', 'roles', 'countries', 'socialLogins', 'socials', 'statuses')
+            compact('user', 'edit', 'roles', 'countries', 'socialLogins', 'statuses')
         );
     }
 
@@ -106,7 +105,13 @@ class ProfileController extends Controller
             'avatar' => 'image'
         ]);
 
-        if ($name = $avatarManager->uploadAndCropAvatar($this->theUser)) {
+        $name = $avatarManager->uploadAndCropAvatar(
+            $this->theUser,
+            $request->file('avatar'),
+            $request->get('points')
+        );
+
+        if ($name) {
             return $this->handleAvatarUpdate($name);
         }
 
@@ -146,20 +151,6 @@ class ProfileController extends Controller
     }
 
     /**
-     * Update user's social networks.
-     *
-     * @param Request $request
-     * @return mixed
-     */
-    public function updateSocialNetworks(Request $request)
-    {
-        $this->users->updateSocialNetworks($this->theUser->id, $request->get('socials'));
-
-        return redirect()->route('profile')
-            ->withSuccess(trans('app.socials_updated'));
-    }
-
-    /**
      * Update user's login details.
      *
      * @param UpdateProfileLoginDetailsRequest $request
@@ -173,6 +164,7 @@ class ProfileController extends Controller
         // just remove it from $data array and do not change it
         if (trim($data['password']) == '') {
             unset($data['password']);
+
             unset($data['password_confirmation']);
         }
 
@@ -186,7 +178,7 @@ class ProfileController extends Controller
      * Enable 2FA for currently logged user.
      *
      * @param EnableTwoFactorRequest $request
-     * @return $this
+     * @return \Illuminate\Http\RedirectResponse
      */
     public function enableTwoFactorAuth(EnableTwoFactorRequest $request)
     {
@@ -210,7 +202,7 @@ class ProfileController extends Controller
     /**
      * Disable 2FA for currently logged user.
      *
-     * @return $this
+     * @return \Illuminate\Http\RedirectResponse
      */
     public function disableTwoFactorAuth()
     {
@@ -238,11 +230,12 @@ class ProfileController extends Controller
      */
     public function activity(ActivityRepository $activitiesRepo, Request $request)
     {
-        $perPage = 20;
         $user = $this->theUser;
 
         $activities = $activitiesRepo->paginateActivitiesForUser(
-            $this->theUser->id, $perPage, $request->get('search')
+            $user->id,
+            $perPage = 20,
+            $request->get('search')
         );
 
         return view('activity.index', compact('activities', 'user'));
@@ -267,18 +260,15 @@ class ProfileController extends Controller
     /**
      * Invalidate user's session.
      *
-     * @param $sessionId
+     * @param $session \stdClass Session object.
      * @param SessionRepository $sessionRepository
      * @return mixed
      */
-    public function invalidateSession($sessionId, SessionRepository $sessionRepository)
+    public function invalidateSession($session, SessionRepository $sessionRepository)
     {
-        $sessionRepository->invalidateUserSession(
-            $this->theUser->id,
-            $sessionId
-        );
+        $sessionRepository->invalidateSession($session->id);
 
         return redirect()->route('profile.sessions')
             ->withSuccess(trans('app.session_invalidated'));
     }
-}
\ No newline at end of file
+}
diff --git a/app/Http/Controllers/RolesController.php b/app/Http/Controllers/Web/RolesController.php
similarity index 94%
rename from app/Http/Controllers/RolesController.php
rename to app/Http/Controllers/Web/RolesController.php
index 2d5309e..9a58f39 100644
--- a/app/Http/Controllers/RolesController.php
+++ b/app/Http/Controllers/Web/RolesController.php
@@ -1,17 +1,14 @@
 <?php
 
-namespace Vanguard\Http\Controllers;
+namespace Vanguard\Http\Controllers\Web;
 
 use Cache;
-use Vanguard\Events\Role\Created;
-use Vanguard\Events\Role\Deleted;
-use Vanguard\Events\Role\Updated;
+use Vanguard\Http\Controllers\Controller;
 use Vanguard\Http\Requests\Role\CreateRoleRequest;
 use Vanguard\Http\Requests\Role\UpdateRoleRequest;
 use Vanguard\Repositories\Role\RoleRepository;
 use Vanguard\Repositories\User\UserRepository;
 use Vanguard\Role;
-use Vanguard\User;
 use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
 
 /**
diff --git a/app/Http/Controllers/SettingsController.php b/app/Http/Controllers/Web/SettingsController.php
similarity index 95%
rename from app/Http/Controllers/SettingsController.php
rename to app/Http/Controllers/Web/SettingsController.php
index 25fca49..073ef5e 100644
--- a/app/Http/Controllers/SettingsController.php
+++ b/app/Http/Controllers/Web/SettingsController.php
@@ -1,10 +1,11 @@
 <?php
 
-namespace Vanguard\Http\Controllers;
+namespace Vanguard\Http\Controllers\Web;
 
 use Vanguard\Events\Settings\Updated as SettingsUpdated;
 use Illuminate\Http\Request;
 use Settings;
+use Vanguard\Http\Controllers\Controller;
 
 /**
  * Class SettingsController
@@ -57,7 +58,7 @@ class SettingsController extends Controller
      */
     private function updateSettings($input)
     {
-        foreach($input as $key => $value) {
+        foreach ($input as $key => $value) {
             Settings::set($key, $value);
         }
 
@@ -123,4 +124,4 @@ class SettingsController extends Controller
     {
         return view('settings.notifications');
     }
-}
\ No newline at end of file
+}
diff --git a/app/Http/Controllers/UsersController.php b/app/Http/Controllers/Web/UsersController.php
similarity index 87%
rename from app/Http/Controllers/UsersController.php
rename to app/Http/Controllers/Web/UsersController.php
index ea35f23..d4912dd 100644
--- a/app/Http/Controllers/UsersController.php
+++ b/app/Http/Controllers/Web/UsersController.php
@@ -1,12 +1,13 @@
 <?php
 
-namespace Vanguard\Http\Controllers;
+namespace Vanguard\Http\Controllers\Web;
 
 use Vanguard\Events\User\Banned;
 use Vanguard\Events\User\Deleted;
 use Vanguard\Events\User\TwoFactorDisabledByAdmin;
 use Vanguard\Events\User\TwoFactorEnabledByAdmin;
 use Vanguard\Events\User\UpdatedByAdmin;
+use Vanguard\Http\Controllers\Controller;
 use Vanguard\Http\Requests\User\CreateUserRequest;
 use Vanguard\Http\Requests\User\EnableTwoFactorRequest;
 use Vanguard\Http\Requests\User\UpdateDetailsRequest;
@@ -54,9 +55,12 @@ class UsersController extends Controller
      */
     public function index()
     {
-        $perPage = 20;
+        $users = $this->users->paginate(
+            $perPage = 20,
+            Input::get('search'),
+            Input::get('status')
+        );
 
-        $users = $this->users->paginate($perPage, Input::get('search'), Input::get('status'));
         $statuses = ['' => trans('app.all')] + UserStatus::lists();
 
         return view('user.list', compact('users', 'statuses'));
@@ -71,11 +75,9 @@ class UsersController extends Controller
      */
     public function view(User $user, ActivityRepository $activities)
     {
-        $socialNetworks = $user->socialNetworks;
-
         $userActivities = $activities->getLatestActivitiesForUser($user->id, 10);
 
-        return view('user.view', compact('user', 'socialNetworks', 'userActivities'));
+        return view('user.view', compact('user', 'userActivities'));
     }
 
     /**
@@ -118,16 +120,17 @@ class UsersController extends Controller
         // status to Active by default.
         $data = $request->all() + ['status' => UserStatus::ACTIVE];
 
+        if (! array_get($data, 'country_id')) {
+            $data['country_id'] = null;
+        }
+
         // Username should be updated only if it is provided.
         // So, if it is an empty string, then we just leave it as it is.
         if (trim($data['username']) == '') {
             $data['username'] = null;
         }
 
-        $data['role_id'] = $request->role;
-
         $user = $this->users->create($data);
-        $this->users->updateSocialNetworks($user->id, []);
 
         return redirect()->route('user.list')
             ->withSuccess(trans('app.user_created'));
@@ -145,14 +148,13 @@ class UsersController extends Controller
     {
         $edit = true;
         $countries = $this->parseCountries($countryRepository);
-        $socials = $user->socialNetworks;
         $roles = $roleRepository->lists();
         $statuses = UserStatus::lists();
         $socialLogins = $this->users->getUserSocialLogins($user->id);
 
         return view(
             'user.edit',
-            compact('edit', 'user', 'countries', 'socials', 'socialLogins', 'roles', 'statuses')
+            compact('edit', 'user', 'countries', 'socialLogins', 'roles', 'statuses')
         );
     }
 
@@ -165,8 +167,14 @@ class UsersController extends Controller
      */
     public function updateDetails(User $user, UpdateDetailsRequest $request)
     {
-        $this->users->update($user->id, $request->all());
-        $this->users->setRole($user->id, $request->get('role'));
+        $data = $request->all();
+
+        if (! array_get($data, 'country_id')) {
+            $data['country_id'] = null;
+        }
+
+        $this->users->update($user->id, $data);
+        $this->users->setRole($user->id, $request->role_id);
 
         event(new UpdatedByAdmin($user));
 
@@ -203,7 +211,9 @@ class UsersController extends Controller
     {
         $this->validate($request, ['avatar' => 'image']);
 
-        if ($name = $avatarManager->uploadAndCropAvatar($user)) {
+        $name = $avatarManager->uploadAndCropAvatar($user, $request->file('avatar'));
+
+        if ($name) {
             $this->users->update($user->id, ['avatar' => $name]);
 
             event(new UpdatedByAdmin($user));
@@ -237,23 +247,6 @@ class UsersController extends Controller
     }
 
     /**
-     * Update user's social networks.
-     *
-     * @param User $user
-     * @param Request $request
-     * @return mixed
-     */
-    public function updateSocialNetworks(User $user, Request $request)
-    {
-        $this->users->updateSocialNetworks($user->id, $request->get('socials'));
-
-        event(new UpdatedByAdmin($user));
-
-        return redirect()->route('user.edit', $user->id)
-            ->withSuccess(trans('app.socials_updated'));
-    }
-
-    /**
      * Update user's login details.
      *
      * @param User $user
@@ -367,13 +360,13 @@ class UsersController extends Controller
      * Invalidate specified session for selected user.
      *
      * @param User $user
-     * @param $sessionId
+     * @param $session
      * @param SessionRepository $sessionRepository
      * @return mixed
      */
-    public function invalidateSession(User $user, $sessionId, SessionRepository $sessionRepository)
+    public function invalidateSession(User $user, $session, SessionRepository $sessionRepository)
     {
-        $sessionRepository->invalidateUserSession($user->id, $sessionId);
+        $sessionRepository->invalidateSession($session->id);
 
         return redirect()->route('user.sessions', $user->id)
             ->withSuccess(trans('app.session_invalidated'));
diff --git a/app/Http/Kernel.php b/app/Http/Kernel.php
index b5c00ff..ae3f01e 100644
--- a/app/Http/Kernel.php
+++ b/app/Http/Kernel.php
@@ -32,6 +32,7 @@ class Kernel extends HttpKernel
             \Illuminate\Routing\Middleware\SubstituteBindings::class,
         ],
         'api' => [
+            \Vanguard\Http\Middleware\UseApiGuard::class,
             'throttle:60,1',
             'bindings'
         ],
diff --git a/app/Http/Middleware/Authenticate.php b/app/Http/Middleware/Authenticate.php
index 5ffb56b..3bd590f 100644
--- a/app/Http/Middleware/Authenticate.php
+++ b/app/Http/Middleware/Authenticate.php
@@ -35,7 +35,7 @@ class Authenticate
     public function handle($request, Closure $next)
     {
         if ($this->auth->guest()) {
-            if ($request->ajax()) {
+            if ($request->ajax() || $request->wantsJson()) {
                 return response('Unauthorized.', 401);
             } else {
                 return redirect()->guest('login');
diff --git a/app/Http/Middleware/CheckPermissions.php b/app/Http/Middleware/CheckPermissions.php
index 5f89b39..6664738 100644
--- a/app/Http/Middleware/CheckPermissions.php
+++ b/app/Http/Middleware/CheckPermissions.php
@@ -32,8 +32,8 @@ class CheckPermissions
             $permissions = explode("|", $permissions);
         }
 
-        if ($this->auth->guest() || !$request->user()->hasPermission($permissions)) {
-            abort(403);
+        if ($this->auth->guest() || ! $request->user()->hasPermission($permissions)) {
+            abort(403, "Forbidden.");
         }
 
         return $next($request);
diff --git a/app/Http/Middleware/DatabaseSession.php b/app/Http/Middleware/DatabaseSession.php
index 29fd52b..22d6488 100644
--- a/app/Http/Middleware/DatabaseSession.php
+++ b/app/Http/Middleware/DatabaseSession.php
@@ -19,7 +19,7 @@ class DatabaseSession
         // If we are not using database session driver,
         // just display 404 page
         if (config('session.driver') != 'database') {
-            throw new NotFoundHttpException;
+            throw new NotFoundHttpException("The entity you are looking for does not exist.");
         }
 
         return $next($request);
diff --git a/app/Http/Middleware/UseApiGuard.php b/app/Http/Middleware/UseApiGuard.php
new file mode 100644
index 0000000..61c0533
--- /dev/null
+++ b/app/Http/Middleware/UseApiGuard.php
@@ -0,0 +1,40 @@
+<?php
+
+namespace Vanguard\Http\Middleware;
+
+use Closure;
+use Illuminate\Contracts\Auth\Factory;
+
+class UseApiGuard
+{
+    /**
+     * The Auth Factory implementation.
+     *
+     * @var Factory
+     */
+    protected $auth;
+
+    /**
+     * Create a new filter instance.
+     *
+     * @param  Factory  $auth
+     */
+    public function __construct(Factory $auth)
+    {
+        $this->auth = $auth;
+    }
+
+    /**
+     * Handle an incoming request.
+     *
+     * @param  \Illuminate\Http\Request  $request
+     * @param  \Closure  $next
+     * @return mixed
+     */
+    public function handle($request, Closure $next)
+    {
+        $this->auth->shouldUse('api');
+
+        return $next($request);
+    }
+}
diff --git a/app/Http/Requests/Activity/GetActivitiesRequest.php b/app/Http/Requests/Activity/GetActivitiesRequest.php
new file mode 100644
index 0000000..191c98b
--- /dev/null
+++ b/app/Http/Requests/Activity/GetActivitiesRequest.php
@@ -0,0 +1,28 @@
+<?php
+
+namespace Vanguard\Http\Requests\Activity;
+
+use Vanguard\Http\Requests\Request;
+use Vanguard\User;
+
+class GetActivitiesRequest extends Request
+{
+    /**
+     * Get the validation rules that apply to the request.
+     *
+     * @return array
+     */
+    public function rules()
+    {
+        return [
+            'per_page' => 'integer|max:100'
+        ];
+    }
+
+    public function messages()
+    {
+        return [
+            'per_page.max' => 'Maximum number of records per page is 100.'
+        ];
+    }
+}
diff --git a/app/Http/Requests/Auth/Social/ApiAuthenticateRequest.php b/app/Http/Requests/Auth/Social/ApiAuthenticateRequest.php
new file mode 100644
index 0000000..abe4aa6
--- /dev/null
+++ b/app/Http/Requests/Auth/Social/ApiAuthenticateRequest.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace Vanguard\Http\Requests\Auth\Social;
+
+use Illuminate\Validation\Rule;
+use Vanguard\Http\Requests\Request;
+
+class ApiAuthenticateRequest extends Request
+{
+    /**
+     * Get the validation rules that apply to the request.
+     *
+     * @return array
+     */
+    public function rules()
+    {
+        return [
+            'network' => [
+                'required',
+                Rule::in(config('auth.social.providers'))
+            ],
+            'social_token' => 'required',
+        ];
+    }
+}
diff --git a/app/Http/Requests/BinaryFileUploadRequest.php b/app/Http/Requests/BinaryFileUploadRequest.php
new file mode 100644
index 0000000..86ee243
--- /dev/null
+++ b/app/Http/Requests/BinaryFileUploadRequest.php
@@ -0,0 +1,77 @@
+<?php
+
+namespace Vanguard\Http\Requests;
+
+use Illuminate\Contracts\Filesystem\Filesystem;
+use Illuminate\Http\UploadedFile;
+use Illuminate\Contracts\Validation\Validator;
+
+abstract class BinaryFileUploadRequest extends Request
+{
+    /**
+     * @var
+     */
+    private $fileName;
+
+    /**
+     * @var
+     */
+    protected $fs;
+
+    /**
+     * {@inheritdoc}
+     */
+    protected function prepareForValidation()
+    {
+        $this->fs = $this->container->make(Filesystem::class);
+
+        $this->files->set(
+            $this->fileFieldName(),
+            $this->getUploadedFile()
+        );
+    }
+
+    /**
+     * Get the file field name which will be used for storing the UploadedFile
+     * into request's FilesBag.
+     * @return string
+     */
+    protected function fileFieldName()
+    {
+        return 'file';
+    }
+
+    /**
+     * Get UploadedFile from request body.
+     * @return UploadedFile
+     */
+    protected function getUploadedFile()
+    {
+        $this->fileName = str_random(20);
+
+
+
+        $this->fs->put($this->fileName, $this->getContent());
+
+        return new UploadedFile(
+            storage_path("app/{$this->fileName}"),
+            $this->fileName,
+            $this->fs->mimeType($this->fileName),
+            null,
+            null,
+            true
+        );
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    protected function failedValidation(Validator $validator)
+    {
+        if ($this->fs->has($this->fileName)) {
+            $this->fs->delete($this->fileName);
+        }
+
+        parent::failedValidation($validator);
+    }
+}
diff --git a/app/Http/Requests/Permission/RemovePermissionRequest.php b/app/Http/Requests/Permission/RemovePermissionRequest.php
new file mode 100644
index 0000000..7961a1a
--- /dev/null
+++ b/app/Http/Requests/Permission/RemovePermissionRequest.php
@@ -0,0 +1,23 @@
+<?php
+
+namespace Vanguard\Http\Requests\Permission;
+
+use Vanguard\Http\Requests\Request;
+
+class RemovePermissionRequest extends Request
+{
+    /**
+     * Determine if the user is authorized to make this request.
+     *
+     * @return bool
+     */
+    public function authorize()
+    {
+        return $this->route('permission')->removable;
+    }
+
+    public function rules()
+    {
+        return [];
+    }
+}
diff --git a/app/Http/Requests/Role/RemoveRoleRequest.php b/app/Http/Requests/Role/RemoveRoleRequest.php
new file mode 100644
index 0000000..a36ccfe
--- /dev/null
+++ b/app/Http/Requests/Role/RemoveRoleRequest.php
@@ -0,0 +1,23 @@
+<?php
+
+namespace Vanguard\Http\Requests\Role;
+
+use Vanguard\Http\Requests\Request;
+
+class RemoveRoleRequest extends Request
+{
+    /**
+     * Determine if the user is authorized to make this request.
+     *
+     * @return bool
+     */
+    public function authorize()
+    {
+        return $this->route('role')->removable;
+    }
+
+    public function rules()
+    {
+        return [];
+    }
+}
diff --git a/app/Http/Requests/Role/UpdateRolePermissionsRequest.php b/app/Http/Requests/Role/UpdateRolePermissionsRequest.php
new file mode 100644
index 0000000..a4b4e6d
--- /dev/null
+++ b/app/Http/Requests/Role/UpdateRolePermissionsRequest.php
@@ -0,0 +1,32 @@
+<?php
+
+namespace Vanguard\Http\Requests\Role;
+
+use Illuminate\Validation\Rule;
+use Vanguard\Http\Requests\Request;
+use Vanguard\Permission;
+
+class UpdateRolePermissionsRequest extends Request
+{
+    /**
+     * Get the validation rules that apply to the request.
+     *
+     * @return array
+     */
+    public function rules()
+    {
+        $permissions = Permission::pluck('id')->toArray();
+
+        return [
+            'permissions' => 'required|array',
+            'permissions.*' => Rule::in($permissions)
+        ];
+    }
+
+    public function messages()
+    {
+        return [
+            'permissions.*' => 'Provided permission does not exist.'
+        ];
+    }
+}
diff --git a/app/Http/Requests/User/CreateUserRequest.php b/app/Http/Requests/User/CreateUserRequest.php
index 0f3f5fa..8febf77 100644
--- a/app/Http/Requests/User/CreateUserRequest.php
+++ b/app/Http/Requests/User/CreateUserRequest.php
@@ -14,12 +14,18 @@ class CreateUserRequest extends Request
      */
     public function rules()
     {
-        return [
+        $rules = [
             'email' => 'required|email|unique:users,email',
             'username' => 'unique:users,username',
             'password' => 'required|min:6|confirmed',
             'birthday' => 'date',
-            'role' => 'required|exists:roles,id'
+            'role_id' => 'required|exists:roles,id',
         ];
+
+        if ($this->get('country_id')) {
+            $rules += ['country_id' => 'exists:countries,id'];
+        }
+
+        return $rules;
     }
 }
diff --git a/app/Http/Requests/User/UpdateDetailsRequest.php b/app/Http/Requests/User/UpdateDetailsRequest.php
index fe6ff18..49539f3 100644
--- a/app/Http/Requests/User/UpdateDetailsRequest.php
+++ b/app/Http/Requests/User/UpdateDetailsRequest.php
@@ -16,7 +16,7 @@ class UpdateDetailsRequest extends Request
     {
         return [
             'birthday' => 'date',
-            'role' => 'required|exists:roles,id'
+            'role_id' => 'required|exists:roles,id'
         ];
     }
 }
diff --git a/app/Http/Requests/User/UpdateUserRequest.php b/app/Http/Requests/User/UpdateUserRequest.php
new file mode 100644
index 0000000..b403e6c
--- /dev/null
+++ b/app/Http/Requests/User/UpdateUserRequest.php
@@ -0,0 +1,31 @@
+<?php
+
+namespace Vanguard\Http\Requests\User;
+
+use Illuminate\Validation\Rule;
+use Vanguard\Http\Requests\Request;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\User;
+
+class UpdateUserRequest extends Request
+{
+    /**
+     * Get the validation rules that apply to the request.
+     *
+     * @return array
+     */
+    public function rules()
+    {
+        $user = $this->user();
+
+        return [
+            'email' => 'email|unique:users,email,' . $user->id,
+            'username' => 'unique:users,username,' . $user->id,
+            'password' => 'min:6|confirmed',
+            'birthday' => 'date',
+            'role_id' => 'exists:roles,id',
+            'country_id' => 'exists:countries,id',
+            'status' => Rule::in(array_keys(UserStatus::lists()))
+        ];
+    }
+}
diff --git a/app/Http/Requests/User/UploadAvatarRawRequest.php b/app/Http/Requests/User/UploadAvatarRawRequest.php
new file mode 100644
index 0000000..be45920
--- /dev/null
+++ b/app/Http/Requests/User/UploadAvatarRawRequest.php
@@ -0,0 +1,22 @@
+<?php
+
+namespace Vanguard\Http\Requests\User;
+
+use Vanguard\Http\Requests\BinaryFileUploadRequest;
+
+class UploadAvatarRawRequest extends BinaryFileUploadRequest
+{
+    public function rules()
+    {
+        return [
+            'file' => 'required|image'
+        ];
+    }
+
+    public function messages()
+    {
+        return [
+            "file.required" => 'The file is required.'
+        ];
+    }
+}
diff --git a/app/Http/Requests/User/UploadAvatarRequest.php b/app/Http/Requests/User/UploadAvatarRequest.php
deleted file mode 100644
index 8f486ca..0000000
--- a/app/Http/Requests/User/UploadAvatarRequest.php
+++ /dev/null
@@ -1,21 +0,0 @@
-<?php
-
-namespace Vanguard\Http\Requests\User;
-
-use Vanguard\Http\Requests\Request;
-use Vanguard\User;
-
-class UploadAvatarRequest extends Request
-{
-    /**
-     * Get the validation rules that apply to the request.
-     *
-     * @return array
-     */
-    public function rules()
-    {
-        return [
-            'file' => 'required|image'
-        ];
-    }
-}
diff --git a/app/Listeners/Registration/SendConfirmationEmail.php b/app/Listeners/Registration/SendConfirmationEmail.php
new file mode 100644
index 0000000..b1674f3
--- /dev/null
+++ b/app/Listeners/Registration/SendConfirmationEmail.php
@@ -0,0 +1,42 @@
+<?php
+
+namespace Vanguard\Listeners\Registration;
+
+use Vanguard\Events\User\Registered;
+use Vanguard\Notifications\EmailConfirmation;
+use Vanguard\Repositories\User\UserRepository;
+
+class SendConfirmationEmail
+{
+    /**
+     * @var UserRepository
+     */
+    private $users;
+
+    public function __construct(UserRepository $users)
+    {
+        $this->users = $users;
+    }
+
+    /**
+     * Handle the event.
+     *
+     * @param  Registered  $event
+     * @return void
+     */
+    public function handle(Registered $event)
+    {
+        if (! settings('reg_email_confirmation')) {
+            return;
+        }
+
+        $user = $event->getRegisteredUser();
+
+        $token = str_random(60);
+        $this->users->update($user->id, [
+            'confirmation_token' => $token
+        ]);
+
+        $user->notify(new EmailConfirmation($token));
+    }
+}
diff --git a/app/Listeners/UserWasRegisteredListener.php b/app/Listeners/Registration/SendSignUpNotification.php
similarity index 76%
rename from app/Listeners/UserWasRegisteredListener.php
rename to app/Listeners/Registration/SendSignUpNotification.php
index 18064b1..de979c9 100644
--- a/app/Listeners/UserWasRegisteredListener.php
+++ b/app/Listeners/Registration/SendSignUpNotification.php
@@ -1,16 +1,12 @@
 <?php
 
-namespace Vanguard\Listeners;
+namespace Vanguard\Listeners\Registration;
 
 use Vanguard\Events\User\Registered;
-use Vanguard\Mailers\NotificationMailer;
-use Vanguard\Mailers\UserMailer;
 use Vanguard\Notifications\UserRegistered;
 use Vanguard\Repositories\User\UserRepository;
-use Illuminate\Queue\InteractsWithQueue;
-use Illuminate\Contracts\Queue\ShouldQueue;
 
-class UserWasRegisteredListener
+class SendSignUpNotification
 {
     /**
      * @var UserRepository
diff --git a/app/Mailers/AbstractMailer.php b/app/Mailers/AbstractMailer.php
deleted file mode 100644
index d200679..0000000
--- a/app/Mailers/AbstractMailer.php
+++ /dev/null
@@ -1,39 +0,0 @@
-<?php
-
-namespace Vanguard\Mailers;
-
-use Illuminate\Contracts\Mail\Mailer as Mail;
-
-abstract class AbstractMailer
-{
-    /**
-     * @var Mail
-     */
-    private $mail;
-
-    /**
-     * @param Mail $mail
-     */
-    function __construct(Mail $mail)
-    {
-        $this->mail = $mail;
-    }
-
-    /**
-     * @param $email
-     * @param $subject
-     * @param $view
-     * @param array $data
-     */
-    public function sendTo($email, $subject, $view, $data = [])
-    {
-        $emails =  is_array($email) ? $email : [$email];
-
-        foreach ($emails as $email) {
-            $this->mail->queue($view, $data, function($message) use($email, $subject)
-            {
-                $message->to($email)->subject($subject);
-            });
-        }
-    }
-}
\ No newline at end of file
diff --git a/app/Mailers/UserMailer.php b/app/Mailers/UserMailer.php
deleted file mode 100644
index ff0145a..0000000
--- a/app/Mailers/UserMailer.php
+++ /dev/null
@@ -1,20 +0,0 @@
-<?php
-
-namespace Vanguard\Mailers;
-
-use Vanguard\Notifications\EmailConfirmation;
-use Vanguard\Notifications\ResetPassword;
-use Vanguard\User;
-
-class UserMailer extends AbstractMailer
-{
-    public function sendConfirmationEmail(User $user, $token)
-    {
-        $user->notify(new EmailConfirmation($token));
-    }
-
-    public function sendPasswordReminder(User $user, $token)
-    {
-        $user->notify(new ResetPassword($token));
-    }
-}
diff --git a/app/Permission.php b/app/Permission.php
index 1088bd2..a0b97bd 100644
--- a/app/Permission.php
+++ b/app/Permission.php
@@ -9,4 +9,8 @@ class Permission extends Model
     protected $table = 'permissions';
 
     protected $fillable = ['name', 'display_name', 'description'];
+
+    protected $casts = [
+        'removable' => 'boolean'
+    ];
 }
diff --git a/app/Providers/AuthServiceProvider.php b/app/Providers/AuthServiceProvider.php
index 290cfbb..941ea42 100644
--- a/app/Providers/AuthServiceProvider.php
+++ b/app/Providers/AuthServiceProvider.php
@@ -4,6 +4,7 @@ namespace Vanguard\Providers;
 
 use Illuminate\Contracts\Auth\Access\Gate as GateContract;
 use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
+use Vanguard\User;
 
 class AuthServiceProvider extends ServiceProvider
 {
@@ -38,5 +39,13 @@ class AuthServiceProvider extends ServiceProvider
         \Blade::directive('endpermission', function ($expression) {
             return "<?php endif; ?>";
         });
+
+        \Gate::define('manage-session', function (User $user, $session) {
+            if ($user->hasPermission('users.manage')) {
+                return true;
+            }
+
+            return (int) $user->id === (int) $session->user_id;
+        });
     }
 }
diff --git a/app/Providers/EventServiceProvider.php b/app/Providers/EventServiceProvider.php
index 6fc7052..0a3262d 100644
--- a/app/Providers/EventServiceProvider.php
+++ b/app/Providers/EventServiceProvider.php
@@ -4,6 +4,8 @@ namespace Vanguard\Providers;
 
 use Vanguard\Events\User\Registered;
 use Vanguard\Listeners\PermissionEventsSubscriber;
+use Vanguard\Listeners\Registration\SendConfirmationEmail;
+use Vanguard\Listeners\Registration\SendSignUpNotification;
 use Vanguard\Listeners\RoleEventsSubscriber;
 use Vanguard\Listeners\UserEventsSubscriber;
 use Vanguard\Listeners\UserWasRegisteredListener;
@@ -17,7 +19,10 @@ class EventServiceProvider extends ServiceProvider
      * @var array
      */
     protected $listen = [
-        Registered::class => [UserWasRegisteredListener::class]
+        Registered::class => [
+            SendConfirmationEmail::class,
+            SendSignUpNotification::class,
+        ]
     ];
 
     /**
diff --git a/app/Providers/RouteServiceProvider.php b/app/Providers/RouteServiceProvider.php
index ad8eb7d..4a80543 100644
--- a/app/Providers/RouteServiceProvider.php
+++ b/app/Providers/RouteServiceProvider.php
@@ -5,6 +5,7 @@ namespace Vanguard\Providers;
 use Route;
 use Vanguard\Permission;
 use Vanguard\Repositories\Role\RoleRepository;
+use Vanguard\Repositories\Session\SessionRepository;
 use Vanguard\Repositories\User\UserRepository;
 use Illuminate\Routing\Router;
 use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;
@@ -13,13 +14,17 @@ use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
 class RouteServiceProvider extends ServiceProvider
 {
     /**
-     * This namespace is applied to the controller routes in your routes file.
-     *
+     * This namespace is applied to the controller routes in your web routes file.
      * In addition, it is set as the URL generator's root namespace.
-     *
      * @var string
      */
-    protected $namespace = 'Vanguard\Http\Controllers';
+    protected $webNamespace = 'Vanguard\Http\Controllers\Web';
+
+    /**
+     * This namespace is applied to the controller routes in your api routes file.
+     * @var string
+     */
+    protected $apiNamespace = 'Vanguard\Http\Controllers\Api';
 
     /**
      * Define your route model bindings, pattern filters, etc.
@@ -32,6 +37,7 @@ class RouteServiceProvider extends ServiceProvider
 
         $this->bindUser();
         $this->bindRole();
+        $this->bindSession();
     }
 
     /**
@@ -41,7 +47,9 @@ class RouteServiceProvider extends ServiceProvider
      */
     public function map()
     {
-        $this->mapApiRoutes();
+        if ($this->app['config']->get('auth.expose_api')) {
+            $this->mapApiRoutes();
+        }
 
         $this->mapWebRoutes();
     }
@@ -56,7 +64,7 @@ class RouteServiceProvider extends ServiceProvider
     protected function mapWebRoutes()
     {
         Route::group([
-            'namespace' => $this->namespace,
+            'namespace' => $this->webNamespace,
             'middleware' => 'web',
         ], function ($router) {
             require base_path('routes/web.php');
@@ -74,7 +82,7 @@ class RouteServiceProvider extends ServiceProvider
     {
         Route::group([
             'middleware' => 'api',
-            'namespace' => $this->namespace,
+            'namespace' => $this->apiNamespace,
             'prefix' => 'api',
         ], function () {
             require base_path('routes/api.php');
@@ -91,6 +99,11 @@ class RouteServiceProvider extends ServiceProvider
         $this->bindUsingRepository('role', RoleRepository::class);
     }
 
+    private function bindSession()
+    {
+        $this->bindUsingRepository('session', SessionRepository::class);
+    }
+
     private function bindUsingRepository($entity, $repository, $method = 'find')
     {
         Route::bind($entity, function ($id) use ($repository, $method) {
@@ -98,7 +111,7 @@ class RouteServiceProvider extends ServiceProvider
                 return $object;
             }
 
-            throw new NotFoundHttpException;
+            throw new NotFoundHttpException("Resource not found.");
         });
     }
 }
diff --git a/app/Repositories/Country/CountryRepository.php b/app/Repositories/Country/CountryRepository.php
index 43ff28c..c05afec 100644
--- a/app/Repositories/Country/CountryRepository.php
+++ b/app/Repositories/Country/CountryRepository.php
@@ -12,4 +12,10 @@ interface CountryRepository
      * @return mixed
      */
     public function lists($column = 'name', $key = 'id');
-}
\ No newline at end of file
+
+    /**
+     * Get all available countries.
+     * @return mixed
+     */
+    public function all();
+}
diff --git a/app/Repositories/Country/EloquentCountry.php b/app/Repositories/Country/EloquentCountry.php
index 0577a13..8a04bf8 100644
--- a/app/Repositories/Country/EloquentCountry.php
+++ b/app/Repositories/Country/EloquentCountry.php
@@ -13,4 +13,12 @@ class EloquentCountry implements CountryRepository
     {
         return Country::orderBy('name')->pluck($column, $key);
     }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function all()
+    {
+        return Country::all();
+    }
 }
diff --git a/app/Repositories/Permission/PermissionRepository.php b/app/Repositories/Permission/PermissionRepository.php
index c433c30..ab4f166 100644
--- a/app/Repositories/Permission/PermissionRepository.php
+++ b/app/Repositories/Permission/PermissionRepository.php
@@ -43,4 +43,4 @@ interface PermissionRepository
      * @return mixed
      */
     public function delete($id);
-}
\ No newline at end of file
+}
diff --git a/app/Repositories/Role/EloquentRole.php b/app/Repositories/Role/EloquentRole.php
index 2fa873b..88b15d7 100644
--- a/app/Repositories/Role/EloquentRole.php
+++ b/app/Repositories/Role/EloquentRole.php
@@ -24,12 +24,7 @@ class EloquentRole implements RoleRepository
      */
     public function getAllWithUsersCount()
     {
-        $prefix = DB::getTablePrefix();
-
-        return Role::leftJoin('users', 'roles.id', '=', 'users.role_id')
-            ->select('roles.*', DB::raw("count({$prefix}users.id) as users_count"))
-            ->groupBy('roles.id')
-            ->get();
+        return Role::withCount('users')->get();
     }
 
     /**
diff --git a/app/Repositories/Session/DbSession.php b/app/Repositories/Session/DbSession.php
index c5d93cd..b5e1144 100644
--- a/app/Repositories/Session/DbSession.php
+++ b/app/Repositories/Session/DbSession.php
@@ -32,20 +32,31 @@ class DbSession implements SessionRepository
         return DB::table('sessions')
             ->where('user_id', $userId)
             ->where('last_activity', '>=', $validTimestamp)
-            ->get(['id', 'ip_address', 'user_agent', 'last_activity'])
+            ->get()
             ->all();
     }
 
     /**
      * {@inheritdoc}
      */
-    public function invalidateUserSession($userId, $sessionId)
+    public function invalidateSession($sessionId)
     {
+        $user = $this->users->findBySessionId($sessionId);
+
         DB::table('sessions')
-            ->where('user_id', $userId)
             ->where('id', $sessionId)
             ->delete();
 
-        $this->users->update($userId, ['remember_token' => null]);
+        $this->users->update($user->id, ['remember_token' => null]);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function find($sessionId)
+    {
+        return DB::table('sessions')
+            ->where('id', $sessionId)
+            ->first();
     }
-}
\ No newline at end of file
+}
diff --git a/app/Repositories/Session/SessionRepository.php b/app/Repositories/Session/SessionRepository.php
index d09752f..c061d65 100644
--- a/app/Repositories/Session/SessionRepository.php
+++ b/app/Repositories/Session/SessionRepository.php
@@ -5,6 +5,13 @@ namespace Vanguard\Repositories\Session;
 interface SessionRepository
 {
     /**
+     * Find session by id.
+     * @param $sessionId
+     * @return mixed
+     */
+    public function find($sessionId);
+
+    /**
      * Get all active sessions for specified user.
      *
      * @param $userId
@@ -15,9 +22,8 @@ interface SessionRepository
     /**
      * Invalidate specified session for provided user
      *
-     * @param $userId
      * @param $sessionId
      * @return mixed
      */
-    public function invalidateUserSession($userId, $sessionId);
-}
\ No newline at end of file
+    public function invalidateSession($sessionId);
+}
diff --git a/app/Repositories/User/EloquentUser.php b/app/Repositories/User/EloquentUser.php
index 1de4a76..7e4368b 100644
--- a/app/Repositories/User/EloquentUser.php
+++ b/app/Repositories/User/EloquentUser.php
@@ -59,12 +59,19 @@ class EloquentUser implements UserRepository
     /**
      * {@inheritdoc}
      */
-    public function create(array $data)
+    public function findBySessionId($sessionId)
     {
-        if (! array_get($data, 'country_id')) {
-            $data['country_id'] = null;
-        }
+        return User::leftJoin('sessions', 'users.id', '=', 'sessions.user_id')
+            ->select('users.*')
+            ->where('sessions.id', $sessionId)
+            ->first();
+    }
 
+    /**
+     * {@inheritdoc}
+     */
+    public function create(array $data)
+    {
         return User::create($data);
     }
 
@@ -102,7 +109,7 @@ class EloquentUser implements UserRepository
             });
         }
 
-        $result = $query->orderBy('created_at', 'desc')
+        $result = $query->orderBy('id', 'desc')
             ->paginate($perPage);
 
         if ($search) {
@@ -117,21 +124,11 @@ class EloquentUser implements UserRepository
      */
     public function update($id, array $data)
     {
-        if (array_has($data, 'country_id')) {
-            $countryId = array_get($data, 'country_id');
-
-            $data['country_id'] = $countryId ?: null;
-        }
+        $user = $this->find($id);
 
-        return $this->find($id)->update($data);
-    }
+        $user->update($data);
 
-    /**
-     * {@inheritdoc}
-     */
-    public function updateSocialNetworks($userId, array $data)
-    {
-        return $this->find($userId)->socialNetworks()->updateOrCreate([], $data);
+        return $user;
     }
 
     /**
diff --git a/app/Repositories/User/UserRepository.php b/app/Repositories/User/UserRepository.php
index 9243dd5..221b76c 100644
--- a/app/Repositories/User/UserRepository.php
+++ b/app/Repositories/User/UserRepository.php
@@ -36,13 +36,21 @@ interface UserRepository
     /**
      * Find user registered via social network.
      *
-     * @param $provider Provider used for authentication.
-     * @param $providerId Provider's unique identifier for authenticated user.
+     * @param $provider string Provider used for authentication.
+     * @param $providerId string Provider's unique identifier for authenticated user.
      * @return mixed
      */
     public function findBySocialId($provider, $providerId);
 
     /**
+     * Find user by specified session id.
+     *
+     * @param $sessionId
+     * @return mixed
+     */
+    public function findBySessionId($sessionId);
+
+    /**
      * Create new user.
      *
      * @param array $data
@@ -55,7 +63,7 @@ interface UserRepository
      *
      * @param $id
      * @param array $data
-     * @return mixed
+     * @return User
      */
     public function update($id, array $data);
 
@@ -79,14 +87,6 @@ interface UserRepository
     public function associateSocialAccountForUser($userId, $provider, SocialUser $user);
 
     /**
-     * Update user social networks.
-     * @param $userId
-     * @param array $data
-     * @return mixed
-     */
-    public function updateSocialNetworks($userId, array $data);
-
-    /**
      * Number of users in database.
      *
      * @return mixed
diff --git a/app/Services/Auth/Api/ExtendsJwtValidation.php b/app/Services/Auth/Api/ExtendsJwtValidation.php
new file mode 100644
index 0000000..a234e8d
--- /dev/null
+++ b/app/Services/Auth/Api/ExtendsJwtValidation.php
@@ -0,0 +1,69 @@
+<?php
+
+namespace Vanguard\Services\Auth\Api;
+
+use Carbon\Carbon;
+use Tymon\JWTAuth\Exceptions\TokenInvalidException;
+
+trait ExtendsJwtValidation
+{
+    protected $jtiIsValid;
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getPayload()
+    {
+        $payload = parent::getPayload();
+
+        $jti = $payload->get('jti');
+        $id = $payload->get('sub');
+
+        if (! $this->jtiIsValid($jti, $id)) {
+            throw new TokenInvalidException("Invalid jti claim.");
+        }
+
+        return $payload;
+    }
+
+    /**
+     * Check if jti claim is valid. For jti claim we use our random
+     * generated token that is being stored inside the database, so
+     * we can easily revoke it anytime we want.
+     *
+     * Remember, the jti claim is not a token itself that is being used
+     * for API authentication. It is just a unique string (more like token ID)
+     * attached to each JWT token to allow us to easily revoke that JWT token later.
+     * @param $jti
+     * @param $userId
+     * @return bool
+     */
+    private function jtiIsValid($jti, $userId)
+    {
+        if (is_null($this->jtiIsValid)) {
+            $count = Token::where('id', $jti)
+                ->where('user_id', $userId)
+                ->where('expires_at', '>', Carbon::now())
+                ->count();
+
+            $this->jtiIsValid = $count == 1;
+        }
+
+
+        return $this->jtiIsValid;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function invalidate($forceForever = true)
+    {
+        $this->requireToken();
+
+        Token::where('id', $this->getClaim('jti'))->delete();
+
+        $this->jtiIsValid = null;
+
+        return $this;
+    }
+}
diff --git a/app/Services/Auth/Api/JWT.php b/app/Services/Auth/Api/JWT.php
new file mode 100644
index 0000000..5318465
--- /dev/null
+++ b/app/Services/Auth/Api/JWT.php
@@ -0,0 +1,8 @@
+<?php
+
+namespace Vanguard\Services\Auth\Api;
+
+class JWT extends \Tymon\JWTAuth\JWT
+{
+    use ExtendsJwtValidation;
+}
diff --git a/app/Services/Auth/Api/JWTAuth.php b/app/Services/Auth/Api/JWTAuth.php
new file mode 100644
index 0000000..a909408
--- /dev/null
+++ b/app/Services/Auth/Api/JWTAuth.php
@@ -0,0 +1,8 @@
+<?php
+
+namespace Vanguard\Services\Auth\Api;
+
+class JWTAuth extends \Tymon\JWTAuth\JWTAuth
+{
+    use ExtendsJwtValidation;
+}
diff --git a/app/Services/Auth/Api/JWTServiceProvider.php b/app/Services/Auth/Api/JWTServiceProvider.php
new file mode 100644
index 0000000..4f6b780
--- /dev/null
+++ b/app/Services/Auth/Api/JWTServiceProvider.php
@@ -0,0 +1,39 @@
+<?php
+
+namespace Vanguard\Services\Auth\Api;
+
+use Tymon\JWTAuth\Providers\LaravelServiceProvider;
+
+class JWTServiceProvider extends LaravelServiceProvider
+{
+    /**
+     * Register the bindings for the main JWT class.
+     *
+     * @return void
+     */
+    protected function registerJWT()
+    {
+        $this->app->singleton('tymon.jwt', function ($app) {
+            return new JWT(
+                $app['tymon.jwt.manager'],
+                $app['tymon.jwt.parser']
+            );
+        });
+    }
+
+    /**
+     * Register the bindings for the main JWTAuth class.
+     *
+     * @return void
+     */
+    protected function registerJWTAuth()
+    {
+        $this->app->singleton('tymon.jwt.auth', function ($app) {
+            return new JWTAuth(
+                $app['tymon.jwt.manager'],
+                $app['tymon.jwt.provider.auth'],
+                $app['tymon.jwt.parser']
+            );
+        });
+    }
+}
diff --git a/app/Services/Auth/Api/Token.php b/app/Services/Auth/Api/Token.php
new file mode 100644
index 0000000..3e56d53
--- /dev/null
+++ b/app/Services/Auth/Api/Token.php
@@ -0,0 +1,12 @@
+<?php
+
+namespace Vanguard\Services\Auth\Api;
+
+use Illuminate\Database\Eloquent\Model;
+
+class Token extends Model
+{
+    protected $table = 'api_tokens';
+
+    public $incrementing = false;
+}
diff --git a/app/Services/Auth/Api/TokenFactory.php b/app/Services/Auth/Api/TokenFactory.php
new file mode 100644
index 0000000..2306323
--- /dev/null
+++ b/app/Services/Auth/Api/TokenFactory.php
@@ -0,0 +1,79 @@
+<?php
+
+namespace Vanguard\Services\Auth\Api;
+
+use Carbon\Carbon;
+use Illuminate\Http\Request;
+use Vanguard\User;
+use Illuminate\Contracts\Config\Repository as ConfigContract;
+
+class TokenFactory
+{
+    /**
+     * @var Request
+     */
+    private $request;
+
+    /**
+     * @var ConfigContract
+     */
+    private $config;
+
+    /**
+     * TokenFactory constructor.
+     * @param Request $request
+     * @param ConfigContract $config
+     */
+    public function __construct(Request $request, ConfigContract $config)
+    {
+        $this->request = $request;
+        $this->config = $config;
+    }
+
+    /**
+     * Create new token for specified user.
+     * @param User $user
+     * @return Token
+     */
+    public function forUser(User $user)
+    {
+        $ttl = $this->config->get('jwt.ttl');
+
+        $token = (new Token)->forceFill([
+            'id' => str_random(40),
+            'user_id' => $user->id,
+            'ip_address' => $this->request->ip(),
+            'user_agent' => $this->getUserAgent(),
+            'expires_at' => is_null($ttl) ? null : Carbon::now()->addMinutes($ttl)
+        ]);
+
+        $token->save();
+
+        if ($this->shouldCleanUp()) {
+            Token::where('expires_at', '<=', Carbon::now())->delete();
+        }
+
+        return $token;
+    }
+
+    /**
+     * Get user agent from request headers.
+     *
+     * @return string
+     */
+    private function getUserAgent()
+    {
+        return substr((string) $this->request->header('User-Agent'), 0, 500);
+    }
+
+    /**
+     * Determine if we should clean up expired tokens.
+     * @return bool
+     */
+    protected function shouldCleanUp()
+    {
+        $lottery = $this->config->get('jwt.lottery');
+
+        return random_int(1, $lottery[1]) <= $lottery[0];
+    }
+}
diff --git a/app/Services/Auth/Social/SocialManager.php b/app/Services/Auth/Social/SocialManager.php
new file mode 100644
index 0000000..f74548d
--- /dev/null
+++ b/app/Services/Auth/Social/SocialManager.php
@@ -0,0 +1,85 @@
+<?php
+
+namespace Vanguard\Services\Auth\Social;
+
+use Laravel\Socialite\Contracts\User as SocialUser;
+use Vanguard\Repositories\Role\RoleRepository;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Support\Enum\UserStatus;
+
+class SocialManager
+{
+    /**
+     * @var UserRepository
+     */
+    private $users;
+    /**
+     * @var RoleRepository
+     */
+    private $roles;
+
+    /**
+     * SocialManager constructor.
+     * @param UserRepository $users
+     * @param RoleRepository $roles
+     */
+    public function __construct(UserRepository $users, RoleRepository $roles)
+    {
+        $this->users = $users;
+        $this->roles = $roles;
+    }
+
+    /**
+     * Associate social user with given provider. If user with the same email address
+     * retrieved from social network exists in our database, we will just associate it
+     * with provided social account. If not, user will be created.
+     *
+     * @param SocialUser $socialUser
+     * @param string $provider
+     * @return mixed|null|\Vanguard\User
+     */
+    public function associate(SocialUser $socialUser, $provider)
+    {
+        $user = $this->users->findByEmail($socialUser->getEmail());
+
+        if (! $user) {
+            // User with email retrieved from social auth provider does not
+            // exist in our database. That means that we have to create new user here
+            list($firstName, $lastName) = $this->parseUserFullName($socialUser);
+
+            $role = $this->roles->findByName('User');
+
+            $user = $this->users->create([
+                'email' => $socialUser->getEmail(),
+                'password' => str_random(10),
+                'first_name' => $firstName,
+                'last_name' => $lastName,
+                'status' => UserStatus::ACTIVE,
+                'avatar' => $socialUser->getAvatar(),
+                'role_id' => $role->id
+            ]);
+        }
+
+        // Associate social account with user account inside our application
+        $this->users->associateSocialAccountForUser($user->id, $provider, $socialUser);
+
+        return $user;
+    }
+
+    /**
+     * Parse User's name from his social network account.
+     *
+     * @param SocialUser $user
+     * @return array
+     */
+    private function parseUserFullName(SocialUser $user)
+    {
+        $name = $user->getName();
+
+        if (strpos($name, " ") !== false) {
+            return explode(" ", $name, 2);
+        }
+
+        return [$name, ''];
+    }
+}
diff --git a/app/Services/Logging/UserActivity/Activity.php b/app/Services/Logging/UserActivity/Activity.php
index 882f04d..ed16239 100644
--- a/app/Services/Logging/UserActivity/Activity.php
+++ b/app/Services/Logging/UserActivity/Activity.php
@@ -17,4 +17,4 @@ class Activity extends Model
     {
         return $this->belongsTo(User::class, 'user_id');
     }
-}
\ No newline at end of file
+}
diff --git a/app/Services/Logging/UserActivity/Logger.php b/app/Services/Logging/UserActivity/Logger.php
index 6bb7a49..66f1b38 100644
--- a/app/Services/Logging/UserActivity/Logger.php
+++ b/app/Services/Logging/UserActivity/Logger.php
@@ -2,9 +2,9 @@
 
 namespace Vanguard\Services\Logging\UserActivity;
 
+use Illuminate\Contracts\Auth\Factory;
 use Vanguard\Repositories\Activity\ActivityRepository;
 use Vanguard\User;
-use Illuminate\Contracts\Auth\Guard;
 use Illuminate\Http\Request;
 
 class Logger
@@ -14,7 +14,7 @@ class Logger
      */
     private $request;
     /**
-     * @var Guard
+     * @var Factory
      */
     private $auth;
 
@@ -27,7 +27,7 @@ class Logger
      */
     private $activities;
 
-    public function __construct(Request $request, Guard $auth, ActivityRepository $activities)
+    public function __construct(Request $request, Factory $auth, ActivityRepository $activities)
     {
         $this->request = $request;
         $this->auth = $auth;
@@ -63,7 +63,7 @@ class Logger
             return $this->user->id;
         }
 
-        return $this->auth->id();
+        return $this->auth->guard()->id();
     }
 
     /**
@@ -83,4 +83,4 @@ class Logger
     {
         $this->user = $user;
     }
-}
\ No newline at end of file
+}
diff --git a/app/Services/Upload/UserAvatarManager.php b/app/Services/Upload/UserAvatarManager.php
index f4be86a..7bc2c23 100644
--- a/app/Services/Upload/UserAvatarManager.php
+++ b/app/Services/Upload/UserAvatarManager.php
@@ -2,9 +2,9 @@
 
 namespace Vanguard\Services\Upload;
 
+use Illuminate\Http\UploadedFile;
 use Vanguard\User;
 use Illuminate\Filesystem\Filesystem;
-use Illuminate\Http\Request;
 use Intervention\Image\ImageManager;
 use Symfony\Component\HttpFoundation\File\File;
 
@@ -27,30 +27,27 @@ class UserAvatarManager
      * @var ImageManager
      */
     private $imageManager;
-    /**
-     * @var Request
-     */
-    private $request;
 
-    public function __construct(Filesystem $fs, ImageManager $imageManager, Request $request)
+    public function __construct(Filesystem $fs, ImageManager $imageManager)
     {
         $this->fs = $fs;
         $this->imageManager = $imageManager;
-        $this->request = $request;
     }
 
     /**
      * Upload and crop user avatar to predefined width and height.
      *
      * @param User $user
+     * @param UploadedFile $file
+     * @param array|null $cropPoints
      * @return string Avatar file name.
      */
-    public function uploadAndCropAvatar(User $user)
+    public function uploadAndCropAvatar(User $user, UploadedFile $file, array $cropPoints = null)
     {
-        list($name, $avatarImage) = $this->uploadFile($user);
+        list($name, $avatarImage) = $this->saveFile($file);
 
         try {
-            $this->cropAndResizeImage($avatarImage);
+            $this->cropAndResizeImage($avatarImage, $cropPoints);
             $this->deleteAvatarIfUploaded($user);
         } catch (\Exception $e) {
             logger("Cannot upload avatar. " . $e->getMessage());
@@ -62,16 +59,6 @@ class UserAvatarManager
     }
 
     /**
-     * Get uploaded file from HTTP request.
-     *
-     * @return array|null|\Symfony\Component\HttpFoundation\File\UploadedFile
-     */
-    private function getUploadedFileFromRequest()
-    {
-        return $this->request->file('avatar');
-    }
-
-    /**
      * Check if user has uploaded avatar photo.
      * If he is using some external url for avatar, then
      * it is assumed that avatar is not uploaded manually.
@@ -85,18 +72,19 @@ class UserAvatarManager
     }
 
     /**
-     * Upload avatar photo for provided user and
-     * delete old avatar if exists.
+     * Save avatar for provided user.
      *
-     * @param User $user
+     * @param UploadedFile $uploadedFile
      * @return array
      */
-    private function uploadFile(User $user)
+    private function saveFile(UploadedFile $uploadedFile)
     {
         $name = $this->generateAvatarName();
-        $uploadedFile = $this->getUploadedFileFromRequest();
 
-        $targetFile = $uploadedFile->move($this->getDestinationDirectory(), $name);
+        $targetFile = $uploadedFile->move(
+            $this->getDestinationDirectory(),
+            $name
+        );
 
         return [$name, $targetFile];
     }
@@ -116,10 +104,17 @@ class UserAvatarManager
      */
     public function deleteAvatarIfUploaded(User $user)
     {
-        if ($this->userHasUploadedAvatar($user)) {
-            $path = sprintf("%s/%s", $this->getDestinationDirectory(), $user->avatar);
-            $this->fs->delete($path);
+        if (! $this->userHasUploadedAvatar($user)) {
+            return;
         }
+
+        $path = sprintf(
+            "%s/%s",
+            $this->getDestinationDirectory(),
+            $user->avatar
+        );
+
+        $this->fs->delete($path);
     }
 
     /**
@@ -129,13 +124,7 @@ class UserAvatarManager
      */
     private function generateAvatarName()
     {
-        $file = $this->getUploadedFileFromRequest();
-
-        return sprintf(
-            "%s.%s",
-            md5(str_random() . time()),
-            $file->getClientOriginalExtension()
-        );
+        return sprintf("%s.png", str_random());
     }
 
     /**
@@ -143,19 +132,28 @@ class UserAvatarManager
      * resize it to predefined width and height.
      *
      * @param File $avatarImage
+     * @param array|null $points
      * @return \Intervention\Image\Image
      */
-    private function cropAndResizeImage(File $avatarImage)
+    private function cropAndResizeImage(File $avatarImage, array $points = null)
     {
-        $points = $this->request->get('points');
-        $image = $this->imageManager->make($avatarImage->getRealPath());
+        $image = $this->imageManager->make(
+            $avatarImage->getRealPath()
+        );
 
-        // Calculate delta between two points on X axis. This
-        // value will be used as width and height for cropped image.
-        $size = floor($points['x2'] - $points['x1']);
+        if ($points) {
+            // Calculate delta between two points on X axis. This
+            // value will be used as width and height for cropped image.
+            $size = floor($points['x2'] - $points['x1']);
+
+            return $image->crop($size, $size, (int) $points['x1'], (int) $points['y1'])
+                ->resize(self::AVATAR_WIDTH, self::AVATAR_HEIGHT)
+                ->save();
+        }
 
-        return $image->crop($size, $size, (int) $points['x1'], (int) $points['y1'])
-            ->resize(self::AVATAR_WIDTH, self::AVATAR_HEIGHT)
+        // If crop points are not provided, we will just crop
+        // provided image to specified width and height.
+        return $image->crop(self::AVATAR_WIDTH, self::AVATAR_HEIGHT)
             ->save();
     }
 }
\ No newline at end of file
diff --git a/app/Support/Authorization/AuthorizationUserTrait.php b/app/Support/Authorization/AuthorizationUserTrait.php
index 23839d8..3ce1a9b 100644
--- a/app/Support/Authorization/AuthorizationUserTrait.php
+++ b/app/Support/Authorization/AuthorizationUserTrait.php
@@ -27,15 +27,31 @@ trait AuthorizationUserTrait
     /**
      * Check if user can perform some action.
      * @param $permission
+     * @param bool $allRequired
      * @return bool
      */
-    public function hasPermission($permission)
+    public function hasPermission($permission, $allRequired = true)
     {
         $permission = (array) $permission;
-        $permissions = $this->role->cachedPermissions()->pluck('name')->toArray();
 
-        foreach ($permission as $perm) {
-            if (! in_array($perm, $permissions, true)) {
+        return $allRequired
+            ? $this->hasAllPermissions($permission)
+            : $this->hasAtLeastOnePermission($permission);
+    }
+
+    /**
+     * Check if user has all provided permissions
+     * (translates to AND logic between permissions).
+     *
+     * @param array $permissions
+     * @return bool
+     */
+    private function hasAllPermissions(array $permissions)
+    {
+        $availablePermissions = $this->role->cachedPermissions()->pluck('name')->toArray();
+
+        foreach ($permissions as $perm) {
+            if (! in_array($perm, $availablePermissions, true)) {
                 return false;
             }
         }
@@ -44,6 +60,26 @@ trait AuthorizationUserTrait
     }
 
     /**
+     * Check if user has at least one of provided permissions
+     * (translates to OR logic between permissions).
+     *
+     * @param array $permissions
+     * @return bool
+     */
+    private function hasAtLeastOnePermission(array $permissions)
+    {
+        $availablePermissions = $this->role->cachedPermissions()->pluck('name')->toArray();
+
+        foreach ($permissions as $perm) {
+            if (in_array($perm, $availablePermissions, true)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
      * Set user's role.
      * @param Role $role
      * @return mixed
diff --git a/app/Support/DataArraySerializer.php b/app/Support/DataArraySerializer.php
new file mode 100644
index 0000000..86bf70c
--- /dev/null
+++ b/app/Support/DataArraySerializer.php
@@ -0,0 +1,100 @@
+<?php
+
+namespace Vanguard\Support;
+
+use League\Fractal\Pagination\PaginatorInterface;
+
+class DataArraySerializer extends \League\Fractal\Serializer\DataArraySerializer
+{
+    /**
+     * {@inheritdoc}
+     */
+    public function item($resourceKey, array $data)
+    {
+        return $data;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function collection($resourceKey, array $data)
+    {
+        if ($resourceKey) {
+            return [$resourceKey => $data];
+        }
+
+        return $data;
+    }
+
+    /**
+     * Format pagination data according to Illiminate defined format.
+     *
+     * @param PaginatorInterface $paginator
+     * @return array
+     */
+    public function paginator(PaginatorInterface $paginator)
+    {
+        $currentPage = $paginator->getCurrentPage();
+        $lastPage = $paginator->getLastPage();
+
+        $nextPage = $lastPage > $currentPage
+            ? $paginator->getUrl($currentPage + 1)
+            : null;
+
+        $prevPage = $currentPage > 1
+            ? $paginator->getUrl($currentPage - 1)
+            : null;
+
+        $data = [
+            'total' => $paginator->getTotal(),
+            'per_page' => $paginator->getPerPage(),
+            'current_page' => $currentPage,
+            'last_page' => $paginator->getLastPage(),
+            'next_page_url' => $nextPage,
+            'prev_page_url' => $prevPage,
+            'from' => $this->firstItem($paginator),
+            'to' => $this->lastItem($paginator),
+        ];
+
+        return ['meta' => $data];
+    }
+
+    /**
+     * Get the number of the first item in the slice.
+     *
+     * @param PaginatorInterface $paginator
+     * @return int
+     */
+    private function firstItem(PaginatorInterface $paginator)
+    {
+        if ($paginator->getCount() === 0) {
+            return;
+        }
+
+        return ($paginator->getCurrentPage() - 1) * $paginator->getPerPage() + 1;
+    }
+
+    /**
+     * Get the number of the last item in the slice.
+     *
+     * @param PaginatorInterface $paginator
+     * @return int
+     */
+    private function lastItem(PaginatorInterface $paginator)
+    {
+        if ($paginator->getCount() === 0) {
+            return;
+        }
+
+        return $this->firstItem($paginator) + $paginator->getCount() - 1;
+    }
+
+    public function meta(array $meta)
+    {
+        if (empty($meta)) {
+            return [];
+        }
+
+        return $meta;
+    }
+}
diff --git a/app/Support/Enum/UserStatus.php b/app/Support/Enum/UserStatus.php
index 1ad890b..819227b 100644
--- a/app/Support/Enum/UserStatus.php
+++ b/app/Support/Enum/UserStatus.php
@@ -16,4 +16,4 @@ class UserStatus
             self::UNCONFIRMED => trans('app.' . self::UNCONFIRMED)
         ];
     }
-}
\ No newline at end of file
+}
diff --git a/app/Transformers/ActivityTransformer.php b/app/Transformers/ActivityTransformer.php
new file mode 100644
index 0000000..4882b16
--- /dev/null
+++ b/app/Transformers/ActivityTransformer.php
@@ -0,0 +1,36 @@
+<?php
+
+namespace Vanguard\Transformers;
+
+use League\Fractal\TransformerAbstract;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Services\Logging\UserActivity\Activity;
+use Vanguard\User;
+
+class ActivityTransformer extends TransformerAbstract
+{
+    protected $availableIncludes = ['user'];
+
+    public function transform(Activity $activity)
+    {
+        $agent = app('agent');
+        $agent->setUserAgent($activity->user_agent);
+
+        return [
+            'id' => (int) $activity->id,
+            'user_id' => (int) $activity->user_id,
+            'ip_address' => $activity->ip_address,
+            'user_agent' => $activity->user_agent,
+            'browser' => $agent->browser(),
+            'platform' => $agent->platform(),
+            'device' => $agent->device(),
+            'description' => $activity->description,
+            'created_at' => (string) $activity->created_at
+        ];
+    }
+
+    public function includeUser(Activity $activity)
+    {
+        return $this->item($activity->user, new UserTransformer);
+    }
+}
diff --git a/app/Transformers/CountryTransformer.php b/app/Transformers/CountryTransformer.php
new file mode 100644
index 0000000..526b7e0
--- /dev/null
+++ b/app/Transformers/CountryTransformer.php
@@ -0,0 +1,32 @@
+<?php
+
+namespace Vanguard\Transformers;
+
+use League\Fractal\TransformerAbstract;
+use Vanguard\Country;
+
+class CountryTransformer extends TransformerAbstract
+{
+    public function transform(Country $country)
+    {
+        return [
+            'id' => (int) $country->id,
+            'name' => $country->name,
+            'full_name' => $country->full_name,
+            'capital' => $country->capital,
+            'citizenship' => $country->citizenship,
+            'country_code' => (int) $country->country_code,
+            'currency' => $country->currency,
+            'currency_code' => $country->currency_code,
+            'currency_sub_unit' => $country->currency_sub_unit,
+            'currency_symbol' => $country->currency_symbol,
+            'iso_3166_2' => $country->iso_3166_2,
+            'iso_3166_3' => $country->iso_3166_3,
+            'region_code' => (int) $country->region_code,
+            'sub_region_code' => (int) $country->sub_region_code,
+            'eea' => (boolean) $country->eea,
+            'calling_code' => (int) $country->calling_code,
+            'flag' => $country->flag ? url("flags/{$country->flag}") : null
+        ];
+    }
+}
diff --git a/app/Transformers/PermissionTransformer.php b/app/Transformers/PermissionTransformer.php
new file mode 100644
index 0000000..2fe91f5
--- /dev/null
+++ b/app/Transformers/PermissionTransformer.php
@@ -0,0 +1,22 @@
+<?php
+
+namespace Vanguard\Transformers;
+
+use League\Fractal\TransformerAbstract;
+use Vanguard\Permission;
+
+class PermissionTransformer extends TransformerAbstract
+{
+    public function transform(Permission $permission)
+    {
+        return [
+            'id' => (int) $permission->id,
+            'name' => $permission->name,
+            'display_name' => $permission->display_name,
+            'description' => $permission->description,
+            'removable' => (boolean) $permission->removable,
+            'updated_at' => (string) $permission->updated_at,
+            'created_at' => (string) $permission->created_at
+        ];
+    }
+}
diff --git a/app/Transformers/RoleTransformer.php b/app/Transformers/RoleTransformer.php
new file mode 100644
index 0000000..4c19bcf
--- /dev/null
+++ b/app/Transformers/RoleTransformer.php
@@ -0,0 +1,33 @@
+<?php
+
+namespace Vanguard\Transformers;
+
+use League\Fractal\TransformerAbstract;
+use Vanguard\Role;
+
+class RoleTransformer extends TransformerAbstract
+{
+    protected $availableIncludes = ['permissions'];
+
+    public function transform(Role $role)
+    {
+        return [
+            'id' => (int) $role->id,
+            'name' => $role->name,
+            'display_name' => $role->display_name,
+            'description' => $role->description,
+            'removable' => (boolean) $role->removable,
+            'users_count' => is_null($role->users_count) ? null : (int) $role->users_count,
+            'updated_at' => (string) $role->updated_at,
+            'created_at' => (string) $role->created_at
+        ];
+    }
+
+    public function includePermissions(Role $role)
+    {
+        return $this->collection(
+            $role->cachedPermissions(),
+            new PermissionTransformer
+        );
+    }
+}
diff --git a/app/Transformers/SessionTransformer.php b/app/Transformers/SessionTransformer.php
new file mode 100644
index 0000000..fac31af
--- /dev/null
+++ b/app/Transformers/SessionTransformer.php
@@ -0,0 +1,27 @@
+<?php
+
+namespace Vanguard\Transformers;
+
+use Carbon\Carbon;
+use League\Fractal\TransformerAbstract;
+use Vanguard\User;
+
+class SessionTransformer extends TransformerAbstract
+{
+    public function transform($session)
+    {
+        $agent = app('agent');
+        $agent->setUserAgent($session->user_agent);
+
+        return [
+            'id' => $session->id,
+            'user_id' => (int) $session->user_id,
+            'ip_address' => $session->ip_address,
+            'user_agent' => $session->user_agent,
+            'browser' => $agent->browser(),
+            'platform' => $agent->platform(),
+            'device' => $agent->device(),
+            'last_activity' => (string) Carbon::createFromTimestamp($session->last_activity)
+        ];
+    }
+}
diff --git a/app/Transformers/UserTransformer.php b/app/Transformers/UserTransformer.php
new file mode 100644
index 0000000..15af0f2
--- /dev/null
+++ b/app/Transformers/UserTransformer.php
@@ -0,0 +1,51 @@
+<?php
+
+namespace Vanguard\Transformers;
+
+use League\Fractal\TransformerAbstract;
+use Vanguard\Repositories\Country\CountryRepository;
+use Vanguard\Repositories\Role\RoleRepository;
+use Vanguard\User;
+
+class UserTransformer extends TransformerAbstract
+{
+    protected $availableIncludes = ['role', 'country'];
+
+    public function transform(User $user)
+    {
+        return [
+            'id' => $user->id,
+            'first_name' => $user->first_name,
+            'last_name' => $user->last_name,
+            'username' => $user->username,
+            'email' => $user->email,
+            'phone' => $user->phone,
+            'avatar' => $user->present()->avatar,
+            'address' => $user->address,
+            'country_id' => $user->country_id ? (int) $user->country_id : null,
+            'role_id' => (int) $user->role_id,
+            'status' => $user->status,
+            'birthday' => $user->birthday ? $user->birthday->format('Y-m-d') : null,
+            'last_login' => (string) $user->last_login,
+            'two_factor_country_code' => (int) $user->two_factor_country_code,
+            'two_factor_phone' => (string) $user->two_factor_phone,
+            'two_factor_options' => json_decode($user->two_factor_options),
+            'created_at' => (string) $user->created_at,
+            'updated_at' => (string) $user->updated_at
+        ];
+    }
+
+    public function includeRole(User $user)
+    {
+        if (! auth('api')->user()->hasPermission('roles.manage')) {
+            return null;
+        }
+
+        return $this->item($user->role, new RoleTransformer);
+    }
+
+    public function includeCountry(User $user)
+    {
+        return $this->item($user->country, new CountryTransformer);
+    }
+}
diff --git a/app/User.php b/app/User.php
index 317eb0d..e4b5e44 100644
--- a/app/User.php
+++ b/app/User.php
@@ -2,8 +2,12 @@
 
 namespace Vanguard;
 
+use Carbon\Carbon;
 use Illuminate\Notifications\Notifiable;
+use Tymon\JWTAuth\Contracts\JWTSubject;
 use Vanguard\Presenters\UserPresenter;
+use Vanguard\Services\Auth\Api\Token;
+use Vanguard\Services\Auth\Api\TokenFactory;
 use Vanguard\Services\Auth\TwoFactor\Authenticatable as TwoFactorAuthenticatable;
 use Vanguard\Services\Auth\TwoFactor\Contracts\Authenticatable as TwoFactorAuthenticatableContract;
 use Vanguard\Services\Logging\UserActivity\Activity;
@@ -13,9 +17,13 @@ use Illuminate\Auth\Passwords\CanResetPassword;
 use Laracasts\Presenter\PresentableTrait;
 use Illuminate\Foundation\Auth\User as Authenticatable;
 
-class User extends Authenticatable implements TwoFactorAuthenticatableContract
+class User extends Authenticatable implements TwoFactorAuthenticatableContract, JWTSubject
 {
-    use TwoFactorAuthenticatable, CanResetPassword, PresentableTrait, AuthorizationUserTrait, Notifiable;
+    use TwoFactorAuthenticatable,
+        CanResetPassword,
+        PresentableTrait,
+        AuthorizationUserTrait,
+        Notifiable;
 
     protected $presenter = UserPresenter::class;
 
@@ -34,9 +42,9 @@ class User extends Authenticatable implements TwoFactorAuthenticatableContract
      * @var array
      */
     protected $fillable = [
-        'name', 'email', 'password', 'username', 'first_name', 'last_name', 'phone', 'avatar',
+        'email', 'password', 'username', 'first_name', 'last_name', 'phone', 'avatar',
         'address', 'country_id', 'birthday', 'last_login', 'confirmation_token', 'status',
-        'group_id', 'remember_token', 'role_id'
+        'remember_token', 'role_id'
     ];
 
     /**
@@ -84,11 +92,6 @@ class User extends Authenticatable implements TwoFactorAuthenticatableContract
         return $this->status == UserStatus::BANNED;
     }
 
-    public function socialNetworks()
-    {
-        return $this->hasOne(UserSocialNetworks::class, 'user_id');
-    }
-
     public function country()
     {
         return $this->belongsTo(Country::class, 'country_id');
@@ -98,4 +101,28 @@ class User extends Authenticatable implements TwoFactorAuthenticatableContract
     {
         return $this->hasMany(Activity::class, 'user_id');
     }
+
+    /**
+     * Get the identifier that will be stored in the subject claim of the JWT.
+     *
+     * @return mixed
+     */
+    public function getJWTIdentifier()
+    {
+        return $this->id;
+    }
+
+    /**
+     * Return a key value array, containing any custom claims to be added to the JWT.
+     *
+     * @return array
+     */
+    public function getJWTCustomClaims()
+    {
+        $token = app(TokenFactory::class)->forUser($this);
+
+        return [
+            'jti' => $token->id
+        ];
+    }
 }
diff --git a/app/UserSocialNetworks.php b/app/UserSocialNetworks.php
deleted file mode 100644
index cfe2738..0000000
--- a/app/UserSocialNetworks.php
+++ /dev/null
@@ -1,29 +0,0 @@
-<?php
-
-namespace Vanguard;
-
-use Vanguard\Presenters\UserPresenter;
-use Vanguard\Support\Enum\UserStatus;
-use Illuminate\Auth\Authenticatable;
-use Illuminate\Database\Eloquent\Model;
-use Illuminate\Auth\Passwords\CanResetPassword;
-use Illuminate\Foundation\Auth\Access\Authorizable;
-use Illuminate\Contracts\Auth\Authenticatable as AuthenticatableContract;
-use Illuminate\Contracts\Auth\Access\Authorizable as AuthorizableContract;
-use Illuminate\Contracts\Auth\CanResetPassword as CanResetPasswordContract;
-use Laracasts\Presenter\PresentableTrait;
-
-class UserSocialNetworks extends Model
-{
-
-    /**
-     * The database table used by the model.
-     *
-     * @var string
-     */
-    protected $table = 'user_social_networks';
-
-    public $timestamps = false;
-
-    protected $fillable = ['facebook', 'twitter', 'google_plus', 'dribbble', 'linked_in', 'skype'];
-}
diff --git a/composer.json b/composer.json
index 5e44f97..6139c47 100644
--- a/composer.json
+++ b/composer.json
@@ -20,7 +20,10 @@
         "paragonie/random_compat": "~1.4",
         "intervention/image": "^2.3",
         "anlutro/l4-settings": "^0.4.6",
-        "anhskohbo/no-captcha": "2.*"
+        "anhskohbo/no-captcha": "2.*",
+        "tymon/jwt-auth": "1.0.0-beta.3",
+        "league/fractal": "^0.16.0",
+        "jenssegers/agent": "^2.5"
     },
     "require-dev": {
         "symfony/css-selector": "~3.0",
diff --git a/composer.lock b/composer.lock
index 7ed658c..d9f7705 100644
--- a/composer.lock
+++ b/composer.lock
@@ -4,8 +4,8 @@
         "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file",
         "This file is @generated automatically"
     ],
-    "hash": "eb556caec1eb7feb299153499208c7db",
-    "content-hash": "f5f4b546f350b676e5d347d566c8ba13",
+    "hash": "d6ed6faf011ba9c40b9c02b6f8fc4863",
+    "content-hash": "9300a3185d3f75a929cfb60795119ef3",
     "packages": [
         {
             "name": "anhskohbo/no-captcha",
@@ -168,16 +168,16 @@
         },
         {
             "name": "erusev/parsedown",
-            "version": "1.6.2",
+            "version": "1.6.3",
             "source": {
                 "type": "git",
                 "url": "https://github.com/erusev/parsedown.git",
-                "reference": "1bf24f7334fe16c88bf9d467863309ceaf285b01"
+                "reference": "728952b90a333b5c6f77f06ea9422b94b585878d"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/erusev/parsedown/zipball/1bf24f7334fe16c88bf9d467863309ceaf285b01",
-                "reference": "1bf24f7334fe16c88bf9d467863309ceaf285b01",
+                "url": "https://api.github.com/repos/erusev/parsedown/zipball/728952b90a333b5c6f77f06ea9422b94b585878d",
+                "reference": "728952b90a333b5c6f77f06ea9422b94b585878d",
                 "shasum": ""
             },
             "require": {
@@ -206,20 +206,20 @@
                 "markdown",
                 "parser"
             ],
-            "time": "2017-03-29 16:04:15"
+            "time": "2017-05-14 14:47:48"
         },
         {
             "name": "guzzlehttp/guzzle",
-            "version": "6.2.3",
+            "version": "6.3.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/guzzle/guzzle.git",
-                "reference": "8d6c6cc55186db87b7dc5009827429ba4e9dc006"
+                "reference": "f4db5a78a5ea468d4831de7f0bf9d9415e348699"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/guzzle/guzzle/zipball/8d6c6cc55186db87b7dc5009827429ba4e9dc006",
-                "reference": "8d6c6cc55186db87b7dc5009827429ba4e9dc006",
+                "url": "https://api.github.com/repos/guzzle/guzzle/zipball/f4db5a78a5ea468d4831de7f0bf9d9415e348699",
+                "reference": "f4db5a78a5ea468d4831de7f0bf9d9415e348699",
                 "shasum": ""
             },
             "require": {
@@ -229,9 +229,12 @@
             },
             "require-dev": {
                 "ext-curl": "*",
-                "phpunit/phpunit": "^4.0",
+                "phpunit/phpunit": "^4.0 || ^5.0",
                 "psr/log": "^1.0"
             },
+            "suggest": {
+                "psr/log": "Required for using the Log middleware"
+            },
             "type": "library",
             "extra": {
                 "branch-alias": {
@@ -268,7 +271,7 @@
                 "rest",
                 "web service"
             ],
-            "time": "2017-02-28 22:50:30"
+            "time": "2017-06-22 18:50:49"
         },
         {
             "name": "guzzlehttp/promises",
@@ -388,16 +391,16 @@
         },
         {
             "name": "intervention/image",
-            "version": "2.3.13",
+            "version": "2.4.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/Intervention/image.git",
-                "reference": "15a517f052ee15d373ffa145c9642d5fec7ddf5c"
+                "reference": "322a4ade249467179c50a3e50eda8760ff3af2a3"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/Intervention/image/zipball/15a517f052ee15d373ffa145c9642d5fec7ddf5c",
-                "reference": "15a517f052ee15d373ffa145c9642d5fec7ddf5c",
+                "url": "https://api.github.com/repos/Intervention/image/zipball/322a4ade249467179c50a3e50eda8760ff3af2a3",
+                "reference": "322a4ade249467179c50a3e50eda8760ff3af2a3",
                 "shasum": ""
             },
             "require": {
@@ -407,7 +410,7 @@
             },
             "require-dev": {
                 "mockery/mockery": "~0.9.2",
-                "phpunit/phpunit": "3.*"
+                "phpunit/phpunit": "^4.8 || ^5.7"
             },
             "suggest": {
                 "ext-gd": "to use GD library based image processing.",
@@ -418,6 +421,14 @@
             "extra": {
                 "branch-alias": {
                     "dev-master": "2.3-dev"
+                },
+                "laravel": {
+                    "providers": [
+                        "Intervention\\Image\\ImageServiceProvider"
+                    ],
+                    "aliases": {
+                        "Image": "Intervention\\Image\\Facades\\Image"
+                    }
                 }
             },
             "autoload": {
@@ -432,8 +443,8 @@
             "authors": [
                 {
                     "name": "Oliver Vogel",
-                    "email": "oliver@olivervogel.net",
-                    "homepage": "http://olivervogel.net/"
+                    "email": "oliver@olivervogel.com",
+                    "homepage": "http://olivervogel.com/"
                 }
             ],
             "description": "Image handling and manipulation library with support for Laravel integration",
@@ -446,7 +457,123 @@
                 "thumbnail",
                 "watermark"
             ],
-            "time": "2017-04-23 18:45:36"
+            "time": "2017-07-03 15:50:40"
+        },
+        {
+            "name": "jaybizzle/crawler-detect",
+            "version": "v1.2.51",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/JayBizzle/Crawler-Detect.git",
+                "reference": "be9074b1206ba7b5ac5662f900295edc088a9da8"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/JayBizzle/Crawler-Detect/zipball/be9074b1206ba7b5ac5662f900295edc088a9da8",
+                "reference": "be9074b1206ba7b5ac5662f900295edc088a9da8",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.3.0"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "4.8.*",
+                "satooshi/php-coveralls": "1.*"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "Jaybizzle\\CrawlerDetect\\": "src/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Mark Beech",
+                    "email": "m@rkbee.ch",
+                    "role": "Developer"
+                }
+            ],
+            "description": "CrawlerDetect is a PHP class for detecting bots/crawlers/spiders via the user agent",
+            "homepage": "https://github.com/JayBizzle/Crawler-Detect/",
+            "keywords": [
+                "crawler",
+                "crawler detect",
+                "crawler detector",
+                "crawlerdetect",
+                "php crawler detect"
+            ],
+            "time": "2017-08-07 18:48:00"
+        },
+        {
+            "name": "jenssegers/agent",
+            "version": "v2.5.2",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/jenssegers/agent.git",
+                "reference": "faf85b10206478382ac93eda122430fee78c544e"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/jenssegers/agent/zipball/faf85b10206478382ac93eda122430fee78c544e",
+                "reference": "faf85b10206478382ac93eda122430fee78c544e",
+                "shasum": ""
+            },
+            "require": {
+                "illuminate/support": "^4.0|^5.0",
+                "jaybizzle/crawler-detect": "^1.2",
+                "mobiledetect/mobiledetectlib": "^2.7.6",
+                "php": ">=5.4.0"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "^4.0|^5.0|^6.0",
+                "satooshi/php-coveralls": "^1.0"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "3.0-dev"
+                },
+                "laravel": {
+                    "providers": [
+                        "Jenssegers\\Agent\\AgentServiceProvider"
+                    ],
+                    "aliases": {
+                        "Agent": "Jenssegers\\Agent\\Facades\\Agent"
+                    }
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Jenssegers\\Agent\\": "src/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Jens Segers",
+                    "homepage": "https://jenssegers.com"
+                }
+            ],
+            "description": "Desktop/mobile user agent parser with support for Laravel, based on Mobiledetect",
+            "homepage": "https://github.com/jenssegers/agent",
+            "keywords": [
+                "Agent",
+                "browser",
+                "desktop",
+                "laravel",
+                "mobile",
+                "platform",
+                "user agent",
+                "useragent"
+            ],
+            "time": "2017-06-27 06:30:13"
         },
         {
             "name": "laracasts/presenter",
@@ -496,20 +623,20 @@
         },
         {
             "name": "laravel/framework",
-            "version": "v5.4.20",
+            "version": "v5.4.33",
             "source": {
                 "type": "git",
                 "url": "https://github.com/laravel/framework.git",
-                "reference": "851aad458bcc904178ded02954d55d36c2c35f8b"
+                "reference": "e53a81a2bf406f501cdf818ad949f8d6c8dabfc0"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/laravel/framework/zipball/851aad458bcc904178ded02954d55d36c2c35f8b",
-                "reference": "851aad458bcc904178ded02954d55d36c2c35f8b",
+                "url": "https://api.github.com/repos/laravel/framework/zipball/e53a81a2bf406f501cdf818ad949f8d6c8dabfc0",
+                "reference": "e53a81a2bf406f501cdf818ad949f8d6c8dabfc0",
                 "shasum": ""
             },
             "require": {
-                "doctrine/inflector": "~1.0",
+                "doctrine/inflector": "~1.1",
                 "erusev/parsedown": "~1.6",
                 "ext-mbstring": "*",
                 "ext-openssl": "*",
@@ -621,20 +748,20 @@
                 "framework",
                 "laravel"
             ],
-            "time": "2017-04-27 13:04:35"
+            "time": "2017-08-14 20:17:41"
         },
         {
             "name": "laravel/socialite",
-            "version": "v3.0.5",
+            "version": "v3.0.7",
             "source": {
                 "type": "git",
                 "url": "https://github.com/laravel/socialite.git",
-                "reference": "2771ab96004b6149d0974f8a469e08c8e54474a5"
+                "reference": "d79174513dbf14359b53e44394cf71373ae03433"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/laravel/socialite/zipball/2771ab96004b6149d0974f8a469e08c8e54474a5",
-                "reference": "2771ab96004b6149d0974f8a469e08c8e54474a5",
+                "url": "https://api.github.com/repos/laravel/socialite/zipball/d79174513dbf14359b53e44394cf71373ae03433",
+                "reference": "d79174513dbf14359b53e44394cf71373ae03433",
                 "shasum": ""
             },
             "require": {
@@ -653,6 +780,14 @@
             "extra": {
                 "branch-alias": {
                     "dev-master": "3.0-dev"
+                },
+                "laravel": {
+                    "providers": [
+                        "Laravel\\Socialite\\SocialiteServiceProvider"
+                    ],
+                    "aliases": {
+                        "Socialite": "Laravel\\Socialite\\Facades\\Socialite"
+                    }
                 }
             },
             "autoload": {
@@ -667,7 +802,7 @@
             "authors": [
                 {
                     "name": "Taylor Otwell",
-                    "email": "taylorotwell@gmail.com"
+                    "email": "taylor@laravel.com"
                 }
             ],
             "description": "Laravel wrapper around OAuth 1 & OAuth 2 libraries.",
@@ -675,20 +810,20 @@
                 "laravel",
                 "oauth"
             ],
-            "time": "2017-04-20 16:24:07"
+            "time": "2017-07-22 14:44:37"
         },
         {
             "name": "laravelcollective/html",
-            "version": "v5.4.1",
+            "version": "v5.4.8",
             "source": {
                 "type": "git",
                 "url": "https://github.com/LaravelCollective/html.git",
-                "reference": "7570f25d58a00fd6909c0563808590f9cdb14d47"
+                "reference": "9b8f51e7a2368911c896f5d42757886bae0717b5"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/LaravelCollective/html/zipball/7570f25d58a00fd6909c0563808590f9cdb14d47",
-                "reference": "7570f25d58a00fd6909c0563808590f9cdb14d47",
+                "url": "https://api.github.com/repos/LaravelCollective/html/zipball/9b8f51e7a2368911c896f5d42757886bae0717b5",
+                "reference": "9b8f51e7a2368911c896f5d42757886bae0717b5",
                 "shasum": ""
             },
             "require": {
@@ -729,20 +864,20 @@
             ],
             "description": "HTML and Form Builders for the Laravel Framework",
             "homepage": "http://laravelcollective.com",
-            "time": "2017-01-26 19:27:05"
+            "time": "2017-05-22 06:35:07"
         },
         {
             "name": "league/flysystem",
-            "version": "1.0.39",
+            "version": "1.0.41",
             "source": {
                 "type": "git",
                 "url": "https://github.com/thephpleague/flysystem.git",
-                "reference": "2474325ee924134bb05848663b12531f6f2e9fbe"
+                "reference": "f400aa98912c561ba625ea4065031b7a41e5a155"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/thephpleague/flysystem/zipball/2474325ee924134bb05848663b12531f6f2e9fbe",
-                "reference": "2474325ee924134bb05848663b12531f6f2e9fbe",
+                "url": "https://api.github.com/repos/thephpleague/flysystem/zipball/f400aa98912c561ba625ea4065031b7a41e5a155",
+                "reference": "f400aa98912c561ba625ea4065031b7a41e5a155",
                 "shasum": ""
             },
             "require": {
@@ -763,13 +898,13 @@
                 "league/flysystem-aws-s3-v3": "Allows you to use S3 storage with AWS SDK v3",
                 "league/flysystem-azure": "Allows you to use Windows Azure Blob storage",
                 "league/flysystem-cached-adapter": "Flysystem adapter decorator for metadata caching",
-                "league/flysystem-copy": "Allows you to use Copy.com storage",
                 "league/flysystem-eventable-filesystem": "Allows you to use EventableFilesystem",
                 "league/flysystem-rackspace": "Allows you to use Rackspace Cloud Files",
                 "league/flysystem-sftp": "Allows you to use SFTP server storage via phpseclib",
                 "league/flysystem-webdav": "Allows you to use WebDAV storage",
                 "league/flysystem-ziparchive": "Allows you to use ZipArchive adapter",
-                "spatie/flysystem-dropbox": "Allows you to use Dropbox storage"
+                "spatie/flysystem-dropbox": "Allows you to use Dropbox storage",
+                "srmklive/flysystem-dropbox-v2": "Allows you to use Dropbox storage for PHP 5 applications"
             },
             "type": "library",
             "extra": {
@@ -812,7 +947,71 @@
                 "sftp",
                 "storage"
             ],
-            "time": "2017-04-25 15:24:43"
+            "time": "2017-08-06 17:41:04"
+        },
+        {
+            "name": "league/fractal",
+            "version": "0.16.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/thephpleague/fractal.git",
+                "reference": "d0445305e308d9207430680acfd580557b679ddc"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/thephpleague/fractal/zipball/d0445305e308d9207430680acfd580557b679ddc",
+                "reference": "d0445305e308d9207430680acfd580557b679ddc",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.4"
+            },
+            "require-dev": {
+                "doctrine/orm": "^2.5",
+                "illuminate/contracts": "~5.0",
+                "mockery/mockery": "~0.9",
+                "pagerfanta/pagerfanta": "~1.0.0",
+                "phpunit/phpunit": "~4.0",
+                "squizlabs/php_codesniffer": "~1.5",
+                "zendframework/zend-paginator": "~2.3"
+            },
+            "suggest": {
+                "illuminate/pagination": "The Illuminate Pagination component.",
+                "pagerfanta/pagerfanta": "Pagerfanta Paginator",
+                "zendframework/zend-paginator": "Zend Framework Paginator"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "0.13-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "League\\Fractal\\": "src"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Phil Sturgeon",
+                    "email": "me@philsturgeon.uk",
+                    "homepage": "http://philsturgeon.uk/",
+                    "role": "Developer"
+                }
+            ],
+            "description": "Handle the output of complex data structures ready for API output.",
+            "homepage": "http://fractal.thephpleague.com/",
+            "keywords": [
+                "api",
+                "json",
+                "league",
+                "rest"
+            ],
+            "time": "2017-03-12 01:28:43"
         },
         {
             "name": "league/oauth1-client",
@@ -878,17 +1077,69 @@
             "time": "2016-08-17 00:36:58"
         },
         {
+            "name": "mobiledetect/mobiledetectlib",
+            "version": "2.8.25",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/serbanghita/Mobile-Detect.git",
+                "reference": "f0896b5c7274d1450023b0b376240be902c3251c"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/serbanghita/Mobile-Detect/zipball/f0896b5c7274d1450023b0b376240be902c3251c",
+                "reference": "f0896b5c7274d1450023b0b376240be902c3251c",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.0.0"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "*"
+            },
+            "type": "library",
+            "autoload": {
+                "classmap": [
+                    "Mobile_Detect.php"
+                ],
+                "psr-0": {
+                    "Detection": "namespaced/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Serban Ghita",
+                    "email": "serbanghita@gmail.com",
+                    "homepage": "http://mobiledetect.net",
+                    "role": "Developer"
+                }
+            ],
+            "description": "Mobile_Detect is a lightweight PHP class for detecting mobile devices. It uses the User-Agent string combined with specific HTTP headers to detect the mobile environment.",
+            "homepage": "https://github.com/serbanghita/Mobile-Detect",
+            "keywords": [
+                "detect mobile devices",
+                "mobile",
+                "mobile detect",
+                "mobile detector",
+                "php mobile detect"
+            ],
+            "time": "2017-03-29 13:59:30"
+        },
+        {
             "name": "monolog/monolog",
-            "version": "1.22.1",
+            "version": "1.23.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/Seldaek/monolog.git",
-                "reference": "1e044bc4b34e91743943479f1be7a1d5eb93add0"
+                "reference": "fd8c787753b3a2ad11bc60c063cff1358a32a3b4"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/Seldaek/monolog/zipball/1e044bc4b34e91743943479f1be7a1d5eb93add0",
-                "reference": "1e044bc4b34e91743943479f1be7a1d5eb93add0",
+                "url": "https://api.github.com/repos/Seldaek/monolog/zipball/fd8c787753b3a2ad11bc60c063cff1358a32a3b4",
+                "reference": "fd8c787753b3a2ad11bc60c063cff1358a32a3b4",
                 "shasum": ""
             },
             "require": {
@@ -909,7 +1160,7 @@
                 "phpunit/phpunit-mock-objects": "2.3.0",
                 "ruflin/elastica": ">=0.90 <3.0",
                 "sentry/sentry": "^0.13",
-                "swiftmailer/swiftmailer": "~5.3"
+                "swiftmailer/swiftmailer": "^5.3|^6.0"
             },
             "suggest": {
                 "aws/aws-sdk-php": "Allow sending log messages to AWS services like DynamoDB",
@@ -953,7 +1204,7 @@
                 "logging",
                 "psr-3"
             ],
-            "time": "2017-03-13 07:08:03"
+            "time": "2017-06-19 01:22:40"
         },
         {
             "name": "mtdowling/cron-expression",
@@ -1000,6 +1251,69 @@
             "time": "2017-01-23 04:29:33"
         },
         {
+            "name": "namshi/jose",
+            "version": "7.2.3",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/namshi/jose.git",
+                "reference": "89a24d7eb3040e285dd5925fcad992378b82bcff"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/namshi/jose/zipball/89a24d7eb3040e285dd5925fcad992378b82bcff",
+                "reference": "89a24d7eb3040e285dd5925fcad992378b82bcff",
+                "shasum": ""
+            },
+            "require": {
+                "ext-date": "*",
+                "ext-hash": "*",
+                "ext-json": "*",
+                "ext-pcre": "*",
+                "ext-spl": "*",
+                "php": ">=5.5",
+                "symfony/polyfill-php56": "^1.0"
+            },
+            "require-dev": {
+                "phpseclib/phpseclib": "^2.0",
+                "phpunit/phpunit": "^4.5|^5.0",
+                "satooshi/php-coveralls": "^1.0"
+            },
+            "suggest": {
+                "ext-openssl": "Allows to use OpenSSL as crypto engine.",
+                "phpseclib/phpseclib": "Allows to use Phpseclib as crypto engine, use version ^2.0."
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "Namshi\\JOSE\\": "src/Namshi/JOSE/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Alessandro Nadalin",
+                    "email": "alessandro.nadalin@gmail.com"
+                },
+                {
+                    "name": "Alessandro Cinelli (cirpo)",
+                    "email": "alessandro.cinelli@gmail.com"
+                }
+            ],
+            "description": "JSON Object Signing and Encryption library for PHP.",
+            "keywords": [
+                "JSON Web Signature",
+                "JSON Web Token",
+                "JWS",
+                "json",
+                "jwt",
+                "token"
+            ],
+            "time": "2016-12-05 07:27:31"
+        },
+        {
             "name": "nesbot/carbon",
             "version": "1.22.1",
             "source": {
@@ -1260,16 +1574,16 @@
         },
         {
             "name": "ramsey/uuid",
-            "version": "3.6.1",
+            "version": "3.7.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/ramsey/uuid.git",
-                "reference": "4ae32dd9ab8860a4bbd750ad269cba7f06f7934e"
+                "reference": "0ef23d1b10cf1bc576e9d865a7e9c47982c5715e"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/ramsey/uuid/zipball/4ae32dd9ab8860a4bbd750ad269cba7f06f7934e",
-                "reference": "4ae32dd9ab8860a4bbd750ad269cba7f06f7934e",
+                "url": "https://api.github.com/repos/ramsey/uuid/zipball/0ef23d1b10cf1bc576e9d865a7e9c47982c5715e",
+                "reference": "0ef23d1b10cf1bc576e9d865a7e9c47982c5715e",
                 "shasum": ""
             },
             "require": {
@@ -1338,20 +1652,20 @@
                 "identifier",
                 "uuid"
             ],
-            "time": "2017-03-26 20:37:53"
+            "time": "2017-08-04 13:39:04"
         },
         {
             "name": "swiftmailer/swiftmailer",
-            "version": "v5.4.7",
+            "version": "v5.4.8",
             "source": {
                 "type": "git",
                 "url": "https://github.com/swiftmailer/swiftmailer.git",
-                "reference": "56db4ed32a6d5c9824c3ecc1d2e538f663f47eb4"
+                "reference": "9a06dc570a0367850280eefd3f1dc2da45aef517"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/swiftmailer/swiftmailer/zipball/56db4ed32a6d5c9824c3ecc1d2e538f663f47eb4",
-                "reference": "56db4ed32a6d5c9824c3ecc1d2e538f663f47eb4",
+                "url": "https://api.github.com/repos/swiftmailer/swiftmailer/zipball/9a06dc570a0367850280eefd3f1dc2da45aef517",
+                "reference": "9a06dc570a0367850280eefd3f1dc2da45aef517",
                 "shasum": ""
             },
             "require": {
@@ -1392,20 +1706,20 @@
                 "mail",
                 "mailer"
             ],
-            "time": "2017-04-20 17:32:18"
+            "time": "2017-05-01 15:54:03"
         },
         {
             "name": "symfony/console",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/console.git",
-                "reference": "c30243cc51f726812be3551316b109a2f5deaf8d"
+                "reference": "b0878233cb5c4391347e5495089c7af11b8e6201"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/console/zipball/c30243cc51f726812be3551316b109a2f5deaf8d",
-                "reference": "c30243cc51f726812be3551316b109a2f5deaf8d",
+                "url": "https://api.github.com/repos/symfony/console/zipball/b0878233cb5c4391347e5495089c7af11b8e6201",
+                "reference": "b0878233cb5c4391347e5495089c7af11b8e6201",
                 "shasum": ""
             },
             "require": {
@@ -1413,10 +1727,16 @@
                 "symfony/debug": "~2.8|~3.0",
                 "symfony/polyfill-mbstring": "~1.0"
             },
+            "conflict": {
+                "symfony/dependency-injection": "<3.3"
+            },
             "require-dev": {
                 "psr/log": "~1.0",
+                "symfony/config": "~3.3",
+                "symfony/dependency-injection": "~3.3",
                 "symfony/event-dispatcher": "~2.8|~3.0",
                 "symfony/filesystem": "~2.8|~3.0",
+                "symfony/http-kernel": "~2.8|~3.0",
                 "symfony/process": "~2.8|~3.0"
             },
             "suggest": {
@@ -1428,7 +1748,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1455,20 +1775,20 @@
             ],
             "description": "Symfony Console Component",
             "homepage": "https://symfony.com",
-            "time": "2017-04-04 14:33:42"
+            "time": "2017-07-29 21:27:59"
         },
         {
             "name": "symfony/css-selector",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/css-selector.git",
-                "reference": "a48f13dc83c168f1253a5d2a5a4fb46c36244c4c"
+                "reference": "4d882dced7b995d5274293039370148e291808f2"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/css-selector/zipball/a48f13dc83c168f1253a5d2a5a4fb46c36244c4c",
-                "reference": "a48f13dc83c168f1253a5d2a5a4fb46c36244c4c",
+                "url": "https://api.github.com/repos/symfony/css-selector/zipball/4d882dced7b995d5274293039370148e291808f2",
+                "reference": "4d882dced7b995d5274293039370148e291808f2",
                 "shasum": ""
             },
             "require": {
@@ -1477,7 +1797,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1508,20 +1828,20 @@
             ],
             "description": "Symfony CssSelector Component",
             "homepage": "https://symfony.com",
-            "time": "2017-02-21 09:12:04"
+            "time": "2017-05-01 15:01:29"
         },
         {
             "name": "symfony/debug",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/debug.git",
-                "reference": "56f613406446a4a0a031475cfd0a01751de22659"
+                "reference": "7c13ae8ce1e2adbbd574fc39de7be498e1284e13"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/debug/zipball/56f613406446a4a0a031475cfd0a01751de22659",
-                "reference": "56f613406446a4a0a031475cfd0a01751de22659",
+                "url": "https://api.github.com/repos/symfony/debug/zipball/7c13ae8ce1e2adbbd574fc39de7be498e1284e13",
+                "reference": "7c13ae8ce1e2adbbd574fc39de7be498e1284e13",
                 "shasum": ""
             },
             "require": {
@@ -1532,13 +1852,12 @@
                 "symfony/http-kernel": ">=2.3,<2.3.24|~2.4.0|>=2.5,<2.5.9|>=2.6,<2.6.2"
             },
             "require-dev": {
-                "symfony/class-loader": "~2.8|~3.0",
                 "symfony/http-kernel": "~2.8|~3.0"
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1565,29 +1884,32 @@
             ],
             "description": "Symfony Debug Component",
             "homepage": "https://symfony.com",
-            "time": "2017-03-28 21:38:24"
+            "time": "2017-07-28 15:27:31"
         },
         {
             "name": "symfony/event-dispatcher",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/event-dispatcher.git",
-                "reference": "154bb1ef7b0e42ccc792bd53edbce18ed73440ca"
+                "reference": "67535f1e3fd662bdc68d7ba317c93eecd973617e"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/event-dispatcher/zipball/154bb1ef7b0e42ccc792bd53edbce18ed73440ca",
-                "reference": "154bb1ef7b0e42ccc792bd53edbce18ed73440ca",
+                "url": "https://api.github.com/repos/symfony/event-dispatcher/zipball/67535f1e3fd662bdc68d7ba317c93eecd973617e",
+                "reference": "67535f1e3fd662bdc68d7ba317c93eecd973617e",
                 "shasum": ""
             },
             "require": {
                 "php": ">=5.5.9"
             },
+            "conflict": {
+                "symfony/dependency-injection": "<3.3"
+            },
             "require-dev": {
                 "psr/log": "~1.0",
                 "symfony/config": "~2.8|~3.0",
-                "symfony/dependency-injection": "~2.8|~3.0",
+                "symfony/dependency-injection": "~3.3",
                 "symfony/expression-language": "~2.8|~3.0",
                 "symfony/stopwatch": "~2.8|~3.0"
             },
@@ -1598,7 +1920,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1625,20 +1947,20 @@
             ],
             "description": "Symfony EventDispatcher Component",
             "homepage": "https://symfony.com",
-            "time": "2017-04-04 07:26:27"
+            "time": "2017-06-09 14:53:08"
         },
         {
             "name": "symfony/finder",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/finder.git",
-                "reference": "b20900ce5ea164cd9314af52725b0bb5a758217a"
+                "reference": "baea7f66d30854ad32988c11a09d7ffd485810c4"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/finder/zipball/b20900ce5ea164cd9314af52725b0bb5a758217a",
-                "reference": "b20900ce5ea164cd9314af52725b0bb5a758217a",
+                "url": "https://api.github.com/repos/symfony/finder/zipball/baea7f66d30854ad32988c11a09d7ffd485810c4",
+                "reference": "baea7f66d30854ad32988c11a09d7ffd485810c4",
                 "shasum": ""
             },
             "require": {
@@ -1647,7 +1969,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1674,20 +1996,20 @@
             ],
             "description": "Symfony Finder Component",
             "homepage": "https://symfony.com",
-            "time": "2017-03-20 09:32:19"
+            "time": "2017-06-01 21:01:25"
         },
         {
             "name": "symfony/http-foundation",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/http-foundation.git",
-                "reference": "cb0b6418f588952c9290b3df4ca650f1b7ab570a"
+                "reference": "49e8cd2d59a7aa9bfab19e46de680c76e500a031"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/http-foundation/zipball/cb0b6418f588952c9290b3df4ca650f1b7ab570a",
-                "reference": "cb0b6418f588952c9290b3df4ca650f1b7ab570a",
+                "url": "https://api.github.com/repos/symfony/http-foundation/zipball/49e8cd2d59a7aa9bfab19e46de680c76e500a031",
+                "reference": "49e8cd2d59a7aa9bfab19e46de680c76e500a031",
                 "shasum": ""
             },
             "require": {
@@ -1700,7 +2022,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1727,20 +2049,20 @@
             ],
             "description": "Symfony HttpFoundation Component",
             "homepage": "https://symfony.com",
-            "time": "2017-04-04 15:30:56"
+            "time": "2017-07-21 11:04:46"
         },
         {
             "name": "symfony/http-kernel",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/http-kernel.git",
-                "reference": "8285ab5faf1306b1a5ebcf287fe91c231a6de88e"
+                "reference": "db10d05f1d95e4168e638db7a81c79616f568ea5"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/http-kernel/zipball/8285ab5faf1306b1a5ebcf287fe91c231a6de88e",
-                "reference": "8285ab5faf1306b1a5ebcf287fe91c231a6de88e",
+                "url": "https://api.github.com/repos/symfony/http-kernel/zipball/db10d05f1d95e4168e638db7a81c79616f568ea5",
+                "reference": "db10d05f1d95e4168e638db7a81c79616f568ea5",
                 "shasum": ""
             },
             "require": {
@@ -1748,18 +2070,22 @@
                 "psr/log": "~1.0",
                 "symfony/debug": "~2.8|~3.0",
                 "symfony/event-dispatcher": "~2.8|~3.0",
-                "symfony/http-foundation": "~2.8.13|~3.1.6|~3.2"
+                "symfony/http-foundation": "~3.3"
             },
             "conflict": {
-                "symfony/config": "<2.8"
+                "symfony/config": "<2.8",
+                "symfony/dependency-injection": "<3.3",
+                "symfony/var-dumper": "<3.3",
+                "twig/twig": "<1.34|<2.4,>=2"
             },
             "require-dev": {
+                "psr/cache": "~1.0",
                 "symfony/browser-kit": "~2.8|~3.0",
                 "symfony/class-loader": "~2.8|~3.0",
                 "symfony/config": "~2.8|~3.0",
                 "symfony/console": "~2.8|~3.0",
                 "symfony/css-selector": "~2.8|~3.0",
-                "symfony/dependency-injection": "~2.8|~3.0",
+                "symfony/dependency-injection": "~3.3",
                 "symfony/dom-crawler": "~2.8|~3.0",
                 "symfony/expression-language": "~2.8|~3.0",
                 "symfony/finder": "~2.8|~3.0",
@@ -1768,7 +2094,7 @@
                 "symfony/stopwatch": "~2.8|~3.0",
                 "symfony/templating": "~2.8|~3.0",
                 "symfony/translation": "~2.8|~3.0",
-                "symfony/var-dumper": "~3.2"
+                "symfony/var-dumper": "~3.3"
             },
             "suggest": {
                 "symfony/browser-kit": "",
@@ -1782,7 +2108,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1809,20 +2135,20 @@
             ],
             "description": "Symfony HttpKernel Component",
             "homepage": "https://symfony.com",
-            "time": "2017-04-05 12:52:03"
+            "time": "2017-08-01 10:25:59"
         },
         {
             "name": "symfony/polyfill-mbstring",
-            "version": "v1.3.0",
+            "version": "v1.5.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/polyfill-mbstring.git",
-                "reference": "e79d363049d1c2128f133a2667e4f4190904f7f4"
+                "reference": "7c8fae0ac1d216eb54349e6a8baa57d515fe8803"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/e79d363049d1c2128f133a2667e4f4190904f7f4",
-                "reference": "e79d363049d1c2128f133a2667e4f4190904f7f4",
+                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/7c8fae0ac1d216eb54349e6a8baa57d515fe8803",
+                "reference": "7c8fae0ac1d216eb54349e6a8baa57d515fe8803",
                 "shasum": ""
             },
             "require": {
@@ -1834,7 +2160,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "1.3-dev"
+                    "dev-master": "1.5-dev"
                 }
             },
             "autoload": {
@@ -1868,20 +2194,128 @@
                 "portable",
                 "shim"
             ],
-            "time": "2016-11-14 01:06:16"
+            "time": "2017-06-14 15:44:48"
+        },
+        {
+            "name": "symfony/polyfill-php56",
+            "version": "v1.5.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/symfony/polyfill-php56.git",
+                "reference": "e85ebdef569b84e8709864e1a290c40f156b30ca"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/symfony/polyfill-php56/zipball/e85ebdef569b84e8709864e1a290c40f156b30ca",
+                "reference": "e85ebdef569b84e8709864e1a290c40f156b30ca",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.3.3",
+                "symfony/polyfill-util": "~1.0"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "1.5-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Symfony\\Polyfill\\Php56\\": ""
+                },
+                "files": [
+                    "bootstrap.php"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Nicolas Grekas",
+                    "email": "p@tchwork.com"
+                },
+                {
+                    "name": "Symfony Community",
+                    "homepage": "https://symfony.com/contributors"
+                }
+            ],
+            "description": "Symfony polyfill backporting some PHP 5.6+ features to lower PHP versions",
+            "homepage": "https://symfony.com",
+            "keywords": [
+                "compatibility",
+                "polyfill",
+                "portable",
+                "shim"
+            ],
+            "time": "2017-06-14 15:44:48"
+        },
+        {
+            "name": "symfony/polyfill-util",
+            "version": "v1.5.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/symfony/polyfill-util.git",
+                "reference": "67925d1cf0b84bd234a83bebf26d4eb281744c6d"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/symfony/polyfill-util/zipball/67925d1cf0b84bd234a83bebf26d4eb281744c6d",
+                "reference": "67925d1cf0b84bd234a83bebf26d4eb281744c6d",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.3.3"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "1.5-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Symfony\\Polyfill\\Util\\": ""
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Nicolas Grekas",
+                    "email": "p@tchwork.com"
+                },
+                {
+                    "name": "Symfony Community",
+                    "homepage": "https://symfony.com/contributors"
+                }
+            ],
+            "description": "Symfony utilities for portability of PHP codes",
+            "homepage": "https://symfony.com",
+            "keywords": [
+                "compat",
+                "compatibility",
+                "polyfill",
+                "shim"
+            ],
+            "time": "2017-07-05 15:09:33"
         },
         {
             "name": "symfony/process",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/process.git",
-                "reference": "57fdaa55827ae14d617550ebe71a820f0a5e2282"
+                "reference": "07432804942b9f6dd7b7377faf9920af5f95d70a"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/process/zipball/57fdaa55827ae14d617550ebe71a820f0a5e2282",
-                "reference": "57fdaa55827ae14d617550ebe71a820f0a5e2282",
+                "url": "https://api.github.com/repos/symfony/process/zipball/07432804942b9f6dd7b7377faf9920af5f95d70a",
+                "reference": "07432804942b9f6dd7b7377faf9920af5f95d70a",
                 "shasum": ""
             },
             "require": {
@@ -1890,7 +2324,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1917,36 +2351,39 @@
             ],
             "description": "Symfony Process Component",
             "homepage": "https://symfony.com",
-            "time": "2017-03-27 18:07:02"
+            "time": "2017-07-13 13:05:09"
         },
         {
             "name": "symfony/routing",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/routing.git",
-                "reference": "d6605f9a5767bc5bc4895e1c762ba93964608aee"
+                "reference": "4aee1a917fd4859ff8b51b9fd1dfb790a5ecfa26"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/routing/zipball/d6605f9a5767bc5bc4895e1c762ba93964608aee",
-                "reference": "d6605f9a5767bc5bc4895e1c762ba93964608aee",
+                "url": "https://api.github.com/repos/symfony/routing/zipball/4aee1a917fd4859ff8b51b9fd1dfb790a5ecfa26",
+                "reference": "4aee1a917fd4859ff8b51b9fd1dfb790a5ecfa26",
                 "shasum": ""
             },
             "require": {
                 "php": ">=5.5.9"
             },
             "conflict": {
-                "symfony/config": "<2.8"
+                "symfony/config": "<2.8",
+                "symfony/dependency-injection": "<3.3",
+                "symfony/yaml": "<3.3"
             },
             "require-dev": {
                 "doctrine/annotations": "~1.0",
                 "doctrine/common": "~2.2",
                 "psr/log": "~1.0",
                 "symfony/config": "~2.8|~3.0",
+                "symfony/dependency-injection": "~3.3",
                 "symfony/expression-language": "~2.8|~3.0",
                 "symfony/http-foundation": "~2.8|~3.0",
-                "symfony/yaml": "~2.8|~3.0"
+                "symfony/yaml": "~3.3"
             },
             "suggest": {
                 "doctrine/annotations": "For using the annotation loader",
@@ -1959,7 +2396,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -1992,20 +2429,20 @@
                 "uri",
                 "url"
             ],
-            "time": "2017-03-02 15:58:09"
+            "time": "2017-07-21 17:43:13"
         },
         {
             "name": "symfony/translation",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/translation.git",
-                "reference": "c740eee70783d2af4d3d6b70d5146f209e6b4d13"
+                "reference": "35dd5fb003c90e8bd4d8cabdf94bf9c96d06fdc3"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/translation/zipball/c740eee70783d2af4d3d6b70d5146f209e6b4d13",
-                "reference": "c740eee70783d2af4d3d6b70d5146f209e6b4d13",
+                "url": "https://api.github.com/repos/symfony/translation/zipball/35dd5fb003c90e8bd4d8cabdf94bf9c96d06fdc3",
+                "reference": "35dd5fb003c90e8bd4d8cabdf94bf9c96d06fdc3",
                 "shasum": ""
             },
             "require": {
@@ -2013,13 +2450,14 @@
                 "symfony/polyfill-mbstring": "~1.0"
             },
             "conflict": {
-                "symfony/config": "<2.8"
+                "symfony/config": "<2.8",
+                "symfony/yaml": "<3.3"
             },
             "require-dev": {
                 "psr/log": "~1.0",
                 "symfony/config": "~2.8|~3.0",
                 "symfony/intl": "^2.8.18|^3.2.5",
-                "symfony/yaml": "~2.8|~3.0"
+                "symfony/yaml": "~3.3"
             },
             "suggest": {
                 "psr/log": "To use logging capability in translator",
@@ -2029,7 +2467,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -2056,20 +2494,20 @@
             ],
             "description": "Symfony Translation Component",
             "homepage": "https://symfony.com",
-            "time": "2017-03-21 21:44:32"
+            "time": "2017-06-24 16:45:30"
         },
         {
             "name": "symfony/var-dumper",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/var-dumper.git",
-                "reference": "81dce20f69a8b40427e1f4e6462178df87cafc03"
+                "reference": "b2623bccb969ad595c2090f9be498b74670d0663"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/var-dumper/zipball/81dce20f69a8b40427e1f4e6462178df87cafc03",
-                "reference": "81dce20f69a8b40427e1f4e6462178df87cafc03",
+                "url": "https://api.github.com/repos/symfony/var-dumper/zipball/b2623bccb969ad595c2090f9be498b74670d0663",
+                "reference": "b2623bccb969ad595c2090f9be498b74670d0663",
                 "shasum": ""
             },
             "require": {
@@ -2080,15 +2518,17 @@
                 "phpunit/phpunit": "<4.8.35|<5.4.3,>=5.0"
             },
             "require-dev": {
-                "twig/twig": "~1.20|~2.0"
+                "ext-iconv": "*",
+                "twig/twig": "~1.34|~2.4"
             },
             "suggest": {
+                "ext-iconv": "To convert non-UTF-8 strings to UTF-8 (or symfony/polyfill-iconv in case ext-iconv cannot be used).",
                 "ext-symfony_debug": ""
             },
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -2122,7 +2562,7 @@
                 "debug",
                 "dump"
             ],
-            "time": "2017-03-12 16:07:05"
+            "time": "2017-07-28 06:06:09"
         },
         {
             "name": "tijsverkoyen/css-to-inline-styles",
@@ -2172,6 +2612,71 @@
             "time": "2016-09-20 12:50:39"
         },
         {
+            "name": "tymon/jwt-auth",
+            "version": "1.0.0-beta.3",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/tymondesigns/jwt-auth.git",
+                "reference": "66a7339ea4946ab75bb6b0d96d3d4477da47631b"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/tymondesigns/jwt-auth/zipball/66a7339ea4946ab75bb6b0d96d3d4477da47631b",
+                "reference": "66a7339ea4946ab75bb6b0d96d3d4477da47631b",
+                "shasum": ""
+            },
+            "require": {
+                "illuminate/auth": "5.1.* || 5.2.* || 5.3.* || 5.4.*",
+                "illuminate/contracts": "5.1.* || 5.2.* || 5.3.* || 5.4.*",
+                "illuminate/http": "5.1.* || 5.2.* || 5.3.* || 5.4.*",
+                "illuminate/support": "5.1.* || 5.2.* || 5.3.* || 5.4.*",
+                "namshi/jose": "^7.0",
+                "nesbot/carbon": "^1.0",
+                "php": "^5.5.9 || ^7.0"
+            },
+            "require-dev": {
+                "cartalyst/sentinel": "2.0.*",
+                "illuminate/console": "5.1.* || 5.2.* || 5.3.* || 5.4.*",
+                "illuminate/database": "5.1.* || 5.2.* || 5.3.* || 5.4.*",
+                "illuminate/routing": "5.1.* || 5.2.* || 5.3.* || 5.4.*",
+                "mockery/mockery": "0.9.*",
+                "phpunit/phpunit": "~4.8 || ~6.0"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-develop": "1.0-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Tymon\\JWTAuth\\": "src/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Sean Tymon",
+                    "email": "tymon148@gmail.com",
+                    "homepage": "http://tymon.xyz",
+                    "role": "Developer"
+                }
+            ],
+            "description": "JSON Web Token Authentication for Laravel and Lumen",
+            "homepage": "https://github.com/tymondesigns/jwt-auth",
+            "keywords": [
+                "Authentication",
+                "JSON Web Token",
+                "auth",
+                "jwt",
+                "laravel"
+            ],
+            "time": "2017-03-25 22:50:20"
+        },
+        {
             "name": "vlucas/phpdotenv",
             "version": "v2.4.0",
             "source": {
@@ -2500,29 +3005,31 @@
         },
         {
             "name": "fzaninotto/faker",
-            "version": "v1.6.0",
+            "version": "v1.7.1",
             "source": {
                 "type": "git",
                 "url": "https://github.com/fzaninotto/Faker.git",
-                "reference": "44f9a286a04b80c76a4e5fb7aad8bb539b920123"
+                "reference": "d3ed4cc37051c1ca52d22d76b437d14809fc7e0d"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/fzaninotto/Faker/zipball/44f9a286a04b80c76a4e5fb7aad8bb539b920123",
-                "reference": "44f9a286a04b80c76a4e5fb7aad8bb539b920123",
+                "url": "https://api.github.com/repos/fzaninotto/Faker/zipball/d3ed4cc37051c1ca52d22d76b437d14809fc7e0d",
+                "reference": "d3ed4cc37051c1ca52d22d76b437d14809fc7e0d",
                 "shasum": ""
             },
             "require": {
-                "php": "^5.3.3|^7.0"
+                "php": "^5.3.3 || ^7.0"
             },
             "require-dev": {
                 "ext-intl": "*",
-                "phpunit/phpunit": "~4.0",
-                "squizlabs/php_codesniffer": "~1.5"
+                "phpunit/phpunit": "^4.0 || ^5.0",
+                "squizlabs/php_codesniffer": "^1.5"
             },
             "type": "library",
             "extra": {
-                "branch-alias": []
+                "branch-alias": {
+                    "dev-master": "1.8-dev"
+                }
             },
             "autoload": {
                 "psr-4": {
@@ -2544,7 +3051,7 @@
                 "faker",
                 "fixtures"
             ],
-            "time": "2016-04-29 12:21:54"
+            "time": "2017-08-15 16:48:10"
         },
         {
             "name": "hamcrest/hamcrest-php",
@@ -2862,22 +3369,22 @@
         },
         {
             "name": "phpdocumentor/reflection-docblock",
-            "version": "3.1.1",
+            "version": "3.2.2",
             "source": {
                 "type": "git",
                 "url": "https://github.com/phpDocumentor/ReflectionDocBlock.git",
-                "reference": "8331b5efe816ae05461b7ca1e721c01b46bafb3e"
+                "reference": "4aada1f93c72c35e22fb1383b47fee43b8f1d157"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/phpDocumentor/ReflectionDocBlock/zipball/8331b5efe816ae05461b7ca1e721c01b46bafb3e",
-                "reference": "8331b5efe816ae05461b7ca1e721c01b46bafb3e",
+                "url": "https://api.github.com/repos/phpDocumentor/ReflectionDocBlock/zipball/4aada1f93c72c35e22fb1383b47fee43b8f1d157",
+                "reference": "4aada1f93c72c35e22fb1383b47fee43b8f1d157",
                 "shasum": ""
             },
             "require": {
                 "php": ">=5.5",
                 "phpdocumentor/reflection-common": "^1.0@dev",
-                "phpdocumentor/type-resolver": "^0.2.0",
+                "phpdocumentor/type-resolver": "^0.3.0",
                 "webmozart/assert": "^1.0"
             },
             "require-dev": {
@@ -2903,24 +3410,24 @@
                 }
             ],
             "description": "With this component, a library can provide support for annotations via DocBlocks or otherwise retrieve information that is embedded in a DocBlock.",
-            "time": "2016-09-30 07:12:33"
+            "time": "2017-08-08 06:39:58"
         },
         {
             "name": "phpdocumentor/type-resolver",
-            "version": "0.2.1",
+            "version": "0.3.0",
             "source": {
                 "type": "git",
                 "url": "https://github.com/phpDocumentor/TypeResolver.git",
-                "reference": "e224fb2ea2fba6d3ad6fdaef91cd09a172155ccb"
+                "reference": "fb3933512008d8162b3cdf9e18dba9309b7c3773"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/phpDocumentor/TypeResolver/zipball/e224fb2ea2fba6d3ad6fdaef91cd09a172155ccb",
-                "reference": "e224fb2ea2fba6d3ad6fdaef91cd09a172155ccb",
+                "url": "https://api.github.com/repos/phpDocumentor/TypeResolver/zipball/fb3933512008d8162b3cdf9e18dba9309b7c3773",
+                "reference": "fb3933512008d8162b3cdf9e18dba9309b7c3773",
                 "shasum": ""
             },
             "require": {
-                "php": ">=5.5",
+                "php": "^5.5 || ^7.0",
                 "phpdocumentor/reflection-common": "^1.0"
             },
             "require-dev": {
@@ -2950,7 +3457,7 @@
                     "email": "me@mikevanriel.com"
                 }
             ],
-            "time": "2016-11-25 06:54:22"
+            "time": "2017-06-03 08:32:36"
         },
         {
             "name": "phpspec/prophecy",
@@ -3266,16 +3773,16 @@
         },
         {
             "name": "phpunit/phpunit",
-            "version": "5.7.19",
+            "version": "5.7.21",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/phpunit.git",
-                "reference": "69c4f49ff376af2692bad9cebd883d17ebaa98a1"
+                "reference": "3b91adfb64264ddec5a2dee9851f354aa66327db"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/phpunit/zipball/69c4f49ff376af2692bad9cebd883d17ebaa98a1",
-                "reference": "69c4f49ff376af2692bad9cebd883d17ebaa98a1",
+                "url": "https://api.github.com/repos/sebastianbergmann/phpunit/zipball/3b91adfb64264ddec5a2dee9851f354aa66327db",
+                "reference": "3b91adfb64264ddec5a2dee9851f354aa66327db",
                 "shasum": ""
             },
             "require": {
@@ -3293,7 +3800,7 @@
                 "phpunit/php-timer": "^1.0.6",
                 "phpunit/phpunit-mock-objects": "^3.2",
                 "sebastian/comparator": "^1.2.4",
-                "sebastian/diff": "~1.2",
+                "sebastian/diff": "^1.4.3",
                 "sebastian/environment": "^1.3.4 || ^2.0",
                 "sebastian/exporter": "~2.0",
                 "sebastian/global-state": "^1.1",
@@ -3344,20 +3851,20 @@
                 "testing",
                 "xunit"
             ],
-            "time": "2017-04-03 02:22:27"
+            "time": "2017-06-21 08:11:54"
         },
         {
             "name": "phpunit/phpunit-mock-objects",
-            "version": "3.4.3",
+            "version": "3.4.4",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/phpunit-mock-objects.git",
-                "reference": "3ab72b65b39b491e0c011e2e09bb2206c2aa8e24"
+                "reference": "a23b761686d50a560cc56233b9ecf49597cc9118"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/phpunit-mock-objects/zipball/3ab72b65b39b491e0c011e2e09bb2206c2aa8e24",
-                "reference": "3ab72b65b39b491e0c011e2e09bb2206c2aa8e24",
+                "url": "https://api.github.com/repos/sebastianbergmann/phpunit-mock-objects/zipball/a23b761686d50a560cc56233b9ecf49597cc9118",
+                "reference": "a23b761686d50a560cc56233b9ecf49597cc9118",
                 "shasum": ""
             },
             "require": {
@@ -3403,7 +3910,7 @@
                 "mock",
                 "xunit"
             ],
-            "time": "2016-12-08 20:27:08"
+            "time": "2017-06-30 09:13:00"
         },
         {
             "name": "sebastian/code-unit-reverse-lookup",
@@ -3516,23 +4023,23 @@
         },
         {
             "name": "sebastian/diff",
-            "version": "1.4.1",
+            "version": "1.4.3",
             "source": {
                 "type": "git",
                 "url": "https://github.com/sebastianbergmann/diff.git",
-                "reference": "13edfd8706462032c2f52b4b862974dd46b71c9e"
+                "reference": "7f066a26a962dbe58ddea9f72a4e82874a3975a4"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/sebastianbergmann/diff/zipball/13edfd8706462032c2f52b4b862974dd46b71c9e",
-                "reference": "13edfd8706462032c2f52b4b862974dd46b71c9e",
+                "url": "https://api.github.com/repos/sebastianbergmann/diff/zipball/7f066a26a962dbe58ddea9f72a4e82874a3975a4",
+                "reference": "7f066a26a962dbe58ddea9f72a4e82874a3975a4",
                 "shasum": ""
             },
             "require": {
-                "php": ">=5.3.3"
+                "php": "^5.3.3 || ^7.0"
             },
             "require-dev": {
-                "phpunit/phpunit": "~4.8"
+                "phpunit/phpunit": "^4.8.35 || ^5.7 || ^6.0"
             },
             "type": "library",
             "extra": {
@@ -3564,7 +4071,7 @@
             "keywords": [
                 "diff"
             ],
-            "time": "2015-12-08 07:14:41"
+            "time": "2017-05-22 07:24:03"
         },
         {
             "name": "sebastian/environment",
@@ -3920,16 +4427,16 @@
         },
         {
             "name": "symfony/class-loader",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/class-loader.git",
-                "reference": "c29a5bc6ca14cfff1f5e3d7781ed74b6e898d2b9"
+                "reference": "386a294d621576302e7cc36965d6ed53b8c73c4f"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/class-loader/zipball/c29a5bc6ca14cfff1f5e3d7781ed74b6e898d2b9",
-                "reference": "c29a5bc6ca14cfff1f5e3d7781ed74b6e898d2b9",
+                "url": "https://api.github.com/repos/symfony/class-loader/zipball/386a294d621576302e7cc36965d6ed53b8c73c4f",
+                "reference": "386a294d621576302e7cc36965d6ed53b8c73c4f",
                 "shasum": ""
             },
             "require": {
@@ -3945,7 +4452,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -3972,20 +4479,20 @@
             ],
             "description": "Symfony ClassLoader Component",
             "homepage": "https://symfony.com",
-            "time": "2017-02-18 17:28:00"
+            "time": "2017-06-02 09:51:43"
         },
         {
             "name": "symfony/dom-crawler",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/dom-crawler.git",
-                "reference": "403944e294cf4ceb3b8447f54cbad88ea7b99cee"
+                "reference": "fc2c588ce376e9fe04a7b8c79e3ec62fe32d95b1"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/dom-crawler/zipball/403944e294cf4ceb3b8447f54cbad88ea7b99cee",
-                "reference": "403944e294cf4ceb3b8447f54cbad88ea7b99cee",
+                "url": "https://api.github.com/repos/symfony/dom-crawler/zipball/fc2c588ce376e9fe04a7b8c79e3ec62fe32d95b1",
+                "reference": "fc2c588ce376e9fe04a7b8c79e3ec62fe32d95b1",
                 "shasum": ""
             },
             "require": {
@@ -4001,7 +4508,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -4028,20 +4535,20 @@
             ],
             "description": "Symfony DomCrawler Component",
             "homepage": "https://symfony.com",
-            "time": "2017-02-21 09:12:04"
+            "time": "2017-05-25 23:10:31"
         },
         {
             "name": "symfony/yaml",
-            "version": "v3.2.7",
+            "version": "v3.3.6",
             "source": {
                 "type": "git",
                 "url": "https://github.com/symfony/yaml.git",
-                "reference": "62b4cdb99d52cb1ff253c465eb1532a80cebb621"
+                "reference": "ddc23324e6cfe066f3dd34a37ff494fa80b617ed"
             },
             "dist": {
                 "type": "zip",
-                "url": "https://api.github.com/repos/symfony/yaml/zipball/62b4cdb99d52cb1ff253c465eb1532a80cebb621",
-                "reference": "62b4cdb99d52cb1ff253c465eb1532a80cebb621",
+                "url": "https://api.github.com/repos/symfony/yaml/zipball/ddc23324e6cfe066f3dd34a37ff494fa80b617ed",
+                "reference": "ddc23324e6cfe066f3dd34a37ff494fa80b617ed",
                 "shasum": ""
             },
             "require": {
@@ -4056,7 +4563,7 @@
             "type": "library",
             "extra": {
                 "branch-alias": {
-                    "dev-master": "3.2-dev"
+                    "dev-master": "3.3-dev"
                 }
             },
             "autoload": {
@@ -4083,7 +4590,7 @@
             ],
             "description": "Symfony Yaml Component",
             "homepage": "https://symfony.com",
-            "time": "2017-03-20 09:45:15"
+            "time": "2017-07-23 12:43:26"
         },
         {
             "name": "webmozart/assert",
diff --git a/config/app.php b/config/app.php
index 651b502..b8b1e5c 100644
--- a/config/app.php
+++ b/config/app.php
@@ -23,7 +23,7 @@ return [
     | Vanguard Version
     |--------------------------------------------------------------------------
     */
-    'version' => '1.3.3',
+    'version' => '2.0.0',
 
     /*
     |--------------------------------------------------------------------------
@@ -183,10 +183,12 @@ return [
         Webpatser\Countries\CountriesServiceProvider::class,
         Intervention\Image\ImageServiceProvider::class,
         anlutro\LaravelSettings\ServiceProvider::class,
+        Jenssegers\Agent\AgentServiceProvider::class,
 
         /*
          * Application Service Providers...
          */
+        Vanguard\Services\Auth\Api\JWTServiceProvider::class,
         Vanguard\Providers\AppServiceProvider::class,
         Vanguard\Providers\AuthServiceProvider::class,
         // App\Providers\BroadcastServiceProvider::class,
@@ -252,7 +254,8 @@ return [
         'Image' => Intervention\Image\Facades\Image::class,
         'Settings' => anlutro\LaravelSettings\Facade::class,
         'Authy' => Vanguard\Services\Auth\TwoFactor\Facade::class,
-
+        'JWTAuth' => Tymon\JWTAuth\Facades\JWTAuth::class,
+        'Agent' => Jenssegers\Agent\Facades\Agent::class,
 
     ],
 
diff --git a/config/auth.php b/config/auth.php
index e48dc0a..3ad00a2 100644
--- a/config/auth.php
+++ b/config/auth.php
@@ -2,10 +2,32 @@
 
 return [
 
+    /*
+    |--------------------------------------------------------------------------
+    | Social Authentication Providers
+    |--------------------------------------------------------------------------
+    |
+    | This option controls the list of enabled social authentication providers.
+    |
+    */
+
     'social' => [
         'providers' => ['facebook', 'twitter', 'google']
     ],
 
+   /*
+   |--------------------------------------------------------------------------
+   | JSON API
+   |--------------------------------------------------------------------------
+   |
+   | Should our JSON api be exposed to the public? If you want to enable the
+   | API, just set the following option to "true":
+   |
+   | Default: false
+   */
+
+    'expose_api' => env('EXPOSE_API', false),
+
     /*
     |--------------------------------------------------------------------------
     | Authentication Defaults
@@ -46,7 +68,7 @@ return [
         ],
 
         'api' => [
-            'driver' => 'token',
+            'driver' => 'jwt',
             'provider' => 'users',
         ],
     ],
diff --git a/config/jwt.php b/config/jwt.php
new file mode 100644
index 0000000..d108260
--- /dev/null
+++ b/config/jwt.php
@@ -0,0 +1,262 @@
+<?php
+
+/*
+ * This file is part of jwt-auth.
+ *
+ * (c) Sean Tymon <tymon148@gmail.com>
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+return [
+
+    /*
+    |--------------------------------------------------------------------------
+    | JWT Authentication Secret
+    |--------------------------------------------------------------------------
+    |
+    | Don't forget to set this in your .env file, as it will be used to sign
+    | your tokens. A helper command is provided for this:
+    | `php artisan jwt:secret`
+    |
+    | Note: This will be used for Symmetric algorithms only (HMAC),
+    | since RSA and ECDSA use a private/public key combo (See below).
+    |
+    */
+
+    'secret' => env('JWT_SECRET'),
+
+    /*
+    |--------------------------------------------------------------------------
+    | Tokens Sweeping Lottery
+    |--------------------------------------------------------------------------
+    |
+    | Expired api tokens (used as "jti" claim inside JWT tokens) must be
+    | manually removed from storage. Here are the chances that it will
+    | happen whenever new token is generated. By default, the odds are 5 out of 100.
+    |
+    */
+
+    'lottery' => [5, 100],
+
+    /*
+    |--------------------------------------------------------------------------
+    | JWT Authentication Keys
+    |--------------------------------------------------------------------------
+    |
+    | The algorithm you are using, will determine whether your tokens are
+    | signed with a random string (defined in `JWT_SECRET`) or using the
+    | following public & private keys.
+    |
+    | Symmetric Algorithms:
+    | HS256, HS384 & HS512 will use `JWT_SECRET`.
+    |
+    | Asymmetric Algorithms:
+    | RS256, RS384 & RS512 / ES256, ES384 & ES512 will use the keys below.
+    |
+    */
+
+    'keys' => [
+
+        /*
+        |--------------------------------------------------------------------------
+        | Public Key
+        |--------------------------------------------------------------------------
+        |
+        | A path or resource to your public key.
+        |
+        | E.g. 'file://path/to/public/key'
+        |
+        */
+
+        'public' => env('JWT_PUBLIC_KEY'),
+
+        /*
+        |--------------------------------------------------------------------------
+        | Private Key
+        |--------------------------------------------------------------------------
+        |
+        | A path or resource to your private key.
+        |
+        | E.g. 'file://path/to/private/key'
+        |
+        */
+
+        'private' => env('JWT_PRIVATE_KEY'),
+
+        /*
+        |--------------------------------------------------------------------------
+        | Passphrase
+        |--------------------------------------------------------------------------
+        |
+        | The passphrase for your private key. Can be null if none set.
+        |
+        */
+
+        'passphrase' => env('JWT_PASSPHRASE'),
+
+    ],
+
+    /*
+    |--------------------------------------------------------------------------
+    | JWT time to live
+    |--------------------------------------------------------------------------
+    |
+    | Specify the length of time (in minutes) that the token will be valid for.
+    | Defaults to 1 hour.
+    |
+    | You can also set this to null, to yield a never expiring token.
+    | Some people may want this behaviour for e.g. a mobile app.
+    | This is not particularly recommended, so make sure you have appropriate
+    | systems in place to revoke the token if necessary.
+    |
+    */
+
+    'ttl' => env('JWT_TTL', 60),
+
+    /*
+    |--------------------------------------------------------------------------
+    | Refresh time to live
+    |--------------------------------------------------------------------------
+    |
+    | Specify the length of time (in minutes) that the token can be refreshed
+    | within. I.E. The user can refresh their token within a 2 week window of
+    | the original token being created until they must re-authenticate.
+    | Defaults to 2 weeks.
+    |
+    | You can also set this to null, to yield an infinite refresh time.
+    | Some may want this instead of never expiring tokens for e.g. a mobile app.
+    | This is not particularly recommended, so make sure you have appropriate
+    | systems in place to revoke the token if necessary.
+    |
+    */
+
+    'refresh_ttl' => env('JWT_REFRESH_TTL', 20160),
+
+    /*
+    |--------------------------------------------------------------------------
+    | JWT hashing algorithm
+    |--------------------------------------------------------------------------
+    |
+    | Specify the hashing algorithm that will be used to sign the token.
+    |
+    | See here: https://github.com/namshi/jose/tree/master/src/Namshi/JOSE/Signer/OpenSSL
+    | for possible values.
+    |
+    */
+
+    'algo' => env('JWT_ALGO', 'HS256'),
+
+    /*
+    |--------------------------------------------------------------------------
+    | Required Claims
+    |--------------------------------------------------------------------------
+    |
+    | Specify the required claims that must exist in any token.
+    | A TokenInvalidException will be thrown if any of these claims are not
+    | present in the payload.
+    |
+    */
+
+    'required_claims' => [
+        'iss',
+        'iat',
+        'exp',
+        'nbf',
+        'sub',
+        'jti',
+    ],
+
+    /*
+    |--------------------------------------------------------------------------
+    | Persistent Claims
+    |--------------------------------------------------------------------------
+    |
+    | Specify the claim keys to be persisted when refreshing a token.
+    | `sub` and `iat` will automatically be persisted, in
+    | addition to the these claims.
+    |
+    | Note: If a claim does not exist then it will be ignored.
+    |
+    */
+
+    'persistent_claims' => [
+        // 'foo',
+        // 'bar',
+    ],
+
+    /*
+    |--------------------------------------------------------------------------
+    | Blacklist Enabled
+    |--------------------------------------------------------------------------
+    |
+    | In order to invalidate tokens, you must have the blacklist enabled.
+    | If you do not want or need this functionality, then set this to false.
+    |
+    */
+
+    'blacklist_enabled' => env('JWT_BLACKLIST_ENABLED', true),
+
+    /*
+    | -------------------------------------------------------------------------
+    | Blacklist Grace Period
+    | -------------------------------------------------------------------------
+    |
+    | When multiple concurrent requests are made with the same JWT,
+    | it is possible that some of them fail, due to token regeneration
+    | on every request.
+    |
+    | Set grace period in seconds to prevent parallel request failure.
+    |
+    */
+
+    'blacklist_grace_period' => env('JWT_BLACKLIST_GRACE_PERIOD', 0),
+
+    /*
+    |--------------------------------------------------------------------------
+    | Providers
+    |--------------------------------------------------------------------------
+    |
+    | Specify the various providers used throughout the package.
+    |
+    */
+
+    'providers' => [
+
+        /*
+        |--------------------------------------------------------------------------
+        | JWT Provider
+        |--------------------------------------------------------------------------
+        |
+        | Specify the provider that is used to create and decode the tokens.
+        |
+        */
+
+        'jwt' => Tymon\JWTAuth\Providers\JWT\Namshi::class,
+
+        /*
+        |--------------------------------------------------------------------------
+        | Authentication Provider
+        |--------------------------------------------------------------------------
+        |
+        | Specify the provider that is used to authenticate users.
+        |
+        */
+
+        'auth' => Tymon\JWTAuth\Providers\Auth\Illuminate::class,
+
+        /*
+        |--------------------------------------------------------------------------
+        | Storage Provider
+        |--------------------------------------------------------------------------
+        |
+        | Specify the provider that is used to store tokens in the blacklist.
+        |
+        */
+
+        'storage' => Tymon\JWTAuth\Providers\Storage\Illuminate::class,
+
+    ],
+
+];
diff --git a/database/factories/ModelFactory.php b/database/factories/ModelFactory.php
index 53b8aca..cb6c8aa 100644
--- a/database/factories/ModelFactory.php
+++ b/database/factories/ModelFactory.php
@@ -82,3 +82,17 @@ $factory->define(Country::class, function (Faker\Generator $faker) {
         'sub_region_code' => 123
     ];
 });
+
+$factory->define(\Vanguard\Services\Auth\Api\Token::class, function (Faker\Generator $faker, array $attrs) {
+    $userId = isset($attrs['user_id'])
+        ? $attrs['user_id']
+        : factory(\Vanguard\User::class)->create()->id;
+
+    return [
+        'id' => str_random(40),
+        'user_id' => $userId,
+        'ip_address' => $faker->ipv4,
+        'user_agent' => substr($faker->userAgent, 0, 500),
+        'expires_at' => \Carbon\Carbon::now()->addMinutes(60)
+    ];
+});
diff --git a/database/migrations/2015_10_10_170827_create_users_table.php b/database/migrations/2015_10_10_170827_create_users_table.php
index a891803..b41dcc5 100644
--- a/database/migrations/2015_10_10_170827_create_users_table.php
+++ b/database/migrations/2015_10_10_170827_create_users_table.php
@@ -15,7 +15,7 @@ class CreateUsersTable extends Migration
         Schema::create('users', function (Blueprint $table) {
             $table->increments('id');
             $table->string('email')->unique();
-            $table->string('username')->nullable();
+            $table->string('username')->nullable()->index();
             $table->string('password');
             $table->string('first_name')->nullable();
             $table->string('last_name')->nullable();
@@ -27,7 +27,7 @@ class CreateUsersTable extends Migration
             $table->date('birthday')->nullable();
             $table->timestamp('last_login')->nullable();
             $table->string('confirmation_token', 60)->nullable();
-            $table->string('status', 20);
+            $table->string('status', 20)->index();
             $table->integer('two_factor_country_code')->nullable();
             $table->integer('two_factor_phone')->nullable();
             $table->text('two_factor_options')->nullable();
diff --git a/database/migrations/2015_10_10_170911_create_user_social_networks_table.php b/database/migrations/2015_10_10_170911_create_user_social_networks_table.php
deleted file mode 100644
index 275160a..0000000
--- a/database/migrations/2015_10_10_170911_create_user_social_networks_table.php
+++ /dev/null
@@ -1,36 +0,0 @@
-<?php
-
-use Illuminate\Database\Schema\Blueprint;
-use Illuminate\Database\Migrations\Migration;
-
-class CreateUserSocialNetworksTable extends Migration
-{
-    /**
-     * Run the migrations.
-     *
-     * @return void
-     */
-    public function up()
-    {
-        Schema::create('user_social_networks', function (Blueprint $table) {
-            $table->increments('id');
-            $table->unsignedInteger('user_id');
-            $table->string('facebook')->nullable();
-            $table->string('twitter')->nullable();
-            $table->string('google_plus')->nullable();
-            $table->string('linked_in')->nullable();
-            $table->string('dribbble')->nullable();
-            $table->string('skype')->nullable();
-        });
-    }
-
-    /**
-     * Reverse the migrations.
-     *
-     * @return void
-     */
-    public function down()
-    {
-        Schema::drop('user_social_networks');
-    }
-}
diff --git a/database/migrations/2015_12_30_171734_add_foreign_keys.php b/database/migrations/2015_12_30_171734_add_foreign_keys.php
index f537c2d..e1633eb 100644
--- a/database/migrations/2015_12_30_171734_add_foreign_keys.php
+++ b/database/migrations/2015_12_30_171734_add_foreign_keys.php
@@ -29,13 +29,6 @@ class AddForeignKeys extends Migration
                 ->on('users')
                 ->onDelete('cascade');
         });
-
-        Schema::table('user_social_networks', function (Blueprint $table) {
-            $table->foreign('user_id')
-                ->references('id')
-                ->on('users')
-                ->onDelete('cascade');
-        });
     }
 
     /**
@@ -53,9 +46,5 @@ class AddForeignKeys extends Migration
         Schema::table('social_logins', function (Blueprint $table) {
             $table->dropForeign('social_logins_user_id_foreign');
         });
-
-        Schema::table('user_social_networks', function (Blueprint $table) {
-            $table->dropForeign('user_social_networks_user_id_foreign');
-        });
     }
 }
diff --git a/database/migrations/2017_04_13_200254_create_api_tokens_table.php b/database/migrations/2017_04_13_200254_create_api_tokens_table.php
new file mode 100644
index 0000000..4529f98
--- /dev/null
+++ b/database/migrations/2017_04_13_200254_create_api_tokens_table.php
@@ -0,0 +1,49 @@
+<?php
+
+use Illuminate\Support\Facades\Schema;
+use Illuminate\Database\Schema\Blueprint;
+use Illuminate\Database\Migrations\Migration;
+
+class CreateApiTokensTable extends Migration
+{
+    /**
+     * Run the migrations.
+     *
+     * @return void
+     */
+    public function up()
+    {
+        Schema::create('api_tokens', function (Blueprint $table) {
+            $table->string('id', 40);
+            $table->unsignedInteger('user_id');
+            $table->string('ip_address', 45)->nullable();
+            $table->text('user_agent')->nullable();
+            $table->timestamps();
+            $table->timestamp('expires_at')->nullable();
+
+            $table->primary('id');
+            $table->index(['id', 'expires_at']);
+        });
+
+        Schema::table('api_tokens', function (Blueprint $table) {
+            $table->foreign('user_id')
+                ->references('id')
+                ->on('users')
+                ->onDelete('cascade');
+        });
+    }
+
+    /**
+     * Reverse the migrations.
+     *
+     * @return void
+     */
+    public function down()
+    {
+        Schema::table('api_tokens', function (Blueprint $table) {
+            $table->dropForeign('api_tokens_user_id_foreign');
+        });
+
+        Schema::dropIfExists('api_tokens');
+    }
+}
diff --git a/database/seeds/CountriesSeeder.php b/database/seeds/CountriesSeeder.php
index 946a5a8..021f57a 100644
--- a/database/seeds/CountriesSeeder.php
+++ b/database/seeds/CountriesSeeder.php
@@ -2,8 +2,8 @@
 
 use Illuminate\Database\Seeder;
 
-class CountriesSeeder extends Seeder {
-
+class CountriesSeeder extends Seeder
+{
     /**
      * Run the database seeds.
      *
@@ -13,7 +13,7 @@ class CountriesSeeder extends Seeder {
     {
         //Get all of the countries
         $countries = Countries::getList();
-        foreach ($countries as $countryId => $country){
+        foreach ($countries as $countryId => $country) {
             DB::table('countries')->insert(array(
                 'id' => $countryId,
                 'capital' => ((isset($country['capital'])) ? $country['capital'] : null),
diff --git a/public/.htaccess b/public/.htaccess
index 5716f17..2e0b3d9 100644
--- a/public/.htaccess
+++ b/public/.htaccess
@@ -13,4 +13,8 @@
     RewriteCond %{REQUEST_FILENAME} !-d
     RewriteCond %{REQUEST_FILENAME} !-f
     RewriteRule ^ index.php [L]
+
+    # Handle Authorization Header
+    RewriteCond %{HTTP:Authorization} .
+    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
 </IfModule>
diff --git a/public/flags/AD.png b/public/flags/AD.png
new file mode 100644
index 0000000..517ce6a
Binary files /dev/null and b/public/flags/AD.png differ
diff --git a/public/flags/AE.png b/public/flags/AE.png
new file mode 100644
index 0000000..b1c0e0a
Binary files /dev/null and b/public/flags/AE.png differ
diff --git a/public/flags/AF.png b/public/flags/AF.png
new file mode 100644
index 0000000..4f7ff20
Binary files /dev/null and b/public/flags/AF.png differ
diff --git a/public/flags/AG.png b/public/flags/AG.png
new file mode 100644
index 0000000..62ecde0
Binary files /dev/null and b/public/flags/AG.png differ
diff --git a/public/flags/AI.png b/public/flags/AI.png
new file mode 100644
index 0000000..ef6e91f
Binary files /dev/null and b/public/flags/AI.png differ
diff --git a/public/flags/AL.png b/public/flags/AL.png
new file mode 100644
index 0000000..dcc3a1d
Binary files /dev/null and b/public/flags/AL.png differ
diff --git a/public/flags/AM.png b/public/flags/AM.png
new file mode 100644
index 0000000..ff49f2e
Binary files /dev/null and b/public/flags/AM.png differ
diff --git a/public/flags/AN.png b/public/flags/AN.png
new file mode 100644
index 0000000..97a4c5e
Binary files /dev/null and b/public/flags/AN.png differ
diff --git a/public/flags/AO.png b/public/flags/AO.png
new file mode 100644
index 0000000..a7a3d04
Binary files /dev/null and b/public/flags/AO.png differ
diff --git a/public/flags/AQ.png b/public/flags/AQ.png
new file mode 100644
index 0000000..7a20159
Binary files /dev/null and b/public/flags/AQ.png differ
diff --git a/public/flags/AR.png b/public/flags/AR.png
new file mode 100644
index 0000000..9cdfa00
Binary files /dev/null and b/public/flags/AR.png differ
diff --git a/public/flags/AS.png b/public/flags/AS.png
new file mode 100644
index 0000000..86c6cc6
Binary files /dev/null and b/public/flags/AS.png differ
diff --git a/public/flags/AT.png b/public/flags/AT.png
new file mode 100644
index 0000000..dd62910
Binary files /dev/null and b/public/flags/AT.png differ
diff --git a/public/flags/AU.png b/public/flags/AU.png
new file mode 100644
index 0000000..a4b8c2e
Binary files /dev/null and b/public/flags/AU.png differ
diff --git a/public/flags/AW.png b/public/flags/AW.png
new file mode 100644
index 0000000..d8300dd
Binary files /dev/null and b/public/flags/AW.png differ
diff --git a/public/flags/AZ.png b/public/flags/AZ.png
new file mode 100644
index 0000000..06e7fca
Binary files /dev/null and b/public/flags/AZ.png differ
diff --git a/public/flags/BA.png b/public/flags/BA.png
new file mode 100644
index 0000000..0ffc1ab
Binary files /dev/null and b/public/flags/BA.png differ
diff --git a/public/flags/BB.png b/public/flags/BB.png
new file mode 100644
index 0000000..7da5265
Binary files /dev/null and b/public/flags/BB.png differ
diff --git a/public/flags/BD.png b/public/flags/BD.png
new file mode 100644
index 0000000..6b7a0f6
Binary files /dev/null and b/public/flags/BD.png differ
diff --git a/public/flags/BE.png b/public/flags/BE.png
new file mode 100644
index 0000000..50602d1
Binary files /dev/null and b/public/flags/BE.png differ
diff --git a/public/flags/BF.png b/public/flags/BF.png
new file mode 100644
index 0000000..40cb714
Binary files /dev/null and b/public/flags/BF.png differ
diff --git a/public/flags/BG.png b/public/flags/BG.png
new file mode 100644
index 0000000..bd6ceb5
Binary files /dev/null and b/public/flags/BG.png differ
diff --git a/public/flags/BH.png b/public/flags/BH.png
new file mode 100644
index 0000000..f1e5997
Binary files /dev/null and b/public/flags/BH.png differ
diff --git a/public/flags/BI.png b/public/flags/BI.png
new file mode 100644
index 0000000..ec4ddab
Binary files /dev/null and b/public/flags/BI.png differ
diff --git a/public/flags/BJ.png b/public/flags/BJ.png
new file mode 100644
index 0000000..af3491e
Binary files /dev/null and b/public/flags/BJ.png differ
diff --git a/public/flags/BM.png b/public/flags/BM.png
new file mode 100644
index 0000000..ac35f5f
Binary files /dev/null and b/public/flags/BM.png differ
diff --git a/public/flags/BN.png b/public/flags/BN.png
new file mode 100644
index 0000000..3df8469
Binary files /dev/null and b/public/flags/BN.png differ
diff --git a/public/flags/BO.png b/public/flags/BO.png
new file mode 100644
index 0000000..1a55b4e
Binary files /dev/null and b/public/flags/BO.png differ
diff --git a/public/flags/BR.png b/public/flags/BR.png
new file mode 100644
index 0000000..c93b9f3
Binary files /dev/null and b/public/flags/BR.png differ
diff --git a/public/flags/BS.png b/public/flags/BS.png
new file mode 100644
index 0000000..6853973
Binary files /dev/null and b/public/flags/BS.png differ
diff --git a/public/flags/BT.png b/public/flags/BT.png
new file mode 100644
index 0000000..78a1796
Binary files /dev/null and b/public/flags/BT.png differ
diff --git a/public/flags/BV.png b/public/flags/BV.png
new file mode 100644
index 0000000..1bd1d74
Binary files /dev/null and b/public/flags/BV.png differ
diff --git a/public/flags/BW.png b/public/flags/BW.png
new file mode 100644
index 0000000..2c8fd04
Binary files /dev/null and b/public/flags/BW.png differ
diff --git a/public/flags/BY.png b/public/flags/BY.png
new file mode 100644
index 0000000..de801cd
Binary files /dev/null and b/public/flags/BY.png differ
diff --git a/public/flags/BZ.png b/public/flags/BZ.png
new file mode 100644
index 0000000..7a6d7fa
Binary files /dev/null and b/public/flags/BZ.png differ
diff --git a/public/flags/CA.png b/public/flags/CA.png
new file mode 100644
index 0000000..5681053
Binary files /dev/null and b/public/flags/CA.png differ
diff --git a/public/flags/CC.png b/public/flags/CC.png
new file mode 100644
index 0000000..89fd31f
Binary files /dev/null and b/public/flags/CC.png differ
diff --git a/public/flags/CD.png b/public/flags/CD.png
new file mode 100644
index 0000000..a7d6b0e
Binary files /dev/null and b/public/flags/CD.png differ
diff --git a/public/flags/CF.png b/public/flags/CF.png
new file mode 100644
index 0000000..d828681
Binary files /dev/null and b/public/flags/CF.png differ
diff --git a/public/flags/CG.png b/public/flags/CG.png
new file mode 100644
index 0000000..128eb14
Binary files /dev/null and b/public/flags/CG.png differ
diff --git a/public/flags/CH.png b/public/flags/CH.png
new file mode 100644
index 0000000..5a1aaa9
Binary files /dev/null and b/public/flags/CH.png differ
diff --git a/public/flags/CI.png b/public/flags/CI.png
new file mode 100644
index 0000000..6ae65c1
Binary files /dev/null and b/public/flags/CI.png differ
diff --git a/public/flags/CK.png b/public/flags/CK.png
new file mode 100644
index 0000000..ef6f10a
Binary files /dev/null and b/public/flags/CK.png differ
diff --git a/public/flags/CL.png b/public/flags/CL.png
new file mode 100644
index 0000000..6f8ca05
Binary files /dev/null and b/public/flags/CL.png differ
diff --git a/public/flags/CM.png b/public/flags/CM.png
new file mode 100644
index 0000000..245ef28
Binary files /dev/null and b/public/flags/CM.png differ
diff --git a/public/flags/CN.png b/public/flags/CN.png
new file mode 100644
index 0000000..089557e
Binary files /dev/null and b/public/flags/CN.png differ
diff --git a/public/flags/CO.png b/public/flags/CO.png
new file mode 100644
index 0000000..2519649
Binary files /dev/null and b/public/flags/CO.png differ
diff --git a/public/flags/CR.png b/public/flags/CR.png
new file mode 100644
index 0000000..1f1153d
Binary files /dev/null and b/public/flags/CR.png differ
diff --git a/public/flags/CS.png b/public/flags/CS.png
new file mode 100644
index 0000000..64bf51c
Binary files /dev/null and b/public/flags/CS.png differ
diff --git a/public/flags/CU.png b/public/flags/CU.png
new file mode 100644
index 0000000..6fbabe5
Binary files /dev/null and b/public/flags/CU.png differ
diff --git a/public/flags/CV.png b/public/flags/CV.png
new file mode 100644
index 0000000..42bb789
Binary files /dev/null and b/public/flags/CV.png differ
diff --git a/public/flags/CX.png b/public/flags/CX.png
new file mode 100644
index 0000000..219a6af
Binary files /dev/null and b/public/flags/CX.png differ
diff --git a/public/flags/CY.png b/public/flags/CY.png
new file mode 100644
index 0000000..b766fa7
Binary files /dev/null and b/public/flags/CY.png differ
diff --git a/public/flags/CZ.png b/public/flags/CZ.png
new file mode 100644
index 0000000..652842c
Binary files /dev/null and b/public/flags/CZ.png differ
diff --git a/public/flags/DE.png b/public/flags/DE.png
new file mode 100644
index 0000000..696228e
Binary files /dev/null and b/public/flags/DE.png differ
diff --git a/public/flags/DJ.png b/public/flags/DJ.png
new file mode 100644
index 0000000..3ee951f
Binary files /dev/null and b/public/flags/DJ.png differ
diff --git a/public/flags/DK.png b/public/flags/DK.png
new file mode 100644
index 0000000..fa0d873
Binary files /dev/null and b/public/flags/DK.png differ
diff --git a/public/flags/DM.png b/public/flags/DM.png
new file mode 100644
index 0000000..529e3c1
Binary files /dev/null and b/public/flags/DM.png differ
diff --git a/public/flags/DO.png b/public/flags/DO.png
new file mode 100644
index 0000000..5213c90
Binary files /dev/null and b/public/flags/DO.png differ
diff --git a/public/flags/DZ.png b/public/flags/DZ.png
new file mode 100644
index 0000000..763af1c
Binary files /dev/null and b/public/flags/DZ.png differ
diff --git a/public/flags/EC.png b/public/flags/EC.png
new file mode 100644
index 0000000..0c2fbcb
Binary files /dev/null and b/public/flags/EC.png differ
diff --git a/public/flags/EE.png b/public/flags/EE.png
new file mode 100644
index 0000000..de76f4f
Binary files /dev/null and b/public/flags/EE.png differ
diff --git a/public/flags/EG.png b/public/flags/EG.png
new file mode 100644
index 0000000..ba14172
Binary files /dev/null and b/public/flags/EG.png differ
diff --git a/public/flags/EH.png b/public/flags/EH.png
new file mode 100644
index 0000000..a165a31
Binary files /dev/null and b/public/flags/EH.png differ
diff --git a/public/flags/ER.png b/public/flags/ER.png
new file mode 100644
index 0000000..007c8a7
Binary files /dev/null and b/public/flags/ER.png differ
diff --git a/public/flags/ES.png b/public/flags/ES.png
new file mode 100644
index 0000000..09436b0
Binary files /dev/null and b/public/flags/ES.png differ
diff --git a/public/flags/ET.png b/public/flags/ET.png
new file mode 100644
index 0000000..8f67ae3
Binary files /dev/null and b/public/flags/ET.png differ
diff --git a/public/flags/FI.png b/public/flags/FI.png
new file mode 100644
index 0000000..1b9d1f3
Binary files /dev/null and b/public/flags/FI.png differ
diff --git a/public/flags/FJ.png b/public/flags/FJ.png
new file mode 100644
index 0000000..6779f54
Binary files /dev/null and b/public/flags/FJ.png differ
diff --git a/public/flags/FK.png b/public/flags/FK.png
new file mode 100644
index 0000000..ef4a688
Binary files /dev/null and b/public/flags/FK.png differ
diff --git a/public/flags/FM.png b/public/flags/FM.png
new file mode 100644
index 0000000..8c9df47
Binary files /dev/null and b/public/flags/FM.png differ
diff --git a/public/flags/FO.png b/public/flags/FO.png
new file mode 100644
index 0000000..1480730
Binary files /dev/null and b/public/flags/FO.png differ
diff --git a/public/flags/FR.png b/public/flags/FR.png
new file mode 100644
index 0000000..8f83570
Binary files /dev/null and b/public/flags/FR.png differ
diff --git a/public/flags/GA.png b/public/flags/GA.png
new file mode 100644
index 0000000..ace259b
Binary files /dev/null and b/public/flags/GA.png differ
diff --git a/public/flags/GB.png b/public/flags/GB.png
new file mode 100644
index 0000000..b626135
Binary files /dev/null and b/public/flags/GB.png differ
diff --git a/public/flags/GD.png b/public/flags/GD.png
new file mode 100644
index 0000000..fcb74af
Binary files /dev/null and b/public/flags/GD.png differ
diff --git a/public/flags/GE.png b/public/flags/GE.png
new file mode 100644
index 0000000..305f83c
Binary files /dev/null and b/public/flags/GE.png differ
diff --git a/public/flags/GF.png b/public/flags/GF.png
new file mode 100644
index 0000000..a8e00f1
Binary files /dev/null and b/public/flags/GF.png differ
diff --git a/public/flags/GH.png b/public/flags/GH.png
new file mode 100644
index 0000000..c8792f0
Binary files /dev/null and b/public/flags/GH.png differ
diff --git a/public/flags/GI.png b/public/flags/GI.png
new file mode 100644
index 0000000..1c14f24
Binary files /dev/null and b/public/flags/GI.png differ
diff --git a/public/flags/GL.png b/public/flags/GL.png
new file mode 100644
index 0000000..9f1c118
Binary files /dev/null and b/public/flags/GL.png differ
diff --git a/public/flags/GM.png b/public/flags/GM.png
new file mode 100644
index 0000000..ee534d3
Binary files /dev/null and b/public/flags/GM.png differ
diff --git a/public/flags/GN.png b/public/flags/GN.png
new file mode 100644
index 0000000..18dbe66
Binary files /dev/null and b/public/flags/GN.png differ
diff --git a/public/flags/GP.png b/public/flags/GP.png
new file mode 100644
index 0000000..16497b1
Binary files /dev/null and b/public/flags/GP.png differ
diff --git a/public/flags/GQ.png b/public/flags/GQ.png
new file mode 100644
index 0000000..0407db5
Binary files /dev/null and b/public/flags/GQ.png differ
diff --git a/public/flags/GR.png b/public/flags/GR.png
new file mode 100644
index 0000000..d1164b8
Binary files /dev/null and b/public/flags/GR.png differ
diff --git a/public/flags/GS.png b/public/flags/GS.png
new file mode 100644
index 0000000..f833281
Binary files /dev/null and b/public/flags/GS.png differ
diff --git a/public/flags/GT.png b/public/flags/GT.png
new file mode 100644
index 0000000..7737e2a
Binary files /dev/null and b/public/flags/GT.png differ
diff --git a/public/flags/GU.png b/public/flags/GU.png
new file mode 100644
index 0000000..f0bb331
Binary files /dev/null and b/public/flags/GU.png differ
diff --git a/public/flags/GW.png b/public/flags/GW.png
new file mode 100644
index 0000000..40957b9
Binary files /dev/null and b/public/flags/GW.png differ
diff --git a/public/flags/GY.png b/public/flags/GY.png
new file mode 100644
index 0000000..aa1c924
Binary files /dev/null and b/public/flags/GY.png differ
diff --git a/public/flags/HK.png b/public/flags/HK.png
new file mode 100644
index 0000000..f48f9dd
Binary files /dev/null and b/public/flags/HK.png differ
diff --git a/public/flags/HM.png b/public/flags/HM.png
new file mode 100644
index 0000000..d6b851d
Binary files /dev/null and b/public/flags/HM.png differ
diff --git a/public/flags/HN.png b/public/flags/HN.png
new file mode 100644
index 0000000..15c3b96
Binary files /dev/null and b/public/flags/HN.png differ
diff --git a/public/flags/HR.png b/public/flags/HR.png
new file mode 100644
index 0000000..2817a76
Binary files /dev/null and b/public/flags/HR.png differ
diff --git a/public/flags/HT.png b/public/flags/HT.png
new file mode 100644
index 0000000..6543f46
Binary files /dev/null and b/public/flags/HT.png differ
diff --git a/public/flags/HU.png b/public/flags/HU.png
new file mode 100644
index 0000000..1e8feab
Binary files /dev/null and b/public/flags/HU.png differ
diff --git a/public/flags/ID.png b/public/flags/ID.png
new file mode 100644
index 0000000..2a9352a
Binary files /dev/null and b/public/flags/ID.png differ
diff --git a/public/flags/IE.png b/public/flags/IE.png
new file mode 100644
index 0000000..5897039
Binary files /dev/null and b/public/flags/IE.png differ
diff --git a/public/flags/IL.png b/public/flags/IL.png
new file mode 100644
index 0000000..9f2ab0b
Binary files /dev/null and b/public/flags/IL.png differ
diff --git a/public/flags/IN.png b/public/flags/IN.png
new file mode 100644
index 0000000..283861c
Binary files /dev/null and b/public/flags/IN.png differ
diff --git a/public/flags/IO.png b/public/flags/IO.png
new file mode 100644
index 0000000..6e40b5c
Binary files /dev/null and b/public/flags/IO.png differ
diff --git a/public/flags/IQ.png b/public/flags/IQ.png
new file mode 100644
index 0000000..2bc1349
Binary files /dev/null and b/public/flags/IQ.png differ
diff --git a/public/flags/IR.png b/public/flags/IR.png
new file mode 100644
index 0000000..2d5c7d5
Binary files /dev/null and b/public/flags/IR.png differ
diff --git a/public/flags/IS.png b/public/flags/IS.png
new file mode 100644
index 0000000..4c79722
Binary files /dev/null and b/public/flags/IS.png differ
diff --git a/public/flags/IT.png b/public/flags/IT.png
new file mode 100644
index 0000000..b914e93
Binary files /dev/null and b/public/flags/IT.png differ
diff --git a/public/flags/JM.png b/public/flags/JM.png
new file mode 100644
index 0000000..2ff6a46
Binary files /dev/null and b/public/flags/JM.png differ
diff --git a/public/flags/JO.png b/public/flags/JO.png
new file mode 100644
index 0000000..9154e6a
Binary files /dev/null and b/public/flags/JO.png differ
diff --git a/public/flags/JP.png b/public/flags/JP.png
new file mode 100644
index 0000000..a7a0953
Binary files /dev/null and b/public/flags/JP.png differ
diff --git a/public/flags/KE.png b/public/flags/KE.png
new file mode 100644
index 0000000..a4e2c79
Binary files /dev/null and b/public/flags/KE.png differ
diff --git a/public/flags/KG.png b/public/flags/KG.png
new file mode 100644
index 0000000..dc441b9
Binary files /dev/null and b/public/flags/KG.png differ
diff --git a/public/flags/KH.png b/public/flags/KH.png
new file mode 100644
index 0000000..abb8d16
Binary files /dev/null and b/public/flags/KH.png differ
diff --git a/public/flags/KI.png b/public/flags/KI.png
new file mode 100644
index 0000000..9f1bdc8
Binary files /dev/null and b/public/flags/KI.png differ
diff --git a/public/flags/KM.png b/public/flags/KM.png
new file mode 100644
index 0000000..8a8dc8d
Binary files /dev/null and b/public/flags/KM.png differ
diff --git a/public/flags/KN.png b/public/flags/KN.png
new file mode 100644
index 0000000..2d949d2
Binary files /dev/null and b/public/flags/KN.png differ
diff --git a/public/flags/KP.png b/public/flags/KP.png
new file mode 100644
index 0000000..8f0f939
Binary files /dev/null and b/public/flags/KP.png differ
diff --git a/public/flags/KR.png b/public/flags/KR.png
new file mode 100644
index 0000000..72648be
Binary files /dev/null and b/public/flags/KR.png differ
diff --git a/public/flags/KW.png b/public/flags/KW.png
new file mode 100644
index 0000000..ba1e6f4
Binary files /dev/null and b/public/flags/KW.png differ
diff --git a/public/flags/KY.png b/public/flags/KY.png
new file mode 100644
index 0000000..eeac5b4
Binary files /dev/null and b/public/flags/KY.png differ
diff --git a/public/flags/KZ.png b/public/flags/KZ.png
new file mode 100644
index 0000000..1c20978
Binary files /dev/null and b/public/flags/KZ.png differ
diff --git a/public/flags/LA.png b/public/flags/LA.png
new file mode 100644
index 0000000..aef91d2
Binary files /dev/null and b/public/flags/LA.png differ
diff --git a/public/flags/LB.png b/public/flags/LB.png
new file mode 100644
index 0000000..bdf887f
Binary files /dev/null and b/public/flags/LB.png differ
diff --git a/public/flags/LC.png b/public/flags/LC.png
new file mode 100644
index 0000000..090e290
Binary files /dev/null and b/public/flags/LC.png differ
diff --git a/public/flags/LI.png b/public/flags/LI.png
new file mode 100644
index 0000000..85fd359
Binary files /dev/null and b/public/flags/LI.png differ
diff --git a/public/flags/LK.png b/public/flags/LK.png
new file mode 100644
index 0000000..9c88572
Binary files /dev/null and b/public/flags/LK.png differ
diff --git a/public/flags/LR.png b/public/flags/LR.png
new file mode 100644
index 0000000..8c5e51b
Binary files /dev/null and b/public/flags/LR.png differ
diff --git a/public/flags/LS.png b/public/flags/LS.png
new file mode 100644
index 0000000..c1b9fe5
Binary files /dev/null and b/public/flags/LS.png differ
diff --git a/public/flags/LT.png b/public/flags/LT.png
new file mode 100644
index 0000000..74ba36c
Binary files /dev/null and b/public/flags/LT.png differ
diff --git a/public/flags/LU.png b/public/flags/LU.png
new file mode 100644
index 0000000..4ac458f
Binary files /dev/null and b/public/flags/LU.png differ
diff --git a/public/flags/LV.png b/public/flags/LV.png
new file mode 100644
index 0000000..d1eadaa
Binary files /dev/null and b/public/flags/LV.png differ
diff --git a/public/flags/LY.png b/public/flags/LY.png
new file mode 100644
index 0000000..2becba0
Binary files /dev/null and b/public/flags/LY.png differ
diff --git a/public/flags/MA.png b/public/flags/MA.png
new file mode 100644
index 0000000..d5faf3c
Binary files /dev/null and b/public/flags/MA.png differ
diff --git a/public/flags/MC.png b/public/flags/MC.png
new file mode 100644
index 0000000..bb5cd21
Binary files /dev/null and b/public/flags/MC.png differ
diff --git a/public/flags/MD.png b/public/flags/MD.png
new file mode 100644
index 0000000..32ed730
Binary files /dev/null and b/public/flags/MD.png differ
diff --git a/public/flags/ME.png b/public/flags/ME.png
new file mode 100644
index 0000000..ee363c3
Binary files /dev/null and b/public/flags/ME.png differ
diff --git a/public/flags/MG.png b/public/flags/MG.png
new file mode 100644
index 0000000..8014ec8
Binary files /dev/null and b/public/flags/MG.png differ
diff --git a/public/flags/MH.png b/public/flags/MH.png
new file mode 100644
index 0000000..0632e77
Binary files /dev/null and b/public/flags/MH.png differ
diff --git a/public/flags/MK.png b/public/flags/MK.png
new file mode 100644
index 0000000..375769f
Binary files /dev/null and b/public/flags/MK.png differ
diff --git a/public/flags/ML.png b/public/flags/ML.png
new file mode 100644
index 0000000..e335f72
Binary files /dev/null and b/public/flags/ML.png differ
diff --git a/public/flags/MM.png b/public/flags/MM.png
new file mode 100644
index 0000000..e3b8a48
Binary files /dev/null and b/public/flags/MM.png differ
diff --git a/public/flags/MN.png b/public/flags/MN.png
new file mode 100644
index 0000000..df53b76
Binary files /dev/null and b/public/flags/MN.png differ
diff --git a/public/flags/MO.png b/public/flags/MO.png
new file mode 100644
index 0000000..66927cb
Binary files /dev/null and b/public/flags/MO.png differ
diff --git a/public/flags/MP.png b/public/flags/MP.png
new file mode 100644
index 0000000..2e38b09
Binary files /dev/null and b/public/flags/MP.png differ
diff --git a/public/flags/MQ.png b/public/flags/MQ.png
new file mode 100644
index 0000000..ab58b57
Binary files /dev/null and b/public/flags/MQ.png differ
diff --git a/public/flags/MR.png b/public/flags/MR.png
new file mode 100644
index 0000000..ce73d26
Binary files /dev/null and b/public/flags/MR.png differ
diff --git a/public/flags/MS.png b/public/flags/MS.png
new file mode 100644
index 0000000..b0316e3
Binary files /dev/null and b/public/flags/MS.png differ
diff --git a/public/flags/MT.png b/public/flags/MT.png
new file mode 100644
index 0000000..004a701
Binary files /dev/null and b/public/flags/MT.png differ
diff --git a/public/flags/MU.png b/public/flags/MU.png
new file mode 100644
index 0000000..3148e21
Binary files /dev/null and b/public/flags/MU.png differ
diff --git a/public/flags/MV.png b/public/flags/MV.png
new file mode 100644
index 0000000..a07e5fe
Binary files /dev/null and b/public/flags/MV.png differ
diff --git a/public/flags/MW.png b/public/flags/MW.png
new file mode 100644
index 0000000..17eaf12
Binary files /dev/null and b/public/flags/MW.png differ
diff --git a/public/flags/MX.png b/public/flags/MX.png
new file mode 100644
index 0000000..4f57a02
Binary files /dev/null and b/public/flags/MX.png differ
diff --git a/public/flags/MY.png b/public/flags/MY.png
new file mode 100644
index 0000000..72eca0e
Binary files /dev/null and b/public/flags/MY.png differ
diff --git a/public/flags/MZ.png b/public/flags/MZ.png
new file mode 100644
index 0000000..6af2b34
Binary files /dev/null and b/public/flags/MZ.png differ
diff --git a/public/flags/NA.png b/public/flags/NA.png
new file mode 100644
index 0000000..84abcae
Binary files /dev/null and b/public/flags/NA.png differ
diff --git a/public/flags/NC.png b/public/flags/NC.png
new file mode 100644
index 0000000..2b5b32c
Binary files /dev/null and b/public/flags/NC.png differ
diff --git a/public/flags/NE.png b/public/flags/NE.png
new file mode 100644
index 0000000..7e51108
Binary files /dev/null and b/public/flags/NE.png differ
diff --git a/public/flags/NF.png b/public/flags/NF.png
new file mode 100644
index 0000000..58f15aa
Binary files /dev/null and b/public/flags/NF.png differ
diff --git a/public/flags/NG.png b/public/flags/NG.png
new file mode 100644
index 0000000..c2b1974
Binary files /dev/null and b/public/flags/NG.png differ
diff --git a/public/flags/NI.png b/public/flags/NI.png
new file mode 100644
index 0000000..82d671f
Binary files /dev/null and b/public/flags/NI.png differ
diff --git a/public/flags/NL.png b/public/flags/NL.png
new file mode 100644
index 0000000..cbd529d
Binary files /dev/null and b/public/flags/NL.png differ
diff --git a/public/flags/NO.png b/public/flags/NO.png
new file mode 100644
index 0000000..7c89dbd
Binary files /dev/null and b/public/flags/NO.png differ
diff --git a/public/flags/NP.png b/public/flags/NP.png
new file mode 100644
index 0000000..924f95d
Binary files /dev/null and b/public/flags/NP.png differ
diff --git a/public/flags/NR.png b/public/flags/NR.png
new file mode 100644
index 0000000..7a1363a
Binary files /dev/null and b/public/flags/NR.png differ
diff --git a/public/flags/NU.png b/public/flags/NU.png
new file mode 100644
index 0000000..541dccf
Binary files /dev/null and b/public/flags/NU.png differ
diff --git a/public/flags/NZ.png b/public/flags/NZ.png
new file mode 100644
index 0000000..d15540a
Binary files /dev/null and b/public/flags/NZ.png differ
diff --git a/public/flags/OM.png b/public/flags/OM.png
new file mode 100644
index 0000000..0735a2e
Binary files /dev/null and b/public/flags/OM.png differ
diff --git a/public/flags/PA.png b/public/flags/PA.png
new file mode 100644
index 0000000..8e3ea66
Binary files /dev/null and b/public/flags/PA.png differ
diff --git a/public/flags/PE.png b/public/flags/PE.png
new file mode 100644
index 0000000..dadb9df
Binary files /dev/null and b/public/flags/PE.png differ
diff --git a/public/flags/PF.png b/public/flags/PF.png
new file mode 100644
index 0000000..14c65de
Binary files /dev/null and b/public/flags/PF.png differ
diff --git a/public/flags/PG.png b/public/flags/PG.png
new file mode 100644
index 0000000..74a9ca0
Binary files /dev/null and b/public/flags/PG.png differ
diff --git a/public/flags/PH.png b/public/flags/PH.png
new file mode 100644
index 0000000..969504d
Binary files /dev/null and b/public/flags/PH.png differ
diff --git a/public/flags/PK.png b/public/flags/PK.png
new file mode 100644
index 0000000..227de2f
Binary files /dev/null and b/public/flags/PK.png differ
diff --git a/public/flags/PL.png b/public/flags/PL.png
new file mode 100644
index 0000000..5e4ce3a
Binary files /dev/null and b/public/flags/PL.png differ
diff --git a/public/flags/PM.png b/public/flags/PM.png
new file mode 100644
index 0000000..ae68653
Binary files /dev/null and b/public/flags/PM.png differ
diff --git a/public/flags/PN.png b/public/flags/PN.png
new file mode 100644
index 0000000..d65b60c
Binary files /dev/null and b/public/flags/PN.png differ
diff --git a/public/flags/PR.png b/public/flags/PR.png
new file mode 100644
index 0000000..9de98df
Binary files /dev/null and b/public/flags/PR.png differ
diff --git a/public/flags/PS.png b/public/flags/PS.png
new file mode 100644
index 0000000..51abceb
Binary files /dev/null and b/public/flags/PS.png differ
diff --git a/public/flags/PT.png b/public/flags/PT.png
new file mode 100644
index 0000000..5e2dd37
Binary files /dev/null and b/public/flags/PT.png differ
diff --git a/public/flags/PW.png b/public/flags/PW.png
new file mode 100644
index 0000000..13d9310
Binary files /dev/null and b/public/flags/PW.png differ
diff --git a/public/flags/PY.png b/public/flags/PY.png
new file mode 100644
index 0000000..a875ab4
Binary files /dev/null and b/public/flags/PY.png differ
diff --git a/public/flags/QA.png b/public/flags/QA.png
new file mode 100644
index 0000000..586cdd0
Binary files /dev/null and b/public/flags/QA.png differ
diff --git a/public/flags/RE.png b/public/flags/RE.png
new file mode 100644
index 0000000..0d01b1c
Binary files /dev/null and b/public/flags/RE.png differ
diff --git a/public/flags/RO.png b/public/flags/RO.png
new file mode 100644
index 0000000..06391f6
Binary files /dev/null and b/public/flags/RO.png differ
diff --git a/public/flags/RU.png b/public/flags/RU.png
new file mode 100644
index 0000000..22ecdcf
Binary files /dev/null and b/public/flags/RU.png differ
diff --git a/public/flags/RW.png b/public/flags/RW.png
new file mode 100644
index 0000000..bfd954e
Binary files /dev/null and b/public/flags/RW.png differ
diff --git a/public/flags/SA.png b/public/flags/SA.png
new file mode 100644
index 0000000..d017c32
Binary files /dev/null and b/public/flags/SA.png differ
diff --git a/public/flags/SB.png b/public/flags/SB.png
new file mode 100644
index 0000000..86f37ac
Binary files /dev/null and b/public/flags/SB.png differ
diff --git a/public/flags/SC.png b/public/flags/SC.png
new file mode 100644
index 0000000..61f47ec
Binary files /dev/null and b/public/flags/SC.png differ
diff --git a/public/flags/SD.png b/public/flags/SD.png
new file mode 100644
index 0000000..201ccdf
Binary files /dev/null and b/public/flags/SD.png differ
diff --git a/public/flags/SE.png b/public/flags/SE.png
new file mode 100644
index 0000000..7e0b3ea
Binary files /dev/null and b/public/flags/SE.png differ
diff --git a/public/flags/SG.png b/public/flags/SG.png
new file mode 100644
index 0000000..6381459
Binary files /dev/null and b/public/flags/SG.png differ
diff --git a/public/flags/SH.png b/public/flags/SH.png
new file mode 100644
index 0000000..98fcb66
Binary files /dev/null and b/public/flags/SH.png differ
diff --git a/public/flags/SI.png b/public/flags/SI.png
new file mode 100644
index 0000000..b721943
Binary files /dev/null and b/public/flags/SI.png differ
diff --git a/public/flags/SJ.png b/public/flags/SJ.png
new file mode 100644
index 0000000..ec8bc71
Binary files /dev/null and b/public/flags/SJ.png differ
diff --git a/public/flags/SK.png b/public/flags/SK.png
new file mode 100644
index 0000000..2dab907
Binary files /dev/null and b/public/flags/SK.png differ
diff --git a/public/flags/SL.png b/public/flags/SL.png
new file mode 100644
index 0000000..9278171
Binary files /dev/null and b/public/flags/SL.png differ
diff --git a/public/flags/SM.png b/public/flags/SM.png
new file mode 100644
index 0000000..42a353a
Binary files /dev/null and b/public/flags/SM.png differ
diff --git a/public/flags/SN.png b/public/flags/SN.png
new file mode 100644
index 0000000..faad514
Binary files /dev/null and b/public/flags/SN.png differ
diff --git a/public/flags/SO.png b/public/flags/SO.png
new file mode 100644
index 0000000..20cad90
Binary files /dev/null and b/public/flags/SO.png differ
diff --git a/public/flags/SR.png b/public/flags/SR.png
new file mode 100644
index 0000000..c9bbffd
Binary files /dev/null and b/public/flags/SR.png differ
diff --git a/public/flags/ST.png b/public/flags/ST.png
new file mode 100644
index 0000000..0b9fb16
Binary files /dev/null and b/public/flags/ST.png differ
diff --git a/public/flags/SV.png b/public/flags/SV.png
new file mode 100644
index 0000000..581b9ae
Binary files /dev/null and b/public/flags/SV.png differ
diff --git a/public/flags/SY.png b/public/flags/SY.png
new file mode 100644
index 0000000..f341bac
Binary files /dev/null and b/public/flags/SY.png differ
diff --git a/public/flags/SZ.png b/public/flags/SZ.png
new file mode 100644
index 0000000..a48a0a6
Binary files /dev/null and b/public/flags/SZ.png differ
diff --git a/public/flags/TC.png b/public/flags/TC.png
new file mode 100644
index 0000000..acecefe
Binary files /dev/null and b/public/flags/TC.png differ
diff --git a/public/flags/TD.png b/public/flags/TD.png
new file mode 100644
index 0000000..909689e
Binary files /dev/null and b/public/flags/TD.png differ
diff --git a/public/flags/TF.png b/public/flags/TF.png
new file mode 100644
index 0000000..078874f
Binary files /dev/null and b/public/flags/TF.png differ
diff --git a/public/flags/TG.png b/public/flags/TG.png
new file mode 100644
index 0000000..4e5e570
Binary files /dev/null and b/public/flags/TG.png differ
diff --git a/public/flags/TH.png b/public/flags/TH.png
new file mode 100644
index 0000000..5d1e896
Binary files /dev/null and b/public/flags/TH.png differ
diff --git a/public/flags/TJ.png b/public/flags/TJ.png
new file mode 100644
index 0000000..4d98616
Binary files /dev/null and b/public/flags/TJ.png differ
diff --git a/public/flags/TK.png b/public/flags/TK.png
new file mode 100644
index 0000000..21ae457
Binary files /dev/null and b/public/flags/TK.png differ
diff --git a/public/flags/TL.png b/public/flags/TL.png
new file mode 100644
index 0000000..e48bb7b
Binary files /dev/null and b/public/flags/TL.png differ
diff --git a/public/flags/TM.png b/public/flags/TM.png
new file mode 100644
index 0000000..ce0f807
Binary files /dev/null and b/public/flags/TM.png differ
diff --git a/public/flags/TN.png b/public/flags/TN.png
new file mode 100644
index 0000000..bf6e8ba
Binary files /dev/null and b/public/flags/TN.png differ
diff --git a/public/flags/TO.png b/public/flags/TO.png
new file mode 100644
index 0000000..0ef29e9
Binary files /dev/null and b/public/flags/TO.png differ
diff --git a/public/flags/TR.png b/public/flags/TR.png
new file mode 100644
index 0000000..813492b
Binary files /dev/null and b/public/flags/TR.png differ
diff --git a/public/flags/TT.png b/public/flags/TT.png
new file mode 100644
index 0000000..4dd7a82
Binary files /dev/null and b/public/flags/TT.png differ
diff --git a/public/flags/TV.png b/public/flags/TV.png
new file mode 100644
index 0000000..b4987b6
Binary files /dev/null and b/public/flags/TV.png differ
diff --git a/public/flags/TW.png b/public/flags/TW.png
new file mode 100644
index 0000000..8d1a0a2
Binary files /dev/null and b/public/flags/TW.png differ
diff --git a/public/flags/TZ.png b/public/flags/TZ.png
new file mode 100644
index 0000000..86fbcf4
Binary files /dev/null and b/public/flags/TZ.png differ
diff --git a/public/flags/UA.png b/public/flags/UA.png
new file mode 100644
index 0000000..f235188
Binary files /dev/null and b/public/flags/UA.png differ
diff --git a/public/flags/UG.png b/public/flags/UG.png
new file mode 100644
index 0000000..65d15b0
Binary files /dev/null and b/public/flags/UG.png differ
diff --git a/public/flags/UM.png b/public/flags/UM.png
new file mode 100644
index 0000000..f79e478
Binary files /dev/null and b/public/flags/UM.png differ
diff --git a/public/flags/US.png b/public/flags/US.png
new file mode 100644
index 0000000..1e483f3
Binary files /dev/null and b/public/flags/US.png differ
diff --git a/public/flags/UY.png b/public/flags/UY.png
new file mode 100644
index 0000000..c67592e
Binary files /dev/null and b/public/flags/UY.png differ
diff --git a/public/flags/UZ.png b/public/flags/UZ.png
new file mode 100644
index 0000000..bd9c10f
Binary files /dev/null and b/public/flags/UZ.png differ
diff --git a/public/flags/VA.png b/public/flags/VA.png
new file mode 100644
index 0000000..5126f2f
Binary files /dev/null and b/public/flags/VA.png differ
diff --git a/public/flags/VC.png b/public/flags/VC.png
new file mode 100644
index 0000000..8e4beaa
Binary files /dev/null and b/public/flags/VC.png differ
diff --git a/public/flags/VE.png b/public/flags/VE.png
new file mode 100644
index 0000000..edb5bd2
Binary files /dev/null and b/public/flags/VE.png differ
diff --git a/public/flags/VG.png b/public/flags/VG.png
new file mode 100644
index 0000000..9eda300
Binary files /dev/null and b/public/flags/VG.png differ
diff --git a/public/flags/VI.png b/public/flags/VI.png
new file mode 100644
index 0000000..8ba30e1
Binary files /dev/null and b/public/flags/VI.png differ
diff --git a/public/flags/VN.png b/public/flags/VN.png
new file mode 100644
index 0000000..eadf26d
Binary files /dev/null and b/public/flags/VN.png differ
diff --git a/public/flags/VU.png b/public/flags/VU.png
new file mode 100644
index 0000000..b1bffe8
Binary files /dev/null and b/public/flags/VU.png differ
diff --git a/public/flags/WF.png b/public/flags/WF.png
new file mode 100644
index 0000000..f97184f
Binary files /dev/null and b/public/flags/WF.png differ
diff --git a/public/flags/WS.png b/public/flags/WS.png
new file mode 100644
index 0000000..0bac2f4
Binary files /dev/null and b/public/flags/WS.png differ
diff --git a/public/flags/YE.png b/public/flags/YE.png
new file mode 100644
index 0000000..7f5c788
Binary files /dev/null and b/public/flags/YE.png differ
diff --git a/public/flags/YT.png b/public/flags/YT.png
new file mode 100644
index 0000000..e2cbf93
Binary files /dev/null and b/public/flags/YT.png differ
diff --git a/public/flags/ZA.png b/public/flags/ZA.png
new file mode 100644
index 0000000..db02bce
Binary files /dev/null and b/public/flags/ZA.png differ
diff --git a/public/flags/ZM.png b/public/flags/ZM.png
new file mode 100644
index 0000000..4b46151
Binary files /dev/null and b/public/flags/ZM.png differ
diff --git a/public/flags/ZW.png b/public/flags/ZW.png
new file mode 100644
index 0000000..0b09cd3
Binary files /dev/null and b/public/flags/ZW.png differ
diff --git a/resources/lang/de/app.php b/resources/lang/de/app.php
index ada8f49..c172fae 100644
--- a/resources/lang/de/app.php
+++ b/resources/lang/de/app.php
@@ -62,6 +62,7 @@ return [
     'i_forgot_my_password' => 'Passwort vergessen?',
     'remember_me' => 'Anmeldedaten merken?',
     'dont_have_an_account' => 'Sie haben noch keinen Account?',
+    'register' => 'Registrieren',
 
     'email' => 'eMail',
     'your_email' => 'Ihre eMail-Adresse',
diff --git a/resources/lang/en/app.php b/resources/lang/en/app.php
index 4127a63..e40fe94 100644
--- a/resources/lang/en/app.php
+++ b/resources/lang/en/app.php
@@ -62,6 +62,7 @@ return [
     'i_forgot_my_password' => 'I forgot my password',
     'remember_me' => 'Remember me?',
     'dont_have_an_account' => 'Don\'t have an account?',
+    'register' => 'Register',
 
     'email' => 'Email',
     'your_email' => 'Your E-Mail',
@@ -198,7 +199,6 @@ return [
     'edit_user' => 'Edit User',
     'edit_user_details' => 'edit user details',
     'details' => 'Details',
-    'social_networks' => 'Social Networks',
     'list_of_registered_users' => 'list of registered users',
     'search_for_users' => 'Search for users...',
     'full_name' => 'Full Name',
@@ -248,7 +248,6 @@ return [
     'phone' => 'Phone',
     'address' => 'Address',
     'country' => 'Country',
-    'update_social_networks' => 'Update Social Networks',
     'in_order_to_enable_2fa_you_must' => 'In order to enable Two-Factor Authentication, you must install',
     'application_on_your_phone' => 'application on your phone',
     'country_code' => 'Country Code',
@@ -273,7 +272,6 @@ return [
 
     'profile_updated_successfully' => 'Profile updated successfully.',
     'avatar_changed' => 'Avatar changed successfully.',
-    'socials_updated' => 'Social networks updated successfully.',
     'login_updated' => 'Login details updated successfully.',
     '2fa_already_enabled' => 'Two-Factor Authentication is already enabled.',
     '2fa_enabled' => 'Two-Factor Authentication enabled successfully.',
diff --git a/resources/lang/en/validation.php b/resources/lang/en/validation.php
index c7a1ecf..812437c 100644
--- a/resources/lang/en/validation.php
+++ b/resources/lang/en/validation.php
@@ -75,6 +75,7 @@ return [
     'timezone'             => 'The :attribute must be a valid zone.',
     'unique'               => 'The :attribute has already been taken.',
     'url'                  => 'The :attribute format is invalid.',
+    'captcha'              => 'reCAPTCHA value is invalid.',
 
     /*
     |--------------------------------------------------------------------------
diff --git a/resources/lang/sr/app.php b/resources/lang/sr/app.php
index 98a0cd8..c80b5cd 100644
--- a/resources/lang/sr/app.php
+++ b/resources/lang/sr/app.php
@@ -60,6 +60,7 @@ return [
     'i_forgot_my_password' => 'Zaboravio sam lozinku',
     'remember_me' => 'Zapamti me',
     'dont_have_an_account' => 'Nemate nalog?',
+    'register' => 'Kreiraj nalog',
 
     'email' => 'E-Adresa',
     'your_email' => 'Vaša E-Adresa',
diff --git a/resources/views/auth/register.blade.php b/resources/views/auth/register.blade.php
index 1024a89..c0c85a8 100644
--- a/resources/views/auth/register.blade.php
+++ b/resources/views/auth/register.blade.php
@@ -55,7 +55,7 @@
 
             <div class="form-group">
                 <button type="submit" class="btn btn-custom btn-lg btn-block" id="btn-login">
-                    Register
+                    @lang('app.register')
                 </button>
             </div>
         </form>
diff --git a/resources/views/partials/sidebar.blade.php b/resources/views/partials/sidebar.blade.php
index 52e57e7..16b10cd 100644
--- a/resources/views/partials/sidebar.blade.php
+++ b/resources/views/partials/sidebar.blade.php
@@ -55,7 +55,7 @@
                 </li>
             @endpermission
 
-            @permission(['settings.general', 'settings.auth', 'settings.notifications'])
+            @permission(['settings.general', 'settings.auth', 'settings.notifications'], false)
             <li class="{{ Request::is('settings*') ? 'active open' : ''  }}">
                 <a href="#">
                     <i class="fa fa-gear fa-fw"></i> @lang('app.settings')
diff --git a/resources/views/user/edit.blade.php b/resources/views/user/edit.blade.php
index 91ddae5..5747cef 100644
--- a/resources/views/user/edit.blade.php
+++ b/resources/views/user/edit.blade.php
@@ -32,12 +32,6 @@
         </a>
     </li>
     <li role="presentation">
-        <a href="#social-networks" aria-controls="social-networks" role="tab" data-toggle="tab">
-            <i class="fa fa-youtube"></i>
-            @lang('app.social_networks')
-        </a>
-    </li>
-    <li role="presentation">
         <a href="#auth" aria-controls="auth" role="tab" data-toggle="tab">
             <i class="fa fa-lock"></i>
             @lang('app.authentication')
@@ -61,15 +55,6 @@
             </div>
         </div>
     </div>
-    <div role="tabpanel" class="tab-pane" id="social-networks">
-        <div class="row">
-            <div class="col-md-12">
-                {!! Form::open(['route' => ['user.update.socials', $user->id]]) !!}
-                    @include('user.partials.social-networks')
-                {!! Form::close() !!}
-            </div>
-        </div>
-    </div>
     <div role="tabpanel" class="tab-pane" id="auth">
         <div class="row">
             <div class="col-md-8">
diff --git a/resources/views/user/partials/details.blade.php b/resources/views/user/partials/details.blade.php
index 5066b50..f13d0ea 100644
--- a/resources/views/user/partials/details.blade.php
+++ b/resources/views/user/partials/details.blade.php
@@ -5,8 +5,8 @@
             <div class="col-md-6">
                 <div class="form-group">
                     <label for="first_name">@lang('app.role')</label>
-                    {!! Form::select('role', $roles, $edit ? $user->role->id : '',
-                        ['class' => 'form-control', 'id' => 'role', $profile ? 'disabled' : '']) !!}
+                    {!! Form::select('role_id', $roles, $edit ? $user->role->id : '',
+                        ['class' => 'form-control', 'id' => 'role_id', $profile ? 'disabled' : '']) !!}
                 </div>
                 <div class="form-group">
                     <label for="status">@lang('app.status')</label>
diff --git a/resources/views/user/partials/social-networks.blade.php b/resources/views/user/partials/social-networks.blade.php
deleted file mode 100644
index 443c855..0000000
--- a/resources/views/user/partials/social-networks.blade.php
+++ /dev/null
@@ -1,69 +0,0 @@
-<div class="panel panel-default">
-    <div class="panel-heading">@lang('app.social_networks')</div>
-    <div class="panel-body">
-        <div class="row">
-            <div class="col-md-6">
-                <div class="form-group">
-                    <label for="facebook">Facebook</label>
-                    <div class="input-icon">
-                        <i class="fa fa-facebook"></i>
-                        <input type="text" class="form-control" id="facebook"
-                               name="socials[facebook]" placeholder="Facebook"
-                               value="{{ $edit ? $socials->facebook : '' }}">
-                    </div>
-                </div>
-                <div class="form-group">
-                    <label for="twitter">Twitter</label>
-                    <div class="input-icon">
-                        <i class="fa fa-twitter"></i>
-                        <input type="text" class="form-control" id="twitter"
-                               name="socials[twitter]" placeholder="Twitter"
-                               value="{{ $edit ? $socials->twitter : '' }}">
-                    </div>
-                </div>
-                <div class="form-group">
-                    <label for="google_plus">Google+</label>
-                    <div class="input-icon">
-                        <i class="fa fa-google-plus"></i>
-                        <input type="text" class="form-control" id="google_plus"
-                               name="socials[google_plus]" placeholder="Google+"
-                               value="{{ $edit ? $socials->google_plus : '' }}">
-                    </div>
-                </div>
-            </div>
-            <div class="col-md-6">
-                <div class="form-group">
-                    <label for="linkedin">LinkedIn</label>
-                    <div class="input-icon">
-                        <i class="fa fa-linkedin"></i>
-                        <input type="text" class="form-control" id="linkedin"
-                               name="socials[linked_in]" placeholder="LinkedIn"
-                               value="{{ $edit ? $socials->linked_in : '' }}">
-                    </div>
-                </div>
-                <div class="form-group">
-                    <label for="dribbble">Dribbble</label>
-                    <div class="input-icon">
-                        <i class="fa fa-dribbble"></i>
-                        <input type="text" class="form-control" id="dribbble"
-                               name="socials[dribbble]" placeholder="Dribbble"
-                               value="{{ $edit ? $socials->dribbble : '' }}">
-                    </div>
-                </div>
-                <div class="form-group">
-                    <label for="Skype">Skype</label>
-                    <div class="input-icon">
-                        <i class="fa fa-skype"></i>
-                        <input type="text" class="form-control" id="skype"
-                               name="socials[skype]" placeholder="Skype ID"
-                               value="{{ $edit ? $socials->skype : '' }}">
-                    </div>
-                </div>
-            </div>
-        </div>
-        <button type="submit" class="btn btn-primary">
-            <i class="fa fa-refresh"></i>
-            @lang('app.update_social_networks')
-        </button>
-    </div>
-</div>
\ No newline at end of file
diff --git a/resources/views/user/profile.blade.php b/resources/views/user/profile.blade.php
index 9a1fdb5..ff23ad6 100644
--- a/resources/views/user/profile.blade.php
+++ b/resources/views/user/profile.blade.php
@@ -30,12 +30,6 @@
         </a>
     </li>
     <li role="presentation">
-        <a href="#social-networks" aria-controls="social-networks" role="tab" data-toggle="tab">
-            <i class="fa fa-youtube"></i>
-            @lang('app.social_networks')
-        </a>
-    </li>
-    <li role="presentation">
         <a href="#auth" aria-controls="auth" role="tab" data-toggle="tab">
             <i class="fa fa-lock"></i>
             @lang('app.authentication')
@@ -59,15 +53,6 @@
             </div>
         </div>
     </div>
-    <div role="tabpanel" class="tab-pane" id="social-networks">
-        <div class="row">
-            <div class="col-md-12">
-                {!! Form::open(['route' => 'profile.update.social-networks', 'method' => 'PUT', 'id' => 'socials-form']) !!}
-                    @include('user.partials.social-networks')
-                {!! Form::close() !!}
-            </div>
-        </div>
-    </div>
     <div role="tabpanel" class="tab-pane" id="auth">
         <div class="row">
             <div class="col-md-8">
diff --git a/resources/views/user/view.blade.php b/resources/views/user/view.blade.php
index 462ae48..6f8a588 100644
--- a/resources/views/user/view.blade.php
+++ b/resources/views/user/view.blade.php
@@ -39,46 +39,6 @@
                 </div>
                 <div class="name"><strong>{{ $user->present()->name }}</strong></div>
 
-                @if ($socialNetworks)
-                    <div class="icons">
-                        @if ($socialNetworks->facebook)
-                            <a href="{{ $socialNetworks->facebook }}" class="btn btn-circle btn-facebook">
-                                <i class="fa fa-facebook"></i>
-                            </a>
-                        @endif
-
-                        @if ($socialNetworks->twitter)
-                            <a href="{{ $socialNetworks->twitter }}" class="btn btn-circle btn-twitter">
-                                <i class="fa fa-twitter"></i>
-                            </a>
-                        @endif
-
-                        @if ($socialNetworks->google_plus)
-                            <a href="{{ $socialNetworks->google_plus }}" class="btn btn-circle btn-google">
-                                <i class="fa fa-google-plus"></i>
-                            </a>
-                        @endif
-
-                        @if ($socialNetworks->linked_in)
-                            <a href="{{ $socialNetworks->linked_in }}" class="btn btn-circle btn-linkedin">
-                                <i class="fa fa-linkedin"></i>
-                            </a>
-                        @endif
-
-                        @if ($socialNetworks->skype)
-                            <a href="{{ $socialNetworks->skype }}" class="btn btn-skype">
-                                <i class="fa fa-skype"></i>
-                            </a>
-                        @endif
-
-                        @if ($socialNetworks->dribbble)
-                            <a href="{{ $socialNetworks->dribbble }}" class="btn btn-circle btn-dribbble">
-                                <i class="fa fa-dribbble"></i>
-                            </a>
-                        @endif
-                    </div>
-                @endif
-
                 <br>
 
                 <table class="table table-hover table-details">
@@ -98,13 +58,6 @@
                                 <td><a href="telto:{{ $user->phone }}">{{ $user->phone }}</a></td>
                             </tr>
                         @endif
-
-                        @if ($socialNetworks && $socialNetworks->skype)
-                            <tr>
-                                <td>Skype</td>
-                                <td>{{ $socialNetworks->skype }}</td>
-                            </tr>
-                        @endif
                     </tbody>
                 </table>
 
diff --git a/routes/api.php b/routes/api.php
index 51535fb..fa3a692 100644
--- a/routes/api.php
+++ b/routes/api.php
@@ -1,12 +1,64 @@
 <?php
 
-/*
-|--------------------------------------------------------------------------
-| API Routes
-|--------------------------------------------------------------------------
-|
-| Here is where you can register API routes for your application. These
-| routes are loaded by the RouteServiceProvider within a group which
-| is assigned the "api" middleware group. Enjoy building your API!
-|
-*/
+Route::post('login', 'Auth\AuthController@login');
+Route::post('login/social', 'Auth\SocialLoginController@index');
+Route::post('logout', 'Auth\AuthController@logout');
+
+if (settings('reg_enabled')) {
+    Route::post('register', 'Auth\RegistrationController@index');
+    Route::post('register/verify-email/{token}', 'Auth\RegistrationController@verifyEmail');
+}
+
+if (settings('forgot_password')) {
+    Route::post('password/remind', 'Auth\Password\RemindController@index');
+    Route::post('password/reset', 'Auth\Password\ResetController@index');
+}
+
+Route::get('stats', 'StatsController@index');
+
+Route::get('me', 'Profile\DetailsController@index');
+Route::patch('me/details', 'Profile\DetailsController@update');
+Route::put('me/avatar', 'Profile\AvatarController@update');
+Route::delete('me/avatar', 'Profile\AvatarController@destroy');
+Route::put('me/avatar/external', 'Profile\AvatarController@updateExternal');
+Route::get('me/sessions', 'Profile\SessionsController@index');
+
+if (settings('2fa.enabled')) {
+    Route::put('me/2fa', 'Profile\TwoFactorController@update');
+    Route::delete('me/2fa', 'Profile\TwoFactorController@destroy');
+}
+
+Route::resource('users', 'Users\UsersController', [
+    'except' => 'create'
+]);
+
+Route::put('users/{user}/avatar', 'Users\AvatarController@update');
+Route::put('users/{user}/avatar/external', 'Users\AvatarController@updateExternal');
+Route::delete('users/{user}/avatar', 'Users\AvatarController@destroy');
+
+if (settings('2fa.enabled')) {
+    Route::put('users/{user}/2fa', 'Users\TwoFactorController@update');
+    Route::delete('users/{user}/2fa', 'Users\TwoFactorController@destroy');
+}
+
+Route::get('users/{user}/activity', 'Users\ActivityController@index');
+Route::get('users/{user}/sessions', 'Users\SessionsController@index');
+
+Route::get('/sessions/{session}', 'SessionsController@show');
+Route::delete('/sessions/{session}', 'SessionsController@destroy');
+
+Route::get('/activity', 'ActivityController@index');
+
+Route::resource('roles', 'Authorization\RolesController', [
+    'except' => 'create'
+]);
+Route::get("roles/{role}/permissions", 'Authorization\RolePermissionsController@show');
+Route::put("roles/{role}/permissions", 'Authorization\RolePermissionsController@update');
+
+Route::resource('permissions', 'Authorization\PermissionsController', [
+    'except' => 'create'
+]);
+
+Route::get('/settings', 'SettingsController@index');
+
+Route::get('/countries', 'CountriesController@index');
diff --git a/routes/web.php b/routes/web.php
index 49513eb..0de3bd8 100644
--- a/routes/web.php
+++ b/routes/web.php
@@ -104,11 +104,6 @@ Route::group(['middleware' => 'auth'], function () {
         'uses' => 'ProfileController@updateLoginDetails'
     ]);
 
-    Route::put('profile/social-networks/update', [
-        'as' => 'profile.update.social-networks',
-        'uses' => 'ProfileController@updateSocialNetworks'
-    ]);
-
     Route::post('profile/two-factor/enable', [
         'as' => 'profile.two-factor.enable',
         'uses' => 'ProfileController@enableTwoFactorAuth'
@@ -182,11 +177,6 @@ Route::group(['middleware' => 'auth'], function () {
         'uses' => 'UsersController@updateAvatarExternal'
     ]);
 
-    Route::post('user/{user}/update/social-networks', [
-        'as' => 'user.update.socials',
-        'uses' => 'UsersController@updateSocialNetworks'
-    ]);
-
     Route::get('user/{user}/sessions', [
         'as' => 'user.sessions',
         'uses' => 'UsersController@sessions'
diff --git a/storage/settings.json b/storage/settings.json
index fbb3389..2faddeb 100644
--- a/storage/settings.json
+++ b/storage/settings.json
@@ -1 +1 @@
-{"remember_me":true,"notifications_signup_email":true,"forgot_password":true,"login_reset_token_lifetime":"30","throttle_enabled":true,"throttle_attempts":10,"throttle_lockout_time":2,"reg_enabled":false,"reg_email_confirmation":false,"2fa":{"enabled":true},"app_name":"foo","registration":{"captcha":{"enabled":false}},"tos":"1","captcha":{"enabled":false}}
\ No newline at end of file
+{"remember_me":true,"notifications_signup_email":true,"forgot_password":true,"login_reset_token_lifetime":"30","throttle_enabled":true,"throttle_attempts":10,"throttle_lockout_time":2,"reg_enabled":false,"reg_email_confirmation":true,"2fa":{"enabled":true},"app_name":"foo","registration":{"captcha":{"enabled":false}},"tos":false,"captcha":{"enabled":false}}
\ No newline at end of file
diff --git a/tests/Feature/ApiTestCase.php b/tests/Feature/ApiTestCase.php
new file mode 100644
index 0000000..7d3f5e2
--- /dev/null
+++ b/tests/Feature/ApiTestCase.php
@@ -0,0 +1,76 @@
+<?php
+
+namespace Tests\Feature;
+
+use Illuminate\Support\Collection;
+use Vanguard\User;
+
+class ApiTestCase extends FunctionalTestCase
+{
+    public function setUp()
+    {
+        putenv("EXPOSE_API=true");
+
+        parent::setUp();
+    }
+
+    /**
+     * @return mixed
+     */
+    protected function login()
+    {
+        $user = factory(User::class)->create();
+
+        $this->be($user, 'api');
+
+        return $user;
+    }
+
+    /**
+     * @return mixed
+     */
+    protected function loginSuperUser()
+    {
+        $user = $this->createSuperUser();
+
+        $this->be($user, 'api');
+
+        return $user;
+    }
+
+    /**
+     * Transform provided collection of items.
+     * @param Collection $collection
+     * @param $transformer
+     * @return array
+     */
+    protected function transformCollection(Collection $collection, $transformer)
+    {
+        $transformed = [];
+
+        foreach ($collection as $item) {
+            $transformed[] = $transformer->transform($item);
+        }
+
+        return $transformed;
+    }
+
+    /**
+     * Check if JWT token in response contains
+     * specified jti claim.
+     * @param $jti
+     * @return $this
+     */
+    protected function assertJwtTokenContains($jti)
+    {
+        $response = $this->decodeResponseJson();
+
+        $parts = explode(".", $response['token']);
+
+        $claims = json_decode(base64_decode($parts[1]));
+
+        $this->assertEquals($jti, $claims->jti);
+
+        return $this;
+    }
+}
diff --git a/tests/Feature/FunctionalTestCase.php b/tests/Feature/FunctionalTestCase.php
index 58caf0d..a6e76c4 100644
--- a/tests/Feature/FunctionalTestCase.php
+++ b/tests/Feature/FunctionalTestCase.php
@@ -6,6 +6,7 @@ use DB;
 use Schema;
 use Settings;
 use Tests\TestCase;
+use Vanguard\Permission;
 use Vanguard\Role;
 use Vanguard\User;
 use Mockery as m;
@@ -72,31 +73,33 @@ class FunctionalTestCase extends TestCase
     }
 
     /**
-     * @param array $attrubutes
+     * @param array $attributes
+     * @param null $guard
      * @return mixed
      */
-    protected function createAndLoginUser(array $attrubutes = [])
+    protected function createAndLoginUser(array $attributes = [], $guard = null)
     {
-        $user = $this->createUserWithSocialNetworks($attrubutes);
+        $user = $this->createUser($attributes);
 
         $user = $this->setRoleForUser($user, 'User');
 
-        $this->be($user);
+        $this->be($user, $guard);
 
         return $user;
     }
 
     /**
-     * @param array $attrubutes
+     * @param array $attributes
+     * @param null $guard
      * @return mixed
      */
-    protected function createAndLoginAdminUser(array $attrubutes = [])
+    protected function createAndLoginAdminUser(array $attributes = [], $guard = null)
     {
-        $user = $this->createUserWithSocialNetworks($attrubutes);
+        $user = $this->createUser($attributes);
 
         $user = $this->setRoleForUser($user, 'Admin');
 
-        $this->be($user);
+        $this->be($user, $guard);
 
         return $user;
     }
@@ -105,12 +108,9 @@ class FunctionalTestCase extends TestCase
      * @param array $attributes
      * @return mixed
      */
-    protected function createUserWithSocialNetworks(array $attributes = [])
+    protected function createUser(array $attributes = [])
     {
-        $user = factory(User::class)->create($attributes);
-        $user->socialNetworks()->create([]);
-
-        return $user;
+        return factory(User::class)->create($attributes);
     }
 
     /**
@@ -143,6 +143,20 @@ class FunctionalTestCase extends TestCase
         return $user;
     }
 
+    /**
+     * @param User $user
+     * @param $permission
+     */
+    public function addPermissionForUser(User $user, $permission)
+    {
+        $permissions = (array) $permission;
+
+        foreach ($permissions as $perm) {
+            $permObj = Permission::firstOrCreate(['name' => $perm]);
+            $user->role->attachPermission($permObj);
+        }
+    }
+
     public function seeInTable($selector, $text, $rowNumber, $columnNumber, $negate = false)
     {
         $fullSelector = "{$selector} tbody tr:nth-child({$rowNumber}) > td:nth-child({$columnNumber})";
@@ -165,4 +179,13 @@ class FunctionalTestCase extends TestCase
         $link = $this->crawler->filter($selector)->first();
         return $this->visit($link->link()->getUri());
     }
+
+    protected function refreshApp()
+    {
+        $this->refreshApplication();
+
+        if ($this->isSQLiteConnection()) {
+            $this->executeCallbacks();
+        }
+    }
 }
diff --git a/tests/Feature/Http/Controllers/Api/ActivityControllerTest.php b/tests/Feature/Http/Controllers/Api/ActivityControllerTest.php
new file mode 100644
index 0000000..9a87438
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/ActivityControllerTest.php
@@ -0,0 +1,118 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api;
+
+use Tests\Feature\ApiTestCase;
+use Vanguard\Services\Logging\UserActivity\Activity;
+use Vanguard\Transformers\ActivityTransformer;
+use Vanguard\User;
+
+class ActivityControllerTest extends ApiTestCase
+{
+    public function test_unauthenticated()
+    {
+        $this->getJson('/api/activity')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_activities_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->getJson('/api/activity')
+            ->assertResponseStatus(403);
+    }
+
+    public function test_paginate_activities()
+    {
+        $user = $this->getUser();
+        $user2 = factory(User::class)->create();
+
+        $activities = factory(Activity::class)->times(25)->create([
+            'user_id' => $user->id
+        ]);
+
+        factory(Activity::class)->times(10)->create([
+            'user_id' => $user2->id
+        ]);
+
+        $this->getJson("/api/activity");
+
+        $transformed = $this->transformCollection(
+            $activities->take(20),
+            new ActivityTransformer
+        );
+
+        $response = $this->decodeResponseJson();
+
+        $this->assertEquals($response['data'], $transformed);
+        $this->assertEquals($response['meta'], [
+            'current_page' => 1,
+            'from' => 1,
+            'to' => 20,
+            'last_page' => 2,
+            'prev_page_url' => null,
+            'next_page_url' => url("api/activity?page=2"),
+            'total' => 35,
+            'per_page' => 20
+        ]);
+    }
+
+    public function test_paginate_activities_with_search_param()
+    {
+        $user = $this->getUser();
+
+        $set1 = factory(Activity::class)->times(10)->create([
+            'user_id' => $user->id,
+            'description' => 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
+        ]);
+
+        $set2 = factory(Activity::class)->times(5)->create([
+            'user_id' => $user->id,
+            'description' => 'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris...'
+        ]);
+
+        $transformed = $this->transformCollection(
+            $set2,
+            new ActivityTransformer
+        );
+
+        $this->getJson("/api/activity?search=minim&per_page=10");
+
+        $response = $this->decodeResponseJson();
+
+        $this->assertEquals($response['data'], $transformed);
+        $this->assertEquals($response['meta'], [
+            'current_page' => 1,
+            'from' => 1,
+            'to' => 5,
+            'last_page' => 1,
+            'prev_page_url' => null,
+            'next_page_url' => null,
+            'total' => 5,
+            'per_page' => 10
+        ]);
+    }
+
+    public function test_paginate_activities_with_more_records_per_page_than_allowed()
+    {
+        $user = $this->getUser();
+
+        $this->getJson("/api/activity?per_page=140");
+
+        $this->seeStatusCode(422);
+    }
+
+    /**
+     * @return mixed
+     */
+    private function getUser()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.activity');
+
+        return $user;
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Auth/AuthControllerTest.php b/tests/Feature/Http/Controllers/Api/Auth/AuthControllerTest.php
new file mode 100644
index 0000000..c01fc31
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Auth/AuthControllerTest.php
@@ -0,0 +1,99 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Auth;
+
+use Carbon\Carbon;
+use Tests\Feature\ApiTestCase;
+use Tests\MailTrap;
+use Vanguard\Services\Auth\Api\Token;
+use Vanguard\User;
+
+class AuthControllerTest extends ApiTestCase
+{
+    use MailTrap;
+
+    public function test_login()
+    {
+        $credentials = [
+            'username' => 'foo',
+            'password' => 'bar'
+        ];
+
+        Carbon::setTestNow(Carbon::now());
+
+        $user = factory(User::class)->create($credentials);
+
+        $this->postJson("/api/login", $credentials);
+
+        $token = Token::where('user_id', $user->id)->first();
+
+        $this->assertJwtTokenContains($token->id);
+    }
+
+    public function test_login_with_invalid_credentials()
+    {
+        $credentials = [
+            'username' => 'foo',
+            'password' => 'bar'
+        ];
+
+        factory(User::class)->create($credentials);
+
+        $this->postJson("/api/login", [
+            'username' => 'foo',
+            'password' => 'invalid'
+        ]);
+
+        $this->assertResponseStatus(401);
+        $this->seeJsonContains([
+            'error' => "Invalid credentials."
+        ]);
+    }
+
+    public function test_login_when_credentials_are_not_provided()
+    {
+        $this->postJson("/api/login");
+
+        $this->assertResponseStatus(422);
+        $this->seeJsonContains([
+            'username' => [
+                trans('validation.required', ['attribute' => 'username'])
+            ],
+            'password' => [
+                trans('validation.required', ['attribute' => 'password'])
+            ]
+        ]);
+    }
+
+    public function test_logout()
+    {
+        $credentials = [
+            'username' => 'foo',
+            'password' => 'bar'
+        ];
+
+        Carbon::setTestNow(Carbon::now());
+
+        $user = factory(User::class)->create($credentials);
+
+        $this->postJson("/api/login", $credentials);
+
+        $token = Token::where('user_id', $user->id)->first();
+
+        $response = $this->decodeResponseJson();
+
+        $this->postJson("/api/logout", [], [
+            'Authorization' => "Bearer {$response['token']}"
+        ]);
+
+        $this->dontSeeInDatabase('api_tokens', ['id' => $token->id])
+            ->assertNull(auth('api')->user());
+    }
+
+    public function test_logout_if_token_is_not_provided()
+    {
+        $this->postJson("/api/logout");
+
+        $this->assertResponseStatus(401);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Auth/Password/RemindControllerTest.php b/tests/Feature/Http/Controllers/Api/Auth/Password/RemindControllerTest.php
new file mode 100644
index 0000000..4cb7132
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Auth/Password/RemindControllerTest.php
@@ -0,0 +1,57 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Auth\Password;
+
+use Carbon\Carbon;
+use Tests\Feature\ApiTestCase;
+use Tests\MailTrap;
+use Vanguard\Events\User\RequestedPasswordResetEmail;
+use Vanguard\Services\Auth\Api\Token;
+use Vanguard\User;
+
+class RemindControllerTest extends ApiTestCase
+{
+    use MailTrap;
+
+    public function test_send_password_reminder()
+    {
+        factory(User::class)->create(['email' => 'test@test.com']);
+
+//        $this->expectsEvents(RequestedPasswordResetEmail::class);
+
+        $this->postJson('api/password/remind', [
+            'email' => 'test@test.com'
+        ]);
+
+        $this->assertResponseOk();
+
+        $message = $this->fetchInbox()[0];
+
+        $this->assertEquals('test@test.com', $message['to_email']);
+        $this->assertEquals(config('mail.from.address'), $message['from_email']);
+        $this->assertEquals(config('mail.from.name'), $message['from_name']);
+        $this->assertContains(
+            trans('app.request_for_password_reset_made'),
+            $message['html_body']
+        );
+
+        $this->assertContains(
+            trans('app.if_you_did_not_requested'),
+            $message['html_body']
+        );
+
+        $this->emptyInbox();
+    }
+
+    public function test_password_reminder_with_wrong_email()
+    {
+        $this->postJson('api/password/remind', [
+            'email' => 'test@test.com'
+        ]);
+
+        $this->assertResponseStatus(422)
+            ->seeJsonEquals([
+                'email' => ['The selected email is invalid.']
+            ]);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Auth/Password/ResetControllerTest.php b/tests/Feature/Http/Controllers/Api/Auth/Password/ResetControllerTest.php
new file mode 100644
index 0000000..b12fc4e
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Auth/Password/ResetControllerTest.php
@@ -0,0 +1,106 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Auth\Password;
+
+use Carbon\Carbon;
+use DB;
+use Hash;
+use Illuminate\Support\Str;
+use Tests\Feature\ApiTestCase;
+use Tests\MailTrap;
+use Vanguard\User;
+
+class ResetControllerTest extends ApiTestCase
+{
+    use MailTrap;
+
+    public function test_password_reset()
+    {
+        $this->setSettings(['forgot_password' => true]);
+
+        $user = factory(User::class)->create([
+            'email' => 'test@test.com'
+        ]);
+
+        $token = $this->createNewToken();
+
+        DB::table('password_resets')->insert([
+            'email' => $user->email,
+            'token' => Hash::make($token),
+            'created_at' => Carbon::now()
+        ]);
+
+        $this->resetPassword($token, $user->email);
+
+        $this->assertResponseOk();
+
+        $user = $user->fresh();
+
+        $this->assertTrue(Hash::check('123123', $user->password));
+    }
+
+    public function test_password_reset_with_expired_token()
+    {
+        $this->setSettings(['forgot_password' => true]);
+
+        $user = factory(User::class)->create([
+            'email' => 'test@test.com'
+        ]);
+
+        $token = $this->createNewToken();
+
+        DB::table('password_resets')->insert([
+            'email' => $user->email,
+            'token' => Hash::make($token),
+            'created_at' => Carbon::now()->subHours(2)
+        ]);
+
+        $this->resetPassword($token, $user->email);
+
+        $this->seeJsonEquals([
+            'error' => "This password reset token is invalid."
+        ]);
+    }
+
+    public function test_password_reset_with_invalid_email()
+    {
+        $this->setSettings(['forgot_password' => true]);
+
+        $user = factory(User::class)->create(['email' => 'test@test.com']);
+
+        $token = $this->createNewToken();
+
+        DB::table('password_resets')->insert([
+            'email' => $user->email,
+            'token' => Hash::make($token),
+            'created_at' => Carbon::now()
+        ]);
+
+        $this->resetPassword($token, 'foo@bar.com');
+
+        $this->seeJsonContains([
+            'error' => "We can't find a user with that e-mail address."
+        ]);
+    }
+
+    private function resetPassword($token, $email)
+    {
+        $this->postJson('api/password/reset', [
+            'token' => $token,
+            'email' => $email,
+            'password' => '123123',
+            'password_confirmation' => '123123'
+        ]);
+    }
+
+    private function createNewToken()
+    {
+        $key = $this->app['config']['app.key'];
+
+        if (Str::startsWith($key, 'base64:')) {
+            $key = base64_decode(substr($key, 7));
+        }
+
+        return hash_hmac('sha256', Str::random(40), $key);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Auth/RegistrationControllerTest.php b/tests/Feature/Http/Controllers/Api/Auth/RegistrationControllerTest.php
new file mode 100644
index 0000000..eefbf25
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Auth/RegistrationControllerTest.php
@@ -0,0 +1,125 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Auth;
+
+use Tests\Feature\ApiTestCase;
+use Tests\MailTrap;
+use Vanguard\User;
+
+class RegistrationControllerTest extends ApiTestCase
+{
+    use MailTrap;
+
+    public function test_register_user_when_registration_is_disabled()
+    {
+        $this->setSettings([
+            'reg_enabled' => false
+        ]);
+
+        $this->postJson('api/register');
+
+        $this->assertResponseStatus(404);
+    }
+
+    public function test_register_user()
+    {
+        $this->setSettings([
+            'reg_enabled' => true,
+            'reg_email_confirmation' => false,
+            'registration.captcha.enabled' => false,
+            'tos' => false
+        ]);
+
+        $data = [
+            'email' => 'john.doe@test.com',
+            'username' => 'john.doe',
+            'password' => '123123',
+            'password_confirmation' => '123123'
+        ];
+
+        $this->postJson("/api/register", $data);
+
+        $expected = array_except($data, ['password', 'password_confirmation']);
+
+        $this->seeStatusCode(201)
+            ->seeJson([
+                'requires_email_confirmation' => false
+            ])
+            ->seeInDatabase('users', $expected);
+    }
+
+    public function test_register_user_with_email_confirmation()
+    {
+        $this->setSettings([
+            'reg_enabled' => true,
+            'reg_email_confirmation' => true,
+            'registration.captcha.enabled' => false,
+            'tos' => false
+        ]);
+
+        $data = [
+            'email' => 'john.doe@test.com',
+            'username' => 'john.doe',
+            'password' => '123123',
+            'password_confirmation' => '123123'
+        ];
+
+        $this->postJson("/api/register", $data);
+
+        $expected = array_except($data, ['password', 'password_confirmation']);
+
+        $this->seeStatusCode(201)
+            ->seeJson([
+                'requires_email_confirmation' => true
+            ])
+            ->seeInDatabase('users', $expected);
+
+        $token = User::where('email', $data['email'])->first()->confirmation_token;
+
+        $message = $this->fetchInbox()[0];
+
+        $this->assertEquals($data['email'], $message['to_email']);
+        $this->assertEquals(config('mail.from.address'), $message['from_email']);
+        $this->assertEquals(config('mail.from.name'), $message['from_name']);
+        $this->assertContains(
+            trans('app.thank_you_for_registering', ['app' => settings('app_name')]),
+            trim($message['html_body'])
+        );
+        $this->assertContains(
+            trans('app.confirm_email_on_link_below'),
+            trim($message['html_body'])
+        );
+        $this->assertContains(
+            route('register.confirm-email', $token),
+            trim($message['html_body'])
+        );
+
+        $this->emptyInbox();
+    }
+
+    public function test_register_with_tos()
+    {
+        $this->setSettings([
+            'reg_enabled' => true,
+            'reg_email_confirmation' => false,
+            'registration.captcha.enabled' => false,
+            'tos' => true
+        ]);
+
+        $data = [
+            'email' => 'john.doe@test.com',
+            'username' => 'john.doe',
+            'password' => '123123',
+            'password_confirmation' => '123123'
+        ];
+
+        $this->postJson("/api/register", $data);
+
+        $this->seeStatusCode(422)
+            ->seeJson([
+                'tos' => [
+                    trans('app.you_have_to_accept_tos')
+                ]
+            ]);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Auth/SocialLoginControllerTest.php b/tests/Feature/Http/Controllers/Api/Auth/SocialLoginControllerTest.php
new file mode 100644
index 0000000..fdb446b
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Auth/SocialLoginControllerTest.php
@@ -0,0 +1,181 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Auth;
+
+use Laravel\Socialite\Two\FacebookProvider;
+use Tests\Feature\ApiTestCase;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Services\Auth\Api\Token;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\User;
+use Mockery as m;
+use Laravel\Socialite\Contracts\User as SocialUserContract;
+
+class SocialLoginControllerTest extends ApiTestCase
+{
+    public function test_social_authentication_for_first_time()
+    {
+        $this->setSettings([
+            'reg_enabled' => true
+        ]);
+
+        $socialUser = new StubSocialUser;
+
+        $this->mockFacebookProvider($socialUser);
+
+        $this->postJson("/api/login/social", [
+            'network' => 'facebook',
+            'social_token' => 'foo'
+        ]);
+
+        $this->assertResponseOk();
+
+        $user = User::whereEmail($socialUser->getEmail())->first();
+
+        $token = Token::where('user_id', $user->id)->first();
+
+        $this->seeInDatabase('users', [
+            'first_name' => 'John',
+            'last_name' => 'Doe',
+            'email' => $socialUser->getEmail(),
+            'status' => UserStatus::ACTIVE,
+            'avatar' => $socialUser->getAvatar()
+        ]);
+
+        $this->seeInDatabase('social_logins', [
+            'user_id' => $user->id,
+            'provider' => 'facebook',
+            'provider_id' => $socialUser->getId(),
+            'avatar' => $socialUser->getAvatar()
+        ]);
+
+        $this->assertJwtTokenContains($token->id);
+    }
+
+    public function test_associate_social_account_with_existing_user()
+    {
+        $this->setSettings([
+            'reg_enabled' => true
+        ]);
+
+        $socialUser = new StubSocialUser;
+
+        $this->mockFacebookProvider($socialUser);
+
+        $user = factory(User::class)->create([
+            'email' => $socialUser->getEmail()
+        ]);
+
+        $this->postJson("/api/login/social", [
+            'network' => 'facebook',
+            'social_token' => 'foo'
+        ]);
+
+        $this->assertResponseOk();
+
+        $this->seeInDatabase('social_logins', [
+            'user_id' => $user->id,
+            'provider' => 'facebook',
+            'provider_id' => $socialUser->getId(),
+            'avatar' => $socialUser->getAvatar()
+        ]);
+
+        $token = Token::where('user_id', $user->id)->first();
+
+        $this->assertJwtTokenContains($token->id);
+    }
+
+    public function test_social_login_if_registration_is_disabled()
+    {
+        $this->setSettings([
+            'reg_enabled' => false
+        ]);
+
+        $socialUser = new StubSocialUser;
+
+        $this->mockFacebookProvider($socialUser);
+
+        $this->postJson("/api/login/social", [
+            'network' => 'facebook',
+            'social_token' => 'foo'
+        ]);
+
+        $this->assertResponseStatus(403)
+            ->seeJsonContains([
+                'error' => "Only users who already created an account can log in."
+            ]);
+    }
+
+    public function test_social_login_with_invalid_provider()
+    {
+        $this->postJson("/api/login/social", [
+            'network' => 'foo',
+            'social_token' => 'bar'
+        ]);
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'network' => [trans('validation.in', ['attribute' => 'network'])]
+            ]);
+    }
+
+    public function test_social_login_for_banned_user()
+    {
+        $socialUser = new StubSocialUser;
+
+        $this->mockFacebookProvider($socialUser);
+
+        $user = factory(User::class)->create([
+            'email' => $socialUser->getEmail(),
+            'status' => UserStatus::BANNED
+        ]);
+
+        app(UserRepository::class)->associateSocialAccountForUser($user->id, 'facebook', $socialUser);
+
+        $this->postJson("/api/login/social", [
+            'network' => 'facebook',
+            'social_token' => 'foo'
+        ]);
+
+        $this->assertResponseStatus(403)
+            ->seeJsonContains([
+                'error' => 'Your account is banned by administrators.'
+            ]);
+    }
+
+    private function mockFacebookProvider($socialUser)
+    {
+        $provider = m::mock(FacebookProvider::class);
+        $provider->shouldReceive('userFromToken')->with('foo')->andReturn($socialUser);
+
+        \Socialite::shouldReceive('driver')->with('facebook')->andReturn($provider);
+    }
+}
+
+class StubSocialUser implements SocialUserContract
+{
+    public function getId()
+    {
+        return '123';
+    }
+
+    public function getNickname()
+    {
+        return 'johndoe';
+    }
+
+    public function getName()
+    {
+        return 'John Doe';
+    }
+
+    public function getEmail()
+    {
+        return 'john@doe.com';
+    }
+
+    public function getAvatar()
+    {
+        return 'http://www.gravatar.com/avatar';
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Authorization/PermissionsControllerTest.php b/tests/Feature/Http/Controllers/Api/Authorization/PermissionsControllerTest.php
new file mode 100644
index 0000000..27a04f0
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Authorization/PermissionsControllerTest.php
@@ -0,0 +1,190 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Authorization;
+
+use Tests\Feature\ApiTestCase;
+use Vanguard\Permission;
+use Vanguard\Transformers\PermissionTransformer;
+use Vanguard\User;
+
+class PermissionsControllerTest extends ApiTestCase
+{
+    public function test_unauthenticated()
+    {
+        $this->getJson('/api/permissions')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_users_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->getJson('/api/permissions')
+            ->assertResponseStatus(403);
+    }
+
+    public function test_get_permissions()
+    {
+        $this->getUser();
+
+        factory(Permission::class)->times(3)->create();
+
+        $this->getJson("/api/permissions");
+
+        $permissions = Permission::all();
+
+        $this->assertResponseOk()
+            ->seeJsonEquals(
+                $this->transformCollection($permissions, new PermissionTransformer)
+            );
+
+        $response = $this->decodeResponseJson();
+
+        // 7 default permissions + 3 newly created
+        $this->assertCount(10, $response);
+    }
+
+    public function test_get_permission()
+    {
+        $this->getUser();
+
+        $permission = factory(Permission::class)->create();
+
+        $this->getJson("/api/permissions/{$permission->id}");
+
+        $this->assertResponseOk()
+            ->seeJsonEquals(
+                (new PermissionTransformer)->transform($permission)
+            );
+    }
+
+    public function test_create_permission()
+    {
+        $this->getUser();
+
+        $data = [
+            'name' => 'foo',
+            'display_name' => 'Foo Permission',
+            'description' => 'This is foo permission.'
+        ];
+
+        $this->postJson("/api/permissions", $data);
+
+        $this->assertResponseOk()
+            ->seeInDatabase('permissions', $data)
+            ->seeJsonContains($data);
+    }
+
+    public function test_create_permission_with_invalid_name()
+    {
+        $this->getUser();
+
+        $this->postJson("/api/permissions");
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'name' => [
+                    trans('validation.required', ['attribute' => 'name'])
+                ]
+            ]);
+
+        $existingPermission = Permission::first();
+
+        $this->postJson("/api/permissions", ['name' => $existingPermission->name]);
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'name' => [
+                    trans('app.permission_already_exists')
+                ]
+            ]);
+
+        $this->postJson("/api/permissions", ['name' => 'foo bar']);
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'name' => [
+                    trans('validation.regex', ['attribute' => 'name'])
+                ]
+            ]);
+    }
+
+    public function test_partially_update_permission()
+    {
+        $this->getUser();
+
+        $permission = factory(Permission::class)->create();
+
+        $data = ['name' => 'foo'];
+
+        $this->patchJson("/api/permissions/{$permission->id}", $data);
+
+        $expected = $data + ['id' => $permission->id];
+
+        $this->assertResponseOk()
+            ->seeInDatabase('permissions', $expected)
+            ->seeJsonContains($expected);
+    }
+
+    public function test_update_permission()
+    {
+        $this->getUser();
+
+        $permission = factory(Permission::class)->create();
+
+        $data = [
+            'name' => 'foo',
+            'display_name' => 'Foo Role',
+            'description' => 'This is foo role.'
+        ];
+
+        $this->patchJson("/api/permissions/{$permission->id}", $data);
+
+        $expected = $data + ['id' => $permission->id];
+
+        $this->assertResponseOk()
+            ->seeInDatabase('permissions', $expected)
+            ->seeJsonContains($expected);
+    }
+
+    public function test_remove_permission()
+    {
+        $this->getUser();
+
+        $permission = factory(Permission::class)->create([
+            'removable' => true
+        ]);
+
+        $this->deleteJson("/api/permissions/{$permission->id}");
+
+        $this->assertResponseOk()
+            ->seeJson(['success' => true])
+            ->dontSeeInDatabase('permissions', ['id' => $permission->id]);
+    }
+
+    public function test_remove_non_removable_permission()
+    {
+        $this->getUser();
+
+        $permission = factory(Permission::class)->create([
+            'removable' => false
+        ]);
+
+        $this->deleteJson("/api/permissions/{$permission->id}");
+
+        $this->seeStatusCode(403);
+    }
+
+    /**
+     * @return mixed
+     */
+    private function getUser()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'permissions.manage');
+
+        return $user;
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Authorization/RolePermissionsControllerTest.php b/tests/Feature/Http/Controllers/Api/Authorization/RolePermissionsControllerTest.php
new file mode 100644
index 0000000..5f1b363
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Authorization/RolePermissionsControllerTest.php
@@ -0,0 +1,90 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Authorization;
+
+use Tests\Feature\ApiTestCase;
+use Vanguard\Permission;
+use Vanguard\Role;
+use Vanguard\Transformers\PermissionTransformer;
+use Vanguard\User;
+
+class RolePermissionsControllerTest extends ApiTestCase
+{
+    public function test_unauthenticated()
+    {
+        $role = factory(Role::class)->create();
+
+        $this->getJson("/api/roles/{$role->id}/permissions")
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_settings_without_permission()
+    {
+        $role = factory(Role::class)->create();
+
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->getJson("/api/roles/{$role->id}/permissions")
+            ->assertResponseStatus(403);
+    }
+
+    public function test_get_role_permissions()
+    {
+        $user = $this->getUser();
+
+        $role = factory(Role::class)->create();
+        $permission = factory(Permission::class)->create();
+
+        $role->attachPermission($permission);
+
+        $this->getJson("/api/roles/{$role->id}/permissions");
+
+        $this->assertResponseOk()
+            ->seeJsonEquals(
+                $this->transformCollection(collect([$permission]), new PermissionTransformer)
+            );
+    }
+
+    public function test_update_role_permissions()
+    {
+        $user = $this->getUser();
+
+        $role = factory(Role::class)->create();
+        $permissions1 = factory(Permission::class)->times(2)->create();
+        $permissions2 = factory(Permission::class)->times(3)->create();
+
+        $role->attachPermissions($permissions1);
+
+        $this->putJson("/api/roles/{$role->id}/permissions", [
+            'permissions' => $permissions2->pluck('id')
+        ]);
+
+        $this->assertResponseOk();
+
+        foreach ($permissions2 as $perm) {
+            $this->seeInDatabase('permission_role', [
+                'permission_id' => $perm->id,
+                'role_id' => $role->id
+            ]);
+        }
+
+        $this->seeJson(
+            $this->transformCollection($permissions2, new PermissionTransformer)
+        );
+    }
+
+    /**
+     * @return mixed
+     */
+    private function getUser()
+    {
+        $user = factory(User::class)->create();
+
+        $this->addPermissionForUser($user, 'permissions.manage');
+
+        $this->be($user, 'api');
+
+        return $user;
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Authorization/RolesControllerTest.php b/tests/Feature/Http/Controllers/Api/Authorization/RolesControllerTest.php
new file mode 100644
index 0000000..367cfc8
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Authorization/RolesControllerTest.php
@@ -0,0 +1,203 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Authorization;
+
+use Carbon\Carbon;
+use Illuminate\Support\Collection;
+use Tests\Feature\ApiTestCase;
+use Tests\Feature\FunctionalTestCase;
+use Vanguard\Country;
+use Vanguard\Role;
+use Vanguard\Services\Logging\UserActivity\Activity;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\Transformers\ActivityTransformer;
+use Vanguard\Transformers\RoleTransformer;
+use Vanguard\Transformers\SessionTransformer;
+use Vanguard\Transformers\UserTransformer;
+use Vanguard\User;
+
+class RolesControllerTest extends ApiTestCase
+{
+    public function test_unauthenticated()
+    {
+        $this->getJson('/api/roles')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_settings_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->getJson('/api/roles')
+            ->assertResponseStatus(403);
+    }
+
+    public function test_get_roles()
+    {
+        $user = $this->getUser();
+
+        factory(Role::class)->times(4)->create();
+
+        $this->getJson("/api/roles");
+
+        $roles = Role::withCount('users')->get();
+
+        $this->assertResponseOk()
+            ->seeJsonEquals(
+                $this->transformCollection($roles, new RoleTransformer)
+            );
+
+        $response = $this->decodeResponseJson();
+
+        $this->assertCount(6, $response);
+    }
+
+    public function test_get_role()
+    {
+        $user = $this->getUser();
+
+        $userRole = Role::whereName('User')->first();
+
+        $this->getJson("/api/roles/{$userRole->id}");
+
+        $this->assertResponseOk()
+            ->seeJsonEquals(
+                (new RoleTransformer)->transform($userRole)
+            );
+    }
+
+    public function test_create_role()
+    {
+        $this->getUser();
+
+        $data = [
+            'name' => 'foo',
+            'display_name' => 'Foo Role',
+            'description' => 'This is foo role.'
+        ];
+
+        $this->postJson("/api/roles", $data);
+
+        $this->assertResponseOk()
+            ->seeInDatabase('roles', $data)
+            ->seeJsonContains($data);
+    }
+
+    public function test_create_role_with_invalid_name()
+    {
+        $this->getUser();
+
+        $this->postJson("/api/roles");
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'name' => [
+                    trans('validation.required', ['attribute' => 'name'])
+                ]
+            ]);
+
+        $this->postJson("/api/roles", ['name' => 'User']);
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'name' => [
+                    trans('validation.unique', ['attribute' => 'name'])
+                ]
+            ]);
+
+        $this->postJson("/api/roles", ['name' => 'foo bar']);
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'name' => [
+                    trans('validation.regex', ['attribute' => 'name'])
+                ]
+            ]);
+    }
+
+    public function test_update_role()
+    {
+        $user = $this->getUser();
+
+        $data = ['name' => 'foo'];
+
+        $this->patchJson("/api/roles/{$user->role_id}", $data);
+
+        $expected = $data + ['id' => $user->role_id];
+
+        $this->assertResponseOk()
+            ->seeInDatabase('roles', $expected)
+            ->seeJsonContains($expected);
+    }
+
+    public function test_partially_update_role()
+    {
+        $user = $this->getUser();
+
+        $data = [
+            'name' => 'foo',
+            'display_name' => 'Foo Role',
+            'description' => 'This is foo role.'
+        ];
+
+        $this->actingAs($user, 'api')->patchJson("/api/roles/{$user->role_id}", $data);
+
+        $expected = $data + ['id' => $user->role_id];
+
+        $this->assertResponseOk()
+            ->seeInDatabase('roles', $expected)
+            ->seeJsonContains($expected);
+    }
+
+    public function test_remove_role()
+    {
+        $userRole = Role::whereName('User')->first();
+
+        $role = factory(Role::class)->create();
+
+        $user = factory(User::class)->create([
+            'role_id' => $role->id,
+        ]);
+
+        $this->addPermissionForUser($user, 'roles.manage');
+
+        $this->actingAs($user, 'api')->deleteJson("/api/roles/{$role->id}");
+
+        $this->seeStatusCode(200)
+            ->seeJson(['success' => true])
+            ->dontSeeInDatabase('roles', ['id' => $role->id])
+            ->assertEquals($userRole->id, $user->fresh()->role_id);
+    }
+
+    public function test_remove_non_removable_role()
+    {
+        $this->getUser();
+
+        $role = factory(Role::class)->create([
+            'removable' => false
+        ]);
+
+        $this->deleteJson("/api/roles/{$role->id}");
+
+        $this->seeStatusCode(403);
+    }
+
+    /**
+     * @return mixed
+     */
+    private function getUser()
+    {
+        $userRole = Role::whereName('User')->first();
+
+        $user = factory(User::class)->create([
+            'role_id' => $userRole->id,
+        ]);
+
+        $this->addPermissionForUser($user, 'roles.manage');
+
+        $this->be($user, 'api');
+
+        return $user;
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/CountriesControllerTest.php b/tests/Feature/Http/Controllers/Api/CountriesControllerTest.php
new file mode 100644
index 0000000..888960d
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/CountriesControllerTest.php
@@ -0,0 +1,31 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api;
+
+use Tests\Feature\ApiTestCase;
+use Vanguard\Country;
+use Vanguard\Transformers\CountryTransformer;
+
+class CountriesControllerTest extends ApiTestCase
+{
+    public function test_unauthenticated()
+    {
+        $this->getJson('/api/countries')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_all_countries()
+    {
+        $this->login();
+
+        $this->getJson("/api/countries");
+
+        $transformed = $this->transformCollection(
+            Country::all(),
+            new CountryTransformer
+        );
+
+        $this->assertResponseOk()
+            ->seeJson($transformed);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Profile/AvatarControllerTest.php b/tests/Feature/Http/Controllers/Api/Profile/AvatarControllerTest.php
new file mode 100644
index 0000000..0f2d35f
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Profile/AvatarControllerTest.php
@@ -0,0 +1,114 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Profile;
+
+use Illuminate\Http\UploadedFile;
+use Tests\Feature\ApiTestCase;
+
+class AvatarControllerTest extends ApiTestCase
+{
+    public function test_only_authenticated_user_can_update_avatar()
+    {
+        $this->putJson('/api/me/avatar');
+
+        $this->assertResponseStatus(401);
+    }
+
+    public function test_upload_avatar_image()
+    {
+        $this->login();
+
+        $file = UploadedFile::fake()->image('avatar.png', 500, 500);
+
+        $fileContent = file_get_contents($file->getRealPath());
+
+        $server = $this->transformHeadersToServerVars([
+            'Accept' => 'application/json',
+            'Content-Type' => 'image/jpeg'
+        ]);
+
+        $this->call('PUT', '/api/me/avatar', [], [], [], $server, $fileContent);
+
+        $response = $this->decodeResponseJson();
+
+        $this->seeStatusCode(200)
+            ->assertNotNull($response['avatar']);
+
+        $uploadedFile = str_replace(url(''), '', $response['avatar']);
+        $uploadedFile = public_path(ltrim($uploadedFile, "/"));
+
+        $this->assertFileExists($uploadedFile);
+
+        list($width, $height) = getimagesize($uploadedFile);
+
+        $this->assertEquals(160, $width);
+        $this->assertEquals(160, $height);
+
+        @unlink($uploadedFile);
+    }
+
+    public function test_upload_invalid_image()
+    {
+        $this->login();
+
+        $file = UploadedFile::fake()->create('avatar.png', 500);
+
+        $fileContent = file_get_contents($file->getRealPath());
+
+        $server = $this->transformHeadersToServerVars([
+            'Accept' => 'application/json',
+            'Content-Type' => 'image/jpeg'
+        ]);
+
+        $this->call('PUT', '/api/me/avatar', [], [], [], $server, $fileContent);
+
+        $this->seeStatusCode(422)
+            ->seeJsonContains([
+                'file' => [
+                    trans('validation.image', ['attribute' => 'file'])
+                ]
+            ]);
+    }
+
+    public function test_update_avatar_from_external_source()
+    {
+        $this->login();
+
+        $url = 'http://google.com';
+
+        $this->putJson('/api/me/avatar/external', [
+            'url' => $url
+        ]);
+
+        $this->assertResponseOk();
+        $this->seeJsonContains([
+            'avatar' => $url
+        ]);
+    }
+
+    public function test_update_avatar_with_invalid_external_source()
+    {
+        $this->login();
+
+        $this->putJson('/api/me/avatar/external', [
+            'url' => 'foo'
+        ]);
+
+        $this->assertResponseStatus(422);
+    }
+
+    public function test_delete_avatar()
+    {
+        $user = $this->login();
+
+        $user->forceFill([
+            'avatar' => 'http://google.com'
+        ])->save();
+
+        $this->deleteJson("api/me/avatar")
+            ->assertResponseOk()
+            ->seeJsonContains([
+                'avatar' => url('assets/img/profile.png') // default profile image
+            ]);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Profile/DetailsControllerTest.php b/tests/Feature/Http/Controllers/Api/Profile/DetailsControllerTest.php
new file mode 100644
index 0000000..a88fccc
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Profile/DetailsControllerTest.php
@@ -0,0 +1,125 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Profile;
+
+use Carbon\Carbon;
+use Tests\Feature\ApiTestCase;
+use Vanguard\Transformers\UserTransformer;
+
+class DetailsControllerTest extends ApiTestCase
+{
+    public function test_get_user_profile_unauthenticated()
+    {
+        $this->getJson('/api/me')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_user_profile()
+    {
+        $user = $this->login();
+
+        $transformed = (new UserTransformer)->transform($user);
+
+        $this->getJson('/api/me')
+            ->seeStatusCode(200)
+            ->seeJson($transformed);
+    }
+
+    public function test_update_user_profile_unauthenticated()
+    {
+        $this->patchJson('/api/me/details')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_update_user_profile()
+    {
+        $user = $this->login();
+
+        $data = $this->getData();
+
+        $this->patchJson("/api/me/details", $data);
+
+        $transformed = (new UserTransformer)->transform($user->fresh());
+
+        $this->seeJson($transformed);
+
+        $this->seeInDatabase('users', array_merge($data, [
+            'id' => $user->id
+        ]));
+    }
+
+    public function test_partially_update_user_details()
+    {
+        $user = $this->login();
+
+        $data = [
+            'first_name' => 'John',
+            'last_name'  => 'Doe'
+        ];
+
+        $this->patchJson("/api/me/details", $data);
+
+        $transformed = (new UserTransformer)->transform($user->fresh());
+
+        $this->seeJson($transformed);
+
+        $this->seeInDatabase('users', array_merge($data, [
+            'id' => $user->id,
+            'birthday' => $user->birthday->format('Y-m-d'),
+            'phone' => $user->phone,
+            'address' => $user->address,
+            'country_id' => $user->country_id,
+        ]));
+    }
+
+    public function test_update_without_country_id()
+    {
+        $user = $this->login();
+
+        $data = $this->getData();
+
+        unset($data['country_id']);
+
+        $this->patchJson("/api/me/details", $data);
+
+        $transformed = (new UserTransformer)->transform($user->fresh());
+
+        $this->seeJson($transformed);
+
+        $this->seeInDatabase('users', array_merge($data, [
+            'id' => $user->id
+        ]));
+    }
+
+    public function test_update_with_invalid_date_format()
+    {
+        $this->login();
+
+        $this->patchJson("/api/me/details", [
+            'birthday' => 'foo'
+        ]);
+
+        $this->assertResponseStatus(422);
+
+        $this->seeJson([
+            'birthday' => [
+                trans('validation.date', ['attribute' => 'birthday'])
+            ]
+        ]);
+    }
+
+    /**
+     * @return array
+     */
+    private function getData(array $attrs = [])
+    {
+        return array_merge([
+            'first_name' => 'John',
+            'last_name'  => 'Doe',
+            'birthday'   => Carbon::now()->subYears(25)->format('Y-m-d'),
+            'phone'      => '(123) 456 789',
+            'address'    => 'some address 1',
+            'country_id' => 688,
+        ], $attrs);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Profile/SessionsControllerTest.php b/tests/Feature/Http/Controllers/Api/Profile/SessionsControllerTest.php
new file mode 100644
index 0000000..e54912d
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Profile/SessionsControllerTest.php
@@ -0,0 +1,69 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Profile;
+
+use Tests\Feature\ApiTestCase;
+use Vanguard\Transformers\SessionTransformer;
+use Vanguard\User;
+
+class SessionsControllerTest extends ApiTestCase
+{
+    public function test_get_user_sessions_unauthenticated()
+    {
+        $this->getJson('/api/me/sessions')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_sessions_if_non_database_driver_is_used()
+    {
+        putenv('SESSION_DRIVER=array');
+
+        $this->refreshApp();
+
+        $this->login();
+
+        $this->getJson('/api/me/sessions')
+            ->assertResponseStatus(404);
+    }
+
+    public function test_get_user_sessions()
+    {
+        putenv('SESSION_DRIVER=database');
+
+        $this->refreshApp();
+
+        $user = $this->login();
+
+        $sessions = $this->generateNonExpiredSessions($user);
+
+        $this->getJson('/api/me/sessions')
+            ->seeStatusCode(200)
+            ->seeJson(
+                $this->transformCollection(collect($sessions), new SessionTransformer)
+            );
+    }
+
+    private function generateNonExpiredSessions(User $user, $count = 5)
+    {
+        $sessions = [];
+        $faker = $this->app->make(\Faker\Generator::class);
+        $lifetime = config('session.lifetime') - 1;
+
+        for ($i = 0; $i < $count; $i++) {
+            array_push($sessions, [
+                'id' => str_random(40),
+                'user_id' => $user->id,
+                'ip_address' => $faker->ipv4,
+                'user_agent' => $faker->userAgent,
+                'payload' => str_random(),
+                'last_activity' => $faker->dateTimeBetween("-{$lifetime} minutes")->getTimestamp()
+            ]);
+        }
+
+        \DB::table('sessions')->insert($sessions);
+
+        return \DB::table('sessions')
+            ->where('user_id', $user->id)
+            ->get();
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Profile/TwoFactorControllerTest.php b/tests/Feature/Http/Controllers/Api/Profile/TwoFactorControllerTest.php
new file mode 100644
index 0000000..f87a6ab
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Profile/TwoFactorControllerTest.php
@@ -0,0 +1,108 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Profile;
+
+use Authy;
+use Settings;
+use Tests\Feature\ApiTestCase;
+use Vanguard\Transformers\UserTransformer;
+use Vanguard\User;
+
+class TwoFactorControllerTest extends ApiTestCase
+{
+    public function test_update_2fa_unathenticated()
+    {
+        $user = factory(User::class)->create();
+
+        $this->putJson("api/me/2fa")
+            ->assertResponseStatus(401);
+    }
+
+    public function test_enable_two_factor_auth()
+    {
+        $user = $this->login();
+
+        Settings::set('2fa.enabled', true);
+
+        Authy::shouldReceive('isEnabled')->andReturn(false);
+        Authy::shouldReceive('register')->andReturnNull();
+
+        $data = ['country_code' => '1', 'phone_number' => '123'];
+ 
+        $this->putJson("api/me/2fa", $data);
+
+        $transformer = new UserTransformer;
+        $updatedUser = $transformer->transform($user->fresh());
+
+        $this->assertResponseOk()
+            ->seeInDatabase('users', [
+                'id' => $user->id,
+                'two_factor_country_code' => $data['country_code'],
+                'two_factor_phone' => $data['phone_number']
+            ])
+            ->seeJsonContains($updatedUser);
+    }
+
+    public function test_enable_two_factor_auth_when_it_is_already_enabled()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        Settings::set('2fa.enabled', true);
+
+        Authy::shouldReceive('isEnabled')->andReturn(true);
+
+        $data = ['country_code' => '1', 'phone_number' => '123'];
+
+        $this->putJson("api/me/2fa", $data);
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'error' => '2FA is already enabled for this user.'
+            ]);
+    }
+
+    public function test_disable_two_factor_auth()
+    {
+        $user = factory(User::class)->create([
+            'two_factor_country_code' => '1',
+            'two_factor_phone' => '123'
+        ]);
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $this->be($user, 'api');
+
+        Settings::set('2fa.enabled', true);
+
+        Authy::shouldReceive('isEnabled')->andReturn(true);
+        Authy::shouldReceive('delete')->andReturnNull();
+
+        $this->deleteJson("api/me/2fa");
+
+        $transformer = new UserTransformer;
+        $user = $transformer->transform($user->fresh());
+
+        $this->assertResponseOk()
+            ->seeJsonContains($user);
+    }
+
+    public function test_disable_2fa_when_it_is_already_disabled()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        Settings::set('2fa.enabled', true);
+
+        Authy::shouldReceive('isEnabled')->andReturn(false);
+
+        $this->deleteJson("api/me/2fa");
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'error' => '2FA is not enabled for this user.'
+            ]);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/SessionsControllerTest.php b/tests/Feature/Http/Controllers/Api/SessionsControllerTest.php
new file mode 100644
index 0000000..b418490
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/SessionsControllerTest.php
@@ -0,0 +1,113 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api;
+
+use Carbon\Carbon;
+use Tests\Feature\ApiTestCase;
+use Tests\Feature\FunctionalTestCase;
+use Vanguard\Transformers\SessionTransformer;
+use Vanguard\User;
+
+class SessionsControllerTest extends ApiTestCase
+{
+    public function setUp()
+    {
+        parent::setUp();
+
+        config(['session.driver' => 'database']);
+    }
+
+    public function test_unauthenticated()
+    {
+        $user = factory(User::class)->create();
+
+        $session = $this->createSession($user);
+
+        $this->getJson("/api/sessions/{$session->id}")
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_session_which_belongs_to_other_user()
+    {
+        $user = $this->login();
+        $user2 = factory(User::class)->create();
+
+        $session = $this->createSession($user2);
+
+        $this->getJson("/api/sessions/{$session->id}")
+            ->assertResponseStatus(403);
+    }
+
+    public function test_get_session()
+    {
+        $user = $this->login();
+
+        $session = $this->createSession($user);
+
+        $this->getJson("/api/sessions/{$session->id}")
+            ->seeStatusCode(200)
+            ->seeJson(
+                (new SessionTransformer)->transform($session)
+            );
+    }
+
+    public function test_invalidate_his_own_session()
+    {
+        $user = $this->login();
+
+        $session = $this->createSession($user);
+
+        $this->deleteJson("/api/sessions/{$session->id}")
+            ->seeStatusCode(200)
+            ->seeJson([
+                'success' => true
+            ]);
+    }
+
+    public function test_invalidate_session_for_other_user()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $user2 = factory(User::class)->create();
+
+        $session = $this->createSession($user2);
+
+        $this->deleteJson("/api/sessions/{$session->id}")
+            ->seeStatusCode(200)
+            ->seeJson([
+                'success' => true
+            ]);
+    }
+
+    public function test_invalidate_session_for_other_user_without_permission()
+    {
+        $user = $this->login();
+
+        $user2 = factory(User::class)->create();
+
+        $session = $this->createSession($user2);
+
+        $this->deleteJson("/api/sessions/{$session->id}")
+            ->seeStatusCode(403);
+    }
+
+    private function createSession(User $user)
+    {
+        $sessionId = str_random(40);
+
+        $data = [
+            'id' => $sessionId,
+            'user_id' => $user->id,
+            'ip_address' => "127.0.0.1",
+            'user_agent' => 'foo',
+            'payload' => str_random(),
+            'last_activity' => Carbon::now()->timestamp
+        ];
+
+        \DB::table('sessions')->insert($data);
+
+        return (object) $data;
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/SettingsControllerTest.php b/tests/Feature/Http/Controllers/Api/SettingsControllerTest.php
new file mode 100644
index 0000000..c629591
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/SettingsControllerTest.php
@@ -0,0 +1,37 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api;
+
+use Settings;
+use Tests\Feature\ApiTestCase;
+use Vanguard\User;
+
+class SettingsControllerTest extends ApiTestCase
+{
+    public function test_unauthenticated()
+    {
+        $this->getJson('/api/settings')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_settings_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->getJson('/api/settings')
+            ->assertResponseStatus(403);
+    }
+
+    public function test_get_settings()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'settings.general');
+
+        $this->getJson("/api/settings");
+
+        $this->assertResponseOk()
+            ->seeJsonEquals(Settings::all());
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/StatsControllerTest.php b/tests/Feature/Http/Controllers/Api/StatsControllerTest.php
new file mode 100644
index 0000000..6301f4b
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/StatsControllerTest.php
@@ -0,0 +1,108 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api;
+
+use Carbon\Carbon;
+use Illuminate\Support\Collection;
+use Tests\Feature\ApiTestCase;
+use Tests\Feature\FunctionalTestCase;
+use Vanguard\Country;
+use Vanguard\Repositories\Activity\ActivityRepository;
+use Vanguard\Repositories\User\UserRepository;
+use Vanguard\Role;
+use Vanguard\Services\Logging\UserActivity\Activity;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\Transformers\ActivityTransformer;
+use Vanguard\Transformers\RoleTransformer;
+use Vanguard\Transformers\SessionTransformer;
+use Vanguard\Transformers\UserTransformer;
+use Vanguard\User;
+
+class StatsControllerTest extends ApiTestCase
+{
+    public function test_unauthenticated()
+    {
+        $this->getJson('/api/stats')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_stats_as_admin()
+    {
+        $adminRole = Role::whereName('Admin')->first();
+
+        $user = factory(User::class)->create([
+            'role_id' => $adminRole->id,
+        ]);
+
+        $this->be($user, 'api');
+
+        Carbon::setTestNow(Carbon::now()->startOfYear());
+
+        $activeUsers = factory(User::class)->times(4)->create([
+            'status' => UserStatus::ACTIVE
+        ]);
+
+        Carbon::setTestNow(null);
+
+        $bannedUsers = factory(User::class)->times(2)->create([
+            'status' => UserStatus::BANNED
+        ]);
+
+        $unconfirmedUsers = factory(User::class)->times(7)->create([
+            'status' => UserStatus::UNCONFIRMED
+        ]);
+
+        $users = app(UserRepository::class);
+
+        $this->getJson("/api/stats");
+
+        $usersPerMonth = $users->countOfNewUsersPerMonth(
+            Carbon::now()->startOfYear(),
+            Carbon::now()
+        );
+
+        $latestRegistrations = $users->latest(7);
+
+        $this->assertResponseOk()
+            ->seeJsonContains([
+                'users_per_month' => $usersPerMonth,
+                'users_per_status' => [
+                    'total' => 14,
+                    'new' => $users->newUsersCount(),
+                    'banned' => 2,
+                    'unconfirmed' => 7
+                ],
+                'latest_registrations' => $this->transformCollection($latestRegistrations, new UserTransformer)
+            ]);
+    }
+
+    public function test_get_stats_as_non_admin_user()
+    {
+        $user = factory(User::class)->create();
+
+        $this->be($user, 'api');
+
+        Carbon::setTestNow(Carbon::now()->subWeek());
+
+        factory(Activity::class)->times(5)->create([
+            'user_id' => $user->id
+        ]);
+
+        Carbon::setTestNow(null);
+
+        factory(Activity::class)->times(5)->create([
+            'user_id' => $user->id
+        ]);
+
+        $this->getJson("/api/stats");
+
+        $expected = app(ActivityRepository::class)->userActivityForPeriod(
+            $user->id,
+            Carbon::now()->subWeek(2),
+            Carbon::now()
+        )->toArray();
+
+        $this->assertResponseOk()
+            ->seeJsonEquals($expected);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Users/ActivityControllerTest.php b/tests/Feature/Http/Controllers/Api/Users/ActivityControllerTest.php
new file mode 100644
index 0000000..f23e14f
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Users/ActivityControllerTest.php
@@ -0,0 +1,109 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Users;
+
+use Tests\Feature\ApiTestCase;
+use Vanguard\Services\Logging\UserActivity\Activity;
+use Vanguard\Transformers\ActivityTransformer;
+use Vanguard\User;
+
+class ActivityControllerTest extends ApiTestCase
+{
+    public function test_auth()
+    {
+        $user = factory(User::class)->create();
+
+        $this->getJson("/api/users/{$user->id}/activity")
+            ->assertResponseStatus(401);
+    }
+
+    public function test_cannot_view_user_activity_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->getJson("/api/users/{$user->id}/activity")
+            ->assertResponseStatus(403);
+    }
+
+    public function test_paginate_activities_for_user()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.activity');
+
+        $activities = factory(Activity::class)->times(25)->create([
+            'user_id' => $user->id
+        ]);
+
+        $this->getJson("/api/users/{$user->id}/activity");
+
+        $transformed = $this->transformCollection(
+            $activities->take(20),
+            new ActivityTransformer
+        );
+
+        $response = $this->decodeResponseJson();
+
+        $this->assertEquals($response['data'], $transformed);
+        $this->assertEquals($response['meta'], [
+            'current_page' => 1,
+            'from' => 1,
+            'to' => 20,
+            'last_page' => 2,
+            'prev_page_url' => null,
+            'next_page_url' => url("api/users/{$user->id}/activity?page=2"),
+            'total' => 25,
+            'per_page' => 20
+        ]);
+    }
+
+    public function test_paginate_activities_for_user_with_search_param()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.activity');
+
+        $set1 = factory(Activity::class)->times(10)->create([
+            'user_id' => $user->id,
+            'description' => 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
+        ]);
+
+        $set2 = factory(Activity::class)->times(5)->create([
+            'user_id' => $user->id,
+            'description' => 'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris...'
+        ]);
+
+        $transformed = $this->transformCollection(
+            $set2,
+            new ActivityTransformer
+        );
+
+        $this->getJson("/api/users/{$user->id}/activity?search=minim&per_page=10");
+
+        $response = $this->decodeResponseJson();
+
+        $this->assertEquals($response['data'], $transformed);
+        $this->assertEquals($response['meta'], [
+            'current_page' => 1,
+            'from' => 1,
+            'to' => 5,
+            'last_page' => 1,
+            'prev_page_url' => null,
+            'next_page_url' => null,
+            'total' => 5,
+            'per_page' => 10
+        ]);
+    }
+
+    public function test_paginate_activities_for_user_with_more_activities_per_page_than_allowed()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.activity');
+
+        $this->getJson("/api/users/{$user->id}/activity?per_page=140");
+
+        $this->seeStatusCode(422);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Users/AvatarControllerTest.php b/tests/Feature/Http/Controllers/Api/Users/AvatarControllerTest.php
new file mode 100644
index 0000000..a738a1e
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Users/AvatarControllerTest.php
@@ -0,0 +1,154 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Users;
+
+use Illuminate\Http\UploadedFile;
+use Tests\Feature\ApiTestCase;
+use Vanguard\Events\User\UpdatedByAdmin;
+use Vanguard\User;
+
+class AvatarControllerTest extends ApiTestCase
+{
+    public function test_upload_user_avatar_unauthenticated()
+    {
+        $user = factory(User::class)->create();
+
+        $server = $this->transformHeadersToServerVars([
+            'Accept' => 'application/json',
+            'Content-Type' => 'image/jpeg'
+        ]);
+
+        $this->call('PUT', "/api/users/{$user->id}/avatar", [], [], [], $server);
+
+        $this->assertResponseStatus(401);
+    }
+
+    public function test_upload_avatar_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $server = $this->transformHeadersToServerVars([
+            'Accept' => 'application/json',
+            'Content-Type' => 'image/jpeg'
+        ]);
+
+        $this->actingAs($user, 'api')
+            ->call('PUT', "/api/users/{$user->id}/avatar", [], [], [], $server);
+
+        $this->assertResponseStatus(403);
+    }
+
+    public function test_upload_avatar_image()
+    {
+        $this->expectsEvents(UpdatedByAdmin::class);
+
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $file = UploadedFile::fake()->image('avatar.png', 500, 500);
+
+        $fileContent = file_get_contents($file->getRealPath());
+
+        $server = $this->transformHeadersToServerVars([
+            'Accept' => 'application/json',
+            'Content-Type' => 'image/jpeg'
+        ]);
+
+        $this->call('PUT', "/api/users/{$user->id}/avatar", [], [], [], $server, $fileContent);
+
+        $response = $this->decodeResponseJson();
+
+        $this->seeStatusCode(200)
+            ->assertNotNull($response['avatar']);
+
+        $uploadedFile = str_replace(url(''), '', $response['avatar']);
+        $uploadedFile = public_path(ltrim($uploadedFile, "/"));
+
+        $this->assertFileExists($uploadedFile);
+
+        list($width, $height) = getimagesize($uploadedFile);
+
+        $this->assertEquals(160, $width);
+        $this->assertEquals(160, $height);
+
+        @unlink($uploadedFile);
+    }
+
+    public function test_upload_invalid_image()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $file = UploadedFile::fake()->create('avatar.png', 500);
+
+        $fileContent = file_get_contents($file->getRealPath());
+
+        $server = $this->transformHeadersToServerVars([
+            'Accept' => 'application/json',
+            'Content-Type' => 'image/jpeg'
+        ]);
+
+        $this->call('PUT', "/api/users/{$user->id}/avatar", [], [], [], $server, $fileContent);
+
+        $this->seeStatusCode(422)
+            ->seeJsonContains([
+                'file' => [
+                    trans('validation.image', ['attribute' => 'file'])
+                ]
+            ]);
+    }
+
+    public function test_update_avatar_from_external_source()
+    {
+        $this->expectsEvents(UpdatedByAdmin::class);
+
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $url = 'http://google.com';
+
+        $this->putJson("/api/users/{$user->id}/avatar/external", [
+            'url' => $url
+        ]);
+
+        $this->assertResponseOk();
+        $this->seeJsonContains([
+            'avatar' => $url
+        ]);
+    }
+
+    public function test_update_avatar_with_invalid_external_source()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $this->putJson("/api/users/{$user->id}/avatar/external", [
+            'url' => 'foo'
+        ]);
+
+        $this->assertResponseStatus(422);
+    }
+
+    public function test_delete_user_avatar()
+    {
+        $this->expectsEvents(UpdatedByAdmin::class);
+
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $user->forceFill([
+            'avatar' => 'http://google.com'
+        ])->save();
+
+        $this->deleteJson("api/users/{$user->id}/avatar")
+            ->assertResponseOk()
+            ->seeJsonContains([
+                'avatar' => url('assets/img/profile.png') // default profile image
+            ]);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Users/SessionsControllerTest.php b/tests/Feature/Http/Controllers/Api/Users/SessionsControllerTest.php
new file mode 100644
index 0000000..cd9b934
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Users/SessionsControllerTest.php
@@ -0,0 +1,66 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Users;
+
+use Tests\Feature\ApiTestCase;
+use Vanguard\Transformers\SessionTransformer;
+use Vanguard\User;
+
+class SessionsControllerTest extends ApiTestCase
+{
+    public function test_get_sessions_unauthenticated()
+    {
+        $user = factory(User::class)->create();
+
+        $this->getJson("/api/users/{$user->id}/sessions")
+            ->seeStatusCode(401);
+    }
+
+    public function test_get_user_sessions_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->getJson("/api/users/{$user->id}/sessions")
+            ->seeStatusCode(403);
+    }
+
+    public function test_get_user_sessions()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $sessions = $this->generateNonExpiredSessions($user);
+
+        $this->getJson("/api/users/{$user->id}/sessions")
+            ->seeStatusCode(200)
+            ->seeJson(
+                $this->transformCollection($sessions, new SessionTransformer)
+            );
+    }
+
+    private function generateNonExpiredSessions(User $user, $count = 5)
+    {
+        $sessions = [];
+        $faker = $this->app->make(\Faker\Generator::class);
+        $lifetime = config('session.lifetime') - 1;
+
+        for ($i = 0; $i < $count; $i++) {
+            array_push($sessions, [
+                'id' => str_random(40),
+                'user_id' => $user->id,
+                'ip_address' => $faker->ipv4,
+                'user_agent' => $faker->userAgent,
+                'payload' => str_random(),
+                'last_activity' => $faker->dateTimeBetween("-{$lifetime} minutes")->getTimestamp()
+            ]);
+        }
+
+        \DB::table('sessions')->insert($sessions);
+
+        return \DB::table('sessions')
+            ->where('user_id', $user->id)
+            ->get();
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Users/TwoFactorControllerTest.php b/tests/Feature/Http/Controllers/Api/Users/TwoFactorControllerTest.php
new file mode 100644
index 0000000..64353bf
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Users/TwoFactorControllerTest.php
@@ -0,0 +1,125 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Users;
+
+use Authy;
+use Settings;
+use Tests\Feature\ApiTestCase;
+use Vanguard\Events\User\TwoFactorDisabledByAdmin;
+use Vanguard\Events\User\TwoFactorEnabledByAdmin;
+use Vanguard\Transformers\UserTransformer;
+use Vanguard\User;
+
+class TwoFactorControllerTest extends ApiTestCase
+{
+    public function test_update_2fa_unathenticated()
+    {
+        $user = factory(User::class)->create();
+
+        $this->putJson("api/users/{$user->id}/2fa")
+            ->assertResponseStatus(401);
+    }
+
+    public function test_update_2fa_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->putJson("api/users/{$user->id}/2fa")
+            ->assertResponseStatus(403);
+    }
+
+    public function test_enable_two_factor_auth_for_user()
+    {
+        $this->expectsEvents(TwoFactorEnabledByAdmin::class);
+
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        Settings::set('2fa.enabled', true);
+
+        Authy::shouldReceive('isEnabled')->andReturn(false);
+        Authy::shouldReceive('register')->andReturnNull();
+
+        $data = ['country_code' => '1', 'phone_number' => '123'];
+ 
+        $this->putJson("api/users/{$user->id}/2fa", $data);
+
+        $transformer = new UserTransformer;
+        $updatedUser = $transformer->transform($user->fresh());
+
+        $this->assertResponseOk()
+            ->seeInDatabase('users', [
+                'id' => $user->id,
+                'two_factor_country_code' => $data['country_code'],
+                'two_factor_phone' => $data['phone_number']
+            ])
+            ->seeJsonContains($updatedUser);
+    }
+
+    public function test_enable_two_factor_auth_for_user_when_it_is_already_enabled()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        Settings::set('2fa.enabled', true);
+
+        Authy::shouldReceive('isEnabled')->andReturn(true);
+
+        $data = ['country_code' => '1', 'phone_number' => '123'];
+
+        $this->putJson("api/users/{$user->id}/2fa", $data);
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'error' => '2FA is already enabled for this user.'
+            ]);
+    }
+
+    public function test_disable_two_factor_auth_for_user()
+    {
+        $this->expectsEvents(TwoFactorDisabledByAdmin::class);
+
+        $user = factory(User::class)->create([
+            'two_factor_country_code' => '1',
+            'two_factor_phone' => '123'
+        ]);
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        $this->be($user, 'api');
+
+        Settings::set('2fa.enabled', true);
+
+        Authy::shouldReceive('isEnabled')->andReturn(true);
+        Authy::shouldReceive('delete')->andReturnNull();
+
+        $this->deleteJson("api/users/{$user->id}/2fa");
+
+        $transformer = new UserTransformer;
+        $user = $transformer->transform($user->fresh());
+
+        $this->assertResponseOk()
+            ->seeJsonContains($user);
+    }
+
+    public function test_disable_2fa_for_user_when_it_is_already_disabled()
+    {
+        $user = $this->login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        Settings::set('2fa.enabled', true);
+
+        Authy::shouldReceive('isEnabled')->andReturn(false);
+
+        $this->deleteJson("api/users/{$user->id}/2fa");
+
+        $this->assertResponseStatus(422)
+            ->seeJsonContains([
+                'error' => '2FA is not enabled for this user.'
+            ]);
+    }
+}
diff --git a/tests/Feature/Http/Controllers/Api/Users/UsersControllerTest.php b/tests/Feature/Http/Controllers/Api/Users/UsersControllerTest.php
new file mode 100644
index 0000000..21f7fc7
--- /dev/null
+++ b/tests/Feature/Http/Controllers/Api/Users/UsersControllerTest.php
@@ -0,0 +1,248 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Users;
+
+use Carbon\Carbon;
+use Illuminate\Support\Collection;
+use Tests\Feature\ApiTestCase;
+use Tests\Feature\FunctionalTestCase;
+use Vanguard\Country;
+use Vanguard\Events\User\Deleted;
+use Vanguard\Events\User\UpdatedByAdmin;
+use Vanguard\Role;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\Transformers\SessionTransformer;
+use Vanguard\Transformers\UserTransformer;
+use Vanguard\User;
+
+class UsersControllerTest extends ApiTestCase
+{
+    public function test_unauthenticated()
+    {
+        $this->getJson('/api/users')
+            ->assertResponseStatus(401);
+    }
+
+    public function test_get_users_without_permission()
+    {
+        $user = factory(User::class)->create();
+
+        $this->actingAs($user, 'api')
+            ->getJson('/api/users')
+            ->assertResponseStatus(403);
+    }
+
+    public function test_paginate_all_users()
+    {
+        $user = $this->login();
+
+        $users = factory(User::class)->times(20)->create();
+        $users->push($user);
+
+        $this->getJson('/api/users');
+
+        $transformed = $this->transformCollection(
+            $users->sortByDesc('id')->take(20),
+            new UserTransformer
+        );
+
+        $response = $this->decodeResponseJson();
+
+        $this->assertEquals($response['data'], $transformed);
+        $this->assertEquals($response['meta'], [
+            'current_page' => 1,
+            'from' => 1,
+            'to' => 20,
+            'last_page' => 2,
+            'prev_page_url' => null,
+            'next_page_url' => url("api/users?page=2"),
+            'total' => 21,
+            'per_page' => 20
+        ]);
+    }
+
+    public function test_paginate_users_with_status()
+    {
+        $user = $this->login();
+
+        $activeUsers = factory(User::class)->times(2)->create([
+            'status' => UserStatus::ACTIVE
+        ]);
+
+        $bannedUsers = factory(User::class)->times(5)->create([
+            'status' => UserStatus::BANNED
+        ]);
+
+        $this->getJson('/api/users?status=' . UserStatus::BANNED);
+
+        $response = $this->decodeResponseJson();
+
+        $this->assertCount(5, $response['data']);
+    }
+
+    public function test_paginate_users_on_search()
+    {
+        $user = $this->login();
+
+        $user1 = factory(User::class)->create([
+            'first_name' => 'John',
+            'last_name' => 'Doe',
+            'email' => 'john.doe@vanguardapp.io'
+        ]);
+
+        $user2 = factory(User::class)->create([
+            'first_name' => 'Jane',
+            'last_name' => 'Doe',
+            'email' => 'jane.doe@vanguardapp.io'
+        ]);
+
+        $user3 = factory(User::class)->create([
+            'first_name' => 'Brad',
+            'last_name' => 'Pitt',
+            'email' => 'b.pitt@vanguardapp.io'
+        ]);
+
+        $this->getJson('/api/users?search=doe');
+
+        $response = $this->decodeResponseJson();
+
+        $this->assertCount(2, $response['data']);
+    }
+
+    public function test_create_user()
+    {
+        $user = $this->login();
+
+        $newUser = factory(User::class)->make();
+
+        $data = array_merge($newUser->toArray(), [
+            'birthday' => $newUser->birthday->format('Y-m-d'),
+            'role' => $newUser->role_id,
+            'password' => '123123',
+            'password_confirmation' => '123123'
+        ]);
+
+        $this->postJson('api/users', $data);
+
+        $expected = [
+            'first_name' => $newUser->first_name,
+            'last_name' => $newUser->last_name,
+            'email' => $newUser->email,
+            'username' => $newUser->username,
+            'country_id' => $newUser->country_id,
+            'birthday' => $newUser->birthday->format('Y-m-d'),
+            'phone' => $newUser->phone,
+            'address' => $newUser->address,
+            'status' => UserStatus::ACTIVE,
+            'role_id' => $newUser->role_id
+        ];
+
+        $this->assertResponseStatus(201)
+            ->seeInDatabase('users', $expected)
+            ->seeJsonContains($expected);
+    }
+
+    public function test_get_user()
+    {
+        $user = $this->login();
+
+        $this->getJson("api/users/{$user->id}")
+            ->assertResponseOk()
+            ->seeJsonContains(
+                (new UserTransformer)->transform($user)
+            );
+    }
+
+    public function test_get_user_which_does_not_exist()
+    {
+        $user = $this->login();
+
+        $this->getJson("api/users/2")
+            ->assertResponseStatus(404);
+    }
+
+    public function test_update_user()
+    {
+        $this->expectsEvents(UpdatedByAdmin::class);
+
+        $user = $this->login();
+
+        $data = [
+            'email' => 'john.doe@test.com',
+            'username' => 'john.doe',
+            'password' => '123123',
+            'password_confirmation' => '123123',
+            'first_name' => 'John',
+            'last_name' => 'Doe',
+            'phone' => '+38123456789',
+            'address' => 'Some random address',
+            'country_id' => Country::first()->id,
+            'birthday' => '1990-10-18',
+            'status' => UserStatus::BANNED,
+            'role_id' => Role::whereName('User')->first()->id
+        ];
+
+        $expected = array_except($data, ['password', 'password_confirmation']);
+        $expected += ['id' => $user->id];
+
+        $this->patchJson("api/users/{$user->id}", $data)
+            ->assertResponseOk()
+            ->seeInDatabase('users', $expected)
+            ->seeJsonContains($expected);
+    }
+
+    public function test_update_only_specific_field()
+    {
+        $this->expectsEvents(UpdatedByAdmin::class);
+
+        $user = $this->login();
+
+        $data = [
+            'email' => 'john.doe@test.com',
+        ];
+
+        $expected = array_merge(
+            $user->toArray(),
+            $data,
+            ['birthday' => $user->birthday->format('Y-m-d')]
+        );
+
+        $expected = array_except($expected, ['created_at', 'updated_at', 'avatar', 'role']);
+
+        $this->patchJson("api/users/{$user->id}", $data)
+            ->assertResponseOk()
+            ->seeInDatabase('users', $expected)
+            ->seeJsonContains($expected);
+    }
+
+    public function test_delete_user()
+    {
+        $this->expectsEvents(Deleted::class);
+
+        $user = $this->login();
+
+        $user2 = factory(User::class)->create();
+
+        $this->deleteJson("api/users/{$user2->id}")
+            ->assertResponseOk()
+            ->seeJsonContains(['success' => true]);
+    }
+
+    public function test_delete_yourself()
+    {
+        $user = $this->login();
+
+        $this->deleteJson("api/users/{$user->id}")
+            ->assertResponseStatus(403)
+            ->seeJsonContains(['error' => "You cannot delete yourself."]);
+    }
+
+    protected function login()
+    {
+        $user = parent::login();
+
+        $this->addPermissionForUser($user, 'users.manage');
+
+        return $user;
+    }
+}
diff --git a/tests/Feature/Http/Controllers/ActivityControllerTest.php b/tests/Feature/Http/Controllers/Web/ActivityControllerTest.php
similarity index 98%
rename from tests/Feature/Http/Controllers/ActivityControllerTest.php
rename to tests/Feature/Http/Controllers/Web/ActivityControllerTest.php
index 27b1e95..2fbc295 100644
--- a/tests/Feature/Http/Controllers/ActivityControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/ActivityControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers;
+namespace Tests\Feature\Http\Controllers\Web;
 
 use Input;
 use Tests\Feature\FunctionalTestCase;
diff --git a/tests/Feature/Http/Controllers/Auth/AuthControllerTest.php b/tests/Feature/Http/Controllers/Web/Auth/AuthControllerTest.php
similarity index 97%
rename from tests/Feature/Http/Controllers/Auth/AuthControllerTest.php
rename to tests/Feature/Http/Controllers/Web/Auth/AuthControllerTest.php
index 01be7e0..0449416 100644
--- a/tests/Feature/Http/Controllers/Auth/AuthControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/Auth/AuthControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers\Auth;
+namespace Tests\Feature\Http\Controllers\Web\Auth;
 
 use Authy;
 use Mockery;
@@ -142,11 +142,10 @@ class AuthControllerTest extends FunctionalTestCase
         $this->setSettings([
             'reg_enabled' => true,
             'reg_email_confirmation' => true,
-            'registration.captcha.enabled' => false
+            'registration.captcha.enabled' => false,
+            'tos' => true
         ]);
 
-        $this->expectsEvents(Registered::class);
-
         $data = $this->getRegistrationFormStubData();
 
         $this->registerUser($data);
@@ -187,7 +186,8 @@ class AuthControllerTest extends FunctionalTestCase
             'reg_enabled' => true,
             'reg_email_confirmation' => false,
             'notifications_signup_email' => false,
-            'registration.captcha.enabled' => false
+            'registration.captcha.enabled' => false,
+            'tos' => true
         ]);
 
         $this->expectsEvents(Registered::class);
@@ -212,7 +212,8 @@ class AuthControllerTest extends FunctionalTestCase
             'reg_enabled' => true,
             'reg_email_confirmation' => false,
             'notifications_signup_email' => true,
-            'registration.captcha.enabled' => false
+            'registration.captcha.enabled' => false,
+            'tos' => true
         ]);
 
         $adminRole = Role::where('name', 'Admin')->first();
diff --git a/tests/Feature/Http/Controllers/Auth/PasswordControllerTest.php b/tests/Feature/Http/Controllers/Web/Auth/PasswordControllerTest.php
similarity index 98%
rename from tests/Feature/Http/Controllers/Auth/PasswordControllerTest.php
rename to tests/Feature/Http/Controllers/Web/Auth/PasswordControllerTest.php
index 02ed9b1..74a44d5 100644
--- a/tests/Feature/Http/Controllers/Auth/PasswordControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/Auth/PasswordControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers\Authy;
+namespace Tests\Feature\Http\Controllers\Web\Auth;
 
 use DB;
 use Hash;
diff --git a/tests/Feature/Http/Controllers/Auth/SocialAuthControllerTest.php b/tests/Feature/Http/Controllers/Web/Auth/SocialAuthControllerTest.php
similarity index 99%
rename from tests/Feature/Http/Controllers/Auth/SocialAuthControllerTest.php
rename to tests/Feature/Http/Controllers/Web/Auth/SocialAuthControllerTest.php
index eaea694..6415865 100644
--- a/tests/Feature/Http/Controllers/Auth/SocialAuthControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/Auth/SocialAuthControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers\Auth;
+namespace Tests\Feature\Http\Controllers\Web\Auth;
 
 use Auth;
 use DB;
diff --git a/tests/Feature/Http/Controllers/PermissionsControllerTest.php b/tests/Feature/Http/Controllers/Web/PermissionsControllerTest.php
similarity index 99%
rename from tests/Feature/Http/Controllers/PermissionsControllerTest.php
rename to tests/Feature/Http/Controllers/Web/PermissionsControllerTest.php
index dca1a50..aadbdfa 100644
--- a/tests/Feature/Http/Controllers/PermissionsControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/PermissionsControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers;
+namespace Tests\Feature\Http\Controllers\Web;
 
 use Tests\Feature\FunctionalTestCase;
 use Vanguard\Events\Permission\Created;
diff --git a/tests/Feature/Http/Controllers/ProfileControllerTest.php b/tests/Feature/Http/Controllers/Web/ProfileControllerTest.php
similarity index 93%
rename from tests/Feature/Http/Controllers/ProfileControllerTest.php
rename to tests/Feature/Http/Controllers/Web/ProfileControllerTest.php
index f7b7da7..772353a 100644
--- a/tests/Feature/Http/Controllers/ProfileControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/ProfileControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers;
+namespace Tests\Feature\Http\Controllers\Web;
 
 use Authy;
 use Hash;
@@ -49,7 +49,7 @@ class ProfileControllerTest extends FunctionalTestCase
         $data = $this->getStubDetailsData();
 
         $extendedData = $data + [
-            'role' => Role::whereName('Admin')->first()->id,
+            'role_id' => Role::whereName('Admin')->first()->id,
             'status' => UserStatus::BANNED,
         ];
 
@@ -141,24 +141,6 @@ class ProfileControllerTest extends FunctionalTestCase
         $this->seeInDatabase('users', ['id' => $this->user->id, 'avatar' => $data['url']]);
     }
 
-    public function test_update_social_networks()
-    {
-        $data = [
-            'facebook' => 'facebook',
-            'twitter' => 'twitter',
-            'google_plus' => 'g+',
-            'linked_in' => 'li',
-            'dribbble' => 'Dribble',
-            'skype' => 'skyyype'
-        ];
-
-        $this->visit("profile")
-            ->submitForm('Update Social Networks', ['socials' => $data])
-            ->seeInDatabase('user_social_networks', $data)
-            ->seePageIs("profile")
-            ->see("Social networks updated successfully.");
-    }
-
     public function test_update_user_login_details()
     {
         $data = [
diff --git a/tests/Feature/Http/Controllers/RolesControllerTest.php b/tests/Feature/Http/Controllers/Web/RolesControllerTest.php
similarity index 98%
rename from tests/Feature/Http/Controllers/RolesControllerTest.php
rename to tests/Feature/Http/Controllers/Web/RolesControllerTest.php
index 6ee121f..c824149 100644
--- a/tests/Feature/Http/Controllers/RolesControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/RolesControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers;
+namespace Tests\Feature\Http\Controllers\Web;
 
 use Tests\Feature\FunctionalTestCase;
 use Vanguard\Role;
diff --git a/tests/Feature/Http/Controllers/SettingsControllerTest.php b/tests/Feature/Http/Controllers/Web/SettingsControllerTest.php
similarity index 94%
rename from tests/Feature/Http/Controllers/SettingsControllerTest.php
rename to tests/Feature/Http/Controllers/Web/SettingsControllerTest.php
index ea9b424..4ebfb9e 100644
--- a/tests/Feature/Http/Controllers/SettingsControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/SettingsControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers;
+namespace Tests\Feature\Http\Controllers\Web;
 
 use Settings;
 use Tests\Feature\FunctionalTestCase;
diff --git a/tests/Feature/Http/Controllers/UsersControllerTest.php b/tests/Feature/Http/Controllers/Web/UsersControllerTest.php
similarity index 89%
rename from tests/Feature/Http/Controllers/UsersControllerTest.php
rename to tests/Feature/Http/Controllers/Web/UsersControllerTest.php
index afeb1cd..21ae1f1 100644
--- a/tests/Feature/Http/Controllers/UsersControllerTest.php
+++ b/tests/Feature/Http/Controllers/Web/UsersControllerTest.php
@@ -1,6 +1,6 @@
 <?php
 
-namespace Tests\Feature\Http\Controllers;
+namespace Tests\Feature\Http\Controllers\Web;
 
 use Authy;
 use Hash;
@@ -29,7 +29,7 @@ class UsersControllerTest extends FunctionalTestCase
         $users = $active->merge($banned);
         $users = $users->merge($unconfirmed);
 
-        $users = $users->reverse();
+        $users = $users->sortByDesc('id')->values();
 
         $this->visit('user')
             ->seeInElement("h1.page-header", "Users")
@@ -72,8 +72,8 @@ class UsersControllerTest extends FunctionalTestCase
             ->submitForm('search-users-btn', ['search' => 'doe'])
             ->seePageIs('user?search=doe&status=')
             ->seeInField('search', 'doe')
-            ->seeInTable('table', $user2->present()->name, 1, 2)
-            ->seeInTable('table', $user3->present()->name, 2, 2);
+            ->seeInTable('table', $user3->present()->name, 1, 2)
+            ->seeInTable('table', $user2->present()->name, 2, 2);
     }
 
     public function test_users_filter_by_status()
@@ -103,7 +103,7 @@ class UsersControllerTest extends FunctionalTestCase
 
         $user = User::where('email', $data['email'])->first();
 
-        $expected = array_except($data, ['role', 'password', 'password_confirmation']);
+        $expected = array_except($data, ['password', 'password_confirmation']);
 
         $this->seeInDatabase('users', $expected)
             ->seePageIs('user')
@@ -126,7 +126,7 @@ class UsersControllerTest extends FunctionalTestCase
 
         $user = User::where('email', $data['email'])->first();
 
-        $expected = array_except($data, ['role', 'password', 'password_confirmation']);
+        $expected = array_except($data, ['password', 'password_confirmation']);
         $expected['country_id'] = null;
 
         $this->seeInDatabase('users', $expected)
@@ -172,7 +172,7 @@ class UsersControllerTest extends FunctionalTestCase
 
         $this->createAndLoginAdminUser();
 
-        $user = $this->createUserWithSocialNetworks();
+        $user = $this->createUser();
         $user = $this->setRoleForUser($user, 'User');
 
         $this->visit('user')
@@ -181,7 +181,7 @@ class UsersControllerTest extends FunctionalTestCase
         $this->visit("user/{$user->id}/edit");
 
         $data = [
-            'role' => Role::whereName('User')->first()->id,
+            'role_id' => Role::whereName('User')->first()->id,
             'status' => UserStatus::BANNED,
             'first_name' => 'foo',
             'last_name' => 'bar',
@@ -193,33 +193,13 @@ class UsersControllerTest extends FunctionalTestCase
 
         $this->submitForm('update-details-btn', $data);
 
-        $expected = array_except($data, 'role') + ['id' => $user->id, 'role_id' => $data['role']];
+        $expected = $data + ['id' => $user->id];
 
         $this->seeInDatabase('users', $expected)
             ->seePageIs("user/{$user->id}/edit")
             ->see('User updated successfully.');
     }
 
-    public function test_update_user_social_networks()
-    {
-        $user = $this->createAndLoginAdminUser();
-
-        $data = [
-            'facebook' => 'facebook',
-            'twitter' => 'twitter',
-            'google_plus' => 'g+',
-            'linked_in' => 'li',
-            'dribbble' => 'Dribble',
-            'skype' => 'skyyype'
-        ];
-
-        $this->visit("user/{$user->id}/edit")
-            ->submitForm('Update Social Networks', ['socials' => $data])
-            ->seeInDatabase('user_social_networks', $data)
-            ->seePageIs("user/{$user->id}/edit")
-            ->see("Social networks updated successfully.");
-    }
-
     public function test_update_user_login_details()
     {
         $user = $this->createAndLoginAdminUser([
@@ -424,7 +404,7 @@ class UsersControllerTest extends FunctionalTestCase
     {
         $this->createAndLoginAdminUser();
 
-        $user = $this->createUserWithSocialNetworks();
+        $user = $this->createUser();
         $user = $this->setRoleForUser($user, 'User');
 
         $this->delete(route('user.delete', $user->id))
@@ -450,7 +430,7 @@ class UsersControllerTest extends FunctionalTestCase
     private function stubUserData(array $override = [])
     {
         return array_merge([
-            'role' => Role::where('name', 'User')->first()->id,
+            'role_id' => Role::where('name', 'User')->first()->id,
             'status' => UserStatus::ACTIVE,
             'first_name' => 'John',
             'last_name' => 'Doe',
@@ -473,13 +453,4 @@ class UsersControllerTest extends FunctionalTestCase
 
         return $user;
     }
-
-    private function refreshApp()
-    {
-        $this->refreshApplication();
-
-        if ($this->isSQLiteConnection()) {
-            $this->executeCallbacks();
-        }
-    }
 }
diff --git a/tests/Feature/Listeners/BaseListenerTestCase.php b/tests/Feature/Listeners/BaseListenerTestCase.php
index 9f4a5cb..24398a3 100644
--- a/tests/Feature/Listeners/BaseListenerTestCase.php
+++ b/tests/Feature/Listeners/BaseListenerTestCase.php
@@ -17,13 +17,13 @@ class BaseListenerTestCase extends FunctionalTestCase
         $this->be($this->user);
     }
 
-    protected function assertMessageLogged($msg)
+    protected function assertMessageLogged($msg, $user = null)
     {
         $this->seeInDatabase('user_activity', [
-            'user_id' => $this->user->id,
+            'user_id' => $user ? $user->id : $this->user->id,
             'ip_address' => Input::ip(),
             'user_agent' => Input::header('User-agent'),
             'description' => $msg
         ]);
     }
-}
\ No newline at end of file
+}
diff --git a/tests/Feature/Listeners/UserEventsSubscriberTest.php b/tests/Feature/Listeners/UserEventsSubscriberTest.php
index a968284..1cf2f9e 100644
--- a/tests/Feature/Listeners/UserEventsSubscriberTest.php
+++ b/tests/Feature/Listeners/UserEventsSubscriberTest.php
@@ -3,6 +3,8 @@
 namespace Tests\Feature\Listeners;
 
 use Mockery as m;
+use Vanguard\Services\Logging\UserActivity\Activity;
+use Vanguard\User;
 
 class UserEventsSubscriberTest extends BaseListenerTestCase
 {
@@ -28,8 +30,16 @@ class UserEventsSubscriberTest extends BaseListenerTestCase
 
     public function test_onRegister()
     {
-        event(new \Vanguard\Events\User\Registered($this->user));
-        $this->assertMessageLogged('Created an account.');
+        $this->setSettings([
+            'reg_enabled' => true,
+            'reg_email_confirmation' => true,
+        ]);
+
+        $user = factory(\Vanguard\User::class)->create();
+
+        event(new \Vanguard\Events\User\Registered($user));
+
+        $this->assertMessageLogged('Created an account.', $user);
     }
 
     public function test_onAvatarChange()
diff --git a/tests/Feature/Repositories/Session/DbSessionTest.php b/tests/Feature/Repositories/Session/DbSessionTest.php
index 694b222..868ea1e 100644
--- a/tests/Feature/Repositories/Session/DbSessionTest.php
+++ b/tests/Feature/Repositories/Session/DbSessionTest.php
@@ -37,8 +37,8 @@ class DbSessionTest extends FunctionalTestCase
         DB::table('sessions')->insert($data2);
 
         $expected = collect([
-            (object) array_except($data1, ['payload', 'user_id']),
-            (object) array_except($data2, ['payload', 'user_id']),
+            (object) $data1,
+            (object) $data2,
         ]);
         $expected = $expected->sortBy('id')->keyBy('id')->toArray();
 
@@ -65,8 +65,9 @@ class DbSessionTest extends FunctionalTestCase
         DB::table('sessions')->insert($data2);
 
         $expected = collect([
-            (object) array_except($data1, ['payload', 'user_id']),
+            (object) $data1
         ]);
+
         $expected = $expected->sortBy('id')->keyBy('id')->toArray();
 
         $actual = collect($this->repo->getUserSessions($user->id))
@@ -87,7 +88,7 @@ class DbSessionTest extends FunctionalTestCase
         $data = $this->getSessionStubData($user);
         DB::table('sessions')->insert($data);
 
-        $this->repo->invalidateUserSession($user->id, $data['id']);
+        $this->repo->invalidateSession($data['id']);
 
         $this->dontSeeInDatabase('sessions', $data)
             ->seeInDatabase('users', ['remember_token' => null]);
diff --git a/tests/Feature/Repositories/User/EloquentUserTest.php b/tests/Feature/Repositories/User/EloquentUserTest.php
index bc27242..0d68c03 100644
--- a/tests/Feature/Repositories/User/EloquentUserTest.php
+++ b/tests/Feature/Repositories/User/EloquentUserTest.php
@@ -68,31 +68,34 @@ class EloquentUserTest extends FunctionalTestCase
         $this->assertNull($this->repo->findBySocialId('bar', '111'));
     }
 
-    public function test_create()
+    public function test_find_by_session_id()
     {
-        $data = factory(User::class)->make()->toArray();
+        $user = factory(User::class)->create();
 
-        $this->repo->create($data + ['password' => 'foo']);
+        $sessionId = str_random(40);
 
-        $this->seeInDatabase('users', $data);
+        DB::table('sessions')->insert([
+            'id' => $sessionId,
+            'user_id' => $user->id,
+            'ip_address' => "127.0.0.1",
+            'user_agent' => "foo",
+            'payload' => str_random(),
+            'last_activity' => Carbon::now()
+        ]);
+
+        $this->assertArraySubset(
+            $user->toArray(),
+            $this->repo->findBySessionId($sessionId)->toArray()
+        );
     }
 
-    public function test_create_without_country()
+    public function test_create()
     {
-        $data1 = factory(User::class)->make(['country_id' => "0"])->toArray();
-        $data2 = factory(User::class)->make(['country_id' => 0])->toArray();
-
-        $this->repo->create($data1 + ['password' => 'foo']);
-        $this->repo->create($data2 + ['password' => 'bar']);
-
-        $expected1 = $data1;
-        $expected1['country_id'] = null;
+        $data = factory(User::class)->make()->toArray();
 
-        $expected2 = $data2;
-        $expected2['country_id'] = null;
+        $this->repo->create($data + ['password' => 'foo']);
 
-        $this->seeInDatabase('users', $expected1);
-        $this->seeInDatabase('users', $expected2);
+        $this->seeInDatabase('users', $data);
     }
 
     public function test_associateSocialAccountForUser()
@@ -120,6 +123,7 @@ class EloquentUserTest extends FunctionalTestCase
     public function test_paginate()
     {
         $users = factory(User::class)->times(5)->create();
+        $users = $users->sortByDesc('id')->values();
 
         $result = $this->repo->paginate(2)->toArray();
 
@@ -172,55 +176,6 @@ class EloquentUserTest extends FunctionalTestCase
         $this->seeInDatabase('users', $data + ['id' => $user->id]);
     }
 
-    public function test_update_without_country()
-    {
-        $user1 = factory(User::class)->create();
-        $user2 = factory(User::class)->create();
-
-        $data = [
-            'first_name' => 'John',
-            'last_name' => 'Doe',
-            'username' => 'foo',
-            'email' => 'test@test.com',
-            'country_id' => "0"
-        ];
-
-        $data2 = [
-            'first_name' => 'Jane',
-            'last_name' => 'Doe',
-            'username' => 'bar',
-            'email' => 'test2@test.com',
-            'country_id' => 0
-        ];
-
-        $this->repo->update($user1->id, $data);
-        $this->repo->update($user2->id, $data2);
-
-        $data['country_id'] = null;
-        $data2['country_id'] = null;
-
-        $this->seeInDatabase('users', $data + ['id' => $user1->id]);
-        $this->seeInDatabase('users', $data2 + ['id' => $user2->id]);
-    }
-
-    public function test_updateSocialNetworks()
-    {
-        $user = factory(User::class)->create();
-
-        $data = [
-            'facebook' => 'foo',
-            'twitter' => 'bar',
-            'dribbble' => 'bazz',
-            'skype' => 'skyyyype',
-            'linked_in' => 'li',
-            'google_plus' => 'g+'
-        ];
-
-        $this->repo->updateSocialNetworks($user->id, $data);
-
-        $this->seeInDatabase('user_social_networks', $data + ['user_id' => $user->id]);
-    }
-
     public function test_delete()
     {
         $user = factory(User::class)->create();
diff --git a/tests/Feature/Services/Auth/Api/TokenFactoryTest.php b/tests/Feature/Services/Auth/Api/TokenFactoryTest.php
new file mode 100644
index 0000000..f894a48
--- /dev/null
+++ b/tests/Feature/Services/Auth/Api/TokenFactoryTest.php
@@ -0,0 +1,101 @@
+<?php
+
+namespace Tests\Feature\Http\Controllers\Api\Auth;
+
+use Authy;
+use Carbon\Carbon;
+use Illuminate\Http\Request;
+use JWTAuth;
+use Mockery;
+use Settings;
+use Tests\Feature\FunctionalTestCase;
+use Tests\MailTrap;
+use Vanguard\Events\User\LoggedIn;
+use Vanguard\Events\User\Registered;
+use Vanguard\Role;
+use Vanguard\Services\Auth\Api\Token;
+use Vanguard\Services\Auth\Api\TokenFactory;
+use Vanguard\Support\Enum\UserStatus;
+use Vanguard\User;
+use Mockery as m;
+
+class TokenFactoryTest extends FunctionalTestCase
+{
+    public function test_token_generation_for_user()
+    {
+        Carbon::setTestNow(Carbon::now());
+
+        $user = factory(User::class)->create();
+
+        $factory = new TokenFactory(
+            $this->mockRequest(),
+            $this->mockConfig()
+        );
+
+        $token = $factory->forUser($user);
+
+        $this->seeInDatabase('api_tokens', [
+            'id' => $token->id,
+            'user_id' => $user->id,
+            'ip_address' => '123.456.789.012',
+            'user_agent' => 'fooooo',
+            'expires_at' => Carbon::now()->addMinutes(10)
+        ]);
+    }
+
+    public function test_expired_tokens_cleanup()
+    {
+        Carbon::setTestNow(Carbon::now());
+
+        $user = factory(User::class)->create();
+
+        $expiredToken = factory(Token::class)->create([
+            'user_id' => $user->id,
+            'expires_at' => Carbon::now()->subDay()
+        ]);
+
+        $factory = new TokenFactory(
+            $this->mockRequest(),
+            $this->mockConfig(10, [100, 100])
+        );
+
+        $token = $factory->forUser($user);
+
+        $this->seeInDatabase('api_tokens', [
+            'id' => $token->id,
+            'user_id' => $user->id,
+        ]);
+
+        $this->dontSeeInDatabase('api_tokens', [
+            'id' => $expiredToken->id
+        ]);
+    }
+
+    /**
+     * @param string $ip
+     * @param string $userAgent
+     * @return m\MockInterface
+     */
+    private function mockRequest($ip = '123.456.789.012', $userAgent = 'fooooo')
+    {
+        $request = m::mock(Request::class);
+        $request->shouldReceive('ip')->once()->andReturn($ip);
+        $request->shouldReceive('header')->once()->with('User-Agent')->andReturn($userAgent);
+
+        return $request;
+    }
+
+    /**
+     * @param int $ttl
+     * @param array $lottery
+     * @return m\MockInterface
+     */
+    private function mockConfig($ttl = 10, $lottery = [5, 100])
+    {
+        $config = m::mock(\Illuminate\Contracts\Config\Repository::class);
+        $config->shouldReceive('get')->with('jwt.ttl')->andReturn($ttl);
+        $config->shouldReceive('get')->with('jwt.lottery')->andReturn($lottery);
+
+        return $config;
+    }
+}
